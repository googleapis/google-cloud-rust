// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [Autokey.CreateKeyHandle][google.cloud.kms.v1.Autokey.CreateKeyHandle].
///
/// [google.cloud.kms.v1.Autokey.CreateKeyHandle]: crate::client::Autokey::create_key_handle
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKeyHandleRequest {
    /// Required. Name of the resource project and location to create the
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] in, e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub parent: std::string::String,

    /// Optional. Id of the [KeyHandle][google.cloud.kms.v1.KeyHandle]. Must be
    /// unique to the resource project and location. If not provided by the caller,
    /// a new UUID is used.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub key_handle_id: std::string::String,

    /// Required. [KeyHandle][google.cloud.kms.v1.KeyHandle] to create.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub key_handle: std::option::Option<crate::model::KeyHandle>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKeyHandleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyHandleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key_handle_id][crate::model::CreateKeyHandleRequest::key_handle_id].
    pub fn set_key_handle_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_handle_id = v.into();
        self
    }

    /// Sets the value of [key_handle][crate::model::CreateKeyHandleRequest::key_handle].
    pub fn set_key_handle<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyHandle>,
    {
        self.key_handle = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_handle][crate::model::CreateKeyHandleRequest::key_handle].
    pub fn set_or_clear_key_handle<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyHandle>,
    {
        self.key_handle = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateKeyHandleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateKeyHandleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateKeyHandleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __key_handle_id,
            __key_handle,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKeyHandleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "keyHandleId" => Ok(__FieldTag::__key_handle_id),
                            "key_handle_id" => Ok(__FieldTag::__key_handle_id),
                            "keyHandle" => Ok(__FieldTag::__key_handle),
                            "key_handle" => Ok(__FieldTag::__key_handle),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateKeyHandleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKeyHandleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_handle_id => {
                            if !fields.insert(__FieldTag::__key_handle_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_handle_id",
                                ));
                            }
                            result.key_handle_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_handle => {
                            if !fields.insert(__FieldTag::__key_handle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_handle",
                                ));
                            }
                            result.key_handle =
                                map.next_value::<std::option::Option<crate::model::KeyHandle>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateKeyHandleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.key_handle_id.is_empty() {
            state.serialize_entry("keyHandleId", &self.key_handle_id)?;
        }
        if self.key_handle.is_some() {
            state.serialize_entry("keyHandle", &self.key_handle)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for [GetKeyHandle][google.cloud.kms.v1.Autokey.GetKeyHandle].
///
/// [google.cloud.kms.v1.Autokey.GetKeyHandle]: crate::client::Autokey::get_key_handle
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetKeyHandleRequest {
    /// Required. Name of the [KeyHandle][google.cloud.kms.v1.KeyHandle] resource,
    /// e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/keyHandles/{KEY_HANDLE_ID}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKeyHandleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyHandleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyHandleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetKeyHandleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetKeyHandleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetKeyHandleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetKeyHandleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetKeyHandleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetKeyHandleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Resource-oriented representation of a request to Cloud KMS Autokey and the
/// resulting provisioning of a [CryptoKey][google.cloud.kms.v1.CryptoKey].
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KeyHandle {
    /// Identifier. Name of the [KeyHandle][google.cloud.kms.v1.KeyHandle]
    /// resource, e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/keyHandles/{KEY_HANDLE_ID}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub name: std::string::String,

    /// Output only. Name of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that has
    /// been provisioned for Customer Managed Encryption Key (CMEK) use in the
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] project and location for the
    /// requested resource type. The [CryptoKey][google.cloud.kms.v1.CryptoKey]
    /// project will reflect the value configured in the
    /// [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] on the resource
    /// project's ancestor folder at the time of the
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] creation. If more than one
    /// ancestor folder has a configured
    /// [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig], the nearest of these
    /// configurations is used.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub kms_key: std::string::String,

    /// Required. Indicates the resource type that the resulting
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] is meant to protect, e.g.
    /// `{SERVICE}.googleapis.com/{TYPE}`. See documentation for supported resource
    /// types.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub resource_type_selector: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KeyHandle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KeyHandle::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::KeyHandle::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [resource_type_selector][crate::model::KeyHandle::resource_type_selector].
    pub fn set_resource_type_selector<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type_selector = v.into();
        self
    }
}

impl wkt::message::Message for KeyHandle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyHandle"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KeyHandle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key,
            __resource_type_selector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyHandle")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "resourceTypeSelector" => Ok(__FieldTag::__resource_type_selector),
                            "resource_type_selector" => Ok(__FieldTag::__resource_type_selector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KeyHandle;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyHandle")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type_selector => {
                            if !fields.insert(__FieldTag::__resource_type_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type_selector",
                                ));
                            }
                            result.resource_type_selector = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KeyHandle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self.resource_type_selector.is_empty() {
            state.serialize_entry("resourceTypeSelector", &self.resource_type_selector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata message for
/// [CreateKeyHandle][google.cloud.kms.v1.Autokey.CreateKeyHandle] long-running
/// operation response.
///
/// [google.cloud.kms.v1.Autokey.CreateKeyHandle]: crate::client::Autokey::create_key_handle
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKeyHandleMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKeyHandleMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateKeyHandleMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateKeyHandleMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateKeyHandleMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKeyHandleMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateKeyHandleMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKeyHandleMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateKeyHandleMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Autokey.ListKeyHandles][google.cloud.kms.v1.Autokey.ListKeyHandles].
///
/// [google.cloud.kms.v1.Autokey.ListKeyHandles]: crate::client::Autokey::list_key_handles
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeyHandlesRequest {
    /// Required. Name of the resource project and location from which to list
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle], e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle] to include in the response. The
    /// service may return fewer than this value. Further
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle] can subsequently be obtained by
    /// including the
    /// [ListKeyHandlesResponse.next_page_token][google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token]
    /// in a subsequent request.  If unspecified, at most 100
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle] will be returned.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    /// [google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token]: crate::model::ListKeyHandlesResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListKeyHandlesResponse.next_page_token][google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token]: crate::model::ListKeyHandlesResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Filter to apply when listing
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle], e.g.
    /// `resource_type_selector="{SERVICE}.googleapis.com/{TYPE}"`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeyHandlesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeyHandlesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeyHandlesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeyHandlesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKeyHandlesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListKeyHandlesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyHandlesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKeyHandlesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKeyHandlesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKeyHandlesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKeyHandlesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKeyHandlesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [Autokey.ListKeyHandles][google.cloud.kms.v1.Autokey.ListKeyHandles].
///
/// [google.cloud.kms.v1.Autokey.ListKeyHandles]: crate::client::Autokey::list_key_handles
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeyHandlesResponse {
    /// Resulting [KeyHandles][google.cloud.kms.v1.KeyHandle].
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub key_handles: std::vec::Vec<crate::model::KeyHandle>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListKeyHandlesRequest.page_token][google.cloud.kms.v1.ListKeyHandlesRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListKeyHandlesRequest.page_token]: crate::model::ListKeyHandlesRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeyHandlesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_handles][crate::model::ListKeyHandlesResponse::key_handles].
    pub fn set_key_handles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KeyHandle>,
    {
        use std::iter::Iterator;
        self.key_handles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKeyHandlesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListKeyHandlesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyHandlesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKeyHandlesResponse {
    type PageItem = crate::model::KeyHandle;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.key_handles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKeyHandlesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_handles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKeyHandlesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyHandles" => Ok(__FieldTag::__key_handles),
                            "key_handles" => Ok(__FieldTag::__key_handles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKeyHandlesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKeyHandlesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_handles => {
                            if !fields.insert(__FieldTag::__key_handles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_handles",
                                ));
                            }
                            result.key_handles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::KeyHandle>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKeyHandlesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_handles.is_empty() {
            state.serialize_entry("keyHandles", &self.key_handles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]: crate::client::AutokeyAdmin::update_autokey_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAutokeyConfigRequest {
    /// Required. [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] with values to
    /// update.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    pub autokey_config: std::option::Option<crate::model::AutokeyConfig>,

    /// Required. Masks which fields of the
    /// [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] to update, e.g.
    /// `keyProject`.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAutokeyConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autokey_config][crate::model::UpdateAutokeyConfigRequest::autokey_config].
    pub fn set_autokey_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutokeyConfig>,
    {
        self.autokey_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autokey_config][crate::model::UpdateAutokeyConfigRequest::autokey_config].
    pub fn set_or_clear_autokey_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutokeyConfig>,
    {
        self.autokey_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAutokeyConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAutokeyConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAutokeyConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateAutokeyConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAutokeyConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __autokey_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAutokeyConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autokeyConfig" => Ok(__FieldTag::__autokey_config),
                            "autokey_config" => Ok(__FieldTag::__autokey_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAutokeyConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAutokeyConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__autokey_config => {
                            if !fields.insert(__FieldTag::__autokey_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autokey_config",
                                ));
                            }
                            result.autokey_config = map
                                .next_value::<std::option::Option<crate::model::AutokeyConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAutokeyConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.autokey_config.is_some() {
            state.serialize_entry("autokeyConfig", &self.autokey_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.GetAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.GetAutokeyConfig]: crate::client::AutokeyAdmin::get_autokey_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAutokeyConfigRequest {
    /// Required. Name of the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig]
    /// resource, e.g. `folders/{FOLDER_NUMBER}/autokeyConfig`.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutokeyConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutokeyConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutokeyConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetAutokeyConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAutokeyConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAutokeyConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAutokeyConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAutokeyConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAutokeyConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cloud KMS Autokey configuration for a folder.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutokeyConfig {
    /// Identifier. Name of the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig]
    /// resource, e.g. `folders/{FOLDER_NUMBER}/autokeyConfig`.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    pub name: std::string::String,

    /// Optional. Name of the key project, e.g. `projects/{PROJECT_ID}` or
    /// `projects/{PROJECT_NUMBER}`, where Cloud KMS Autokey will provision a new
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] when a
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] is created. On
    /// [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig],
    /// the caller will require `cloudkms.cryptoKeys.setIamPolicy` permission on
    /// this key project. Once configured, for Cloud KMS Autokey to function
    /// properly, this key project must have the Cloud KMS API activated and the
    /// Cloud KMS Service Agent for this key project must be granted the
    /// `cloudkms.admin` role (or pertinent permissions). A request with an empty
    /// key project field will clear the configuration.
    ///
    /// [google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]: crate::client::AutokeyAdmin::update_autokey_config
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    pub key_project: std::string::String,

    /// Output only. The state for the AutokeyConfig.
    pub state: crate::model::autokey_config::State,

    /// Optional. A checksum computed by the server based on the value of other
    /// fields. This may be sent on update requests to ensure that the client has
    /// an up-to-date value before proceeding. The request will be rejected with an
    /// ABORTED error on a mismatched etag.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutokeyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutokeyConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [key_project][crate::model::AutokeyConfig::key_project].
    pub fn set_key_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_project = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutokeyConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::autokey_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AutokeyConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for AutokeyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AutokeyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutokeyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __key_project,
            __state,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutokeyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "keyProject" => Ok(__FieldTag::__key_project),
                            "key_project" => Ok(__FieldTag::__key_project),
                            "state" => Ok(__FieldTag::__state),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutokeyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutokeyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_project => {
                            if !fields.insert(__FieldTag::__key_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_project",
                                ));
                            }
                            result.key_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::autokey_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutokeyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.key_project.is_empty() {
            state.serialize_entry("keyProject", &self.key_project)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AutokeyConfig].
pub mod autokey_config {
    #[allow(unused_imports)]
    use super::*;

    /// The states AutokeyConfig can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the AutokeyConfig is unspecified.
        Unspecified,
        /// The AutokeyConfig is currently active.
        Active,
        /// A previously configured key project has been deleted and the current
        /// AutokeyConfig is unusable.
        KeyProjectDeleted,
        /// The AutokeyConfig is not yet initialized or has been reset to its default
        /// uninitialized state.
        Uninitialized,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::KeyProjectDeleted => std::option::Option::Some(2),
                Self::Uninitialized => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::KeyProjectDeleted => std::option::Option::Some("KEY_PROJECT_DELETED"),
                Self::Uninitialized => std::option::Option::Some("UNINITIALIZED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::KeyProjectDeleted,
                3 => Self::Uninitialized,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "KEY_PROJECT_DELETED" => Self::KeyProjectDeleted,
                "UNINITIALIZED" => Self::Uninitialized,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::KeyProjectDeleted => serializer.serialize_i32(2),
                Self::Uninitialized => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.kms.v1.AutokeyConfig.State",
            ))
        }
    }
}

/// Request message for
/// [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig]: crate::client::AutokeyAdmin::show_effective_autokey_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ShowEffectiveAutokeyConfigRequest {
    /// Required. Name of the resource project to the show effective Cloud KMS
    /// Autokey configuration for. This may be helpful for interrogating the effect
    /// of nested folder configurations on a given resource project.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShowEffectiveAutokeyConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ShowEffectiveAutokeyConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ShowEffectiveAutokeyConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ShowEffectiveAutokeyConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShowEffectiveAutokeyConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShowEffectiveAutokeyConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShowEffectiveAutokeyConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShowEffectiveAutokeyConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShowEffectiveAutokeyConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig]: crate::client::AutokeyAdmin::show_effective_autokey_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ShowEffectiveAutokeyConfigResponse {
    /// Name of the key project configured in the resource project's folder
    /// ancestry.
    pub key_project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShowEffectiveAutokeyConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_project][crate::model::ShowEffectiveAutokeyConfigResponse::key_project].
    pub fn set_key_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_project = v.into();
        self
    }
}

impl wkt::message::Message for ShowEffectiveAutokeyConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ShowEffectiveAutokeyConfigResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShowEffectiveAutokeyConfigResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShowEffectiveAutokeyConfigResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyProject" => Ok(__FieldTag::__key_project),
                            "key_project" => Ok(__FieldTag::__key_project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShowEffectiveAutokeyConfigResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShowEffectiveAutokeyConfigResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_project => {
                            if !fields.insert(__FieldTag::__key_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_project",
                                ));
                            }
                            result.key_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShowEffectiveAutokeyConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_project.is_empty() {
            state.serialize_entry("keyProject", &self.key_project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.ListEkmConnections][google.cloud.kms.v1.EkmService.ListEkmConnections].
///
/// [google.cloud.kms.v1.EkmService.ListEkmConnections]: crate::client::EkmService::list_ekm_connections
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEkmConnectionsRequest {
    /// Required. The resource name of the location associated with the
    /// [EkmConnections][google.cloud.kms.v1.EkmConnection] to list, in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [EkmConnections][google.cloud.kms.v1.EkmConnection] to include in the
    /// response. Further [EkmConnections][google.cloud.kms.v1.EkmConnection] can
    /// subsequently be obtained by including the
    /// [ListEkmConnectionsResponse.next_page_token][google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]: crate::model::ListEkmConnectionsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListEkmConnectionsResponse.next_page_token][google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]: crate::model::ListEkmConnectionsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order.  For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEkmConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEkmConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEkmConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEkmConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEkmConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEkmConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEkmConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListEkmConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEkmConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEkmConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEkmConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEkmConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEkmConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [EkmService.ListEkmConnections][google.cloud.kms.v1.EkmService.ListEkmConnections].
///
/// [google.cloud.kms.v1.EkmService.ListEkmConnections]: crate::client::EkmService::list_ekm_connections
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEkmConnectionsResponse {
    /// The list of [EkmConnections][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub ekm_connections: std::vec::Vec<crate::model::EkmConnection>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListEkmConnectionsRequest.page_token][google.cloud.kms.v1.ListEkmConnectionsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListEkmConnectionsRequest.page_token]: crate::model::ListEkmConnectionsRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of [EkmConnections][google.cloud.kms.v1.EkmConnection]
    /// that matched the query.
    ///
    /// This field is not populated if
    /// [ListEkmConnectionsRequest.filter][google.cloud.kms.v1.ListEkmConnectionsRequest.filter]
    /// is applied.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.ListEkmConnectionsRequest.filter]: crate::model::ListEkmConnectionsRequest::filter
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEkmConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_connections][crate::model::ListEkmConnectionsResponse::ekm_connections].
    pub fn set_ekm_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmConnection>,
    {
        use std::iter::Iterator;
        self.ekm_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEkmConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListEkmConnectionsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListEkmConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListEkmConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEkmConnectionsResponse {
    type PageItem = crate::model::EkmConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ekm_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEkmConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ekm_connections,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEkmConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ekmConnections" => Ok(__FieldTag::__ekm_connections),
                            "ekm_connections" => Ok(__FieldTag::__ekm_connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEkmConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEkmConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ekm_connections => {
                            if !fields.insert(__FieldTag::__ekm_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_connections",
                                ));
                            }
                            result.ekm_connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EkmConnection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEkmConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ekm_connections.is_empty() {
            state.serialize_entry("ekmConnections", &self.ekm_connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.GetEkmConnection][google.cloud.kms.v1.EkmService.GetEkmConnection].
///
/// [google.cloud.kms.v1.EkmService.GetEkmConnection]: crate::client::EkmService::get_ekm_connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEkmConnectionRequest {
    /// Required. The [name][google.cloud.kms.v1.EkmConnection.name] of the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] to get.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.name]: crate::model::EkmConnection::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEkmConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetEkmConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEkmConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEkmConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEkmConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEkmConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEkmConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.CreateEkmConnection][google.cloud.kms.v1.EkmService.CreateEkmConnection].
///
/// [google.cloud.kms.v1.EkmService.CreateEkmConnection]: crate::client::EkmService::create_ekm_connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEkmConnectionRequest {
    /// Required. The resource name of the location associated with the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`.
    pub ekm_connection_id: std::string::String,

    /// Required. An [EkmConnection][google.cloud.kms.v1.EkmConnection] with
    /// initial field values.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub ekm_connection: std::option::Option<crate::model::EkmConnection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEkmConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEkmConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [ekm_connection_id][crate::model::CreateEkmConnectionRequest::ekm_connection_id].
    pub fn set_ekm_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_connection_id = v.into();
        self
    }

    /// Sets the value of [ekm_connection][crate::model::CreateEkmConnectionRequest::ekm_connection].
    pub fn set_ekm_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EkmConnection>,
    {
        self.ekm_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ekm_connection][crate::model::CreateEkmConnectionRequest::ekm_connection].
    pub fn set_or_clear_ekm_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EkmConnection>,
    {
        self.ekm_connection = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEkmConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateEkmConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEkmConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __ekm_connection_id,
            __ekm_connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEkmConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "ekmConnectionId" => Ok(__FieldTag::__ekm_connection_id),
                            "ekm_connection_id" => Ok(__FieldTag::__ekm_connection_id),
                            "ekmConnection" => Ok(__FieldTag::__ekm_connection),
                            "ekm_connection" => Ok(__FieldTag::__ekm_connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEkmConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEkmConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ekm_connection_id => {
                            if !fields.insert(__FieldTag::__ekm_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_connection_id",
                                ));
                            }
                            result.ekm_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ekm_connection => {
                            if !fields.insert(__FieldTag::__ekm_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_connection",
                                ));
                            }
                            result.ekm_connection = map
                                .next_value::<std::option::Option<crate::model::EkmConnection>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEkmConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.ekm_connection_id.is_empty() {
            state.serialize_entry("ekmConnectionId", &self.ekm_connection_id)?;
        }
        if self.ekm_connection.is_some() {
            state.serialize_entry("ekmConnection", &self.ekm_connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.UpdateEkmConnection][google.cloud.kms.v1.EkmService.UpdateEkmConnection].
///
/// [google.cloud.kms.v1.EkmService.UpdateEkmConnection]: crate::client::EkmService::update_ekm_connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEkmConnectionRequest {
    /// Required. [EkmConnection][google.cloud.kms.v1.EkmConnection] with updated
    /// values.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub ekm_connection: std::option::Option<crate::model::EkmConnection>,

    /// Required. List of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEkmConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_connection][crate::model::UpdateEkmConnectionRequest::ekm_connection].
    pub fn set_ekm_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EkmConnection>,
    {
        self.ekm_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ekm_connection][crate::model::UpdateEkmConnectionRequest::ekm_connection].
    pub fn set_or_clear_ekm_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EkmConnection>,
    {
        self.ekm_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEkmConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEkmConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEkmConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateEkmConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEkmConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ekm_connection,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEkmConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ekmConnection" => Ok(__FieldTag::__ekm_connection),
                            "ekm_connection" => Ok(__FieldTag::__ekm_connection),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEkmConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEkmConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ekm_connection => {
                            if !fields.insert(__FieldTag::__ekm_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_connection",
                                ));
                            }
                            result.ekm_connection = map
                                .next_value::<std::option::Option<crate::model::EkmConnection>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEkmConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ekm_connection.is_some() {
            state.serialize_entry("ekmConnection", &self.ekm_connection)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.GetEkmConfig][google.cloud.kms.v1.EkmService.GetEkmConfig].
///
/// [google.cloud.kms.v1.EkmService.GetEkmConfig]: crate::client::EkmService::get_ekm_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEkmConfigRequest {
    /// Required. The [name][google.cloud.kms.v1.EkmConfig.name] of the
    /// [EkmConfig][google.cloud.kms.v1.EkmConfig] to get.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    /// [google.cloud.kms.v1.EkmConfig.name]: crate::model::EkmConfig::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEkmConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetEkmConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEkmConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEkmConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEkmConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEkmConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEkmConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.UpdateEkmConfig][google.cloud.kms.v1.EkmService.UpdateEkmConfig].
///
/// [google.cloud.kms.v1.EkmService.UpdateEkmConfig]: crate::client::EkmService::update_ekm_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEkmConfigRequest {
    /// Required. [EkmConfig][google.cloud.kms.v1.EkmConfig] with updated values.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    pub ekm_config: std::option::Option<crate::model::EkmConfig>,

    /// Required. List of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEkmConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_config][crate::model::UpdateEkmConfigRequest::ekm_config].
    pub fn set_ekm_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EkmConfig>,
    {
        self.ekm_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ekm_config][crate::model::UpdateEkmConfigRequest::ekm_config].
    pub fn set_or_clear_ekm_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EkmConfig>,
    {
        self.ekm_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEkmConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEkmConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEkmConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateEkmConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEkmConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ekm_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEkmConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ekmConfig" => Ok(__FieldTag::__ekm_config),
                            "ekm_config" => Ok(__FieldTag::__ekm_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEkmConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEkmConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ekm_config => {
                            if !fields.insert(__FieldTag::__ekm_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_config",
                                ));
                            }
                            result.ekm_config =
                                map.next_value::<std::option::Option<crate::model::EkmConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEkmConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ekm_config.is_some() {
            state.serialize_entry("ekmConfig", &self.ekm_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A [Certificate][google.cloud.kms.v1.Certificate] represents an X.509
/// certificate used to authenticate HTTPS connections to EKM replicas.
///
/// [google.cloud.kms.v1.Certificate]: crate::model::Certificate
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Certificate {
    /// Required. The raw certificate bytes in DER format.
    pub raw_der: ::bytes::Bytes,

    /// Output only. True if the certificate was parsed successfully.
    pub parsed: bool,

    /// Output only. The issuer distinguished name in RFC 2253 format. Only present
    /// if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub issuer: std::string::String,

    /// Output only. The subject distinguished name in RFC 2253 format. Only
    /// present if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub subject: std::string::String,

    /// Output only. The subject Alternative DNS names. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub subject_alternative_dns_names: std::vec::Vec<std::string::String>,

    /// Output only. The certificate is not valid before this time. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub not_before_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The certificate is not valid after this time. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub not_after_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The certificate serial number as a hex string. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub serial_number: std::string::String,

    /// Output only. The SHA-256 certificate fingerprint as a hex string. Only
    /// present if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    pub sha256_fingerprint: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Certificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_der][crate::model::Certificate::raw_der].
    pub fn set_raw_der<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_der = v.into();
        self
    }

    /// Sets the value of [parsed][crate::model::Certificate::parsed].
    pub fn set_parsed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.parsed = v.into();
        self
    }

    /// Sets the value of [issuer][crate::model::Certificate::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::Certificate::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [subject_alternative_dns_names][crate::model::Certificate::subject_alternative_dns_names].
    pub fn set_subject_alternative_dns_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_alternative_dns_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [not_before_time][crate::model::Certificate::not_before_time].
    pub fn set_not_before_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.not_before_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [not_before_time][crate::model::Certificate::not_before_time].
    pub fn set_or_clear_not_before_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.not_before_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [not_after_time][crate::model::Certificate::not_after_time].
    pub fn set_not_after_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.not_after_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [not_after_time][crate::model::Certificate::not_after_time].
    pub fn set_or_clear_not_after_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.not_after_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serial_number][crate::model::Certificate::serial_number].
    pub fn set_serial_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serial_number = v.into();
        self
    }

    /// Sets the value of [sha256_fingerprint][crate::model::Certificate::sha256_fingerprint].
    pub fn set_sha256_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sha256_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for Certificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.Certificate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Certificate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __raw_der,
            __parsed,
            __issuer,
            __subject,
            __subject_alternative_dns_names,
            __not_before_time,
            __not_after_time,
            __serial_number,
            __sha256_fingerprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Certificate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rawDer" => Ok(__FieldTag::__raw_der),
                            "raw_der" => Ok(__FieldTag::__raw_der),
                            "parsed" => Ok(__FieldTag::__parsed),
                            "issuer" => Ok(__FieldTag::__issuer),
                            "subject" => Ok(__FieldTag::__subject),
                            "subjectAlternativeDnsNames" => {
                                Ok(__FieldTag::__subject_alternative_dns_names)
                            }
                            "subject_alternative_dns_names" => {
                                Ok(__FieldTag::__subject_alternative_dns_names)
                            }
                            "notBeforeTime" => Ok(__FieldTag::__not_before_time),
                            "not_before_time" => Ok(__FieldTag::__not_before_time),
                            "notAfterTime" => Ok(__FieldTag::__not_after_time),
                            "not_after_time" => Ok(__FieldTag::__not_after_time),
                            "serialNumber" => Ok(__FieldTag::__serial_number),
                            "serial_number" => Ok(__FieldTag::__serial_number),
                            "sha256Fingerprint" => Ok(__FieldTag::__sha256_fingerprint),
                            "sha256_fingerprint" => Ok(__FieldTag::__sha256_fingerprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Certificate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Certificate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__raw_der => {
                            if !fields.insert(__FieldTag::__raw_der) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_der",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.raw_der = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__parsed => {
                            if !fields.insert(__FieldTag::__parsed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parsed",
                                ));
                            }
                            result.parsed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issuer => {
                            if !fields.insert(__FieldTag::__issuer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer",
                                ));
                            }
                            result.issuer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_alternative_dns_names => {
                            if !fields.insert(__FieldTag::__subject_alternative_dns_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_alternative_dns_names",
                                ));
                            }
                            result.subject_alternative_dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__not_before_time => {
                            if !fields.insert(__FieldTag::__not_before_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for not_before_time",
                                ));
                            }
                            result.not_before_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__not_after_time => {
                            if !fields.insert(__FieldTag::__not_after_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for not_after_time",
                                ));
                            }
                            result.not_after_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__serial_number => {
                            if !fields.insert(__FieldTag::__serial_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serial_number",
                                ));
                            }
                            result.serial_number = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sha256_fingerprint => {
                            if !fields.insert(__FieldTag::__sha256_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha256_fingerprint",
                                ));
                            }
                            result.sha256_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Certificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.raw_der.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rawDer", &__With(&self.raw_der))?;
        }
        if !wkt::internal::is_default(&self.parsed) {
            state.serialize_entry("parsed", &self.parsed)?;
        }
        if !self.issuer.is_empty() {
            state.serialize_entry("issuer", &self.issuer)?;
        }
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !self.subject_alternative_dns_names.is_empty() {
            state.serialize_entry(
                "subjectAlternativeDnsNames",
                &self.subject_alternative_dns_names,
            )?;
        }
        if self.not_before_time.is_some() {
            state.serialize_entry("notBeforeTime", &self.not_before_time)?;
        }
        if self.not_after_time.is_some() {
            state.serialize_entry("notAfterTime", &self.not_after_time)?;
        }
        if !self.serial_number.is_empty() {
            state.serialize_entry("serialNumber", &self.serial_number)?;
        }
        if !self.sha256_fingerprint.is_empty() {
            state.serialize_entry("sha256Fingerprint", &self.sha256_fingerprint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An [EkmConnection][google.cloud.kms.v1.EkmConnection] represents an
/// individual EKM connection. It can be used for creating
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] with a
/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
/// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC], as well as
/// performing cryptographic operations using keys created within the
/// [EkmConnection][google.cloud.kms.v1.EkmConnection].
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
/// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EkmConnection {
    /// Output only. The resource name for the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] in the format
    /// `projects/*/locations/*/ekmConnections/*`.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub name: std::string::String,

    /// Output only. The time at which the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] was created.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A list of
    /// [ServiceResolvers][google.cloud.kms.v1.EkmConnection.ServiceResolver] where
    /// the EKM can be reached. There should be one ServiceResolver per EKM
    /// replica. Currently, only a single
    /// [ServiceResolver][google.cloud.kms.v1.EkmConnection.ServiceResolver] is
    /// supported.
    ///
    /// [google.cloud.kms.v1.EkmConnection.ServiceResolver]: crate::model::ekm_connection::ServiceResolver
    pub service_resolvers: std::vec::Vec<crate::model::ekm_connection::ServiceResolver>,

    /// Optional. Etag of the currently stored
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub etag: std::string::String,

    /// Optional. Describes who can perform control plane operations on the EKM. If
    /// unset, this defaults to
    /// [MANUAL][google.cloud.kms.v1.EkmConnection.KeyManagementMode.MANUAL].
    ///
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode.MANUAL]: crate::model::ekm_connection::KeyManagementMode::Manual
    pub key_management_mode: crate::model::ekm_connection::KeyManagementMode,

    /// Optional. Identifies the EKM Crypto Space that this
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] maps to. Note: This
    /// field is required if
    /// [KeyManagementMode][google.cloud.kms.v1.EkmConnection.KeyManagementMode] is
    /// [CLOUD_KMS][google.cloud.kms.v1.EkmConnection.KeyManagementMode.CLOUD_KMS].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode]: crate::model::ekm_connection::KeyManagementMode
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode.CLOUD_KMS]: crate::model::ekm_connection::KeyManagementMode::CloudKms
    pub crypto_space_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EkmConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::EkmConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_resolvers][crate::model::EkmConnection::service_resolvers].
    pub fn set_service_resolvers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ekm_connection::ServiceResolver>,
    {
        use std::iter::Iterator;
        self.service_resolvers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::EkmConnection::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [key_management_mode][crate::model::EkmConnection::key_management_mode].
    pub fn set_key_management_mode<
        T: std::convert::Into<crate::model::ekm_connection::KeyManagementMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_management_mode = v.into();
        self
    }

    /// Sets the value of [crypto_space_path][crate::model::EkmConnection::crypto_space_path].
    pub fn set_crypto_space_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_space_path = v.into();
        self
    }
}

impl wkt::message::Message for EkmConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EkmConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EkmConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __service_resolvers,
            __etag,
            __key_management_mode,
            __crypto_space_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EkmConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "serviceResolvers" => Ok(__FieldTag::__service_resolvers),
                            "service_resolvers" => Ok(__FieldTag::__service_resolvers),
                            "etag" => Ok(__FieldTag::__etag),
                            "keyManagementMode" => Ok(__FieldTag::__key_management_mode),
                            "key_management_mode" => Ok(__FieldTag::__key_management_mode),
                            "cryptoSpacePath" => Ok(__FieldTag::__crypto_space_path),
                            "crypto_space_path" => Ok(__FieldTag::__crypto_space_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EkmConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EkmConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__service_resolvers => {
                            if !fields.insert(__FieldTag::__service_resolvers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_resolvers",
                                ));
                            }
                            result.service_resolvers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ekm_connection::ServiceResolver>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_management_mode => {
                            if !fields.insert(__FieldTag::__key_management_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_management_mode",
                                ));
                            }
                            result.key_management_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::ekm_connection::KeyManagementMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_space_path => {
                            if !fields.insert(__FieldTag::__crypto_space_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_space_path",
                                ));
                            }
                            result.crypto_space_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EkmConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.service_resolvers.is_empty() {
            state.serialize_entry("serviceResolvers", &self.service_resolvers)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.key_management_mode) {
            state.serialize_entry("keyManagementMode", &self.key_management_mode)?;
        }
        if !self.crypto_space_path.is_empty() {
            state.serialize_entry("cryptoSpacePath", &self.crypto_space_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EkmConnection].
pub mod ekm_connection {
    #[allow(unused_imports)]
    use super::*;

    /// A [ServiceResolver][google.cloud.kms.v1.EkmConnection.ServiceResolver]
    /// represents an EKM replica that can be reached within an
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.ServiceResolver]: crate::model::ekm_connection::ServiceResolver
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServiceResolver {
        /// Required. The resource name of the Service Directory service pointing to
        /// an EKM replica, in the format
        /// `projects/*/locations/*/namespaces/*/services/*`.
        pub service_directory_service: std::string::String,

        /// Optional. The filter applied to the endpoints of the resolved service. If
        /// no filter is specified, all endpoints will be considered. An endpoint
        /// will be chosen arbitrarily from the filtered list for each request.
        ///
        /// For endpoint filter syntax and examples, see
        /// <https://cloud.google.com/service-directory/docs/reference/rpc/google.cloud.servicedirectory.v1#resolveservicerequest>.
        pub endpoint_filter: std::string::String,

        /// Required. The hostname of the EKM replica used at TLS and HTTP layers.
        pub hostname: std::string::String,

        /// Required. A list of leaf server certificates used to authenticate HTTPS
        /// connections to the EKM replica. Currently, a maximum of 10
        /// [Certificate][google.cloud.kms.v1.Certificate] is supported.
        ///
        /// [google.cloud.kms.v1.Certificate]: crate::model::Certificate
        pub server_certificates: std::vec::Vec<crate::model::Certificate>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServiceResolver {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_directory_service][crate::model::ekm_connection::ServiceResolver::service_directory_service].
        pub fn set_service_directory_service<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_directory_service = v.into();
            self
        }

        /// Sets the value of [endpoint_filter][crate::model::ekm_connection::ServiceResolver::endpoint_filter].
        pub fn set_endpoint_filter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.endpoint_filter = v.into();
            self
        }

        /// Sets the value of [hostname][crate::model::ekm_connection::ServiceResolver::hostname].
        pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.hostname = v.into();
            self
        }

        /// Sets the value of [server_certificates][crate::model::ekm_connection::ServiceResolver::server_certificates].
        pub fn set_server_certificates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Certificate>,
        {
            use std::iter::Iterator;
            self.server_certificates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ServiceResolver {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.kms.v1.EkmConnection.ServiceResolver"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServiceResolver {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_directory_service,
                __endpoint_filter,
                __hostname,
                __server_certificates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServiceResolver")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceDirectoryService" => {
                                    Ok(__FieldTag::__service_directory_service)
                                }
                                "service_directory_service" => {
                                    Ok(__FieldTag::__service_directory_service)
                                }
                                "endpointFilter" => Ok(__FieldTag::__endpoint_filter),
                                "endpoint_filter" => Ok(__FieldTag::__endpoint_filter),
                                "hostname" => Ok(__FieldTag::__hostname),
                                "serverCertificates" => Ok(__FieldTag::__server_certificates),
                                "server_certificates" => Ok(__FieldTag::__server_certificates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServiceResolver;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServiceResolver")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_directory_service => {
                                if !fields.insert(__FieldTag::__service_directory_service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_directory_service",
                                    ));
                                }
                                result.service_directory_service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__endpoint_filter => {
                                if !fields.insert(__FieldTag::__endpoint_filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpoint_filter",
                                    ));
                                }
                                result.endpoint_filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__hostname => {
                                if !fields.insert(__FieldTag::__hostname) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hostname",
                                    ));
                                }
                                result.hostname = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__server_certificates => {
                                if !fields.insert(__FieldTag::__server_certificates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for server_certificates",
                                    ));
                                }
                                result.server_certificates =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::Certificate>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ServiceResolver {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_directory_service.is_empty() {
                state
                    .serialize_entry("serviceDirectoryService", &self.service_directory_service)?;
            }
            if !self.endpoint_filter.is_empty() {
                state.serialize_entry("endpointFilter", &self.endpoint_filter)?;
            }
            if !self.hostname.is_empty() {
                state.serialize_entry("hostname", &self.hostname)?;
            }
            if !self.server_certificates.is_empty() {
                state.serialize_entry("serverCertificates", &self.server_certificates)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// [KeyManagementMode][google.cloud.kms.v1.EkmConnection.KeyManagementMode]
    /// describes who can perform control plane cryptographic operations using this
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode]: crate::model::ekm_connection::KeyManagementMode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyManagementMode {
        /// Not specified.
        Unspecified,
        /// EKM-side key management operations on
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] created with this
        /// [EkmConnection][google.cloud.kms.v1.EkmConnection] must be initiated from
        /// the EKM directly and cannot be performed from Cloud KMS. This means that:
        ///
        /// * When creating a
        ///   [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] associated with
        ///   this
        ///   [EkmConnection][google.cloud.kms.v1.EkmConnection], the caller must
        ///   supply the key path of pre-existing external key material that will be
        ///   linked to the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
        /// * Destruction of external key material cannot be requested via the
        ///   Cloud KMS API and must be performed directly in the EKM.
        /// * Automatic rotation of key material is not supported.
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
        Manual,
        /// All [CryptoKeys][google.cloud.kms.v1.CryptoKey] created with this
        /// [EkmConnection][google.cloud.kms.v1.EkmConnection] use EKM-side key
        /// management operations initiated from Cloud KMS. This means that:
        ///
        /// * When a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
        ///   associated with this [EkmConnection][google.cloud.kms.v1.EkmConnection]
        ///   is
        ///   created, the EKM automatically generates new key material and a new
        ///   key path. The caller cannot supply the key path of pre-existing
        ///   external key material.
        /// * Destruction of external key material associated with this
        ///   [EkmConnection][google.cloud.kms.v1.EkmConnection] can be requested by
        ///   calling
        ///   [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
        /// * Automatic rotation of key material is supported.
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
        /// [google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]: crate::client::KeyManagementService::destroy_crypto_key_version
        CloudKms,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyManagementMode::value] or
        /// [KeyManagementMode::name].
        UnknownValue(key_management_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod key_management_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KeyManagementMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Manual => std::option::Option::Some(1),
                Self::CloudKms => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KEY_MANAGEMENT_MODE_UNSPECIFIED"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::CloudKms => std::option::Option::Some("CLOUD_KMS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KeyManagementMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KeyManagementMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KeyManagementMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Manual,
                2 => Self::CloudKms,
                _ => Self::UnknownValue(key_management_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KeyManagementMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_MANAGEMENT_MODE_UNSPECIFIED" => Self::Unspecified,
                "MANUAL" => Self::Manual,
                "CLOUD_KMS" => Self::CloudKms,
                _ => Self::UnknownValue(key_management_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KeyManagementMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Manual => serializer.serialize_i32(1),
                Self::CloudKms => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KeyManagementMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KeyManagementMode>::new(
                ".google.cloud.kms.v1.EkmConnection.KeyManagementMode",
            ))
        }
    }
}

/// An [EkmConfig][google.cloud.kms.v1.EkmConfig] is a singleton resource that
/// represents configuration parameters that apply to all
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] with a
/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
/// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] in a given
/// project and location.
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
/// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EkmConfig {
    /// Output only. The resource name for the
    /// [EkmConfig][google.cloud.kms.v1.EkmConfig] in the format
    /// `projects/*/locations/*/ekmConfig`.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    pub name: std::string::String,

    /// Optional. Resource name of the default
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection]. Setting this field to
    /// the empty string removes the default.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub default_ekm_connection: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [default_ekm_connection][crate::model::EkmConfig::default_ekm_connection].
    pub fn set_default_ekm_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_ekm_connection = v.into();
        self
    }
}

impl wkt::message::Message for EkmConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EkmConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EkmConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __default_ekm_connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EkmConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "defaultEkmConnection" => Ok(__FieldTag::__default_ekm_connection),
                            "default_ekm_connection" => Ok(__FieldTag::__default_ekm_connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EkmConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EkmConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_ekm_connection => {
                            if !fields.insert(__FieldTag::__default_ekm_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_ekm_connection",
                                ));
                            }
                            result.default_ekm_connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EkmConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.default_ekm_connection.is_empty() {
            state.serialize_entry("defaultEkmConnection", &self.default_ekm_connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [EkmService.VerifyConnectivity][google.cloud.kms.v1.EkmService.VerifyConnectivity].
///
/// [google.cloud.kms.v1.EkmService.VerifyConnectivity]: crate::client::EkmService::verify_connectivity
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyConnectivityRequest {
    /// Required. The [name][google.cloud.kms.v1.EkmConnection.name] of the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] to verify.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.name]: crate::model::EkmConnection::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyConnectivityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyConnectivityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for VerifyConnectivityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.VerifyConnectivityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyConnectivityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyConnectivityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyConnectivityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyConnectivityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyConnectivityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [EkmService.VerifyConnectivity][google.cloud.kms.v1.EkmService.VerifyConnectivity].
///
/// [google.cloud.kms.v1.EkmService.VerifyConnectivity]: crate::client::EkmService::verify_connectivity
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyConnectivityResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyConnectivityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VerifyConnectivityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.VerifyConnectivityResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyConnectivityResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyConnectivityResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyConnectivityResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyConnectivityResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyConnectivityResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A [KeyRing][google.cloud.kms.v1.KeyRing] is a toplevel logical grouping of
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey].
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KeyRing {
    /// Output only. The resource name for the
    /// [KeyRing][google.cloud.kms.v1.KeyRing] in the format
    /// `projects/*/locations/*/keyRings/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub name: std::string::String,

    /// Output only. The time at which this [KeyRing][google.cloud.kms.v1.KeyRing]
    /// was created.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KeyRing {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KeyRing::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::KeyRing::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::KeyRing::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for KeyRing {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyRing"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KeyRing {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyRing")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KeyRing;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyRing")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KeyRing {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A [CryptoKey][google.cloud.kms.v1.CryptoKey] represents a logical key that
/// can be used for cryptographic operations.
///
/// A [CryptoKey][google.cloud.kms.v1.CryptoKey] is made up of zero or more
/// [versions][google.cloud.kms.v1.CryptoKeyVersion], which represent the actual
/// key material used in cryptographic operations.
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoKey {
    /// Output only. The resource name for this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] in the format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub name: std::string::String,

    /// Output only. A copy of the "primary"
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that will be used
    /// by [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] when this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] is given in
    /// [EncryptRequest.name][google.cloud.kms.v1.EncryptRequest.name].
    ///
    /// The [CryptoKey][google.cloud.kms.v1.CryptoKey]'s primary version can be
    /// updated via
    /// [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
    ///
    /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
    /// may have a primary. For other keys, this field will be omitted.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::CryptoKeyPurpose::EncryptDecrypt
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.EncryptRequest.name]: crate::model::EncryptRequest::name
    /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
    /// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]: crate::client::KeyManagementService::update_crypto_key_primary_version
    pub primary: std::option::Option<crate::model::CryptoKeyVersion>,

    /// Immutable. The immutable purpose of this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub purpose: crate::model::crypto_key::CryptoKeyPurpose,

    /// Output only. The time at which this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] was created.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// At [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time],
    /// the Key Management Service will automatically:
    ///
    /// 1. Create a new version of this [CryptoKey][google.cloud.kms.v1.CryptoKey].
    /// 1. Mark the new version as primary.
    ///
    /// Key rotations performed manually via
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// and
    /// [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]
    /// do not affect
    /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time].
    ///
    /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
    /// support automatic rotation. For other keys, this field must be omitted.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::CryptoKeyPurpose::EncryptDecrypt
    /// [google.cloud.kms.v1.CryptoKey.next_rotation_time]: crate::model::CryptoKey::next_rotation_time
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
    /// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]: crate::client::KeyManagementService::update_crypto_key_primary_version
    pub next_rotation_time: std::option::Option<wkt::Timestamp>,

    /// A template describing settings for new
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] instances. The
    /// properties of new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// instances created by either
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// or auto-rotation are controlled by this template.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
    pub version_template: std::option::Option<crate::model::CryptoKeyVersionTemplate>,

    /// Labels with user-defined metadata. For more information, see
    /// [Labeling Keys](https://cloud.google.com/kms/docs/labeling-keys).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. Whether this key may contain imported versions only.
    pub import_only: bool,

    /// Immutable. The period of time that versions of this key spend in the
    /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
    /// state before transitioning to
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
    /// If not specified at creation time, the default duration is 30 days.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::CryptoKeyVersionState::Destroyed
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]: crate::model::crypto_key_version::CryptoKeyVersionState::DestroyScheduled
    pub destroy_scheduled_duration: std::option::Option<wkt::Duration>,

    /// Immutable. The resource name of the backend environment where the key
    /// material for all [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
    /// associated with this [CryptoKey][google.cloud.kms.v1.CryptoKey] reside and
    /// where all related cryptographic operations are performed. Only applicable
    /// if [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] have a
    /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
    /// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC], with the
    /// resource name in the format `projects/*/locations/*/ekmConnections/*`.
    /// Note, this list is non-exhaustive and may apply to additional
    /// [ProtectionLevels][google.cloud.kms.v1.ProtectionLevel] in the future.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
    pub crypto_key_backend: std::string::String,

    /// Optional. The policy used for Key Access Justifications Policy Enforcement.
    /// If this field is present and this key is enrolled in Key Access
    /// Justifications Policy Enforcement, the policy will be evaluated in encrypt,
    /// decrypt, and sign operations, and the operation will fail if rejected by
    /// the policy. The policy is defined by specifying zero or more allowed
    /// justification codes.
    /// <https://cloud.google.com/assured-workloads/key-access-justifications/docs/justification-codes>
    /// By default, this field is absent, and all justification codes are allowed.
    pub key_access_justifications_policy:
        std::option::Option<crate::model::KeyAccessJustificationsPolicy>,

    /// Controls the rate of automatic rotation.
    pub rotation_schedule: std::option::Option<crate::model::crypto_key::RotationSchedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CryptoKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [primary][crate::model::CryptoKey::primary].
    pub fn set_primary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        self.primary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary][crate::model::CryptoKey::primary].
    pub fn set_or_clear_primary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        self.primary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [purpose][crate::model::CryptoKey::purpose].
    pub fn set_purpose<T: std::convert::Into<crate::model::crypto_key::CryptoKeyPurpose>>(
        mut self,
        v: T,
    ) -> Self {
        self.purpose = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CryptoKey::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CryptoKey::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_rotation_time][crate::model::CryptoKey::next_rotation_time].
    pub fn set_next_rotation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_rotation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_rotation_time][crate::model::CryptoKey::next_rotation_time].
    pub fn set_or_clear_next_rotation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_rotation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version_template][crate::model::CryptoKey::version_template].
    pub fn set_version_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersionTemplate>,
    {
        self.version_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version_template][crate::model::CryptoKey::version_template].
    pub fn set_or_clear_version_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersionTemplate>,
    {
        self.version_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CryptoKey::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [import_only][crate::model::CryptoKey::import_only].
    pub fn set_import_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.import_only = v.into();
        self
    }

    /// Sets the value of [destroy_scheduled_duration][crate::model::CryptoKey::destroy_scheduled_duration].
    pub fn set_destroy_scheduled_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.destroy_scheduled_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destroy_scheduled_duration][crate::model::CryptoKey::destroy_scheduled_duration].
    pub fn set_or_clear_destroy_scheduled_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.destroy_scheduled_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [crypto_key_backend][crate::model::CryptoKey::crypto_key_backend].
    pub fn set_crypto_key_backend<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_backend = v.into();
        self
    }

    /// Sets the value of [key_access_justifications_policy][crate::model::CryptoKey::key_access_justifications_policy].
    pub fn set_key_access_justifications_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyAccessJustificationsPolicy>,
    {
        self.key_access_justifications_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_access_justifications_policy][crate::model::CryptoKey::key_access_justifications_policy].
    pub fn set_or_clear_key_access_justifications_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::KeyAccessJustificationsPolicy>,
    {
        self.key_access_justifications_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rotation_schedule][crate::model::CryptoKey::rotation_schedule].
    ///
    /// Note that all the setters affecting `rotation_schedule` are mutually
    /// exclusive.
    pub fn set_rotation_schedule<
        T: std::convert::Into<std::option::Option<crate::model::crypto_key::RotationSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rotation_schedule = v.into();
        self
    }

    /// The value of [rotation_schedule][crate::model::CryptoKey::rotation_schedule]
    /// if it holds a `RotationPeriod`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rotation_period(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.rotation_schedule.as_ref().and_then(|v| match v {
            crate::model::crypto_key::RotationSchedule::RotationPeriod(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rotation_schedule][crate::model::CryptoKey::rotation_schedule]
    /// to hold a `RotationPeriod`.
    ///
    /// Note that all the setters affecting `rotation_schedule` are
    /// mutually exclusive.
    pub fn set_rotation_period<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rotation_schedule = std::option::Option::Some(
            crate::model::crypto_key::RotationSchedule::RotationPeriod(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CryptoKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __primary,
            __purpose,
            __create_time,
            __next_rotation_time,
            __rotation_period,
            __version_template,
            __labels,
            __import_only,
            __destroy_scheduled_duration,
            __crypto_key_backend,
            __key_access_justifications_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "primary" => Ok(__FieldTag::__primary),
                            "purpose" => Ok(__FieldTag::__purpose),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "nextRotationTime" => Ok(__FieldTag::__next_rotation_time),
                            "next_rotation_time" => Ok(__FieldTag::__next_rotation_time),
                            "rotationPeriod" => Ok(__FieldTag::__rotation_period),
                            "rotation_period" => Ok(__FieldTag::__rotation_period),
                            "versionTemplate" => Ok(__FieldTag::__version_template),
                            "version_template" => Ok(__FieldTag::__version_template),
                            "labels" => Ok(__FieldTag::__labels),
                            "importOnly" => Ok(__FieldTag::__import_only),
                            "import_only" => Ok(__FieldTag::__import_only),
                            "destroyScheduledDuration" => {
                                Ok(__FieldTag::__destroy_scheduled_duration)
                            }
                            "destroy_scheduled_duration" => {
                                Ok(__FieldTag::__destroy_scheduled_duration)
                            }
                            "cryptoKeyBackend" => Ok(__FieldTag::__crypto_key_backend),
                            "crypto_key_backend" => Ok(__FieldTag::__crypto_key_backend),
                            "keyAccessJustificationsPolicy" => {
                                Ok(__FieldTag::__key_access_justifications_policy)
                            }
                            "key_access_justifications_policy" => {
                                Ok(__FieldTag::__key_access_justifications_policy)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary => {
                            if !fields.insert(__FieldTag::__primary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary",
                                ));
                            }
                            result.primary = map
                                .next_value::<std::option::Option<crate::model::CryptoKeyVersion>>(
                                )?;
                        }
                        __FieldTag::__purpose => {
                            if !fields.insert(__FieldTag::__purpose) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purpose",
                                ));
                            }
                            result.purpose = map.next_value::<std::option::Option<crate::model::crypto_key::CryptoKeyPurpose>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_rotation_time => {
                            if !fields.insert(__FieldTag::__next_rotation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_rotation_time",
                                ));
                            }
                            result.next_rotation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rotation_period => {
                            if !fields.insert(__FieldTag::__rotation_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rotation_period",
                                ));
                            }
                            if result.rotation_schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rotation_schedule`, a oneof with full ID .google.cloud.kms.v1.CryptoKey.rotation_period, latest field was rotationPeriod",
                                ));
                            }
                            result.rotation_schedule = std::option::Option::Some(
                                crate::model::crypto_key::RotationSchedule::RotationPeriod(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__version_template => {
                            if !fields.insert(__FieldTag::__version_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_template",
                                ));
                            }
                            result.version_template = map.next_value::<std::option::Option<crate::model::CryptoKeyVersionTemplate>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_only => {
                            if !fields.insert(__FieldTag::__import_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_only",
                                ));
                            }
                            result.import_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destroy_scheduled_duration => {
                            if !fields.insert(__FieldTag::__destroy_scheduled_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destroy_scheduled_duration",
                                ));
                            }
                            result.destroy_scheduled_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__crypto_key_backend => {
                            if !fields.insert(__FieldTag::__crypto_key_backend) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_backend",
                                ));
                            }
                            result.crypto_key_backend = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_access_justifications_policy => {
                            if !fields.insert(__FieldTag::__key_access_justifications_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_access_justifications_policy",
                                ));
                            }
                            result.key_access_justifications_policy =
                                map.next_value::<std::option::Option<
                                    crate::model::KeyAccessJustificationsPolicy,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.primary.is_some() {
            state.serialize_entry("primary", &self.primary)?;
        }
        if !wkt::internal::is_default(&self.purpose) {
            state.serialize_entry("purpose", &self.purpose)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.next_rotation_time.is_some() {
            state.serialize_entry("nextRotationTime", &self.next_rotation_time)?;
        }
        if let Some(value) = self.rotation_period() {
            state.serialize_entry("rotationPeriod", value)?;
        }
        if self.version_template.is_some() {
            state.serialize_entry("versionTemplate", &self.version_template)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.import_only) {
            state.serialize_entry("importOnly", &self.import_only)?;
        }
        if self.destroy_scheduled_duration.is_some() {
            state.serialize_entry("destroyScheduledDuration", &self.destroy_scheduled_duration)?;
        }
        if !self.crypto_key_backend.is_empty() {
            state.serialize_entry("cryptoKeyBackend", &self.crypto_key_backend)?;
        }
        if self.key_access_justifications_policy.is_some() {
            state.serialize_entry(
                "keyAccessJustificationsPolicy",
                &self.key_access_justifications_policy,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CryptoKey].
pub mod crypto_key {
    #[allow(unused_imports)]
    use super::*;

    /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose]
    /// describes the cryptographic capabilities of a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey]. A given key can only be used
    /// for the operations allowed by its purpose. For more information, see [Key
    /// purposes](https://cloud.google.com/kms/docs/algorithms#key_purposes).
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose]: crate::model::crypto_key::CryptoKeyPurpose
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CryptoKeyPurpose {
        /// Not specified.
        Unspecified,
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
        /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
        /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
        EncryptDecrypt,
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with
        /// [AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign]
        /// and
        /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.AsymmetricSign]: crate::client::KeyManagementService::asymmetric_sign
        /// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
        AsymmetricSign,
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with
        /// [AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]
        /// and
        /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]: crate::client::KeyManagementService::asymmetric_decrypt
        /// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
        AsymmetricDecrypt,
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with [RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt]
        /// and [RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
        /// This purpose is meant to be used for interoperable symmetric
        /// encryption and does not support automatic CryptoKey rotation.
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.RawDecrypt]: crate::client::KeyManagementService::raw_decrypt
        /// [google.cloud.kms.v1.KeyManagementService.RawEncrypt]: crate::client::KeyManagementService::raw_encrypt
        RawEncryptDecrypt,
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with [MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.MacSign]: crate::client::KeyManagementService::mac_sign
        Mac,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CryptoKeyPurpose::value] or
        /// [CryptoKeyPurpose::name].
        UnknownValue(crypto_key_purpose::UnknownValue),
    }

    #[doc(hidden)]
    pub mod crypto_key_purpose {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CryptoKeyPurpose {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EncryptDecrypt => std::option::Option::Some(1),
                Self::AsymmetricSign => std::option::Option::Some(5),
                Self::AsymmetricDecrypt => std::option::Option::Some(6),
                Self::RawEncryptDecrypt => std::option::Option::Some(7),
                Self::Mac => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CRYPTO_KEY_PURPOSE_UNSPECIFIED"),
                Self::EncryptDecrypt => std::option::Option::Some("ENCRYPT_DECRYPT"),
                Self::AsymmetricSign => std::option::Option::Some("ASYMMETRIC_SIGN"),
                Self::AsymmetricDecrypt => std::option::Option::Some("ASYMMETRIC_DECRYPT"),
                Self::RawEncryptDecrypt => std::option::Option::Some("RAW_ENCRYPT_DECRYPT"),
                Self::Mac => std::option::Option::Some("MAC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CryptoKeyPurpose {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CryptoKeyPurpose {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CryptoKeyPurpose {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EncryptDecrypt,
                5 => Self::AsymmetricSign,
                6 => Self::AsymmetricDecrypt,
                7 => Self::RawEncryptDecrypt,
                9 => Self::Mac,
                _ => Self::UnknownValue(crypto_key_purpose::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CryptoKeyPurpose {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CRYPTO_KEY_PURPOSE_UNSPECIFIED" => Self::Unspecified,
                "ENCRYPT_DECRYPT" => Self::EncryptDecrypt,
                "ASYMMETRIC_SIGN" => Self::AsymmetricSign,
                "ASYMMETRIC_DECRYPT" => Self::AsymmetricDecrypt,
                "RAW_ENCRYPT_DECRYPT" => Self::RawEncryptDecrypt,
                "MAC" => Self::Mac,
                _ => Self::UnknownValue(crypto_key_purpose::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CryptoKeyPurpose {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EncryptDecrypt => serializer.serialize_i32(1),
                Self::AsymmetricSign => serializer.serialize_i32(5),
                Self::AsymmetricDecrypt => serializer.serialize_i32(6),
                Self::RawEncryptDecrypt => serializer.serialize_i32(7),
                Self::Mac => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CryptoKeyPurpose {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CryptoKeyPurpose>::new(
                ".google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose",
            ))
        }
    }

    /// Controls the rate of automatic rotation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RotationSchedule {
        /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time]
        /// will be advanced by this period when the service automatically rotates a
        /// key. Must be at least 24 hours and at most 876,000 hours.
        ///
        /// If [rotation_period][google.cloud.kms.v1.CryptoKey.rotation_period] is
        /// set,
        /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time]
        /// must also be set.
        ///
        /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
        /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
        /// support automatic rotation. For other keys, this field must be omitted.
        ///
        /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::CryptoKeyPurpose::EncryptDecrypt
        /// [google.cloud.kms.v1.CryptoKey.next_rotation_time]: crate::model::CryptoKey::next_rotation_time
        /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
        /// [google.cloud.kms.v1.CryptoKey.rotation_period]: crate::model::CryptoKey::rotation_schedule
        RotationPeriod(std::boxed::Box<wkt::Duration>),
    }
}

/// A [CryptoKeyVersionTemplate][google.cloud.kms.v1.CryptoKeyVersionTemplate]
/// specifies the properties to use when creating a new
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], either manually
/// with
/// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
/// or automatically as a result of auto-rotation.
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.CryptoKeyVersionTemplate]: crate::model::CryptoKeyVersionTemplate
/// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoKeyVersionTemplate {
    /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when creating
    /// a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this
    /// template. Immutable. Defaults to
    /// [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::ProtectionLevel::Software
    pub protection_level: crate::model::ProtectionLevel,

    /// Required.
    /// [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// to use when creating a
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this
    /// template.
    ///
    /// For backwards compatibility, GOOGLE_SYMMETRIC_ENCRYPTION is implied if both
    /// this field is omitted and
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] is
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::CryptoKeyPurpose::EncryptDecrypt
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKeyVersionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protection_level][crate::model::CryptoKeyVersionTemplate::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::CryptoKeyVersionTemplate::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }
}

impl wkt::message::Message for CryptoKeyVersionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CryptoKeyVersionTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoKeyVersionTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protection_level,
            __algorithm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoKeyVersionTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoKeyVersionTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoKeyVersionTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            result.algorithm = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoKeyVersionTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !wkt::internal::is_default(&self.algorithm) {
            state.serialize_entry("algorithm", &self.algorithm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains an HSM-generated attestation about a key operation. For more
/// information, see [Verifying attestations]
/// (<https://cloud.google.com/kms/docs/attest-key>).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KeyOperationAttestation {
    /// Output only. The format of the attestation data.
    pub format: crate::model::key_operation_attestation::AttestationFormat,

    /// Output only. The attestation data provided by the HSM when the key
    /// operation was performed.
    pub content: ::bytes::Bytes,

    /// Output only. The certificate chains needed to validate the attestation
    pub cert_chains:
        std::option::Option<crate::model::key_operation_attestation::CertificateChains>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KeyOperationAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::KeyOperationAttestation::format].
    pub fn set_format<
        T: std::convert::Into<crate::model::key_operation_attestation::AttestationFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [content][crate::model::KeyOperationAttestation::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [cert_chains][crate::model::KeyOperationAttestation::cert_chains].
    pub fn set_cert_chains<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::key_operation_attestation::CertificateChains>,
    {
        self.cert_chains = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cert_chains][crate::model::KeyOperationAttestation::cert_chains].
    pub fn set_or_clear_cert_chains<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::key_operation_attestation::CertificateChains>,
    {
        self.cert_chains = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for KeyOperationAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyOperationAttestation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KeyOperationAttestation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __content,
            __cert_chains,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyOperationAttestation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "content" => Ok(__FieldTag::__content),
                            "certChains" => Ok(__FieldTag::__cert_chains),
                            "cert_chains" => Ok(__FieldTag::__cert_chains),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KeyOperationAttestation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyOperationAttestation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<
                                    crate::model::key_operation_attestation::AttestationFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cert_chains => {
                            if !fields.insert(__FieldTag::__cert_chains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_chains",
                                ));
                            }
                            result.cert_chains = map.next_value::<std::option::Option<
                                crate::model::key_operation_attestation::CertificateChains,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KeyOperationAttestation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if self.cert_chains.is_some() {
            state.serialize_entry("certChains", &self.cert_chains)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [KeyOperationAttestation].
pub mod key_operation_attestation {
    #[allow(unused_imports)]
    use super::*;

    /// Certificate chains needed to verify the attestation.
    /// Certificates in chains are PEM-encoded and are ordered based on
    /// <https://tools.ietf.org/html/rfc5246#section-7.4.2>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CertificateChains {
        /// Cavium certificate chain corresponding to the attestation.
        pub cavium_certs: std::vec::Vec<std::string::String>,

        /// Google card certificate chain corresponding to the attestation.
        pub google_card_certs: std::vec::Vec<std::string::String>,

        /// Google partition certificate chain corresponding to the attestation.
        pub google_partition_certs: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CertificateChains {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cavium_certs][crate::model::key_operation_attestation::CertificateChains::cavium_certs].
        pub fn set_cavium_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.cavium_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [google_card_certs][crate::model::key_operation_attestation::CertificateChains::google_card_certs].
        pub fn set_google_card_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.google_card_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [google_partition_certs][crate::model::key_operation_attestation::CertificateChains::google_partition_certs].
        pub fn set_google_partition_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.google_partition_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CertificateChains {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.kms.v1.KeyOperationAttestation.CertificateChains"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CertificateChains {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cavium_certs,
                __google_card_certs,
                __google_partition_certs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CertificateChains")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "caviumCerts" => Ok(__FieldTag::__cavium_certs),
                                "cavium_certs" => Ok(__FieldTag::__cavium_certs),
                                "googleCardCerts" => Ok(__FieldTag::__google_card_certs),
                                "google_card_certs" => Ok(__FieldTag::__google_card_certs),
                                "googlePartitionCerts" => Ok(__FieldTag::__google_partition_certs),
                                "google_partition_certs" => {
                                    Ok(__FieldTag::__google_partition_certs)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CertificateChains;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CertificateChains")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cavium_certs => {
                                if !fields.insert(__FieldTag::__cavium_certs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cavium_certs",
                                    ));
                                }
                                result.cavium_certs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__google_card_certs => {
                                if !fields.insert(__FieldTag::__google_card_certs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for google_card_certs",
                                    ));
                                }
                                result.google_card_certs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__google_partition_certs => {
                                if !fields.insert(__FieldTag::__google_partition_certs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for google_partition_certs",
                                    ));
                                }
                                result.google_partition_certs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CertificateChains {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cavium_certs.is_empty() {
                state.serialize_entry("caviumCerts", &self.cavium_certs)?;
            }
            if !self.google_card_certs.is_empty() {
                state.serialize_entry("googleCardCerts", &self.google_card_certs)?;
            }
            if !self.google_partition_certs.is_empty() {
                state.serialize_entry("googlePartitionCerts", &self.google_partition_certs)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Attestation formats provided by the HSM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttestationFormat {
        /// Not specified.
        Unspecified,
        /// Cavium HSM attestation compressed with gzip. Note that this format is
        /// defined by Cavium and subject to change at any time.
        ///
        /// See
        /// <https://www.marvell.com/products/security-solutions/nitrox-hs-adapters/software-key-attestation.html>.
        CaviumV1Compressed,
        /// Cavium HSM attestation V2 compressed with gzip. This is a new format
        /// introduced in Cavium's version 3.2-08.
        CaviumV2Compressed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttestationFormat::value] or
        /// [AttestationFormat::name].
        UnknownValue(attestation_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attestation_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttestationFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CaviumV1Compressed => std::option::Option::Some(3),
                Self::CaviumV2Compressed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTESTATION_FORMAT_UNSPECIFIED"),
                Self::CaviumV1Compressed => std::option::Option::Some("CAVIUM_V1_COMPRESSED"),
                Self::CaviumV2Compressed => std::option::Option::Some("CAVIUM_V2_COMPRESSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttestationFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttestationFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttestationFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                3 => Self::CaviumV1Compressed,
                4 => Self::CaviumV2Compressed,
                _ => Self::UnknownValue(attestation_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttestationFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTESTATION_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "CAVIUM_V1_COMPRESSED" => Self::CaviumV1Compressed,
                "CAVIUM_V2_COMPRESSED" => Self::CaviumV2Compressed,
                _ => Self::UnknownValue(attestation_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttestationFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CaviumV1Compressed => serializer.serialize_i32(3),
                Self::CaviumV2Compressed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttestationFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttestationFormat>::new(
                ".google.cloud.kms.v1.KeyOperationAttestation.AttestationFormat",
            ))
        }
    }
}

/// A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents an
/// individual cryptographic key, and the associated key material.
///
/// An
/// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
/// version can be used for cryptographic operations.
///
/// For security reasons, the raw cryptographic key material represented by a
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] can never be viewed
/// or exported. It can only be used to encrypt, decrypt, or sign data when an
/// authorized user or application invokes Cloud KMS.
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::CryptoKeyVersionState::Enabled
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoKeyVersion {
    /// Output only. The resource name for this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// The current state of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub state: crate::model::crypto_key_version::CryptoKeyVersionState,

    /// Output only. The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel]
    /// describing how crypto operations are performed with this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    /// Output only. The
    /// [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// that this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// supports.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    /// Output only. Statement that was generated and signed by the HSM at key
    /// creation time. Use this statement to verify attributes of the key as stored
    /// on the HSM, independently of Google. Only provided for key versions with
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersion.protection_level]
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.protection_level]: crate::model::CryptoKeyVersion::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    pub attestation: std::option::Option<crate::model::KeyOperationAttestation>,

    /// Output only. The time at which this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] was created.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
    /// generated.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub generate_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material is
    /// scheduled for destruction. Only present if
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]: crate::model::crypto_key_version::CryptoKeyVersionState::DestroyScheduled
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    pub destroy_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this CryptoKeyVersion's key material was
    /// destroyed. Only present if
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::CryptoKeyVersionState::Destroyed
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    pub destroy_event_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the [ImportJob][google.cloud.kms.v1.ImportJob]
    /// used in the most recent import of this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Only present if
    /// the underlying key material was imported.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub import_job: std::string::String,

    /// Output only. The time at which this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
    /// most recently imported.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub import_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The root cause of the most recent import failure. Only present
    /// if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]: crate::model::crypto_key_version::CryptoKeyVersionState::ImportFailed
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    pub import_failure_reason: std::string::String,

    /// Output only. The root cause of the most recent generation failure. Only
    /// present if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [GENERATION_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.GENERATION_FAILED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.GENERATION_FAILED]: crate::model::crypto_key_version::CryptoKeyVersionState::GenerationFailed
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    pub generation_failure_reason: std::string::String,

    /// Output only. The root cause of the most recent external destruction
    /// failure. Only present if
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [EXTERNAL_DESTRUCTION_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED]: crate::model::crypto_key_version::CryptoKeyVersionState::ExternalDestructionFailed
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    pub external_destruction_failure_reason: std::string::String,

    /// ExternalProtectionLevelOptions stores a group of additional fields for
    /// configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that
    /// are specific to the
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] protection level
    /// and [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]
    /// protection levels.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::ProtectionLevel::External
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
    pub external_protection_level_options:
        std::option::Option<crate::model::ExternalProtectionLevelOptions>,

    /// Output only. Whether or not this key version is eligible for reimport, by
    /// being specified as a target in
    /// [ImportCryptoKeyVersionRequest.crypto_key_version][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.crypto_key_version].
    ///
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.crypto_key_version]: crate::model::ImportCryptoKeyVersionRequest::crypto_key_version
    pub reimport_eligible: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKeyVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CryptoKeyVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CryptoKeyVersion::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::CryptoKeyVersion::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::CryptoKeyVersion::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [attestation][crate::model::CryptoKeyVersion::attestation].
    pub fn set_attestation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyOperationAttestation>,
    {
        self.attestation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attestation][crate::model::CryptoKeyVersion::attestation].
    pub fn set_or_clear_attestation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyOperationAttestation>,
    {
        self.attestation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::CryptoKeyVersion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CryptoKeyVersion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [generate_time][crate::model::CryptoKeyVersion::generate_time].
    pub fn set_generate_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.generate_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generate_time][crate::model::CryptoKeyVersion::generate_time].
    pub fn set_or_clear_generate_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.generate_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destroy_time][crate::model::CryptoKeyVersion::destroy_time].
    pub fn set_destroy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.destroy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destroy_time][crate::model::CryptoKeyVersion::destroy_time].
    pub fn set_or_clear_destroy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.destroy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destroy_event_time][crate::model::CryptoKeyVersion::destroy_event_time].
    pub fn set_destroy_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.destroy_event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destroy_event_time][crate::model::CryptoKeyVersion::destroy_event_time].
    pub fn set_or_clear_destroy_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.destroy_event_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_job][crate::model::CryptoKeyVersion::import_job].
    pub fn set_import_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job = v.into();
        self
    }

    /// Sets the value of [import_time][crate::model::CryptoKeyVersion::import_time].
    pub fn set_import_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.import_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_time][crate::model::CryptoKeyVersion::import_time].
    pub fn set_or_clear_import_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.import_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_failure_reason][crate::model::CryptoKeyVersion::import_failure_reason].
    pub fn set_import_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_failure_reason = v.into();
        self
    }

    /// Sets the value of [generation_failure_reason][crate::model::CryptoKeyVersion::generation_failure_reason].
    pub fn set_generation_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.generation_failure_reason = v.into();
        self
    }

    /// Sets the value of [external_destruction_failure_reason][crate::model::CryptoKeyVersion::external_destruction_failure_reason].
    pub fn set_external_destruction_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_destruction_failure_reason = v.into();
        self
    }

    /// Sets the value of [external_protection_level_options][crate::model::CryptoKeyVersion::external_protection_level_options].
    pub fn set_external_protection_level_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalProtectionLevelOptions>,
    {
        self.external_protection_level_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_protection_level_options][crate::model::CryptoKeyVersion::external_protection_level_options].
    pub fn set_or_clear_external_protection_level_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ExternalProtectionLevelOptions>,
    {
        self.external_protection_level_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reimport_eligible][crate::model::CryptoKeyVersion::reimport_eligible].
    pub fn set_reimport_eligible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reimport_eligible = v.into();
        self
    }
}

impl wkt::message::Message for CryptoKeyVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CryptoKeyVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoKeyVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __protection_level,
            __algorithm,
            __attestation,
            __create_time,
            __generate_time,
            __destroy_time,
            __destroy_event_time,
            __import_job,
            __import_time,
            __import_failure_reason,
            __generation_failure_reason,
            __external_destruction_failure_reason,
            __external_protection_level_options,
            __reimport_eligible,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoKeyVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            "attestation" => Ok(__FieldTag::__attestation),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "generateTime" => Ok(__FieldTag::__generate_time),
                            "generate_time" => Ok(__FieldTag::__generate_time),
                            "destroyTime" => Ok(__FieldTag::__destroy_time),
                            "destroy_time" => Ok(__FieldTag::__destroy_time),
                            "destroyEventTime" => Ok(__FieldTag::__destroy_event_time),
                            "destroy_event_time" => Ok(__FieldTag::__destroy_event_time),
                            "importJob" => Ok(__FieldTag::__import_job),
                            "import_job" => Ok(__FieldTag::__import_job),
                            "importTime" => Ok(__FieldTag::__import_time),
                            "import_time" => Ok(__FieldTag::__import_time),
                            "importFailureReason" => Ok(__FieldTag::__import_failure_reason),
                            "import_failure_reason" => Ok(__FieldTag::__import_failure_reason),
                            "generationFailureReason" => {
                                Ok(__FieldTag::__generation_failure_reason)
                            }
                            "generation_failure_reason" => {
                                Ok(__FieldTag::__generation_failure_reason)
                            }
                            "externalDestructionFailureReason" => {
                                Ok(__FieldTag::__external_destruction_failure_reason)
                            }
                            "external_destruction_failure_reason" => {
                                Ok(__FieldTag::__external_destruction_failure_reason)
                            }
                            "externalProtectionLevelOptions" => {
                                Ok(__FieldTag::__external_protection_level_options)
                            }
                            "external_protection_level_options" => {
                                Ok(__FieldTag::__external_protection_level_options)
                            }
                            "reimportEligible" => Ok(__FieldTag::__reimport_eligible),
                            "reimport_eligible" => Ok(__FieldTag::__reimport_eligible),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoKeyVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoKeyVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            result.algorithm = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attestation => {
                            if !fields.insert(__FieldTag::__attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attestation",
                                ));
                            }
                            result.attestation = map.next_value::<std::option::Option<crate::model::KeyOperationAttestation>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__generate_time => {
                            if !fields.insert(__FieldTag::__generate_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generate_time",
                                ));
                            }
                            result.generate_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__destroy_time => {
                            if !fields.insert(__FieldTag::__destroy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destroy_time",
                                ));
                            }
                            result.destroy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__destroy_event_time => {
                            if !fields.insert(__FieldTag::__destroy_event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destroy_event_time",
                                ));
                            }
                            result.destroy_event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__import_job => {
                            if !fields.insert(__FieldTag::__import_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job",
                                ));
                            }
                            result.import_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_time => {
                            if !fields.insert(__FieldTag::__import_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_time",
                                ));
                            }
                            result.import_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__import_failure_reason => {
                            if !fields.insert(__FieldTag::__import_failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_failure_reason",
                                ));
                            }
                            result.import_failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation_failure_reason => {
                            if !fields.insert(__FieldTag::__generation_failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_failure_reason",
                                ));
                            }
                            result.generation_failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_destruction_failure_reason => {
                            if !fields.insert(__FieldTag::__external_destruction_failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_destruction_failure_reason",
                                ));
                            }
                            result.external_destruction_failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_protection_level_options => {
                            if !fields.insert(__FieldTag::__external_protection_level_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_protection_level_options",
                                ));
                            }
                            result.external_protection_level_options =
                                map.next_value::<std::option::Option<
                                    crate::model::ExternalProtectionLevelOptions,
                                >>()?;
                        }
                        __FieldTag::__reimport_eligible => {
                            if !fields.insert(__FieldTag::__reimport_eligible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reimport_eligible",
                                ));
                            }
                            result.reimport_eligible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoKeyVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !wkt::internal::is_default(&self.algorithm) {
            state.serialize_entry("algorithm", &self.algorithm)?;
        }
        if self.attestation.is_some() {
            state.serialize_entry("attestation", &self.attestation)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.generate_time.is_some() {
            state.serialize_entry("generateTime", &self.generate_time)?;
        }
        if self.destroy_time.is_some() {
            state.serialize_entry("destroyTime", &self.destroy_time)?;
        }
        if self.destroy_event_time.is_some() {
            state.serialize_entry("destroyEventTime", &self.destroy_event_time)?;
        }
        if !self.import_job.is_empty() {
            state.serialize_entry("importJob", &self.import_job)?;
        }
        if self.import_time.is_some() {
            state.serialize_entry("importTime", &self.import_time)?;
        }
        if !self.import_failure_reason.is_empty() {
            state.serialize_entry("importFailureReason", &self.import_failure_reason)?;
        }
        if !self.generation_failure_reason.is_empty() {
            state.serialize_entry("generationFailureReason", &self.generation_failure_reason)?;
        }
        if !self.external_destruction_failure_reason.is_empty() {
            state.serialize_entry(
                "externalDestructionFailureReason",
                &self.external_destruction_failure_reason,
            )?;
        }
        if self.external_protection_level_options.is_some() {
            state.serialize_entry(
                "externalProtectionLevelOptions",
                &self.external_protection_level_options,
            )?;
        }
        if !wkt::internal::is_default(&self.reimport_eligible) {
            state.serialize_entry("reimportEligible", &self.reimport_eligible)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CryptoKeyVersion].
pub mod crypto_key_version {
    #[allow(unused_imports)]
    use super::*;

    /// The algorithm of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], indicating what
    /// parameters must be used for each cryptographic operation.
    ///
    /// The
    /// [GOOGLE_SYMMETRIC_ENCRYPTION][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION]
    /// algorithm is usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// Algorithms beginning with `RSA_SIGN_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
    ///
    /// The fields in the name after `RSA_SIGN_` correspond to the following
    /// parameters: padding algorithm, modulus bit length, and digest algorithm.
    ///
    /// For PSS, the salt length used is equal to the length of digest
    /// algorithm. For example,
    /// [RSA_SIGN_PSS_2048_SHA256][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256]
    /// will use PSS with a salt length of 256 bits or 32 bytes.
    ///
    /// Algorithms beginning with `RSA_DECRYPT_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
    ///
    /// The fields in the name after `RSA_DECRYPT_` correspond to the following
    /// parameters: padding algorithm, modulus bit length, and digest algorithm.
    ///
    /// Algorithms beginning with `EC_SIGN_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
    ///
    /// The fields in the name after `EC_SIGN_` correspond to the following
    /// parameters: elliptic curve, digest algorithm.
    ///
    /// Algorithms beginning with `HMAC_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [MAC][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.MAC].
    ///
    /// The suffix following `HMAC_` corresponds to the hash algorithm being used
    /// (eg. SHA256).
    ///
    /// Algorithms beginning with `PQ_` are post-quantum.
    ///
    /// For more information, see [Key purposes and algorithms]
    /// (<https://cloud.google.com/kms/docs/algorithms>).
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT]: crate::model::crypto_key::CryptoKeyPurpose::AsymmetricDecrypt
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]: crate::model::crypto_key::CryptoKeyPurpose::AsymmetricSign
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::CryptoKeyPurpose::EncryptDecrypt
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.MAC]: crate::model::crypto_key::CryptoKeyPurpose::Mac
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm::GoogleSymmetricEncryption
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm::RsaSignPss2048Sha256
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CryptoKeyVersionAlgorithm {
        /// Not specified.
        Unspecified,
        /// Creates symmetric encryption keys.
        GoogleSymmetricEncryption,
        /// AES-GCM (Galois Counter Mode) using 128-bit keys.
        Aes128Gcm,
        /// AES-GCM (Galois Counter Mode) using 256-bit keys.
        Aes256Gcm,
        /// AES-CBC (Cipher Block Chaining Mode) using 128-bit keys.
        Aes128Cbc,
        /// AES-CBC (Cipher Block Chaining Mode) using 256-bit keys.
        Aes256Cbc,
        /// AES-CTR (Counter Mode) using 128-bit keys.
        Aes128Ctr,
        /// AES-CTR (Counter Mode) using 256-bit keys.
        Aes256Ctr,
        /// RSASSA-PSS 2048 bit key with a SHA256 digest.
        RsaSignPss2048Sha256,
        /// RSASSA-PSS 3072 bit key with a SHA256 digest.
        RsaSignPss3072Sha256,
        /// RSASSA-PSS 4096 bit key with a SHA256 digest.
        RsaSignPss4096Sha256,
        /// RSASSA-PSS 4096 bit key with a SHA512 digest.
        RsaSignPss4096Sha512,
        /// RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.
        RsaSignPkcs12048Sha256,
        /// RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.
        RsaSignPkcs13072Sha256,
        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.
        RsaSignPkcs14096Sha256,
        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.
        RsaSignPkcs14096Sha512,
        /// RSASSA-PKCS1-v1_5 signing without encoding, with a 2048 bit key.
        RsaSignRawPkcs12048,
        /// RSASSA-PKCS1-v1_5 signing without encoding, with a 3072 bit key.
        RsaSignRawPkcs13072,
        /// RSASSA-PKCS1-v1_5 signing without encoding, with a 4096 bit key.
        RsaSignRawPkcs14096,
        /// RSAES-OAEP 2048 bit key with a SHA256 digest.
        RsaDecryptOaep2048Sha256,
        /// RSAES-OAEP 3072 bit key with a SHA256 digest.
        RsaDecryptOaep3072Sha256,
        /// RSAES-OAEP 4096 bit key with a SHA256 digest.
        RsaDecryptOaep4096Sha256,
        /// RSAES-OAEP 4096 bit key with a SHA512 digest.
        RsaDecryptOaep4096Sha512,
        /// RSAES-OAEP 2048 bit key with a SHA1 digest.
        RsaDecryptOaep2048Sha1,
        /// RSAES-OAEP 3072 bit key with a SHA1 digest.
        RsaDecryptOaep3072Sha1,
        /// RSAES-OAEP 4096 bit key with a SHA1 digest.
        RsaDecryptOaep4096Sha1,
        /// ECDSA on the NIST P-256 curve with a SHA256 digest.
        /// Other hash functions can also be used:
        /// <https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms>
        EcSignP256Sha256,
        /// ECDSA on the NIST P-384 curve with a SHA384 digest.
        /// Other hash functions can also be used:
        /// <https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms>
        EcSignP384Sha384,
        /// ECDSA on the non-NIST secp256k1 curve. This curve is only supported for
        /// HSM protection level.
        /// Other hash functions can also be used:
        /// <https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms>
        EcSignSecp256K1Sha256,
        /// EdDSA on the Curve25519 in pure mode (taking data as input).
        EcSignEd25519,
        /// HMAC-SHA256 signing with a 256 bit key.
        HmacSha256,
        /// HMAC-SHA1 signing with a 160 bit key.
        HmacSha1,
        /// HMAC-SHA384 signing with a 384 bit key.
        HmacSha384,
        /// HMAC-SHA512 signing with a 512 bit key.
        HmacSha512,
        /// HMAC-SHA224 signing with a 224 bit key.
        HmacSha224,
        /// Algorithm representing symmetric encryption by an external key manager.
        ExternalSymmetricEncryption,
        /// The post-quantum Module-Lattice-Based Digital Signature Algorithm, at
        /// security level 3. Randomized version.
        PqSignMlDsa65,
        /// The post-quantum stateless hash-based digital signature algorithm, at
        /// security level 1. Randomized version.
        PqSignSlhDsaSha2128S,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CryptoKeyVersionAlgorithm::value] or
        /// [CryptoKeyVersionAlgorithm::name].
        UnknownValue(crypto_key_version_algorithm::UnknownValue),
    }

    #[doc(hidden)]
    pub mod crypto_key_version_algorithm {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CryptoKeyVersionAlgorithm {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleSymmetricEncryption => std::option::Option::Some(1),
                Self::Aes128Gcm => std::option::Option::Some(41),
                Self::Aes256Gcm => std::option::Option::Some(19),
                Self::Aes128Cbc => std::option::Option::Some(42),
                Self::Aes256Cbc => std::option::Option::Some(43),
                Self::Aes128Ctr => std::option::Option::Some(44),
                Self::Aes256Ctr => std::option::Option::Some(45),
                Self::RsaSignPss2048Sha256 => std::option::Option::Some(2),
                Self::RsaSignPss3072Sha256 => std::option::Option::Some(3),
                Self::RsaSignPss4096Sha256 => std::option::Option::Some(4),
                Self::RsaSignPss4096Sha512 => std::option::Option::Some(15),
                Self::RsaSignPkcs12048Sha256 => std::option::Option::Some(5),
                Self::RsaSignPkcs13072Sha256 => std::option::Option::Some(6),
                Self::RsaSignPkcs14096Sha256 => std::option::Option::Some(7),
                Self::RsaSignPkcs14096Sha512 => std::option::Option::Some(16),
                Self::RsaSignRawPkcs12048 => std::option::Option::Some(28),
                Self::RsaSignRawPkcs13072 => std::option::Option::Some(29),
                Self::RsaSignRawPkcs14096 => std::option::Option::Some(30),
                Self::RsaDecryptOaep2048Sha256 => std::option::Option::Some(8),
                Self::RsaDecryptOaep3072Sha256 => std::option::Option::Some(9),
                Self::RsaDecryptOaep4096Sha256 => std::option::Option::Some(10),
                Self::RsaDecryptOaep4096Sha512 => std::option::Option::Some(17),
                Self::RsaDecryptOaep2048Sha1 => std::option::Option::Some(37),
                Self::RsaDecryptOaep3072Sha1 => std::option::Option::Some(38),
                Self::RsaDecryptOaep4096Sha1 => std::option::Option::Some(39),
                Self::EcSignP256Sha256 => std::option::Option::Some(12),
                Self::EcSignP384Sha384 => std::option::Option::Some(13),
                Self::EcSignSecp256K1Sha256 => std::option::Option::Some(31),
                Self::EcSignEd25519 => std::option::Option::Some(40),
                Self::HmacSha256 => std::option::Option::Some(32),
                Self::HmacSha1 => std::option::Option::Some(33),
                Self::HmacSha384 => std::option::Option::Some(34),
                Self::HmacSha512 => std::option::Option::Some(35),
                Self::HmacSha224 => std::option::Option::Some(36),
                Self::ExternalSymmetricEncryption => std::option::Option::Some(18),
                Self::PqSignMlDsa65 => std::option::Option::Some(56),
                Self::PqSignSlhDsaSha2128S => std::option::Option::Some(57),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED")
                }
                Self::GoogleSymmetricEncryption => {
                    std::option::Option::Some("GOOGLE_SYMMETRIC_ENCRYPTION")
                }
                Self::Aes128Gcm => std::option::Option::Some("AES_128_GCM"),
                Self::Aes256Gcm => std::option::Option::Some("AES_256_GCM"),
                Self::Aes128Cbc => std::option::Option::Some("AES_128_CBC"),
                Self::Aes256Cbc => std::option::Option::Some("AES_256_CBC"),
                Self::Aes128Ctr => std::option::Option::Some("AES_128_CTR"),
                Self::Aes256Ctr => std::option::Option::Some("AES_256_CTR"),
                Self::RsaSignPss2048Sha256 => std::option::Option::Some("RSA_SIGN_PSS_2048_SHA256"),
                Self::RsaSignPss3072Sha256 => std::option::Option::Some("RSA_SIGN_PSS_3072_SHA256"),
                Self::RsaSignPss4096Sha256 => std::option::Option::Some("RSA_SIGN_PSS_4096_SHA256"),
                Self::RsaSignPss4096Sha512 => std::option::Option::Some("RSA_SIGN_PSS_4096_SHA512"),
                Self::RsaSignPkcs12048Sha256 => {
                    std::option::Option::Some("RSA_SIGN_PKCS1_2048_SHA256")
                }
                Self::RsaSignPkcs13072Sha256 => {
                    std::option::Option::Some("RSA_SIGN_PKCS1_3072_SHA256")
                }
                Self::RsaSignPkcs14096Sha256 => {
                    std::option::Option::Some("RSA_SIGN_PKCS1_4096_SHA256")
                }
                Self::RsaSignPkcs14096Sha512 => {
                    std::option::Option::Some("RSA_SIGN_PKCS1_4096_SHA512")
                }
                Self::RsaSignRawPkcs12048 => std::option::Option::Some("RSA_SIGN_RAW_PKCS1_2048"),
                Self::RsaSignRawPkcs13072 => std::option::Option::Some("RSA_SIGN_RAW_PKCS1_3072"),
                Self::RsaSignRawPkcs14096 => std::option::Option::Some("RSA_SIGN_RAW_PKCS1_4096"),
                Self::RsaDecryptOaep2048Sha256 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_2048_SHA256")
                }
                Self::RsaDecryptOaep3072Sha256 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_3072_SHA256")
                }
                Self::RsaDecryptOaep4096Sha256 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_4096_SHA256")
                }
                Self::RsaDecryptOaep4096Sha512 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_4096_SHA512")
                }
                Self::RsaDecryptOaep2048Sha1 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_2048_SHA1")
                }
                Self::RsaDecryptOaep3072Sha1 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_3072_SHA1")
                }
                Self::RsaDecryptOaep4096Sha1 => {
                    std::option::Option::Some("RSA_DECRYPT_OAEP_4096_SHA1")
                }
                Self::EcSignP256Sha256 => std::option::Option::Some("EC_SIGN_P256_SHA256"),
                Self::EcSignP384Sha384 => std::option::Option::Some("EC_SIGN_P384_SHA384"),
                Self::EcSignSecp256K1Sha256 => {
                    std::option::Option::Some("EC_SIGN_SECP256K1_SHA256")
                }
                Self::EcSignEd25519 => std::option::Option::Some("EC_SIGN_ED25519"),
                Self::HmacSha256 => std::option::Option::Some("HMAC_SHA256"),
                Self::HmacSha1 => std::option::Option::Some("HMAC_SHA1"),
                Self::HmacSha384 => std::option::Option::Some("HMAC_SHA384"),
                Self::HmacSha512 => std::option::Option::Some("HMAC_SHA512"),
                Self::HmacSha224 => std::option::Option::Some("HMAC_SHA224"),
                Self::ExternalSymmetricEncryption => {
                    std::option::Option::Some("EXTERNAL_SYMMETRIC_ENCRYPTION")
                }
                Self::PqSignMlDsa65 => std::option::Option::Some("PQ_SIGN_ML_DSA_65"),
                Self::PqSignSlhDsaSha2128S => {
                    std::option::Option::Some("PQ_SIGN_SLH_DSA_SHA2_128S")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CryptoKeyVersionAlgorithm {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CryptoKeyVersionAlgorithm {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CryptoKeyVersionAlgorithm {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleSymmetricEncryption,
                2 => Self::RsaSignPss2048Sha256,
                3 => Self::RsaSignPss3072Sha256,
                4 => Self::RsaSignPss4096Sha256,
                5 => Self::RsaSignPkcs12048Sha256,
                6 => Self::RsaSignPkcs13072Sha256,
                7 => Self::RsaSignPkcs14096Sha256,
                8 => Self::RsaDecryptOaep2048Sha256,
                9 => Self::RsaDecryptOaep3072Sha256,
                10 => Self::RsaDecryptOaep4096Sha256,
                12 => Self::EcSignP256Sha256,
                13 => Self::EcSignP384Sha384,
                15 => Self::RsaSignPss4096Sha512,
                16 => Self::RsaSignPkcs14096Sha512,
                17 => Self::RsaDecryptOaep4096Sha512,
                18 => Self::ExternalSymmetricEncryption,
                19 => Self::Aes256Gcm,
                28 => Self::RsaSignRawPkcs12048,
                29 => Self::RsaSignRawPkcs13072,
                30 => Self::RsaSignRawPkcs14096,
                31 => Self::EcSignSecp256K1Sha256,
                32 => Self::HmacSha256,
                33 => Self::HmacSha1,
                34 => Self::HmacSha384,
                35 => Self::HmacSha512,
                36 => Self::HmacSha224,
                37 => Self::RsaDecryptOaep2048Sha1,
                38 => Self::RsaDecryptOaep3072Sha1,
                39 => Self::RsaDecryptOaep4096Sha1,
                40 => Self::EcSignEd25519,
                41 => Self::Aes128Gcm,
                42 => Self::Aes128Cbc,
                43 => Self::Aes256Cbc,
                44 => Self::Aes128Ctr,
                45 => Self::Aes256Ctr,
                56 => Self::PqSignMlDsa65,
                57 => Self::PqSignSlhDsaSha2128S,
                _ => Self::UnknownValue(crypto_key_version_algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CryptoKeyVersionAlgorithm {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_SYMMETRIC_ENCRYPTION" => Self::GoogleSymmetricEncryption,
                "AES_128_GCM" => Self::Aes128Gcm,
                "AES_256_GCM" => Self::Aes256Gcm,
                "AES_128_CBC" => Self::Aes128Cbc,
                "AES_256_CBC" => Self::Aes256Cbc,
                "AES_128_CTR" => Self::Aes128Ctr,
                "AES_256_CTR" => Self::Aes256Ctr,
                "RSA_SIGN_PSS_2048_SHA256" => Self::RsaSignPss2048Sha256,
                "RSA_SIGN_PSS_3072_SHA256" => Self::RsaSignPss3072Sha256,
                "RSA_SIGN_PSS_4096_SHA256" => Self::RsaSignPss4096Sha256,
                "RSA_SIGN_PSS_4096_SHA512" => Self::RsaSignPss4096Sha512,
                "RSA_SIGN_PKCS1_2048_SHA256" => Self::RsaSignPkcs12048Sha256,
                "RSA_SIGN_PKCS1_3072_SHA256" => Self::RsaSignPkcs13072Sha256,
                "RSA_SIGN_PKCS1_4096_SHA256" => Self::RsaSignPkcs14096Sha256,
                "RSA_SIGN_PKCS1_4096_SHA512" => Self::RsaSignPkcs14096Sha512,
                "RSA_SIGN_RAW_PKCS1_2048" => Self::RsaSignRawPkcs12048,
                "RSA_SIGN_RAW_PKCS1_3072" => Self::RsaSignRawPkcs13072,
                "RSA_SIGN_RAW_PKCS1_4096" => Self::RsaSignRawPkcs14096,
                "RSA_DECRYPT_OAEP_2048_SHA256" => Self::RsaDecryptOaep2048Sha256,
                "RSA_DECRYPT_OAEP_3072_SHA256" => Self::RsaDecryptOaep3072Sha256,
                "RSA_DECRYPT_OAEP_4096_SHA256" => Self::RsaDecryptOaep4096Sha256,
                "RSA_DECRYPT_OAEP_4096_SHA512" => Self::RsaDecryptOaep4096Sha512,
                "RSA_DECRYPT_OAEP_2048_SHA1" => Self::RsaDecryptOaep2048Sha1,
                "RSA_DECRYPT_OAEP_3072_SHA1" => Self::RsaDecryptOaep3072Sha1,
                "RSA_DECRYPT_OAEP_4096_SHA1" => Self::RsaDecryptOaep4096Sha1,
                "EC_SIGN_P256_SHA256" => Self::EcSignP256Sha256,
                "EC_SIGN_P384_SHA384" => Self::EcSignP384Sha384,
                "EC_SIGN_SECP256K1_SHA256" => Self::EcSignSecp256K1Sha256,
                "EC_SIGN_ED25519" => Self::EcSignEd25519,
                "HMAC_SHA256" => Self::HmacSha256,
                "HMAC_SHA1" => Self::HmacSha1,
                "HMAC_SHA384" => Self::HmacSha384,
                "HMAC_SHA512" => Self::HmacSha512,
                "HMAC_SHA224" => Self::HmacSha224,
                "EXTERNAL_SYMMETRIC_ENCRYPTION" => Self::ExternalSymmetricEncryption,
                "PQ_SIGN_ML_DSA_65" => Self::PqSignMlDsa65,
                "PQ_SIGN_SLH_DSA_SHA2_128S" => Self::PqSignSlhDsaSha2128S,
                _ => Self::UnknownValue(crypto_key_version_algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CryptoKeyVersionAlgorithm {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleSymmetricEncryption => serializer.serialize_i32(1),
                Self::Aes128Gcm => serializer.serialize_i32(41),
                Self::Aes256Gcm => serializer.serialize_i32(19),
                Self::Aes128Cbc => serializer.serialize_i32(42),
                Self::Aes256Cbc => serializer.serialize_i32(43),
                Self::Aes128Ctr => serializer.serialize_i32(44),
                Self::Aes256Ctr => serializer.serialize_i32(45),
                Self::RsaSignPss2048Sha256 => serializer.serialize_i32(2),
                Self::RsaSignPss3072Sha256 => serializer.serialize_i32(3),
                Self::RsaSignPss4096Sha256 => serializer.serialize_i32(4),
                Self::RsaSignPss4096Sha512 => serializer.serialize_i32(15),
                Self::RsaSignPkcs12048Sha256 => serializer.serialize_i32(5),
                Self::RsaSignPkcs13072Sha256 => serializer.serialize_i32(6),
                Self::RsaSignPkcs14096Sha256 => serializer.serialize_i32(7),
                Self::RsaSignPkcs14096Sha512 => serializer.serialize_i32(16),
                Self::RsaSignRawPkcs12048 => serializer.serialize_i32(28),
                Self::RsaSignRawPkcs13072 => serializer.serialize_i32(29),
                Self::RsaSignRawPkcs14096 => serializer.serialize_i32(30),
                Self::RsaDecryptOaep2048Sha256 => serializer.serialize_i32(8),
                Self::RsaDecryptOaep3072Sha256 => serializer.serialize_i32(9),
                Self::RsaDecryptOaep4096Sha256 => serializer.serialize_i32(10),
                Self::RsaDecryptOaep4096Sha512 => serializer.serialize_i32(17),
                Self::RsaDecryptOaep2048Sha1 => serializer.serialize_i32(37),
                Self::RsaDecryptOaep3072Sha1 => serializer.serialize_i32(38),
                Self::RsaDecryptOaep4096Sha1 => serializer.serialize_i32(39),
                Self::EcSignP256Sha256 => serializer.serialize_i32(12),
                Self::EcSignP384Sha384 => serializer.serialize_i32(13),
                Self::EcSignSecp256K1Sha256 => serializer.serialize_i32(31),
                Self::EcSignEd25519 => serializer.serialize_i32(40),
                Self::HmacSha256 => serializer.serialize_i32(32),
                Self::HmacSha1 => serializer.serialize_i32(33),
                Self::HmacSha384 => serializer.serialize_i32(34),
                Self::HmacSha512 => serializer.serialize_i32(35),
                Self::HmacSha224 => serializer.serialize_i32(36),
                Self::ExternalSymmetricEncryption => serializer.serialize_i32(18),
                Self::PqSignMlDsa65 => serializer.serialize_i32(56),
                Self::PqSignSlhDsaSha2128S => serializer.serialize_i32(57),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CryptoKeyVersionAlgorithm {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<CryptoKeyVersionAlgorithm>::new(
                    ".google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm",
                ),
            )
        }
    }

    /// The state of a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion],
    /// indicating if it can be used.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CryptoKeyVersionState {
        /// Not specified.
        Unspecified,
        /// This version is still being generated. It may not be used, enabled,
        /// disabled, or destroyed yet. Cloud KMS will automatically mark this
        /// version
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// as soon as the version is ready.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::CryptoKeyVersionState::Enabled
        PendingGeneration,
        /// This version may be used for cryptographic operations.
        Enabled,
        /// This version may not be used, but the key material is still available,
        /// and the version can be placed back into the
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// state.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::CryptoKeyVersionState::Enabled
        Disabled,
        /// The key material of this version is destroyed and no longer stored.
        /// This version may only become
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// again if this version is
        /// [reimport_eligible][google.cloud.kms.v1.CryptoKeyVersion.reimport_eligible]
        /// and the original key material is reimported with a call to
        /// [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::CryptoKeyVersionState::Enabled
        /// [google.cloud.kms.v1.CryptoKeyVersion.reimport_eligible]: crate::model::CryptoKeyVersion::reimport_eligible
        /// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
        Destroyed,
        /// This version is scheduled for destruction, and will be destroyed soon.
        /// Call
        /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
        /// to put it back into the
        /// [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
        /// state.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]: crate::model::crypto_key_version::CryptoKeyVersionState::Disabled
        /// [google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]: crate::client::KeyManagementService::restore_crypto_key_version
        DestroyScheduled,
        /// This version is still being imported. It may not be used, enabled,
        /// disabled, or destroyed yet. Cloud KMS will automatically mark this
        /// version
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// as soon as the version is ready.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::CryptoKeyVersionState::Enabled
        PendingImport,
        /// This version was not imported successfully. It may not be used, enabled,
        /// disabled, or destroyed. The submitted key material has been discarded.
        /// Additional details can be found in
        /// [CryptoKeyVersion.import_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.import_failure_reason].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.import_failure_reason]: crate::model::CryptoKeyVersion::import_failure_reason
        ImportFailed,
        /// This version was not generated successfully. It may not be used, enabled,
        /// disabled, or destroyed. Additional details can be found in
        /// [CryptoKeyVersion.generation_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.generation_failure_reason].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.generation_failure_reason]: crate::model::CryptoKeyVersion::generation_failure_reason
        GenerationFailed,
        /// This version was destroyed, and it may not be used or enabled again.
        /// Cloud KMS is waiting for the corresponding key material residing in an
        /// external key manager to be destroyed.
        PendingExternalDestruction,
        /// This version was destroyed, and it may not be used or enabled again.
        /// However, Cloud KMS could not confirm that the corresponding key material
        /// residing in an external key manager was destroyed. Additional details can
        /// be found in
        /// [CryptoKeyVersion.external_destruction_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.external_destruction_failure_reason].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.external_destruction_failure_reason]: crate::model::CryptoKeyVersion::external_destruction_failure_reason
        ExternalDestructionFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CryptoKeyVersionState::value] or
        /// [CryptoKeyVersionState::name].
        UnknownValue(crypto_key_version_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod crypto_key_version_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CryptoKeyVersionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PendingGeneration => std::option::Option::Some(5),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Destroyed => std::option::Option::Some(3),
                Self::DestroyScheduled => std::option::Option::Some(4),
                Self::PendingImport => std::option::Option::Some(6),
                Self::ImportFailed => std::option::Option::Some(7),
                Self::GenerationFailed => std::option::Option::Some(8),
                Self::PendingExternalDestruction => std::option::Option::Some(9),
                Self::ExternalDestructionFailed => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CRYPTO_KEY_VERSION_STATE_UNSPECIFIED")
                }
                Self::PendingGeneration => std::option::Option::Some("PENDING_GENERATION"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Destroyed => std::option::Option::Some("DESTROYED"),
                Self::DestroyScheduled => std::option::Option::Some("DESTROY_SCHEDULED"),
                Self::PendingImport => std::option::Option::Some("PENDING_IMPORT"),
                Self::ImportFailed => std::option::Option::Some("IMPORT_FAILED"),
                Self::GenerationFailed => std::option::Option::Some("GENERATION_FAILED"),
                Self::PendingExternalDestruction => {
                    std::option::Option::Some("PENDING_EXTERNAL_DESTRUCTION")
                }
                Self::ExternalDestructionFailed => {
                    std::option::Option::Some("EXTERNAL_DESTRUCTION_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CryptoKeyVersionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CryptoKeyVersionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CryptoKeyVersionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Destroyed,
                4 => Self::DestroyScheduled,
                5 => Self::PendingGeneration,
                6 => Self::PendingImport,
                7 => Self::ImportFailed,
                8 => Self::GenerationFailed,
                9 => Self::PendingExternalDestruction,
                10 => Self::ExternalDestructionFailed,
                _ => Self::UnknownValue(crypto_key_version_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CryptoKeyVersionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING_GENERATION" => Self::PendingGeneration,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "DESTROYED" => Self::Destroyed,
                "DESTROY_SCHEDULED" => Self::DestroyScheduled,
                "PENDING_IMPORT" => Self::PendingImport,
                "IMPORT_FAILED" => Self::ImportFailed,
                "GENERATION_FAILED" => Self::GenerationFailed,
                "PENDING_EXTERNAL_DESTRUCTION" => Self::PendingExternalDestruction,
                "EXTERNAL_DESTRUCTION_FAILED" => Self::ExternalDestructionFailed,
                _ => Self::UnknownValue(crypto_key_version_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CryptoKeyVersionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PendingGeneration => serializer.serialize_i32(5),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Destroyed => serializer.serialize_i32(3),
                Self::DestroyScheduled => serializer.serialize_i32(4),
                Self::PendingImport => serializer.serialize_i32(6),
                Self::ImportFailed => serializer.serialize_i32(7),
                Self::GenerationFailed => serializer.serialize_i32(8),
                Self::PendingExternalDestruction => serializer.serialize_i32(9),
                Self::ExternalDestructionFailed => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CryptoKeyVersionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CryptoKeyVersionState>::new(
                ".google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState",
            ))
        }
    }

    /// A view for [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]s.
    /// Controls the level of detail returned for
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] in
    /// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]
    /// and
    /// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]: crate::client::KeyManagementService::list_crypto_key_versions
    /// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeys]: crate::client::KeyManagementService::list_crypto_keys
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CryptoKeyVersionView {
        /// Default view for each
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Does not
        /// include the
        /// [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation] field.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.CryptoKeyVersion.attestation]: crate::model::CryptoKeyVersion::attestation
        Unspecified,
        /// Provides all fields in each
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], including the
        /// [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.CryptoKeyVersion.attestation]: crate::model::CryptoKeyVersion::attestation
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CryptoKeyVersionView::value] or
        /// [CryptoKeyVersionView::name].
        UnknownValue(crypto_key_version_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod crypto_key_version_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CryptoKeyVersionView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED")
                }
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CryptoKeyVersionView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CryptoKeyVersionView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CryptoKeyVersionView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Full,
                _ => Self::UnknownValue(crypto_key_version_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CryptoKeyVersionView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED" => Self::Unspecified,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(crypto_key_version_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CryptoKeyVersionView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CryptoKeyVersionView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CryptoKeyVersionView>::new(
                ".google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionView",
            ))
        }
    }
}

/// Data with integrity verification field.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ChecksummedData {
    /// Raw Data.
    pub data: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C
    /// checksum of the returned
    /// [ChecksummedData.data][google.cloud.kms.v1.ChecksummedData.data]. An
    /// integrity check of
    /// [ChecksummedData.data][google.cloud.kms.v1.ChecksummedData.data] can be
    /// performed by computing the CRC32C checksum of
    /// [ChecksummedData.data][google.cloud.kms.v1.ChecksummedData.data] and
    /// comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed `2^32-1`, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.ChecksummedData.data]: crate::model::ChecksummedData::data
    pub crc32c_checksum: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChecksummedData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::ChecksummedData::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [crc32c_checksum][crate::model::ChecksummedData::crc32c_checksum].
    pub fn set_crc32c_checksum<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.crc32c_checksum = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crc32c_checksum][crate::model::ChecksummedData::crc32c_checksum].
    pub fn set_or_clear_crc32c_checksum<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.crc32c_checksum = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ChecksummedData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ChecksummedData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChecksummedData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data,
            __crc32c_checksum,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChecksummedData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "data" => Ok(__FieldTag::__data),
                            "crc32cChecksum" => Ok(__FieldTag::__crc32c_checksum),
                            "crc32c_checksum" => Ok(__FieldTag::__crc32c_checksum),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChecksummedData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChecksummedData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__crc32c_checksum => {
                            if !fields.insert(__FieldTag::__crc32c_checksum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crc32c_checksum",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.crc32c_checksum = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChecksummedData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if self.crc32c_checksum.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("crc32cChecksum", &__With(&self.crc32c_checksum))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The public keys for a given
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Obtained via
/// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PublicKey {
    /// The public key, encoded in PEM format. For more information, see the
    /// [RFC 7468](https://tools.ietf.org/html/rfc7468) sections for
    /// [General Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
    /// [Textual Encoding of Subject Public Key Info]
    /// (<https://tools.ietf.org/html/rfc7468#section-13>).
    pub pem: std::string::String,

    /// The
    /// [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// associated with this key.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem]. An integrity check of
    /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] can be performed by
    /// computing the CRC32C checksum of
    /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] and comparing your
    /// results to this field. Discard the response in case of non-matching
    /// checksum values, and perform a limited number of retries. A persistent
    /// mismatch may indicate an issue in your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed `2^32-1`, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// NOTE: This field is in Beta.
    ///
    /// [google.cloud.kms.v1.PublicKey.pem]: crate::model::PublicKey::pem
    pub pem_crc32c: std::option::Option<wkt::Int64Value>,

    /// The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
    /// Provided here for verification.
    ///
    /// NOTE: This field is in Beta.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    pub name: std::string::String,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    /// The [PublicKey][google.cloud.kms.v1.PublicKey] format specified by the
    /// customer through the
    /// [public_key_format][google.cloud.kms.v1.GetPublicKeyRequest.public_key_format]
    /// field.
    ///
    /// [google.cloud.kms.v1.GetPublicKeyRequest.public_key_format]: crate::model::GetPublicKeyRequest::public_key_format
    /// [google.cloud.kms.v1.PublicKey]: crate::model::PublicKey
    pub public_key_format: crate::model::public_key::PublicKeyFormat,

    /// This field contains the public key (with integrity verification), formatted
    /// according to the
    /// [public_key_format][google.cloud.kms.v1.PublicKey.public_key_format] field.
    ///
    /// [google.cloud.kms.v1.PublicKey.public_key_format]: crate::model::PublicKey::public_key_format
    pub public_key: std::option::Option<crate::model::ChecksummedData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PublicKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pem][crate::model::PublicKey::pem].
    pub fn set_pem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::PublicKey::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [pem_crc32c][crate::model::PublicKey::pem_crc32c].
    pub fn set_pem_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.pem_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pem_crc32c][crate::model::PublicKey::pem_crc32c].
    pub fn set_or_clear_pem_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.pem_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::PublicKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::PublicKey::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [public_key_format][crate::model::PublicKey::public_key_format].
    pub fn set_public_key_format<
        T: std::convert::Into<crate::model::public_key::PublicKeyFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.public_key_format = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::PublicKey::public_key].
    pub fn set_public_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ChecksummedData>,
    {
        self.public_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_key][crate::model::PublicKey::public_key].
    pub fn set_or_clear_public_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ChecksummedData>,
    {
        self.public_key = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PublicKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.PublicKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PublicKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pem,
            __algorithm,
            __pem_crc32c,
            __name,
            __protection_level,
            __public_key_format,
            __public_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublicKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pem" => Ok(__FieldTag::__pem),
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            "pemCrc32c" => Ok(__FieldTag::__pem_crc32c),
                            "pem_crc32c" => Ok(__FieldTag::__pem_crc32c),
                            "name" => Ok(__FieldTag::__name),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            "publicKeyFormat" => Ok(__FieldTag::__public_key_format),
                            "public_key_format" => Ok(__FieldTag::__public_key_format),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PublicKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublicKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pem => {
                            if !fields.insert(__FieldTag::__pem) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem",
                                ));
                            }
                            result.pem = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            result.algorithm = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pem_crc32c => {
                            if !fields.insert(__FieldTag::__pem_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pem_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_key_format => {
                            if !fields.insert(__FieldTag::__public_key_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key_format",
                                ));
                            }
                            result.public_key_format = map.next_value::<std::option::Option<crate::model::public_key::PublicKeyFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<crate::model::ChecksummedData>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PublicKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pem.is_empty() {
            state.serialize_entry("pem", &self.pem)?;
        }
        if !wkt::internal::is_default(&self.algorithm) {
            state.serialize_entry("algorithm", &self.algorithm)?;
        }
        if self.pem_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pemCrc32c", &__With(&self.pem_crc32c))?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !wkt::internal::is_default(&self.public_key_format) {
            state.serialize_entry("publicKeyFormat", &self.public_key_format)?;
        }
        if self.public_key.is_some() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PublicKey].
pub mod public_key {
    #[allow(unused_imports)]
    use super::*;

    /// The supported [PublicKey][google.cloud.kms.v1.PublicKey] formats.
    ///
    /// [google.cloud.kms.v1.PublicKey]: crate::model::PublicKey
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PublicKeyFormat {
        /// If the
        /// [public_key_format][google.cloud.kms.v1.GetPublicKeyRequest.public_key_format]
        /// field is not specified:
        ///
        /// - For PQC algorithms, an error will be returned.
        /// - For non-PQC algorithms, the default format is PEM, and the field
        ///   [pem][google.cloud.kms.v1.PublicKey.pem] will be populated.
        ///
        /// Otherwise, the public key will be exported through the
        /// [public_key][google.cloud.kms.v1.PublicKey.public_key] field in the
        /// requested format.
        ///
        /// [google.cloud.kms.v1.GetPublicKeyRequest.public_key_format]: crate::model::GetPublicKeyRequest::public_key_format
        /// [google.cloud.kms.v1.PublicKey.pem]: crate::model::PublicKey::pem
        /// [google.cloud.kms.v1.PublicKey.public_key]: crate::model::PublicKey::public_key
        Unspecified,
        /// The returned public key will be encoded in PEM format.
        /// See the [RFC7468](https://tools.ietf.org/html/rfc7468) sections for
        /// [General Considerations](https://tools.ietf.org/html/rfc7468#section-2)
        /// and [Textual Encoding of Subject Public Key Info]
        /// (<https://tools.ietf.org/html/rfc7468#section-13>) for more information.
        Pem,
        /// This is supported only for PQC algorithms.
        /// The key material is returned in the format defined by NIST PQC
        /// standards (FIPS 203, FIPS 204, and FIPS 205).
        NistPqc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PublicKeyFormat::value] or
        /// [PublicKeyFormat::name].
        UnknownValue(public_key_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod public_key_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PublicKeyFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pem => std::option::Option::Some(1),
                Self::NistPqc => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PUBLIC_KEY_FORMAT_UNSPECIFIED"),
                Self::Pem => std::option::Option::Some("PEM"),
                Self::NistPqc => std::option::Option::Some("NIST_PQC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PublicKeyFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PublicKeyFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PublicKeyFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pem,
                3 => Self::NistPqc,
                _ => Self::UnknownValue(public_key_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PublicKeyFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PUBLIC_KEY_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "PEM" => Self::Pem,
                "NIST_PQC" => Self::NistPqc,
                _ => Self::UnknownValue(public_key_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PublicKeyFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pem => serializer.serialize_i32(1),
                Self::NistPqc => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PublicKeyFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PublicKeyFormat>::new(
                ".google.cloud.kms.v1.PublicKey.PublicKeyFormat",
            ))
        }
    }
}

/// An [ImportJob][google.cloud.kms.v1.ImportJob] can be used to create
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] using pre-existing
/// key material, generated outside of Cloud KMS.
///
/// When an [ImportJob][google.cloud.kms.v1.ImportJob] is created, Cloud KMS will
/// generate a "wrapping key", which is a public/private key pair. You use the
/// wrapping key to encrypt (also known as wrap) the pre-existing key material to
/// protect it during the import process. The nature of the wrapping key depends
/// on the choice of
/// [import_method][google.cloud.kms.v1.ImportJob.import_method]. When the
/// wrapping key generation is complete, the
/// [state][google.cloud.kms.v1.ImportJob.state] will be set to
/// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] and the
/// [public_key][google.cloud.kms.v1.ImportJob.public_key] can be fetched. The
/// fetched public key can then be used to wrap your pre-existing key material.
///
/// Once the key material is wrapped, it can be imported into a new
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in an existing
/// [CryptoKey][google.cloud.kms.v1.CryptoKey] by calling
/// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
/// Multiple [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] can be
/// imported with a single [ImportJob][google.cloud.kms.v1.ImportJob]. Cloud KMS
/// uses the private key portion of the wrapping key to unwrap the key material.
/// Only Cloud KMS has access to the private key.
///
/// An [ImportJob][google.cloud.kms.v1.ImportJob] expires 3 days after it is
/// created. Once expired, Cloud KMS will no longer be able to import or unwrap
/// any key material that was wrapped with the
/// [ImportJob][google.cloud.kms.v1.ImportJob]'s public key.
///
/// For more information, see
/// [Importing a key](https://cloud.google.com/kms/docs/importing-a-key).
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
/// [google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE]: crate::model::import_job::ImportJobState::Active
/// [google.cloud.kms.v1.ImportJob.import_method]: crate::model::ImportJob::import_method
/// [google.cloud.kms.v1.ImportJob.public_key]: crate::model::ImportJob::public_key
/// [google.cloud.kms.v1.ImportJob.state]: crate::model::ImportJob::state
/// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportJob {
    /// Output only. The resource name for this
    /// [ImportJob][google.cloud.kms.v1.ImportJob] in the format
    /// `projects/*/locations/*/keyRings/*/importJobs/*`.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub name: std::string::String,

    /// Required. Immutable. The wrapping method to be used for incoming key
    /// material.
    pub import_method: crate::model::import_job::ImportMethod,

    /// Required. Immutable. The protection level of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob]. This must match the
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
    /// of the [version_template][google.cloud.kms.v1.CryptoKey.version_template]
    /// on the [CryptoKey][google.cloud.kms.v1.CryptoKey] you attempt to import
    /// into.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.version_template]: crate::model::CryptoKey::version_template
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub protection_level: crate::model::ProtectionLevel,

    /// Output only. The time at which this
    /// [ImportJob][google.cloud.kms.v1.ImportJob] was created.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]'s key
    /// material was generated.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub generate_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [ImportJob][google.cloud.kms.v1.ImportJob] is scheduled for expiration and
    /// can no longer be used to import key material.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]
    /// expired. Only present if [state][google.cloud.kms.v1.ImportJob.state] is
    /// [EXPIRED][google.cloud.kms.v1.ImportJob.ImportJobState.EXPIRED].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.ImportJobState.EXPIRED]: crate::model::import_job::ImportJobState::Expired
    /// [google.cloud.kms.v1.ImportJob.state]: crate::model::ImportJob::state
    pub expire_event_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob], indicating if it can be used.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub state: crate::model::import_job::ImportJobState,

    /// Output only. The public key with which to wrap key material prior to
    /// import. Only returned if [state][google.cloud.kms.v1.ImportJob.state] is
    /// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE].
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE]: crate::model::import_job::ImportJobState::Active
    /// [google.cloud.kms.v1.ImportJob.state]: crate::model::ImportJob::state
    pub public_key: std::option::Option<crate::model::import_job::WrappingPublicKey>,

    /// Output only. Statement that was generated and signed by the key creator
    /// (for example, an HSM) at key creation time. Use this statement to verify
    /// attributes of the key as stored on the HSM, independently of Google.
    /// Only present if the chosen
    /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] is one with a
    /// protection level of [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportMethod]: crate::model::import_job::ImportMethod
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    pub attestation: std::option::Option<crate::model::KeyOperationAttestation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [import_method][crate::model::ImportJob::import_method].
    pub fn set_import_method<T: std::convert::Into<crate::model::import_job::ImportMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_method = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::ImportJob::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [generate_time][crate::model::ImportJob::generate_time].
    pub fn set_generate_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.generate_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generate_time][crate::model::ImportJob::generate_time].
    pub fn set_or_clear_generate_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.generate_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::ImportJob::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::ImportJob::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_event_time][crate::model::ImportJob::expire_event_time].
    pub fn set_expire_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_event_time][crate::model::ImportJob::expire_event_time].
    pub fn set_or_clear_expire_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_event_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ImportJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_job::ImportJobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::ImportJob::public_key].
    pub fn set_public_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::import_job::WrappingPublicKey>,
    {
        self.public_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_key][crate::model::ImportJob::public_key].
    pub fn set_or_clear_public_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::import_job::WrappingPublicKey>,
    {
        self.public_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attestation][crate::model::ImportJob::attestation].
    pub fn set_attestation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyOperationAttestation>,
    {
        self.attestation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attestation][crate::model::ImportJob::attestation].
    pub fn set_or_clear_attestation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyOperationAttestation>,
    {
        self.attestation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ImportJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __import_method,
            __protection_level,
            __create_time,
            __generate_time,
            __expire_time,
            __expire_event_time,
            __state,
            __public_key,
            __attestation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "importMethod" => Ok(__FieldTag::__import_method),
                            "import_method" => Ok(__FieldTag::__import_method),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "generateTime" => Ok(__FieldTag::__generate_time),
                            "generate_time" => Ok(__FieldTag::__generate_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "expireEventTime" => Ok(__FieldTag::__expire_event_time),
                            "expire_event_time" => Ok(__FieldTag::__expire_event_time),
                            "state" => Ok(__FieldTag::__state),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "attestation" => Ok(__FieldTag::__attestation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_method => {
                            if !fields.insert(__FieldTag::__import_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_method",
                                ));
                            }
                            result.import_method = map.next_value::<std::option::Option<crate::model::import_job::ImportMethod>>()?.unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__generate_time => {
                            if !fields.insert(__FieldTag::__generate_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generate_time",
                                ));
                            }
                            result.generate_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_event_time => {
                            if !fields.insert(__FieldTag::__expire_event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_event_time",
                                ));
                            }
                            result.expire_event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::import_job::ImportJobState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key =
                                map.next_value::<std::option::Option<
                                    crate::model::import_job::WrappingPublicKey,
                                >>()?;
                        }
                        __FieldTag::__attestation => {
                            if !fields.insert(__FieldTag::__attestation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attestation",
                                ));
                            }
                            result.attestation = map.next_value::<std::option::Option<crate::model::KeyOperationAttestation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.import_method) {
            state.serialize_entry("importMethod", &self.import_method)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.generate_time.is_some() {
            state.serialize_entry("generateTime", &self.generate_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.expire_event_time.is_some() {
            state.serialize_entry("expireEventTime", &self.expire_event_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.public_key.is_some() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if self.attestation.is_some() {
            state.serialize_entry("attestation", &self.attestation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportJob].
pub mod import_job {
    #[allow(unused_imports)]
    use super::*;

    /// The public key component of the wrapping key. For details of the type of
    /// key this public key corresponds to, see the
    /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod].
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportMethod]: crate::model::import_job::ImportMethod
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WrappingPublicKey {
        /// The public key, encoded in PEM format. For more information, see the [RFC
        /// 7468](https://tools.ietf.org/html/rfc7468) sections for [General
        /// Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
        /// [Textual Encoding of Subject Public Key Info]
        /// (<https://tools.ietf.org/html/rfc7468#section-13>).
        pub pem: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WrappingPublicKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pem][crate::model::import_job::WrappingPublicKey::pem].
        pub fn set_pem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pem = v.into();
            self
        }
    }

    impl wkt::message::Message for WrappingPublicKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.kms.v1.ImportJob.WrappingPublicKey"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WrappingPublicKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pem,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WrappingPublicKey")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pem" => Ok(__FieldTag::__pem),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WrappingPublicKey;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WrappingPublicKey")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pem => {
                                if !fields.insert(__FieldTag::__pem) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pem",
                                    ));
                                }
                                result.pem = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WrappingPublicKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.pem.is_empty() {
                state.serialize_entry("pem", &self.pem)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] describes the
    /// key wrapping method chosen for this
    /// [ImportJob][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.ImportMethod]: crate::model::import_job::ImportMethod
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportMethod {
        /// Not specified.
        Unspecified,
        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 3072 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        RsaOaep3072Sha1Aes256,
        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 4096 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        RsaOaep4096Sha1Aes256,
        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 3072 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        RsaOaep3072Sha256Aes256,
        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 4096 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        RsaOaep4096Sha256Aes256,
        /// This ImportMethod represents RSAES-OAEP with a 3072 bit RSA key. The
        /// key material to be imported is wrapped directly with the RSA key. Due
        /// to technical limitations of RSA wrapping, this method cannot be used to
        /// wrap RSA keys for import.
        RsaOaep3072Sha256,
        /// This ImportMethod represents RSAES-OAEP with a 4096 bit RSA key. The
        /// key material to be imported is wrapped directly with the RSA key. Due
        /// to technical limitations of RSA wrapping, this method cannot be used to
        /// wrap RSA keys for import.
        RsaOaep4096Sha256,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ImportMethod::value] or
        /// [ImportMethod::name].
        UnknownValue(import_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod import_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ImportMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RsaOaep3072Sha1Aes256 => std::option::Option::Some(1),
                Self::RsaOaep4096Sha1Aes256 => std::option::Option::Some(2),
                Self::RsaOaep3072Sha256Aes256 => std::option::Option::Some(3),
                Self::RsaOaep4096Sha256Aes256 => std::option::Option::Some(4),
                Self::RsaOaep3072Sha256 => std::option::Option::Some(5),
                Self::RsaOaep4096Sha256 => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPORT_METHOD_UNSPECIFIED"),
                Self::RsaOaep3072Sha1Aes256 => {
                    std::option::Option::Some("RSA_OAEP_3072_SHA1_AES_256")
                }
                Self::RsaOaep4096Sha1Aes256 => {
                    std::option::Option::Some("RSA_OAEP_4096_SHA1_AES_256")
                }
                Self::RsaOaep3072Sha256Aes256 => {
                    std::option::Option::Some("RSA_OAEP_3072_SHA256_AES_256")
                }
                Self::RsaOaep4096Sha256Aes256 => {
                    std::option::Option::Some("RSA_OAEP_4096_SHA256_AES_256")
                }
                Self::RsaOaep3072Sha256 => std::option::Option::Some("RSA_OAEP_3072_SHA256"),
                Self::RsaOaep4096Sha256 => std::option::Option::Some("RSA_OAEP_4096_SHA256"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ImportMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ImportMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ImportMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RsaOaep3072Sha1Aes256,
                2 => Self::RsaOaep4096Sha1Aes256,
                3 => Self::RsaOaep3072Sha256Aes256,
                4 => Self::RsaOaep4096Sha256Aes256,
                5 => Self::RsaOaep3072Sha256,
                6 => Self::RsaOaep4096Sha256,
                _ => Self::UnknownValue(import_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ImportMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPORT_METHOD_UNSPECIFIED" => Self::Unspecified,
                "RSA_OAEP_3072_SHA1_AES_256" => Self::RsaOaep3072Sha1Aes256,
                "RSA_OAEP_4096_SHA1_AES_256" => Self::RsaOaep4096Sha1Aes256,
                "RSA_OAEP_3072_SHA256_AES_256" => Self::RsaOaep3072Sha256Aes256,
                "RSA_OAEP_4096_SHA256_AES_256" => Self::RsaOaep4096Sha256Aes256,
                "RSA_OAEP_3072_SHA256" => Self::RsaOaep3072Sha256,
                "RSA_OAEP_4096_SHA256" => Self::RsaOaep4096Sha256,
                _ => Self::UnknownValue(import_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ImportMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RsaOaep3072Sha1Aes256 => serializer.serialize_i32(1),
                Self::RsaOaep4096Sha1Aes256 => serializer.serialize_i32(2),
                Self::RsaOaep3072Sha256Aes256 => serializer.serialize_i32(3),
                Self::RsaOaep4096Sha256Aes256 => serializer.serialize_i32(4),
                Self::RsaOaep3072Sha256 => serializer.serialize_i32(5),
                Self::RsaOaep4096Sha256 => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ImportMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportMethod>::new(
                ".google.cloud.kms.v1.ImportJob.ImportMethod",
            ))
        }
    }

    /// The state of the [ImportJob][google.cloud.kms.v1.ImportJob], indicating if
    /// it can be used.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportJobState {
        /// Not specified.
        Unspecified,
        /// The wrapping key for this job is still being generated. It may not be
        /// used. Cloud KMS will automatically mark this job as
        /// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] as soon as
        /// the wrapping key is generated.
        ///
        /// [google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE]: crate::model::import_job::ImportJobState::Active
        PendingGeneration,
        /// This job may be used in
        /// [CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]
        /// and
        /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
        /// requests.
        ///
        /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]: crate::client::KeyManagementService::create_crypto_key
        /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
        Active,
        /// This job can no longer be used and may not leave this state once entered.
        Expired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ImportJobState::value] or
        /// [ImportJobState::name].
        UnknownValue(import_job_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod import_job_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ImportJobState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PendingGeneration => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Expired => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPORT_JOB_STATE_UNSPECIFIED"),
                Self::PendingGeneration => std::option::Option::Some("PENDING_GENERATION"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ImportJobState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ImportJobState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ImportJobState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PendingGeneration,
                2 => Self::Active,
                3 => Self::Expired,
                _ => Self::UnknownValue(import_job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ImportJobState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPORT_JOB_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING_GENERATION" => Self::PendingGeneration,
                "ACTIVE" => Self::Active,
                "EXPIRED" => Self::Expired,
                _ => Self::UnknownValue(import_job_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ImportJobState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PendingGeneration => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Expired => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ImportJobState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportJobState>::new(
                ".google.cloud.kms.v1.ImportJob.ImportJobState",
            ))
        }
    }
}

/// ExternalProtectionLevelOptions stores a group of additional fields for
/// configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that
/// are specific to the [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL]
/// protection level and
/// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] protection
/// levels.
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::ProtectionLevel::External
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalProtectionLevelOptions {
    /// The URI for an external resource that this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub external_key_uri: std::string::String,

    /// The path to the external key material on the EKM when using
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] e.g., "v0/my/key". Set
    /// this field instead of external_key_uri when using an
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub ekm_connection_key_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalProtectionLevelOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_key_uri][crate::model::ExternalProtectionLevelOptions::external_key_uri].
    pub fn set_external_key_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_key_uri = v.into();
        self
    }

    /// Sets the value of [ekm_connection_key_path][crate::model::ExternalProtectionLevelOptions::ekm_connection_key_path].
    pub fn set_ekm_connection_key_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_connection_key_path = v.into();
        self
    }
}

impl wkt::message::Message for ExternalProtectionLevelOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ExternalProtectionLevelOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalProtectionLevelOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_key_uri,
            __ekm_connection_key_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalProtectionLevelOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalKeyUri" => Ok(__FieldTag::__external_key_uri),
                            "external_key_uri" => Ok(__FieldTag::__external_key_uri),
                            "ekmConnectionKeyPath" => Ok(__FieldTag::__ekm_connection_key_path),
                            "ekm_connection_key_path" => Ok(__FieldTag::__ekm_connection_key_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalProtectionLevelOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalProtectionLevelOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_key_uri => {
                            if !fields.insert(__FieldTag::__external_key_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_key_uri",
                                ));
                            }
                            result.external_key_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ekm_connection_key_path => {
                            if !fields.insert(__FieldTag::__ekm_connection_key_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_connection_key_path",
                                ));
                            }
                            result.ekm_connection_key_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalProtectionLevelOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.external_key_uri.is_empty() {
            state.serialize_entry("externalKeyUri", &self.external_key_uri)?;
        }
        if !self.ekm_connection_key_path.is_empty() {
            state.serialize_entry("ekmConnectionKeyPath", &self.ekm_connection_key_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A
/// [KeyAccessJustificationsPolicy][google.cloud.kms.v1.KeyAccessJustificationsPolicy]
/// specifies zero or more allowed
/// [AccessReason][google.cloud.kms.v1.AccessReason] values for encrypt, decrypt,
/// and sign operations on a [CryptoKey][google.cloud.kms.v1.CryptoKey].
///
/// [google.cloud.kms.v1.AccessReason]: crate::model::AccessReason
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.KeyAccessJustificationsPolicy]: crate::model::KeyAccessJustificationsPolicy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KeyAccessJustificationsPolicy {
    /// The list of allowed reasons for access to a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey]. Zero allowed access reasons
    /// means all encrypt, decrypt, and sign operations for the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with this policy will
    /// fail.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub allowed_access_reasons: std::vec::Vec<crate::model::AccessReason>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KeyAccessJustificationsPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_access_reasons][crate::model::KeyAccessJustificationsPolicy::allowed_access_reasons].
    pub fn set_allowed_access_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessReason>,
    {
        use std::iter::Iterator;
        self.allowed_access_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for KeyAccessJustificationsPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyAccessJustificationsPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KeyAccessJustificationsPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_access_reasons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyAccessJustificationsPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedAccessReasons" => Ok(__FieldTag::__allowed_access_reasons),
                            "allowed_access_reasons" => Ok(__FieldTag::__allowed_access_reasons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KeyAccessJustificationsPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyAccessJustificationsPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_access_reasons => {
                            if !fields.insert(__FieldTag::__allowed_access_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_access_reasons",
                                ));
                            }
                            result.allowed_access_reasons = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AccessReason>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KeyAccessJustificationsPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed_access_reasons.is_empty() {
            state.serialize_entry("allowedAccessReasons", &self.allowed_access_reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
///
/// [google.cloud.kms.v1.KeyManagementService.ListKeyRings]: crate::client::KeyManagementService::list_key_rings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeyRingsRequest {
    /// Required. The resource name of the location associated with the
    /// [KeyRings][google.cloud.kms.v1.KeyRing], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [KeyRings][google.cloud.kms.v1.KeyRing] to include in the response. Further
    /// [KeyRings][google.cloud.kms.v1.KeyRing] can subsequently be obtained by
    /// including the
    /// [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]
    /// in a subsequent request.  If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]: crate::model::ListKeyRingsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]: crate::model::ListKeyRingsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order.  For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeyRingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeyRingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeyRingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeyRingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKeyRingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListKeyRingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListKeyRingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyRingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKeyRingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKeyRingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKeyRingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKeyRingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKeyRingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeys]: crate::client::KeyManagementService::list_crypto_keys
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCryptoKeysRequest {
    /// Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
    /// to list, in the format `projects/*/locations/*/keyRings/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] to include in the response.
    /// Further [CryptoKeys][google.cloud.kms.v1.CryptoKey] can subsequently be
    /// obtained by including the
    /// [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]
    /// in a subsequent request.  If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]: crate::model::ListCryptoKeysResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]: crate::model::ListCryptoKeysResponse::next_page_token
    pub page_token: std::string::String,

    /// The fields of the primary version to include in the response.
    pub version_view: crate::model::crypto_key_version::CryptoKeyVersionView,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order. For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCryptoKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCryptoKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCryptoKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCryptoKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [version_view][crate::model::ListCryptoKeysRequest::version_view].
    pub fn set_version_view<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version_view = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCryptoKeysRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCryptoKeysRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCryptoKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCryptoKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __version_view,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCryptoKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "versionView" => Ok(__FieldTag::__version_view),
                            "version_view" => Ok(__FieldTag::__version_view),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCryptoKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCryptoKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_view => {
                            if !fields.insert(__FieldTag::__version_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_view",
                                ));
                            }
                            result.version_view = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCryptoKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.version_view) {
            state.serialize_entry("versionView", &self.version_view)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]: crate::client::KeyManagementService::list_crypto_key_versions
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCryptoKeyVersionsRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to list, in the format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] to include in the
    /// response. Further [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
    /// can subsequently be obtained by including the
    /// [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]: crate::model::ListCryptoKeyVersionsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]: crate::model::ListCryptoKeyVersionsResponse::next_page_token
    pub page_token: std::string::String,

    /// The fields to include in the response.
    pub view: crate::model::crypto_key_version::CryptoKeyVersionView,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order. For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCryptoKeyVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCryptoKeyVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCryptoKeyVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCryptoKeyVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListCryptoKeyVersionsRequest::view].
    pub fn set_view<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCryptoKeyVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCryptoKeyVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCryptoKeyVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeyVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCryptoKeyVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __view,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCryptoKeyVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "view" => Ok(__FieldTag::__view),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCryptoKeyVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCryptoKeyVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCryptoKeyVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
///
/// [google.cloud.kms.v1.KeyManagementService.ListImportJobs]: crate::client::KeyManagementService::list_import_jobs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImportJobsRequest {
    /// Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
    /// to list, in the format `projects/*/locations/*/keyRings/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [ImportJobs][google.cloud.kms.v1.ImportJob] to include in the response.
    /// Further [ImportJobs][google.cloud.kms.v1.ImportJob] can subsequently be
    /// obtained by including the
    /// [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ListImportJobsResponse.next_page_token]: crate::model::ListImportJobsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListImportJobsResponse.next_page_token]: crate::model::ListImportJobsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order. For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImportJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImportJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImportJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImportJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImportJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImportJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListImportJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListImportJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImportJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImportJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImportJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImportJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImportJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
///
/// [google.cloud.kms.v1.KeyManagementService.ListKeyRings]: crate::client::KeyManagementService::list_key_rings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeyRingsResponse {
    /// The list of [KeyRings][google.cloud.kms.v1.KeyRing].
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub key_rings: std::vec::Vec<crate::model::KeyRing>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListKeyRingsRequest.page_token][google.cloud.kms.v1.ListKeyRingsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListKeyRingsRequest.page_token]: crate::model::ListKeyRingsRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of [KeyRings][google.cloud.kms.v1.KeyRing] that matched
    /// the query.
    ///
    /// This field is not populated if
    /// [ListKeyRingsRequest.filter][google.cloud.kms.v1.ListKeyRingsRequest.filter]
    /// is applied.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.ListKeyRingsRequest.filter]: crate::model::ListKeyRingsRequest::filter
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeyRingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_rings][crate::model::ListKeyRingsResponse::key_rings].
    pub fn set_key_rings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KeyRing>,
    {
        use std::iter::Iterator;
        self.key_rings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKeyRingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListKeyRingsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListKeyRingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyRingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKeyRingsResponse {
    type PageItem = crate::model::KeyRing;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.key_rings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKeyRingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_rings,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKeyRingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyRings" => Ok(__FieldTag::__key_rings),
                            "key_rings" => Ok(__FieldTag::__key_rings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKeyRingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKeyRingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_rings => {
                            if !fields.insert(__FieldTag::__key_rings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_rings",
                                ));
                            }
                            result.key_rings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::KeyRing>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKeyRingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_rings.is_empty() {
            state.serialize_entry("keyRings", &self.key_rings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeys]: crate::client::KeyManagementService::list_crypto_keys
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCryptoKeysResponse {
    /// The list of [CryptoKeys][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub crypto_keys: std::vec::Vec<crate::model::CryptoKey>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCryptoKeysRequest.page_token][google.cloud.kms.v1.ListCryptoKeysRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListCryptoKeysRequest.page_token]: crate::model::ListCryptoKeysRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of [CryptoKeys][google.cloud.kms.v1.CryptoKey] that
    /// matched the query.
    ///
    /// This field is not populated if
    /// [ListCryptoKeysRequest.filter][google.cloud.kms.v1.ListCryptoKeysRequest.filter]
    /// is applied.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.ListCryptoKeysRequest.filter]: crate::model::ListCryptoKeysRequest::filter
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCryptoKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_keys][crate::model::ListCryptoKeysResponse::crypto_keys].
    pub fn set_crypto_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CryptoKey>,
    {
        use std::iter::Iterator;
        self.crypto_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCryptoKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListCryptoKeysResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListCryptoKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCryptoKeysResponse {
    type PageItem = crate::model::CryptoKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crypto_keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCryptoKeysResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_keys,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCryptoKeysResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKeys" => Ok(__FieldTag::__crypto_keys),
                            "crypto_keys" => Ok(__FieldTag::__crypto_keys),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCryptoKeysResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCryptoKeysResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_keys => {
                            if !fields.insert(__FieldTag::__crypto_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_keys",
                                ));
                            }
                            result.crypto_keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CryptoKey>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCryptoKeysResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.crypto_keys.is_empty() {
            state.serialize_entry("cryptoKeys", &self.crypto_keys)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]: crate::client::KeyManagementService::list_crypto_key_versions
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCryptoKeyVersionsResponse {
    /// The list of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub crypto_key_versions: std::vec::Vec<crate::model::CryptoKeyVersion>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCryptoKeyVersionsRequest.page_token][google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token]: crate::model::ListCryptoKeyVersionsRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] that matched the
    /// query.
    ///
    /// This field is not populated if
    /// [ListCryptoKeyVersionsRequest.filter][google.cloud.kms.v1.ListCryptoKeyVersionsRequest.filter]
    /// is applied.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsRequest.filter]: crate::model::ListCryptoKeyVersionsRequest::filter
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCryptoKeyVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key_versions][crate::model::ListCryptoKeyVersionsResponse::crypto_key_versions].
    pub fn set_crypto_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        use std::iter::Iterator;
        self.crypto_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCryptoKeyVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListCryptoKeyVersionsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListCryptoKeyVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeyVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCryptoKeyVersionsResponse {
    type PageItem = crate::model::CryptoKeyVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crypto_key_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCryptoKeyVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_key_versions,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCryptoKeyVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKeyVersions" => Ok(__FieldTag::__crypto_key_versions),
                            "crypto_key_versions" => Ok(__FieldTag::__crypto_key_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCryptoKeyVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCryptoKeyVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_key_versions => {
                            if !fields.insert(__FieldTag::__crypto_key_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_versions",
                                ));
                            }
                            result.crypto_key_versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CryptoKeyVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCryptoKeyVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.crypto_key_versions.is_empty() {
            state.serialize_entry("cryptoKeyVersions", &self.crypto_key_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
///
/// [google.cloud.kms.v1.KeyManagementService.ListImportJobs]: crate::client::KeyManagementService::list_import_jobs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImportJobsResponse {
    /// The list of [ImportJobs][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub import_jobs: std::vec::Vec<crate::model::ImportJob>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListImportJobsRequest.page_token][google.cloud.kms.v1.ListImportJobsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListImportJobsRequest.page_token]: crate::model::ListImportJobsRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of [ImportJobs][google.cloud.kms.v1.ImportJob] that
    /// matched the query.
    ///
    /// This field is not populated if
    /// [ListImportJobsRequest.filter][google.cloud.kms.v1.ListImportJobsRequest.filter]
    /// is applied.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ListImportJobsRequest.filter]: crate::model::ListImportJobsRequest::filter
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImportJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_jobs][crate::model::ListImportJobsResponse::import_jobs].
    pub fn set_import_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportJob>,
    {
        use std::iter::Iterator;
        self.import_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListImportJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListImportJobsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListImportJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListImportJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListImportJobsResponse {
    type PageItem = crate::model::ImportJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.import_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImportJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __import_jobs,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImportJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importJobs" => Ok(__FieldTag::__import_jobs),
                            "import_jobs" => Ok(__FieldTag::__import_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImportJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImportJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__import_jobs => {
                            if !fields.insert(__FieldTag::__import_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_jobs",
                                ));
                            }
                            result.import_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImportJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImportJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.import_jobs.is_empty() {
            state.serialize_entry("importJobs", &self.import_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.GetKeyRing][google.cloud.kms.v1.KeyManagementService.GetKeyRing].
///
/// [google.cloud.kms.v1.KeyManagementService.GetKeyRing]: crate::client::KeyManagementService::get_key_ring
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetKeyRingRequest {
    /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
    /// [KeyRing][google.cloud.kms.v1.KeyRing] to get.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.KeyRing.name]: crate::model::KeyRing::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKeyRingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyRingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyRingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetKeyRingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetKeyRingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetKeyRingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetKeyRingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetKeyRingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetKeyRingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.GetCryptoKey][google.cloud.kms.v1.KeyManagementService.GetCryptoKey].
///
/// [google.cloud.kms.v1.KeyManagementService.GetCryptoKey]: crate::client::KeyManagementService::get_crypto_key
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCryptoKeyRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to get.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.name]: crate::model::CryptoKey::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCryptoKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCryptoKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCryptoKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetCryptoKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCryptoKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCryptoKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCryptoKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCryptoKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCryptoKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.GetCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion]: crate::client::KeyManagementService::get_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCryptoKeyVersionRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to get.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCryptoKeyVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetCryptoKeyVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCryptoKeyVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCryptoKeyVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCryptoKeyVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCryptoKeyVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCryptoKeyVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
///
/// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPublicKeyRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key to get.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    pub name: std::string::String,

    /// Optional. The [PublicKey][google.cloud.kms.v1.PublicKey] format specified
    /// by the user. This field is required for PQC algorithms. If specified, the
    /// public key will be exported through the
    /// [public_key][google.cloud.kms.v1.PublicKey.public_key] field in the
    /// requested format. Otherwise, the [pem][google.cloud.kms.v1.PublicKey.pem]
    /// field will be populated for non-PQC algorithms, and an error will be
    /// returned for PQC algorithms.
    ///
    /// [google.cloud.kms.v1.PublicKey]: crate::model::PublicKey
    /// [google.cloud.kms.v1.PublicKey.pem]: crate::model::PublicKey::pem
    /// [google.cloud.kms.v1.PublicKey.public_key]: crate::model::PublicKey::public_key
    pub public_key_format: crate::model::public_key::PublicKeyFormat,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPublicKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPublicKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [public_key_format][crate::model::GetPublicKeyRequest::public_key_format].
    pub fn set_public_key_format<
        T: std::convert::Into<crate::model::public_key::PublicKeyFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.public_key_format = v.into();
        self
    }
}

impl wkt::message::Message for GetPublicKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetPublicKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPublicKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __public_key_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPublicKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "publicKeyFormat" => Ok(__FieldTag::__public_key_format),
                            "public_key_format" => Ok(__FieldTag::__public_key_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPublicKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPublicKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_key_format => {
                            if !fields.insert(__FieldTag::__public_key_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key_format",
                                ));
                            }
                            result.public_key_format = map.next_value::<std::option::Option<crate::model::public_key::PublicKeyFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPublicKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.public_key_format) {
            state.serialize_entry("publicKeyFormat", &self.public_key_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.GetImportJob][google.cloud.kms.v1.KeyManagementService.GetImportJob].
///
/// [google.cloud.kms.v1.KeyManagementService.GetImportJob]: crate::client::KeyManagementService::get_import_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetImportJobRequest {
    /// Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob] to get.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.name]: crate::model::ImportJob::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.CreateKeyRing][google.cloud.kms.v1.KeyManagementService.CreateKeyRing].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateKeyRing]: crate::client::KeyManagementService::create_key_ring
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKeyRingRequest {
    /// Required. The resource name of the location associated with the
    /// [KeyRings][google.cloud.kms.v1.KeyRing], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    pub key_ring_id: std::string::String,

    /// Required. A [KeyRing][google.cloud.kms.v1.KeyRing] with initial field
    /// values.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub key_ring: std::option::Option<crate::model::KeyRing>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKeyRingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyRingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key_ring_id][crate::model::CreateKeyRingRequest::key_ring_id].
    pub fn set_key_ring_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_ring_id = v.into();
        self
    }

    /// Sets the value of [key_ring][crate::model::CreateKeyRingRequest::key_ring].
    pub fn set_key_ring<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyRing>,
    {
        self.key_ring = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_ring][crate::model::CreateKeyRingRequest::key_ring].
    pub fn set_or_clear_key_ring<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyRing>,
    {
        self.key_ring = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateKeyRingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateKeyRingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateKeyRingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __key_ring_id,
            __key_ring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKeyRingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "keyRingId" => Ok(__FieldTag::__key_ring_id),
                            "key_ring_id" => Ok(__FieldTag::__key_ring_id),
                            "keyRing" => Ok(__FieldTag::__key_ring),
                            "key_ring" => Ok(__FieldTag::__key_ring),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateKeyRingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKeyRingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_ring_id => {
                            if !fields.insert(__FieldTag::__key_ring_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_ring_id",
                                ));
                            }
                            result.key_ring_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_ring => {
                            if !fields.insert(__FieldTag::__key_ring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_ring",
                                ));
                            }
                            result.key_ring =
                                map.next_value::<std::option::Option<crate::model::KeyRing>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateKeyRingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.key_ring_id.is_empty() {
            state.serialize_entry("keyRingId", &self.key_ring_id)?;
        }
        if self.key_ring.is_some() {
            state.serialize_entry("keyRing", &self.key_ring)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]: crate::client::KeyManagementService::create_crypto_key
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCryptoKeyRequest {
    /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the KeyRing
    /// associated with the [CryptoKeys][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyRing.name]: crate::model::KeyRing::name
    pub parent: std::string::String,

    /// Required. It must be unique within a KeyRing and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    pub crypto_key_id: std::string::String,

    /// Required. A [CryptoKey][google.cloud.kms.v1.CryptoKey] with initial field
    /// values.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// If set to true, the request will create a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] without any
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. You must
    /// manually call
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// or
    /// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]
    /// before you can use this [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
    /// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
    pub skip_initial_version_creation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCryptoKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCryptoKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [crypto_key_id][crate::model::CreateCryptoKeyRequest::crypto_key_id].
    pub fn set_crypto_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_id = v.into();
        self
    }

    /// Sets the value of [crypto_key][crate::model::CreateCryptoKeyRequest::crypto_key].
    pub fn set_crypto_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key][crate::model::CreateCryptoKeyRequest::crypto_key].
    pub fn set_or_clear_crypto_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_initial_version_creation][crate::model::CreateCryptoKeyRequest::skip_initial_version_creation].
    pub fn set_skip_initial_version_creation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_initial_version_creation = v.into();
        self
    }
}

impl wkt::message::Message for CreateCryptoKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateCryptoKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCryptoKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __crypto_key_id,
            __crypto_key,
            __skip_initial_version_creation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCryptoKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cryptoKeyId" => Ok(__FieldTag::__crypto_key_id),
                            "crypto_key_id" => Ok(__FieldTag::__crypto_key_id),
                            "cryptoKey" => Ok(__FieldTag::__crypto_key),
                            "crypto_key" => Ok(__FieldTag::__crypto_key),
                            "skipInitialVersionCreation" => {
                                Ok(__FieldTag::__skip_initial_version_creation)
                            }
                            "skip_initial_version_creation" => {
                                Ok(__FieldTag::__skip_initial_version_creation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCryptoKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCryptoKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_id => {
                            if !fields.insert(__FieldTag::__crypto_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_id",
                                ));
                            }
                            result.crypto_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key => {
                            if !fields.insert(__FieldTag::__crypto_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key",
                                ));
                            }
                            result.crypto_key =
                                map.next_value::<std::option::Option<crate::model::CryptoKey>>()?;
                        }
                        __FieldTag::__skip_initial_version_creation => {
                            if !fields.insert(__FieldTag::__skip_initial_version_creation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_initial_version_creation",
                                ));
                            }
                            result.skip_initial_version_creation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCryptoKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.crypto_key_id.is_empty() {
            state.serialize_entry("cryptoKeyId", &self.crypto_key_id)?;
        }
        if self.crypto_key.is_some() {
            state.serialize_entry("cryptoKey", &self.crypto_key)?;
        }
        if !wkt::internal::is_default(&self.skip_initial_version_creation) {
            state.serialize_entry(
                "skipInitialVersionCreation",
                &self.skip_initial_version_creation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCryptoKeyVersionRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with the
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.name]: crate::model::CryptoKey::name
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub parent: std::string::String,

    /// Required. A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
    /// initial field values.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub crypto_key_version: std::option::Option<crate::model::CryptoKeyVersion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCryptoKeyVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [crypto_key_version][crate::model::CreateCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_crypto_key_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        self.crypto_key_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key_version][crate::model::CreateCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_or_clear_crypto_key_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        self.crypto_key_version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateCryptoKeyVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCryptoKeyVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __crypto_key_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCryptoKeyVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cryptoKeyVersion" => Ok(__FieldTag::__crypto_key_version),
                            "crypto_key_version" => Ok(__FieldTag::__crypto_key_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCryptoKeyVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCryptoKeyVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_version => {
                            if !fields.insert(__FieldTag::__crypto_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_version",
                                ));
                            }
                            result.crypto_key_version = map
                                .next_value::<std::option::Option<crate::model::CryptoKeyVersion>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCryptoKeyVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.crypto_key_version.is_some() {
            state.serialize_entry("cryptoKeyVersion", &self.crypto_key_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportCryptoKeyVersionRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to be imported into.
    ///
    /// The create permission is only required on this key when creating a new
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.name]: crate::model::CryptoKey::name
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub parent: std::string::String,

    /// Optional. The optional [name][google.cloud.kms.v1.CryptoKeyVersion.name] of
    /// an existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to
    /// target for an import operation. If this field is not present, a new
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] containing the
    /// supplied key material is created.
    ///
    /// If this field is present, the supplied key material is imported into
    /// the existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. To
    /// import into an existing
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] must be a child of
    /// [ImportCryptoKeyVersionRequest.parent][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.parent],
    /// have been previously created via
    /// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion],
    /// and be in
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]
    /// or
    /// [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]
    /// state. The key material and algorithm must match the previous
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] exactly if the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] has ever contained
    /// key material.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::CryptoKeyVersionState::Destroyed
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]: crate::model::crypto_key_version::CryptoKeyVersionState::ImportFailed
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.parent]: crate::model::ImportCryptoKeyVersionRequest::parent
    /// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
    pub crypto_key_version: std::string::String,

    /// Required. The
    /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// of the key being imported. This does not need to match the
    /// [version_template][google.cloud.kms.v1.CryptoKey.version_template] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] this version imports into.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.version_template]: crate::model::CryptoKey::version_template
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    /// Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob] that was used to wrap this key
    /// material.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.name]: crate::model::ImportJob::name
    pub import_job: std::string::String,

    /// Optional. The wrapped key material to import.
    ///
    /// Before wrapping, key material must be formatted. If importing symmetric key
    /// material, the expected key material format is plain bytes. If importing
    /// asymmetric key material, the expected key material format is PKCS#8-encoded
    /// DER (the PrivateKeyInfo structure from RFC 5208).
    ///
    /// When wrapping with import methods
    /// ([RSA_OAEP_3072_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]
    /// or
    /// [RSA_OAEP_4096_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256]
    /// or
    /// [RSA_OAEP_3072_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256_AES_256]
    /// or
    /// [RSA_OAEP_4096_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256_AES_256]),
    ///
    /// this field must contain the concatenation of:
    ///
    /// This format is the same as the format produced by PKCS#11 mechanism
    /// CKM_RSA_AES_KEY_WRAP.
    ///
    /// When wrapping with import methods
    /// ([RSA_OAEP_3072_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256]
    /// or
    /// [RSA_OAEP_4096_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256]),
    ///
    /// this field must contain the formatted key to be imported, wrapped with the
    /// [public_key][google.cloud.kms.v1.ImportJob.public_key] using RSAES-OAEP
    /// with SHA-256, MGF1 with SHA-256, and an empty label.
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]: crate::model::import_job::ImportMethod::RsaOaep3072Sha1Aes256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256]: crate::model::import_job::ImportMethod::RsaOaep3072Sha256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256_AES_256]: crate::model::import_job::ImportMethod::RsaOaep3072Sha256Aes256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256]: crate::model::import_job::ImportMethod::RsaOaep4096Sha1Aes256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256]: crate::model::import_job::ImportMethod::RsaOaep4096Sha256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256_AES_256]: crate::model::import_job::ImportMethod::RsaOaep4096Sha256Aes256
    /// [google.cloud.kms.v1.ImportJob.public_key]: crate::model::ImportJob::public_key
    pub wrapped_key: ::bytes::Bytes,

    /// This field is legacy. Use the field
    /// [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]
    /// instead.
    ///
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]: crate::model::ImportCryptoKeyVersionRequest::wrapped_key
    pub wrapped_key_material:
        std::option::Option<crate::model::import_crypto_key_version_request::WrappedKeyMaterial>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportCryptoKeyVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [crypto_key_version][crate::model::ImportCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_crypto_key_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_version = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::ImportCryptoKeyVersionRequest::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::ImportCryptoKeyVersionRequest::import_job].
    pub fn set_import_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job = v.into();
        self
    }

    /// Sets the value of [wrapped_key][crate::model::ImportCryptoKeyVersionRequest::wrapped_key].
    pub fn set_wrapped_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key = v.into();
        self
    }

    /// Sets the value of [wrapped_key_material][crate::model::ImportCryptoKeyVersionRequest::wrapped_key_material].
    ///
    /// Note that all the setters affecting `wrapped_key_material` are mutually
    /// exclusive.
    pub fn set_wrapped_key_material<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::import_crypto_key_version_request::WrappedKeyMaterial,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapped_key_material = v.into();
        self
    }

    /// The value of [wrapped_key_material][crate::model::ImportCryptoKeyVersionRequest::wrapped_key_material]
    /// if it holds a `RsaAesWrappedKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rsa_aes_wrapped_key(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.wrapped_key_material.as_ref().and_then(|v| match v {
            crate::model::import_crypto_key_version_request::WrappedKeyMaterial::RsaAesWrappedKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [wrapped_key_material][crate::model::ImportCryptoKeyVersionRequest::wrapped_key_material]
    /// to hold a `RsaAesWrappedKey`.
    ///
    /// Note that all the setters affecting `wrapped_key_material` are
    /// mutually exclusive.
    pub fn set_rsa_aes_wrapped_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key_material = std::option::Option::Some(
            crate::model::import_crypto_key_version_request::WrappedKeyMaterial::RsaAesWrappedKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ImportCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ImportCryptoKeyVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportCryptoKeyVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __crypto_key_version,
            __algorithm,
            __import_job,
            __wrapped_key,
            __rsa_aes_wrapped_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportCryptoKeyVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cryptoKeyVersion" => Ok(__FieldTag::__crypto_key_version),
                            "crypto_key_version" => Ok(__FieldTag::__crypto_key_version),
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            "importJob" => Ok(__FieldTag::__import_job),
                            "import_job" => Ok(__FieldTag::__import_job),
                            "wrappedKey" => Ok(__FieldTag::__wrapped_key),
                            "wrapped_key" => Ok(__FieldTag::__wrapped_key),
                            "rsaAesWrappedKey" => Ok(__FieldTag::__rsa_aes_wrapped_key),
                            "rsa_aes_wrapped_key" => Ok(__FieldTag::__rsa_aes_wrapped_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportCryptoKeyVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportCryptoKeyVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_version => {
                            if !fields.insert(__FieldTag::__crypto_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_version",
                                ));
                            }
                            result.crypto_key_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            result.algorithm = map
                                .next_value::<std::option::Option<
                                    crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_job => {
                            if !fields.insert(__FieldTag::__import_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job",
                                ));
                            }
                            result.import_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wrapped_key => {
                            if !fields.insert(__FieldTag::__wrapped_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wrapped_key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wrapped_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rsa_aes_wrapped_key => {
                            if !fields.insert(__FieldTag::__rsa_aes_wrapped_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rsa_aes_wrapped_key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.wrapped_key_material.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `wrapped_key_material`, a oneof with full ID .google.cloud.kms.v1.ImportCryptoKeyVersionRequest.rsa_aes_wrapped_key, latest field was rsaAesWrappedKey",
                                ));
                            }
                            result.wrapped_key_material = std::option::Option::Some(
                                crate::model::import_crypto_key_version_request::WrappedKeyMaterial::RsaAesWrappedKey(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportCryptoKeyVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.crypto_key_version.is_empty() {
            state.serialize_entry("cryptoKeyVersion", &self.crypto_key_version)?;
        }
        if !wkt::internal::is_default(&self.algorithm) {
            state.serialize_entry("algorithm", &self.algorithm)?;
        }
        if !self.import_job.is_empty() {
            state.serialize_entry("importJob", &self.import_job)?;
        }
        if !self.wrapped_key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("wrappedKey", &__With(&self.wrapped_key))?;
        }
        if let Some(value) = self.rsa_aes_wrapped_key() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rsaAesWrappedKey", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportCryptoKeyVersionRequest].
pub mod import_crypto_key_version_request {
    #[allow(unused_imports)]
    use super::*;

    /// This field is legacy. Use the field
    /// [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]
    /// instead.
    ///
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]: crate::model::ImportCryptoKeyVersionRequest::wrapped_key
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WrappedKeyMaterial {
        /// Optional. This field has the same meaning as
        /// [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key].
        /// Prefer to use that field in new work. Either that field or this field
        /// (but not both) must be specified.
        ///
        /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]: crate::model::ImportCryptoKeyVersionRequest::wrapped_key
        RsaAesWrappedKey(::bytes::Bytes),
    }
}

/// Request message for
/// [KeyManagementService.CreateImportJob][google.cloud.kms.v1.KeyManagementService.CreateImportJob].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateImportJob]: crate::client::KeyManagementService::create_import_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateImportJobRequest {
    /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
    /// [KeyRing][google.cloud.kms.v1.KeyRing] associated with the
    /// [ImportJobs][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.KeyRing.name]: crate::model::KeyRing::name
    pub parent: std::string::String,

    /// Required. It must be unique within a KeyRing and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    pub import_job_id: std::string::String,

    /// Required. An [ImportJob][google.cloud.kms.v1.ImportJob] with initial field
    /// values.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub import_job: std::option::Option<crate::model::ImportJob>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImportJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_job_id][crate::model::CreateImportJobRequest::import_job_id].
    pub fn set_import_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job_id = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::CreateImportJobRequest::import_job].
    pub fn set_import_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportJob>,
    {
        self.import_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_job][crate::model::CreateImportJobRequest::import_job].
    pub fn set_or_clear_import_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportJob>,
    {
        self.import_job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __import_job_id,
            __import_job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "importJobId" => Ok(__FieldTag::__import_job_id),
                            "import_job_id" => Ok(__FieldTag::__import_job_id),
                            "importJob" => Ok(__FieldTag::__import_job),
                            "import_job" => Ok(__FieldTag::__import_job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_job_id => {
                            if !fields.insert(__FieldTag::__import_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job_id",
                                ));
                            }
                            result.import_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_job => {
                            if !fields.insert(__FieldTag::__import_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_job",
                                ));
                            }
                            result.import_job =
                                map.next_value::<std::option::Option<crate::model::ImportJob>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.import_job_id.is_empty() {
            state.serialize_entry("importJobId", &self.import_job_id)?;
        }
        if self.import_job.is_some() {
            state.serialize_entry("importJob", &self.import_job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.UpdateCryptoKey][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey].
///
/// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey]: crate::client::KeyManagementService::update_crypto_key
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCryptoKeyRequest {
    /// Required. [CryptoKey][google.cloud.kms.v1.CryptoKey] with updated values.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// Required. List of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCryptoKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::UpdateCryptoKeyRequest::crypto_key].
    pub fn set_crypto_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key][crate::model::UpdateCryptoKeyRequest::crypto_key].
    pub fn set_or_clear_crypto_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKey>,
    {
        self.crypto_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCryptoKeyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCryptoKeyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCryptoKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateCryptoKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCryptoKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_key,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCryptoKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKey" => Ok(__FieldTag::__crypto_key),
                            "crypto_key" => Ok(__FieldTag::__crypto_key),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCryptoKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCryptoKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_key => {
                            if !fields.insert(__FieldTag::__crypto_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key",
                                ));
                            }
                            result.crypto_key =
                                map.next_value::<std::option::Option<crate::model::CryptoKey>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCryptoKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crypto_key.is_some() {
            state.serialize_entry("cryptoKey", &self.crypto_key)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.UpdateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion]: crate::client::KeyManagementService::update_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCryptoKeyVersionRequest {
    /// Required. [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
    /// updated values.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub crypto_key_version: std::option::Option<crate::model::CryptoKeyVersion>,

    /// Required. List of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key_version][crate::model::UpdateCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_crypto_key_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        self.crypto_key_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key_version][crate::model::UpdateCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_or_clear_crypto_key_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        self.crypto_key_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCryptoKeyVersionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCryptoKeyVersionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateCryptoKeyVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCryptoKeyVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crypto_key_version,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCryptoKeyVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cryptoKeyVersion" => Ok(__FieldTag::__crypto_key_version),
                            "crypto_key_version" => Ok(__FieldTag::__crypto_key_version),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCryptoKeyVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCryptoKeyVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crypto_key_version => {
                            if !fields.insert(__FieldTag::__crypto_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_version",
                                ));
                            }
                            result.crypto_key_version = map
                                .next_value::<std::option::Option<crate::model::CryptoKeyVersion>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCryptoKeyVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crypto_key_version.is_some() {
            state.serialize_entry("cryptoKeyVersion", &self.crypto_key_version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]: crate::client::KeyManagementService::update_crypto_key_primary_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCryptoKeyPrimaryVersionRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to update.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub name: std::string::String,

    /// Required. The id of the child
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use as primary.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub crypto_key_version_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCryptoKeyPrimaryVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateCryptoKeyPrimaryVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [crypto_key_version_id][crate::model::UpdateCryptoKeyPrimaryVersionRequest::crypto_key_version_id].
    pub fn set_crypto_key_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_version_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCryptoKeyPrimaryVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateCryptoKeyPrimaryVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCryptoKeyPrimaryVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __crypto_key_version_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCryptoKeyPrimaryVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cryptoKeyVersionId" => Ok(__FieldTag::__crypto_key_version_id),
                            "crypto_key_version_id" => Ok(__FieldTag::__crypto_key_version_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCryptoKeyPrimaryVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCryptoKeyPrimaryVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_version_id => {
                            if !fields.insert(__FieldTag::__crypto_key_version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_version_id",
                                ));
                            }
                            result.crypto_key_version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCryptoKeyPrimaryVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.crypto_key_version_id.is_empty() {
            state.serialize_entry("cryptoKeyVersionId", &self.crypto_key_version_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]: crate::client::KeyManagementService::destroy_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DestroyCryptoKeyVersionRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to destroy.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestroyCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DestroyCryptoKeyVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DestroyCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.DestroyCryptoKeyVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DestroyCryptoKeyVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DestroyCryptoKeyVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DestroyCryptoKeyVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DestroyCryptoKeyVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DestroyCryptoKeyVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]: crate::client::KeyManagementService::restore_crypto_key_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreCryptoKeyVersionRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to restore.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreCryptoKeyVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestoreCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RestoreCryptoKeyVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreCryptoKeyVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreCryptoKeyVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreCryptoKeyVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreCryptoKeyVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreCryptoKeyVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] or
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// encryption.
    ///
    /// If a [CryptoKey][google.cloud.kms.v1.CryptoKey] is specified, the server
    /// will use its [primary version][google.cloud.kms.v1.CryptoKey.primary].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.primary]: crate::model::CryptoKey::primary
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Required. The data to encrypt. Must be no larger than 64KiB.
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
    /// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys, the
    /// plaintext must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::ProtectionLevel::External
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::ProtectionLevel::Software
    pub plaintext: ::bytes::Bytes,

    /// Optional. Optional data that, if specified, must also be provided during
    /// decryption through
    /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
    /// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys the
    /// AAD must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]: crate::model::DecryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::ProtectionLevel::External
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::ProtectionLevel::ExternalVpc
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::ProtectionLevel::Software
    pub additional_authenticated_data: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext])
    /// is equal to
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.plaintext]: crate::model::EncryptRequest::plaintext
    /// [google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]: crate::model::EncryptRequest::plaintext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data])
    /// is equal to
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]: crate::model::EncryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]: crate::model::EncryptRequest::additional_authenticated_data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [plaintext][crate::model::EncryptRequest::plaintext].
    pub fn set_plaintext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::EncryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::EncryptRequest::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plaintext_crc32c][crate::model::EncryptRequest::plaintext_crc32c].
    pub fn set_or_clear_plaintext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::EncryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_authenticated_data_crc32c][crate::model::EncryptRequest::additional_authenticated_data_crc32c].
    pub fn set_or_clear_additional_authenticated_data_crc32c<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EncryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EncryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __plaintext,
            __additional_authenticated_data,
            __plaintext_crc32c,
            __additional_authenticated_data_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "plaintext" => Ok(__FieldTag::__plaintext),
                            "additionalAuthenticatedData" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "additional_authenticated_data" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "plaintextCrc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "plaintext_crc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "additionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            "additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plaintext => {
                            if !fields.insert(__FieldTag::__plaintext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_authenticated_data => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__additional_authenticated_data_crc32c => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data_crc32c =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.plaintext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("plaintext", &__With(&self.plaintext))?;
        }
        if !self.additional_authenticated_data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedData",
                &__With(&self.additional_authenticated_data),
            )?;
        }
        if self.plaintext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("plaintextCrc32c", &__With(&self.plaintext_crc32c))?;
        }
        if self.additional_authenticated_data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedDataCrc32c",
                &__With(&self.additional_authenticated_data_crc32c),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DecryptRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to use for decryption. The
    /// server will choose the appropriate version.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub name: std::string::String,

    /// Required. The encrypted data originally returned in
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
    ///
    /// [google.cloud.kms.v1.EncryptResponse.ciphertext]: crate::model::EncryptResponse::ciphertext
    pub ciphertext: ::bytes::Bytes,

    /// Optional. Optional data that must match the data originally supplied in
    /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
    ///
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]: crate::model::EncryptRequest::additional_authenticated_data
    pub additional_authenticated_data: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext])
    /// is equal to
    /// [DecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.DecryptRequest.ciphertext]: crate::model::DecryptRequest::ciphertext
    /// [google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c]: crate::model::DecryptRequest::ciphertext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data])
    /// is equal to
    /// [DecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]: crate::model::DecryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c]: crate::model::DecryptRequest::additional_authenticated_data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DecryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DecryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::DecryptRequest::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::DecryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::DecryptRequest::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ciphertext_crc32c][crate::model::DecryptRequest::ciphertext_crc32c].
    pub fn set_or_clear_ciphertext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::DecryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_authenticated_data_crc32c][crate::model::DecryptRequest::additional_authenticated_data_crc32c].
    pub fn set_or_clear_additional_authenticated_data_crc32c<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DecryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.DecryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DecryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ciphertext,
            __additional_authenticated_data,
            __ciphertext_crc32c,
            __additional_authenticated_data_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DecryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ciphertext" => Ok(__FieldTag::__ciphertext),
                            "additionalAuthenticatedData" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "additional_authenticated_data" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "ciphertextCrc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "ciphertext_crc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "additionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            "additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DecryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DecryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ciphertext => {
                            if !fields.insert(__FieldTag::__ciphertext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_authenticated_data => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__additional_authenticated_data_crc32c => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data_crc32c =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DecryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ciphertext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ciphertext", &__With(&self.ciphertext))?;
        }
        if !self.additional_authenticated_data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedData",
                &__With(&self.additional_authenticated_data),
            )?;
        }
        if self.ciphertext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ciphertextCrc32c", &__With(&self.ciphertext_crc32c))?;
        }
        if self.additional_authenticated_data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedDataCrc32c",
                &__With(&self.additional_authenticated_data_crc32c),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawEncrypt]: crate::client::KeyManagementService::raw_encrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RawEncryptRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Required. The data to encrypt. Must be no larger than 64KiB.
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
    /// plaintext must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::ProtectionLevel::Software
    pub plaintext: ::bytes::Bytes,

    /// Optional. Optional data that, if specified, must also be provided during
    /// decryption through
    /// [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
    ///
    /// This field may only be used in conjunction with an
    /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm] that accepts
    /// additional authenticated data (for example, AES-GCM).
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
    /// plaintext must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.algorithm]: crate::model::CryptoKeyVersion::algorithm
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::ProtectionLevel::Software
    /// [google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data]: crate::model::RawDecryptRequest::additional_authenticated_data
    pub additional_authenticated_data: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [RawEncryptRequest.plaintext][google.cloud.kms.v1.RawEncryptRequest.plaintext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received plaintext using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that CRC32C(plaintext) is equal
    /// to plaintext_crc32c, and if so, perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.plaintext]: crate::model::RawEncryptRequest::plaintext
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received additional_authenticated_data using
    /// this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(additional_authenticated_data) is equal to
    /// additional_authenticated_data_crc32c, and if so, perform
    /// a limited number of retries. A persistent mismatch may indicate an issue in
    /// your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data]: crate::model::RawEncryptRequest::additional_authenticated_data
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. A customer-supplied initialization vector that will be used for
    /// encryption. If it is not provided for AES-CBC and AES-CTR, one will be
    /// generated. It will be returned in
    /// [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.initialization_vector]: crate::model::RawEncryptResponse::initialization_vector
    pub initialization_vector: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [RawEncryptRequest.initialization_vector][google.cloud.kms.v1.RawEncryptRequest.initialization_vector].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received initialization_vector using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(initialization_vector) is equal to
    /// initialization_vector_crc32c, and if so, perform
    /// a limited number of retries. A persistent mismatch may indicate an issue in
    /// your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.initialization_vector]: crate::model::RawEncryptRequest::initialization_vector
    pub initialization_vector_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawEncryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RawEncryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [plaintext][crate::model::RawEncryptRequest::plaintext].
    pub fn set_plaintext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::RawEncryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::RawEncryptRequest::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plaintext_crc32c][crate::model::RawEncryptRequest::plaintext_crc32c].
    pub fn set_or_clear_plaintext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::RawEncryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_authenticated_data_crc32c][crate::model::RawEncryptRequest::additional_authenticated_data_crc32c].
    pub fn set_or_clear_additional_authenticated_data_crc32c<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initialization_vector][crate::model::RawEncryptRequest::initialization_vector].
    pub fn set_initialization_vector<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.initialization_vector = v.into();
        self
    }

    /// Sets the value of [initialization_vector_crc32c][crate::model::RawEncryptRequest::initialization_vector_crc32c].
    pub fn set_initialization_vector_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.initialization_vector_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initialization_vector_crc32c][crate::model::RawEncryptRequest::initialization_vector_crc32c].
    pub fn set_or_clear_initialization_vector_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.initialization_vector_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RawEncryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawEncryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawEncryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __plaintext,
            __additional_authenticated_data,
            __plaintext_crc32c,
            __additional_authenticated_data_crc32c,
            __initialization_vector,
            __initialization_vector_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawEncryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "plaintext" => Ok(__FieldTag::__plaintext),
                            "additionalAuthenticatedData" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "additional_authenticated_data" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "plaintextCrc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "plaintext_crc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "additionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            "additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            "initializationVector" => Ok(__FieldTag::__initialization_vector),
                            "initialization_vector" => Ok(__FieldTag::__initialization_vector),
                            "initializationVectorCrc32c" => {
                                Ok(__FieldTag::__initialization_vector_crc32c)
                            }
                            "initialization_vector_crc32c" => {
                                Ok(__FieldTag::__initialization_vector_crc32c)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawEncryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawEncryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__plaintext => {
                            if !fields.insert(__FieldTag::__plaintext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_authenticated_data => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__additional_authenticated_data_crc32c => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data_crc32c =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__initialization_vector => {
                            if !fields.insert(__FieldTag::__initialization_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_vector",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initialization_vector =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__initialization_vector_crc32c => {
                            if !fields.insert(__FieldTag::__initialization_vector_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_vector_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initialization_vector_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawEncryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.plaintext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("plaintext", &__With(&self.plaintext))?;
        }
        if !self.additional_authenticated_data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedData",
                &__With(&self.additional_authenticated_data),
            )?;
        }
        if self.plaintext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("plaintextCrc32c", &__With(&self.plaintext_crc32c))?;
        }
        if self.additional_authenticated_data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedDataCrc32c",
                &__With(&self.additional_authenticated_data_crc32c),
            )?;
        }
        if !self.initialization_vector.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initializationVector", &__With(&self.initialization_vector))?;
        }
        if self.initialization_vector_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "initializationVectorCrc32c",
                &__With(&self.initialization_vector_crc32c),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawDecrypt]: crate::client::KeyManagementService::raw_decrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RawDecryptRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Required. The encrypted data originally returned in
    /// [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.ciphertext]: crate::model::RawEncryptResponse::ciphertext
    pub ciphertext: ::bytes::Bytes,

    /// Optional. Optional data that must match the data originally supplied in
    /// [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
    ///
    /// [google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data]: crate::model::RawEncryptRequest::additional_authenticated_data
    pub additional_authenticated_data: ::bytes::Bytes,

    /// Required. The initialization vector (IV) used during encryption, which must
    /// match the data originally provided in
    /// [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.initialization_vector]: crate::model::RawEncryptResponse::initialization_vector
    pub initialization_vector: ::bytes::Bytes,

    /// The length of the authentication tag that is appended to the end of
    /// the ciphertext. If unspecified (0), the default value for the key's
    /// algorithm will be used (for AES-GCM, the default value is 16).
    pub tag_length: i32,

    /// Optional. An optional CRC32C checksum of the
    /// [RawDecryptRequest.ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received ciphertext using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that CRC32C(ciphertext) is equal
    /// to ciphertext_crc32c, and if so, perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.ciphertext]: crate::model::RawDecryptRequest::ciphertext
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received additional_authenticated_data using
    /// this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(additional_authenticated_data) is equal to
    /// additional_authenticated_data_crc32c, and if so, perform
    /// a limited number of retries. A persistent mismatch may indicate an issue in
    /// your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data]: crate::model::RawDecryptRequest::additional_authenticated_data
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received initialization_vector using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(initialization_vector) is equal to initialization_vector_crc32c, and
    /// if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.initialization_vector]: crate::model::RawDecryptRequest::initialization_vector
    pub initialization_vector_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawDecryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RawDecryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::RawDecryptRequest::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::RawDecryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [initialization_vector][crate::model::RawDecryptRequest::initialization_vector].
    pub fn set_initialization_vector<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.initialization_vector = v.into();
        self
    }

    /// Sets the value of [tag_length][crate::model::RawDecryptRequest::tag_length].
    pub fn set_tag_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.tag_length = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::RawDecryptRequest::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ciphertext_crc32c][crate::model::RawDecryptRequest::ciphertext_crc32c].
    pub fn set_or_clear_ciphertext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::RawDecryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_authenticated_data_crc32c][crate::model::RawDecryptRequest::additional_authenticated_data_crc32c].
    pub fn set_or_clear_additional_authenticated_data_crc32c<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.additional_authenticated_data_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initialization_vector_crc32c][crate::model::RawDecryptRequest::initialization_vector_crc32c].
    pub fn set_initialization_vector_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.initialization_vector_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initialization_vector_crc32c][crate::model::RawDecryptRequest::initialization_vector_crc32c].
    pub fn set_or_clear_initialization_vector_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.initialization_vector_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RawDecryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawDecryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawDecryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ciphertext,
            __additional_authenticated_data,
            __initialization_vector,
            __tag_length,
            __ciphertext_crc32c,
            __additional_authenticated_data_crc32c,
            __initialization_vector_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawDecryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ciphertext" => Ok(__FieldTag::__ciphertext),
                            "additionalAuthenticatedData" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "additional_authenticated_data" => {
                                Ok(__FieldTag::__additional_authenticated_data)
                            }
                            "initializationVector" => Ok(__FieldTag::__initialization_vector),
                            "initialization_vector" => Ok(__FieldTag::__initialization_vector),
                            "tagLength" => Ok(__FieldTag::__tag_length),
                            "tag_length" => Ok(__FieldTag::__tag_length),
                            "ciphertextCrc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "ciphertext_crc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "additionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            "additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__additional_authenticated_data_crc32c)
                            }
                            "initializationVectorCrc32c" => {
                                Ok(__FieldTag::__initialization_vector_crc32c)
                            }
                            "initialization_vector_crc32c" => {
                                Ok(__FieldTag::__initialization_vector_crc32c)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawDecryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawDecryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ciphertext => {
                            if !fields.insert(__FieldTag::__ciphertext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_authenticated_data => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__initialization_vector => {
                            if !fields.insert(__FieldTag::__initialization_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_vector",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initialization_vector =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tag_length => {
                            if !fields.insert(__FieldTag::__tag_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tag_length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__additional_authenticated_data_crc32c => {
                            if !fields.insert(__FieldTag::__additional_authenticated_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_authenticated_data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.additional_authenticated_data_crc32c =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__initialization_vector_crc32c => {
                            if !fields.insert(__FieldTag::__initialization_vector_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_vector_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initialization_vector_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawDecryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ciphertext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ciphertext", &__With(&self.ciphertext))?;
        }
        if !self.additional_authenticated_data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedData",
                &__With(&self.additional_authenticated_data),
            )?;
        }
        if !self.initialization_vector.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initializationVector", &__With(&self.initialization_vector))?;
        }
        if !wkt::internal::is_default(&self.tag_length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tagLength", &__With(&self.tag_length))?;
        }
        if self.ciphertext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ciphertextCrc32c", &__With(&self.ciphertext_crc32c))?;
        }
        if self.additional_authenticated_data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "additionalAuthenticatedDataCrc32c",
                &__With(&self.additional_authenticated_data_crc32c),
            )?;
        }
        if self.initialization_vector_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "initializationVectorCrc32c",
                &__With(&self.initialization_vector_crc32c),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricSign]: crate::client::KeyManagementService::asymmetric_sign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AsymmetricSignRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Optional. The digest of the data to sign. The digest must be produced with
    /// the same digest algorithm as specified by the key version's
    /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm].
    ///
    /// This field may not be supplied if
    /// [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
    /// is supplied.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data]: crate::model::AsymmetricSignRequest::data
    /// [google.cloud.kms.v1.CryptoKeyVersion.algorithm]: crate::model::CryptoKeyVersion::algorithm
    pub digest: std::option::Option<crate::model::Digest>,

    /// Optional. An optional CRC32C checksum of the
    /// [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest])
    /// is equal to
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest]: crate::model::AsymmetricSignRequest::digest
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]: crate::model::AsymmetricSignRequest::digest_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub digest_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. The data to sign.
    /// It can't be supplied if
    /// [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
    /// is supplied.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest]: crate::model::AsymmetricSignRequest::digest
    pub data: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data])
    /// is equal to
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data]: crate::model::AsymmetricSignRequest::data
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]: crate::model::AsymmetricSignRequest::data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub data_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsymmetricSignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AsymmetricSignRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::AsymmetricSignRequest::digest].
    pub fn set_digest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Digest>,
    {
        self.digest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [digest][crate::model::AsymmetricSignRequest::digest].
    pub fn set_or_clear_digest<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Digest>,
    {
        self.digest = v.map(|x| x.into());
        self
    }

    /// Sets the value of [digest_crc32c][crate::model::AsymmetricSignRequest::digest_crc32c].
    pub fn set_digest_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.digest_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [digest_crc32c][crate::model::AsymmetricSignRequest::digest_crc32c].
    pub fn set_or_clear_digest_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.digest_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data][crate::model::AsymmetricSignRequest::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::AsymmetricSignRequest::data_crc32c].
    pub fn set_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_crc32c][crate::model::AsymmetricSignRequest::data_crc32c].
    pub fn set_or_clear_data_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AsymmetricSignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricSignRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsymmetricSignRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __digest,
            __digest_crc32c,
            __data,
            __data_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsymmetricSignRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "digest" => Ok(__FieldTag::__digest),
                            "digestCrc32c" => Ok(__FieldTag::__digest_crc32c),
                            "digest_crc32c" => Ok(__FieldTag::__digest_crc32c),
                            "data" => Ok(__FieldTag::__data),
                            "dataCrc32c" => Ok(__FieldTag::__data_crc32c),
                            "data_crc32c" => Ok(__FieldTag::__data_crc32c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsymmetricSignRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsymmetricSignRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__digest => {
                            if !fields.insert(__FieldTag::__digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest",
                                ));
                            }
                            result.digest =
                                map.next_value::<std::option::Option<crate::model::Digest>>()?;
                        }
                        __FieldTag::__digest_crc32c => {
                            if !fields.insert(__FieldTag::__digest_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digest_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.digest_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_crc32c => {
                            if !fields.insert(__FieldTag::__data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsymmetricSignRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.digest.is_some() {
            state.serialize_entry("digest", &self.digest)?;
        }
        if self.digest_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("digestCrc32c", &__With(&self.digest_crc32c))?;
        }
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if self.data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataCrc32c", &__With(&self.data_crc32c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]: crate::client::KeyManagementService::asymmetric_decrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AsymmetricDecryptRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Required. The data encrypted with the named
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s public key using
    /// OAEP.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub ciphertext: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext])
    /// is equal to
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]: crate::model::AsymmetricDecryptRequest::ciphertext
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]: crate::model::AsymmetricDecryptRequest::ciphertext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsymmetricDecryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AsymmetricDecryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::AsymmetricDecryptRequest::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::AsymmetricDecryptRequest::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ciphertext_crc32c][crate::model::AsymmetricDecryptRequest::ciphertext_crc32c].
    pub fn set_or_clear_ciphertext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AsymmetricDecryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricDecryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsymmetricDecryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ciphertext,
            __ciphertext_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsymmetricDecryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ciphertext" => Ok(__FieldTag::__ciphertext),
                            "ciphertextCrc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "ciphertext_crc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsymmetricDecryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsymmetricDecryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ciphertext => {
                            if !fields.insert(__FieldTag::__ciphertext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsymmetricDecryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ciphertext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ciphertext", &__With(&self.ciphertext))?;
        }
        if self.ciphertext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ciphertextCrc32c", &__With(&self.ciphertext_crc32c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
///
/// [google.cloud.kms.v1.KeyManagementService.MacSign]: crate::client::KeyManagementService::mac_sign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MacSignRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Required. The data to sign. The MAC tag is computed over this data field
    /// based on the specific algorithm.
    pub data: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]. If
    /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will verify the integrity of the received
    /// [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]) is
    /// equal to
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacSignRequest.data]: crate::model::MacSignRequest::data
    /// [google.cloud.kms.v1.MacSignRequest.data_crc32c]: crate::model::MacSignRequest::data_crc32c
    pub data_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MacSignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacSignRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::MacSignRequest::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::MacSignRequest::data_crc32c].
    pub fn set_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_crc32c][crate::model::MacSignRequest::data_crc32c].
    pub fn set_or_clear_data_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MacSignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacSignRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MacSignRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data,
            __data_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MacSignRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "data" => Ok(__FieldTag::__data),
                            "dataCrc32c" => Ok(__FieldTag::__data_crc32c),
                            "data_crc32c" => Ok(__FieldTag::__data_crc32c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MacSignRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MacSignRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_crc32c => {
                            if !fields.insert(__FieldTag::__data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MacSignRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if self.data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataCrc32c", &__With(&self.data_crc32c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
///
/// [google.cloud.kms.v1.KeyManagementService.MacVerify]: crate::client::KeyManagementService::mac_verify
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MacVerifyRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// verification.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Required. The data used previously as a
    /// [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] to generate
    /// the MAC tag.
    ///
    /// [google.cloud.kms.v1.MacSignRequest.data]: crate::model::MacSignRequest::data
    pub data: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data]. If
    /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will verify the integrity of the received
    /// [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] using
    /// this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data])
    /// is equal to
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.data]: crate::model::MacVerifyRequest::data
    /// [google.cloud.kms.v1.MacVerifyRequest.data_crc32c]: crate::model::MacVerifyRequest::data_crc32c
    pub data_crc32c: std::option::Option<wkt::Int64Value>,

    /// Required. The signature to verify.
    pub mac: ::bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac]. If
    /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will verify the integrity of the received
    /// [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac]) is
    /// equal to
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.mac]: crate::model::MacVerifyRequest::mac
    /// [google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]: crate::model::MacVerifyRequest::mac_crc32c
    pub mac_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MacVerifyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacVerifyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::MacVerifyRequest::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::MacVerifyRequest::data_crc32c].
    pub fn set_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_crc32c][crate::model::MacVerifyRequest::data_crc32c].
    pub fn set_or_clear_data_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mac][crate::model::MacVerifyRequest::mac].
    pub fn set_mac<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.mac = v.into();
        self
    }

    /// Sets the value of [mac_crc32c][crate::model::MacVerifyRequest::mac_crc32c].
    pub fn set_mac_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.mac_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mac_crc32c][crate::model::MacVerifyRequest::mac_crc32c].
    pub fn set_or_clear_mac_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.mac_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MacVerifyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacVerifyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MacVerifyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data,
            __data_crc32c,
            __mac,
            __mac_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MacVerifyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "data" => Ok(__FieldTag::__data),
                            "dataCrc32c" => Ok(__FieldTag::__data_crc32c),
                            "data_crc32c" => Ok(__FieldTag::__data_crc32c),
                            "mac" => Ok(__FieldTag::__mac),
                            "macCrc32c" => Ok(__FieldTag::__mac_crc32c),
                            "mac_crc32c" => Ok(__FieldTag::__mac_crc32c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MacVerifyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MacVerifyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_crc32c => {
                            if !fields.insert(__FieldTag::__data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__mac => {
                            if !fields.insert(__FieldTag::__mac) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mac",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mac = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mac_crc32c => {
                            if !fields.insert(__FieldTag::__mac_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mac_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mac_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MacVerifyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if self.data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataCrc32c", &__With(&self.data_crc32c))?;
        }
        if !self.mac.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mac", &__With(&self.mac))?;
        }
        if self.mac_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("macCrc32c", &__With(&self.mac_crc32c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
///
/// [google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes]: crate::client::KeyManagementService::generate_random_bytes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateRandomBytesRequest {
    /// The project-specific location in which to generate random bytes.
    /// For example, "projects/my-project/locations/us-central1".
    pub location: std::string::String,

    /// The length in bytes of the amount of randomness to retrieve.  Minimum 8
    /// bytes, maximum 1024 bytes.
    pub length_bytes: i32,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when
    /// generating the random data. Currently, only
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] protection level is
    /// supported.
    ///
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateRandomBytesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::GenerateRandomBytesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [length_bytes][crate::model::GenerateRandomBytesRequest::length_bytes].
    pub fn set_length_bytes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length_bytes = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::GenerateRandomBytesRequest::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for GenerateRandomBytesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GenerateRandomBytesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateRandomBytesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __length_bytes,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateRandomBytesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "lengthBytes" => Ok(__FieldTag::__length_bytes),
                            "length_bytes" => Ok(__FieldTag::__length_bytes),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateRandomBytesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateRandomBytesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length_bytes => {
                            if !fields.insert(__FieldTag::__length_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateRandomBytesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.length_bytes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lengthBytes", &__With(&self.length_bytes))?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptResponse {
    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption. Check this field to verify that the intended resource was used
    /// for encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// The encrypted data.
    pub ciphertext: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
    /// An integrity check of
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
    /// can be performed by computing the CRC32C checksum of
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.EncryptResponse.ciphertext]: crate::model::EncryptResponse::ciphertext
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]. A false value of
    /// this field indicates either that
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.plaintext]: crate::model::EncryptRequest::plaintext
    /// [google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]: crate::model::EncryptRequest::plaintext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub verified_plaintext_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [AAD][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]. A
    /// false value of this field indicates either that
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]: crate::model::EncryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]: crate::model::EncryptRequest::additional_authenticated_data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub verified_additional_authenticated_data_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::EncryptResponse::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::EncryptResponse::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ciphertext_crc32c][crate::model::EncryptResponse::ciphertext_crc32c].
    pub fn set_or_clear_ciphertext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verified_plaintext_crc32c][crate::model::EncryptResponse::verified_plaintext_crc32c].
    pub fn set_verified_plaintext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_additional_authenticated_data_crc32c][crate::model::EncryptResponse::verified_additional_authenticated_data_crc32c].
    pub fn set_verified_additional_authenticated_data_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::EncryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for EncryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EncryptResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ciphertext,
            __ciphertext_crc32c,
            __verified_plaintext_crc32c,
            __verified_additional_authenticated_data_crc32c,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ciphertext" => Ok(__FieldTag::__ciphertext),
                            "ciphertextCrc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "ciphertext_crc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "verifiedPlaintextCrc32c" => {
                                Ok(__FieldTag::__verified_plaintext_crc32c)
                            }
                            "verified_plaintext_crc32c" => {
                                Ok(__FieldTag::__verified_plaintext_crc32c)
                            }
                            "verifiedAdditionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            }
                            "verified_additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            }
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ciphertext => {
                            if !fields.insert(__FieldTag::__ciphertext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__verified_plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__verified_plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_plaintext_crc32c",
                                ));
                            }
                            result.verified_plaintext_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_additional_authenticated_data_crc32c => {
                            if !fields
                                .insert(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_additional_authenticated_data_crc32c",
                                ));
                            }
                            result.verified_additional_authenticated_data_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ciphertext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ciphertext", &__With(&self.ciphertext))?;
        }
        if self.ciphertext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ciphertextCrc32c", &__With(&self.ciphertext_crc32c))?;
        }
        if !wkt::internal::is_default(&self.verified_plaintext_crc32c) {
            state.serialize_entry("verifiedPlaintextCrc32c", &self.verified_plaintext_crc32c)?;
        }
        if !wkt::internal::is_default(&self.verified_additional_authenticated_data_crc32c) {
            state.serialize_entry(
                "verifiedAdditionalAuthenticatedDataCrc32c",
                &self.verified_additional_authenticated_data_crc32c,
            )?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DecryptResponse {
    /// The decrypted data originally supplied in
    /// [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
    ///
    /// [google.cloud.kms.v1.EncryptRequest.plaintext]: crate::model::EncryptRequest::plaintext
    pub plaintext: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext].
    /// An integrity check of
    /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
    /// can be performed by computing the CRC32C checksum of
    /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: receiving this response message indicates that
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
    /// successfully decrypt the
    /// [ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.DecryptRequest.ciphertext]: crate::model::DecryptRequest::ciphertext
    /// [google.cloud.kms.v1.DecryptResponse.plaintext]: crate::model::DecryptResponse::plaintext
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Whether the Decryption was performed using the primary key version.
    pub used_primary: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DecryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plaintext][crate::model::DecryptResponse::plaintext].
    pub fn set_plaintext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::DecryptResponse::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plaintext_crc32c][crate::model::DecryptResponse::plaintext_crc32c].
    pub fn set_or_clear_plaintext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [used_primary][crate::model::DecryptResponse::used_primary].
    pub fn set_used_primary<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.used_primary = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::DecryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for DecryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.DecryptResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DecryptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plaintext,
            __plaintext_crc32c,
            __used_primary,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DecryptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "plaintext" => Ok(__FieldTag::__plaintext),
                            "plaintextCrc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "plaintext_crc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "usedPrimary" => Ok(__FieldTag::__used_primary),
                            "used_primary" => Ok(__FieldTag::__used_primary),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DecryptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DecryptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plaintext => {
                            if !fields.insert(__FieldTag::__plaintext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__used_primary => {
                            if !fields.insert(__FieldTag::__used_primary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_primary",
                                ));
                            }
                            result.used_primary = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DecryptResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.plaintext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("plaintext", &__With(&self.plaintext))?;
        }
        if self.plaintext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("plaintextCrc32c", &__With(&self.plaintext_crc32c))?;
        }
        if !wkt::internal::is_default(&self.used_primary) {
            state.serialize_entry("usedPrimary", &self.used_primary)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawEncrypt]: crate::client::KeyManagementService::raw_encrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RawEncryptResponse {
    /// The encrypted data. In the case of AES-GCM, the authentication tag
    /// is the [tag_length][google.cloud.kms.v1.RawEncryptResponse.tag_length]
    /// bytes at the end of this field.
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.tag_length]: crate::model::RawEncryptResponse::tag_length
    pub ciphertext: ::bytes::Bytes,

    /// The initialization vector (IV) generated by the service during
    /// encryption. This value must be stored and provided in
    /// [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector]
    /// at decryption time.
    ///
    /// [google.cloud.kms.v1.RawDecryptRequest.initialization_vector]: crate::model::RawDecryptRequest::initialization_vector
    pub initialization_vector: ::bytes::Bytes,

    /// The length of the authentication tag that is appended to
    /// the end of the ciphertext.
    pub tag_length: i32,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
    /// An integrity check of ciphertext can be performed by computing the CRC32C
    /// checksum of ciphertext and comparing your results to this field. Discard
    /// the response in case of non-matching checksum values, and perform a limited
    /// number of retries. A persistent mismatch may indicate an issue in your
    /// computation of the CRC32C checksum. Note: This field is defined as int64
    /// for reasons of compatibility across different languages. However, it is a
    /// non-negative integer, which will never exceed 2^32-1, and can be safely
    /// downconverted to uint32 in languages that support this type.
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.ciphertext]: crate::model::RawEncryptResponse::ciphertext
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
    /// An integrity check of initialization_vector can be performed by computing
    /// the CRC32C checksum of initialization_vector and comparing your results to
    /// this field. Discard the response in case of non-matching checksum values,
    /// and perform a limited number of retries. A persistent mismatch may indicate
    /// an issue in your computation of the CRC32C checksum. Note: This field is
    /// defined as int64 for reasons of compatibility across different languages.
    /// However, it is a non-negative integer, which will never exceed 2^32-1, and
    /// can be safely downconverted to uint32 in languages that support this type.
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.initialization_vector]: crate::model::RawEncryptResponse::initialization_vector
    pub initialization_vector_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the plaintext. A false value of this
    /// field indicates either that
    /// [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]: crate::model::RawEncryptRequest::plaintext_crc32c
    pub verified_plaintext_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of additional_authenticated_data. A false
    /// value of this field indicates either that //
    /// [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]: crate::model::RawEncryptRequest::additional_authenticated_data_crc32c
    pub verified_additional_authenticated_data_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of initialization_vector. A false value of
    /// this field indicates either that
    /// [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]: crate::model::RawEncryptRequest::initialization_vector_crc32c
    pub verified_initialization_vector_crc32c: bool,

    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption. Check this field to verify that the intended resource was used
    /// for encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawEncryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ciphertext][crate::model::RawEncryptResponse::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [initialization_vector][crate::model::RawEncryptResponse::initialization_vector].
    pub fn set_initialization_vector<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.initialization_vector = v.into();
        self
    }

    /// Sets the value of [tag_length][crate::model::RawEncryptResponse::tag_length].
    pub fn set_tag_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.tag_length = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::RawEncryptResponse::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ciphertext_crc32c][crate::model::RawEncryptResponse::ciphertext_crc32c].
    pub fn set_or_clear_ciphertext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.ciphertext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initialization_vector_crc32c][crate::model::RawEncryptResponse::initialization_vector_crc32c].
    pub fn set_initialization_vector_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.initialization_vector_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initialization_vector_crc32c][crate::model::RawEncryptResponse::initialization_vector_crc32c].
    pub fn set_or_clear_initialization_vector_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.initialization_vector_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verified_plaintext_crc32c][crate::model::RawEncryptResponse::verified_plaintext_crc32c].
    pub fn set_verified_plaintext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_additional_authenticated_data_crc32c][crate::model::RawEncryptResponse::verified_additional_authenticated_data_crc32c].
    pub fn set_verified_additional_authenticated_data_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_initialization_vector_crc32c][crate::model::RawEncryptResponse::verified_initialization_vector_crc32c].
    pub fn set_verified_initialization_vector_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_initialization_vector_crc32c = v.into();
        self
    }

    /// Sets the value of [name][crate::model::RawEncryptResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::RawEncryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for RawEncryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawEncryptResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawEncryptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ciphertext,
            __initialization_vector,
            __tag_length,
            __ciphertext_crc32c,
            __initialization_vector_crc32c,
            __verified_plaintext_crc32c,
            __verified_additional_authenticated_data_crc32c,
            __verified_initialization_vector_crc32c,
            __name,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawEncryptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ciphertext" => Ok(__FieldTag::__ciphertext),
                            "initializationVector" => Ok(__FieldTag::__initialization_vector),
                            "initialization_vector" => Ok(__FieldTag::__initialization_vector),
                            "tagLength" => Ok(__FieldTag::__tag_length),
                            "tag_length" => Ok(__FieldTag::__tag_length),
                            "ciphertextCrc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "ciphertext_crc32c" => Ok(__FieldTag::__ciphertext_crc32c),
                            "initializationVectorCrc32c" => {
                                Ok(__FieldTag::__initialization_vector_crc32c)
                            }
                            "initialization_vector_crc32c" => {
                                Ok(__FieldTag::__initialization_vector_crc32c)
                            }
                            "verifiedPlaintextCrc32c" => {
                                Ok(__FieldTag::__verified_plaintext_crc32c)
                            }
                            "verified_plaintext_crc32c" => {
                                Ok(__FieldTag::__verified_plaintext_crc32c)
                            }
                            "verifiedAdditionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            }
                            "verified_additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            }
                            "verifiedInitializationVectorCrc32c" => {
                                Ok(__FieldTag::__verified_initialization_vector_crc32c)
                            }
                            "verified_initialization_vector_crc32c" => {
                                Ok(__FieldTag::__verified_initialization_vector_crc32c)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawEncryptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawEncryptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ciphertext => {
                            if !fields.insert(__FieldTag::__ciphertext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__initialization_vector => {
                            if !fields.insert(__FieldTag::__initialization_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_vector",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initialization_vector =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tag_length => {
                            if !fields.insert(__FieldTag::__tag_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tag_length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ciphertext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ciphertext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__initialization_vector_crc32c => {
                            if !fields.insert(__FieldTag::__initialization_vector_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_vector_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initialization_vector_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__verified_plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__verified_plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_plaintext_crc32c",
                                ));
                            }
                            result.verified_plaintext_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_additional_authenticated_data_crc32c => {
                            if !fields
                                .insert(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_additional_authenticated_data_crc32c",
                                ));
                            }
                            result.verified_additional_authenticated_data_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_initialization_vector_crc32c => {
                            if !fields.insert(__FieldTag::__verified_initialization_vector_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_initialization_vector_crc32c",
                                ));
                            }
                            result.verified_initialization_vector_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawEncryptResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ciphertext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ciphertext", &__With(&self.ciphertext))?;
        }
        if !self.initialization_vector.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initializationVector", &__With(&self.initialization_vector))?;
        }
        if !wkt::internal::is_default(&self.tag_length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tagLength", &__With(&self.tag_length))?;
        }
        if self.ciphertext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ciphertextCrc32c", &__With(&self.ciphertext_crc32c))?;
        }
        if self.initialization_vector_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "initializationVectorCrc32c",
                &__With(&self.initialization_vector_crc32c),
            )?;
        }
        if !wkt::internal::is_default(&self.verified_plaintext_crc32c) {
            state.serialize_entry("verifiedPlaintextCrc32c", &self.verified_plaintext_crc32c)?;
        }
        if !wkt::internal::is_default(&self.verified_additional_authenticated_data_crc32c) {
            state.serialize_entry(
                "verifiedAdditionalAuthenticatedDataCrc32c",
                &self.verified_additional_authenticated_data_crc32c,
            )?;
        }
        if !wkt::internal::is_default(&self.verified_initialization_vector_crc32c) {
            state.serialize_entry(
                "verifiedInitializationVectorCrc32c",
                &self.verified_initialization_vector_crc32c,
            )?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawDecrypt]: crate::client::KeyManagementService::raw_decrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RawDecryptResponse {
    /// The decrypted data.
    pub plaintext: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [RawDecryptResponse.plaintext][google.cloud.kms.v1.RawDecryptResponse.plaintext].
    /// An integrity check of plaintext can be performed by computing the CRC32C
    /// checksum of plaintext and comparing your results to this field. Discard the
    /// response in case of non-matching checksum values, and perform a limited
    /// number of retries. A persistent mismatch may indicate an issue in your
    /// computation of the CRC32C checksum. Note: receiving this response message
    /// indicates that
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
    /// successfully decrypt the
    /// [ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.ciphertext]: crate::model::RawDecryptRequest::ciphertext
    /// [google.cloud.kms.v1.RawDecryptResponse.plaintext]: crate::model::RawDecryptResponse::plaintext
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    /// Integrity verification field. A flag indicating whether
    /// [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the ciphertext. A false value of this
    /// field indicates either that
    /// [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]: crate::model::RawDecryptRequest::ciphertext_crc32c
    pub verified_ciphertext_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of additional_authenticated_data. A false
    /// value of this field indicates either that //
    /// [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]: crate::model::RawDecryptRequest::additional_authenticated_data_crc32c
    pub verified_additional_authenticated_data_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of initialization_vector. A false value of
    /// this field indicates either that
    /// [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]: crate::model::RawDecryptRequest::initialization_vector_crc32c
    pub verified_initialization_vector_crc32c: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawDecryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plaintext][crate::model::RawDecryptResponse::plaintext].
    pub fn set_plaintext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::RawDecryptResponse::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plaintext_crc32c][crate::model::RawDecryptResponse::plaintext_crc32c].
    pub fn set_or_clear_plaintext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [protection_level][crate::model::RawDecryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [verified_ciphertext_crc32c][crate::model::RawDecryptResponse::verified_ciphertext_crc32c].
    pub fn set_verified_ciphertext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_additional_authenticated_data_crc32c][crate::model::RawDecryptResponse::verified_additional_authenticated_data_crc32c].
    pub fn set_verified_additional_authenticated_data_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_initialization_vector_crc32c][crate::model::RawDecryptResponse::verified_initialization_vector_crc32c].
    pub fn set_verified_initialization_vector_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_initialization_vector_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for RawDecryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawDecryptResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawDecryptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plaintext,
            __plaintext_crc32c,
            __protection_level,
            __verified_ciphertext_crc32c,
            __verified_additional_authenticated_data_crc32c,
            __verified_initialization_vector_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawDecryptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "plaintext" => Ok(__FieldTag::__plaintext),
                            "plaintextCrc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "plaintext_crc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            "verifiedCiphertextCrc32c" => {
                                Ok(__FieldTag::__verified_ciphertext_crc32c)
                            }
                            "verified_ciphertext_crc32c" => {
                                Ok(__FieldTag::__verified_ciphertext_crc32c)
                            }
                            "verifiedAdditionalAuthenticatedDataCrc32c" => {
                                Ok(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            }
                            "verified_additional_authenticated_data_crc32c" => {
                                Ok(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            }
                            "verifiedInitializationVectorCrc32c" => {
                                Ok(__FieldTag::__verified_initialization_vector_crc32c)
                            }
                            "verified_initialization_vector_crc32c" => {
                                Ok(__FieldTag::__verified_initialization_vector_crc32c)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawDecryptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawDecryptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plaintext => {
                            if !fields.insert(__FieldTag::__plaintext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__verified_ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_ciphertext_crc32c",
                                ));
                            }
                            result.verified_ciphertext_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_additional_authenticated_data_crc32c => {
                            if !fields
                                .insert(__FieldTag::__verified_additional_authenticated_data_crc32c)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_additional_authenticated_data_crc32c",
                                ));
                            }
                            result.verified_additional_authenticated_data_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_initialization_vector_crc32c => {
                            if !fields.insert(__FieldTag::__verified_initialization_vector_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_initialization_vector_crc32c",
                                ));
                            }
                            result.verified_initialization_vector_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawDecryptResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.plaintext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("plaintext", &__With(&self.plaintext))?;
        }
        if self.plaintext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("plaintextCrc32c", &__With(&self.plaintext_crc32c))?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !wkt::internal::is_default(&self.verified_ciphertext_crc32c) {
            state.serialize_entry("verifiedCiphertextCrc32c", &self.verified_ciphertext_crc32c)?;
        }
        if !wkt::internal::is_default(&self.verified_additional_authenticated_data_crc32c) {
            state.serialize_entry(
                "verifiedAdditionalAuthenticatedDataCrc32c",
                &self.verified_additional_authenticated_data_crc32c,
            )?;
        }
        if !wkt::internal::is_default(&self.verified_initialization_vector_crc32c) {
            state.serialize_entry(
                "verifiedInitializationVectorCrc32c",
                &self.verified_initialization_vector_crc32c,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricSign]: crate::client::KeyManagementService::asymmetric_sign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AsymmetricSignResponse {
    /// The created signature.
    pub signature: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature].
    /// An integrity check of
    /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
    /// can be performed by computing the CRC32C checksum of
    /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignResponse.signature]: crate::model::AsymmetricSignResponse::signature
    pub signature_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]. A false value
    /// of this field indicates either that
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest]: crate::model::AsymmetricSignRequest::digest
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]: crate::model::AsymmetricSignRequest::digest_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub verified_digest_crc32c: bool,

    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    /// Check this field to verify that the intended resource was used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// Integrity verification field. A flag indicating whether
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.AsymmetricSignRequest.data]. A false value of
    /// this field indicates either that
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data]: crate::model::AsymmetricSignRequest::data
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]: crate::model::AsymmetricSignRequest::data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub verified_data_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsymmetricSignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signature][crate::model::AsymmetricSignResponse::signature].
    pub fn set_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [signature_crc32c][crate::model::AsymmetricSignResponse::signature_crc32c].
    pub fn set_signature_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.signature_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [signature_crc32c][crate::model::AsymmetricSignResponse::signature_crc32c].
    pub fn set_or_clear_signature_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.signature_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verified_digest_crc32c][crate::model::AsymmetricSignResponse::verified_digest_crc32c].
    pub fn set_verified_digest_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_digest_crc32c = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AsymmetricSignResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [verified_data_crc32c][crate::model::AsymmetricSignResponse::verified_data_crc32c].
    pub fn set_verified_data_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_data_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::AsymmetricSignResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for AsymmetricSignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricSignResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsymmetricSignResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signature,
            __signature_crc32c,
            __verified_digest_crc32c,
            __name,
            __verified_data_crc32c,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsymmetricSignResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signature" => Ok(__FieldTag::__signature),
                            "signatureCrc32c" => Ok(__FieldTag::__signature_crc32c),
                            "signature_crc32c" => Ok(__FieldTag::__signature_crc32c),
                            "verifiedDigestCrc32c" => Ok(__FieldTag::__verified_digest_crc32c),
                            "verified_digest_crc32c" => Ok(__FieldTag::__verified_digest_crc32c),
                            "name" => Ok(__FieldTag::__name),
                            "verifiedDataCrc32c" => Ok(__FieldTag::__verified_data_crc32c),
                            "verified_data_crc32c" => Ok(__FieldTag::__verified_data_crc32c),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsymmetricSignResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsymmetricSignResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signature => {
                            if !fields.insert(__FieldTag::__signature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.signature = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__signature_crc32c => {
                            if !fields.insert(__FieldTag::__signature_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.signature_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__verified_digest_crc32c => {
                            if !fields.insert(__FieldTag::__verified_digest_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_digest_crc32c",
                                ));
                            }
                            result.verified_digest_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_data_crc32c => {
                            if !fields.insert(__FieldTag::__verified_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_data_crc32c",
                                ));
                            }
                            result.verified_data_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsymmetricSignResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.signature.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("signature", &__With(&self.signature))?;
        }
        if self.signature_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("signatureCrc32c", &__With(&self.signature_crc32c))?;
        }
        if !wkt::internal::is_default(&self.verified_digest_crc32c) {
            state.serialize_entry("verifiedDigestCrc32c", &self.verified_digest_crc32c)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.verified_data_crc32c) {
            state.serialize_entry("verifiedDataCrc32c", &self.verified_data_crc32c)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]: crate::client::KeyManagementService::asymmetric_decrypt
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AsymmetricDecryptResponse {
    /// The decrypted data originally encrypted with the matching public key.
    pub plaintext: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext].
    /// An integrity check of
    /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
    /// can be performed by computing the CRC32C checksum of
    /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]: crate::model::AsymmetricDecryptResponse::plaintext
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]. A
    /// false value of this field indicates either that
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]: crate::model::AsymmetricDecryptRequest::ciphertext
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]: crate::model::AsymmetricDecryptRequest::ciphertext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    pub verified_ciphertext_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsymmetricDecryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plaintext][crate::model::AsymmetricDecryptResponse::plaintext].
    pub fn set_plaintext<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::AsymmetricDecryptResponse::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [plaintext_crc32c][crate::model::AsymmetricDecryptResponse::plaintext_crc32c].
    pub fn set_or_clear_plaintext_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.plaintext_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verified_ciphertext_crc32c][crate::model::AsymmetricDecryptResponse::verified_ciphertext_crc32c].
    pub fn set_verified_ciphertext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::AsymmetricDecryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for AsymmetricDecryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricDecryptResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsymmetricDecryptResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plaintext,
            __plaintext_crc32c,
            __verified_ciphertext_crc32c,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsymmetricDecryptResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "plaintext" => Ok(__FieldTag::__plaintext),
                            "plaintextCrc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "plaintext_crc32c" => Ok(__FieldTag::__plaintext_crc32c),
                            "verifiedCiphertextCrc32c" => {
                                Ok(__FieldTag::__verified_ciphertext_crc32c)
                            }
                            "verified_ciphertext_crc32c" => {
                                Ok(__FieldTag::__verified_ciphertext_crc32c)
                            }
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsymmetricDecryptResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsymmetricDecryptResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plaintext => {
                            if !fields.insert(__FieldTag::__plaintext) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__plaintext_crc32c => {
                            if !fields.insert(__FieldTag::__plaintext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plaintext_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.plaintext_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__verified_ciphertext_crc32c => {
                            if !fields.insert(__FieldTag::__verified_ciphertext_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_ciphertext_crc32c",
                                ));
                            }
                            result.verified_ciphertext_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsymmetricDecryptResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.plaintext.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("plaintext", &__With(&self.plaintext))?;
        }
        if self.plaintext_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("plaintextCrc32c", &__With(&self.plaintext_crc32c))?;
        }
        if !wkt::internal::is_default(&self.verified_ciphertext_crc32c) {
            state.serialize_entry("verifiedCiphertextCrc32c", &self.verified_ciphertext_crc32c)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
///
/// [google.cloud.kms.v1.KeyManagementService.MacSign]: crate::client::KeyManagementService::mac_sign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MacSignResponse {
    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    /// Check this field to verify that the intended resource was used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// The created signature.
    pub mac: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac]. An
    /// integrity check of
    /// [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] can be
    /// performed by computing the CRC32C checksum of
    /// [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] and
    /// comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.MacSignResponse.mac]: crate::model::MacSignResponse::mac
    pub mac_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.MacSignRequest.data]. A false value of this
    /// field indicates either that
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacSignRequest.data]: crate::model::MacSignRequest::data
    /// [google.cloud.kms.v1.MacSignRequest.data_crc32c]: crate::model::MacSignRequest::data_crc32c
    pub verified_data_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MacSignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacSignResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mac][crate::model::MacSignResponse::mac].
    pub fn set_mac<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.mac = v.into();
        self
    }

    /// Sets the value of [mac_crc32c][crate::model::MacSignResponse::mac_crc32c].
    pub fn set_mac_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.mac_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mac_crc32c][crate::model::MacSignResponse::mac_crc32c].
    pub fn set_or_clear_mac_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.mac_crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verified_data_crc32c][crate::model::MacSignResponse::verified_data_crc32c].
    pub fn set_verified_data_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_data_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::MacSignResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for MacSignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacSignResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MacSignResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __mac,
            __mac_crc32c,
            __verified_data_crc32c,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MacSignResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "mac" => Ok(__FieldTag::__mac),
                            "macCrc32c" => Ok(__FieldTag::__mac_crc32c),
                            "mac_crc32c" => Ok(__FieldTag::__mac_crc32c),
                            "verifiedDataCrc32c" => Ok(__FieldTag::__verified_data_crc32c),
                            "verified_data_crc32c" => Ok(__FieldTag::__verified_data_crc32c),
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MacSignResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MacSignResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mac => {
                            if !fields.insert(__FieldTag::__mac) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mac",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mac = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mac_crc32c => {
                            if !fields.insert(__FieldTag::__mac_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mac_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mac_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__verified_data_crc32c => {
                            if !fields.insert(__FieldTag::__verified_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_data_crc32c",
                                ));
                            }
                            result.verified_data_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MacSignResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.mac.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mac", &__With(&self.mac))?;
        }
        if self.mac_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("macCrc32c", &__With(&self.mac_crc32c))?;
        }
        if !wkt::internal::is_default(&self.verified_data_crc32c) {
            state.serialize_entry("verifiedDataCrc32c", &self.verified_data_crc32c)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
///
/// [google.cloud.kms.v1.KeyManagementService.MacVerify]: crate::client::KeyManagementService::mac_verify
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MacVerifyResponse {
    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
    /// verification. Check this field to verify that the intended resource was
    /// used for verification.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub name: std::string::String,

    /// This field indicates whether or not the verification operation for
    /// [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] over
    /// [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] was
    /// successful.
    ///
    /// [google.cloud.kms.v1.MacVerifyRequest.data]: crate::model::MacVerifyRequest::data
    /// [google.cloud.kms.v1.MacVerifyRequest.mac]: crate::model::MacVerifyRequest::mac
    pub success: bool,

    /// Integrity verification field. A flag indicating whether
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.MacVerifyRequest.data]. A false value of this
    /// field indicates either that
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.data]: crate::model::MacVerifyRequest::data
    /// [google.cloud.kms.v1.MacVerifyRequest.data_crc32c]: crate::model::MacVerifyRequest::data_crc32c
    pub verified_data_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.MacVerifyRequest.mac]. A false value of this
    /// field indicates either that
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.mac]: crate::model::MacVerifyRequest::mac
    /// [google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]: crate::model::MacVerifyRequest::mac_crc32c
    pub verified_mac_crc32c: bool,

    /// Integrity verification field. This value is used for the integrity
    /// verification of [MacVerifyResponse.success]. If the value of this field
    /// contradicts the value of [MacVerifyResponse.success], discard the response
    /// and perform a limited number of retries.
    pub verified_success_integrity: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
    /// verification.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MacVerifyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacVerifyResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [success][crate::model::MacVerifyResponse::success].
    pub fn set_success<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.success = v.into();
        self
    }

    /// Sets the value of [verified_data_crc32c][crate::model::MacVerifyResponse::verified_data_crc32c].
    pub fn set_verified_data_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_data_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_mac_crc32c][crate::model::MacVerifyResponse::verified_mac_crc32c].
    pub fn set_verified_mac_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_mac_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_success_integrity][crate::model::MacVerifyResponse::verified_success_integrity].
    pub fn set_verified_success_integrity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_success_integrity = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::MacVerifyResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for MacVerifyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacVerifyResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MacVerifyResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __success,
            __verified_data_crc32c,
            __verified_mac_crc32c,
            __verified_success_integrity,
            __protection_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MacVerifyResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "success" => Ok(__FieldTag::__success),
                            "verifiedDataCrc32c" => Ok(__FieldTag::__verified_data_crc32c),
                            "verified_data_crc32c" => Ok(__FieldTag::__verified_data_crc32c),
                            "verifiedMacCrc32c" => Ok(__FieldTag::__verified_mac_crc32c),
                            "verified_mac_crc32c" => Ok(__FieldTag::__verified_mac_crc32c),
                            "verifiedSuccessIntegrity" => {
                                Ok(__FieldTag::__verified_success_integrity)
                            }
                            "verified_success_integrity" => {
                                Ok(__FieldTag::__verified_success_integrity)
                            }
                            "protectionLevel" => Ok(__FieldTag::__protection_level),
                            "protection_level" => Ok(__FieldTag::__protection_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MacVerifyResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MacVerifyResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__success => {
                            if !fields.insert(__FieldTag::__success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success",
                                ));
                            }
                            result.success = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_data_crc32c => {
                            if !fields.insert(__FieldTag::__verified_data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_data_crc32c",
                                ));
                            }
                            result.verified_data_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_mac_crc32c => {
                            if !fields.insert(__FieldTag::__verified_mac_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_mac_crc32c",
                                ));
                            }
                            result.verified_mac_crc32c = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verified_success_integrity => {
                            if !fields.insert(__FieldTag::__verified_success_integrity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verified_success_integrity",
                                ));
                            }
                            result.verified_success_integrity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protection_level => {
                            if !fields.insert(__FieldTag::__protection_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protection_level",
                                ));
                            }
                            result.protection_level = map
                                .next_value::<std::option::Option<crate::model::ProtectionLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MacVerifyResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.success) {
            state.serialize_entry("success", &self.success)?;
        }
        if !wkt::internal::is_default(&self.verified_data_crc32c) {
            state.serialize_entry("verifiedDataCrc32c", &self.verified_data_crc32c)?;
        }
        if !wkt::internal::is_default(&self.verified_mac_crc32c) {
            state.serialize_entry("verifiedMacCrc32c", &self.verified_mac_crc32c)?;
        }
        if !wkt::internal::is_default(&self.verified_success_integrity) {
            state.serialize_entry("verifiedSuccessIntegrity", &self.verified_success_integrity)?;
        }
        if !wkt::internal::is_default(&self.protection_level) {
            state.serialize_entry("protectionLevel", &self.protection_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
///
/// [google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes]: crate::client::KeyManagementService::generate_random_bytes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateRandomBytesResponse {
    /// The generated data.
    pub data: ::bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data].
    /// An integrity check of
    /// [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
    /// can be performed by computing the CRC32C checksum of
    /// [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.GenerateRandomBytesResponse.data]: crate::model::GenerateRandomBytesResponse::data
    pub data_crc32c: std::option::Option<wkt::Int64Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateRandomBytesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::GenerateRandomBytesResponse::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::GenerateRandomBytesResponse::data_crc32c].
    pub fn set_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_crc32c][crate::model::GenerateRandomBytesResponse::data_crc32c].
    pub fn set_or_clear_data_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateRandomBytesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GenerateRandomBytesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateRandomBytesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data,
            __data_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateRandomBytesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "data" => Ok(__FieldTag::__data),
                            "dataCrc32c" => Ok(__FieldTag::__data_crc32c),
                            "data_crc32c" => Ok(__FieldTag::__data_crc32c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateRandomBytesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateRandomBytesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_crc32c => {
                            if !fields.insert(__FieldTag::__data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateRandomBytesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if self.data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataCrc32c", &__With(&self.data_crc32c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A [Digest][google.cloud.kms.v1.Digest] holds a cryptographic message digest.
///
/// [google.cloud.kms.v1.Digest]: crate::model::Digest
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Digest {
    /// Required. The message digest.
    pub digest: std::option::Option<crate::model::digest::Digest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Digest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [digest][crate::model::Digest::digest].
    ///
    /// Note that all the setters affecting `digest` are mutually
    /// exclusive.
    pub fn set_digest<T: std::convert::Into<std::option::Option<crate::model::digest::Digest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.digest = v.into();
        self
    }

    /// The value of [digest][crate::model::Digest::digest]
    /// if it holds a `Sha256`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sha256(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.digest.as_ref().and_then(|v| match v {
            crate::model::digest::Digest::Sha256(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [digest][crate::model::Digest::digest]
    /// to hold a `Sha256`.
    ///
    /// Note that all the setters affecting `digest` are
    /// mutually exclusive.
    pub fn set_sha256<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest = std::option::Option::Some(crate::model::digest::Digest::Sha256(v.into()));
        self
    }

    /// The value of [digest][crate::model::Digest::digest]
    /// if it holds a `Sha384`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sha384(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.digest.as_ref().and_then(|v| match v {
            crate::model::digest::Digest::Sha384(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [digest][crate::model::Digest::digest]
    /// to hold a `Sha384`.
    ///
    /// Note that all the setters affecting `digest` are
    /// mutually exclusive.
    pub fn set_sha384<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest = std::option::Option::Some(crate::model::digest::Digest::Sha384(v.into()));
        self
    }

    /// The value of [digest][crate::model::Digest::digest]
    /// if it holds a `Sha512`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sha512(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.digest.as_ref().and_then(|v| match v {
            crate::model::digest::Digest::Sha512(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [digest][crate::model::Digest::digest]
    /// to hold a `Sha512`.
    ///
    /// Note that all the setters affecting `digest` are
    /// mutually exclusive.
    pub fn set_sha512<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest = std::option::Option::Some(crate::model::digest::Digest::Sha512(v.into()));
        self
    }
}

impl wkt::message::Message for Digest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.Digest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Digest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sha256,
            __sha384,
            __sha512,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Digest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sha256" => Ok(__FieldTag::__sha256),
                            "sha384" => Ok(__FieldTag::__sha384),
                            "sha512" => Ok(__FieldTag::__sha512),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Digest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Digest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sha256 => {
                            if !fields.insert(__FieldTag::__sha256) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha256",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.digest.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `digest`, a oneof with full ID .google.cloud.kms.v1.Digest.sha256, latest field was sha256",
                                ));
                            }
                            result.digest =
                                std::option::Option::Some(crate::model::digest::Digest::Sha256(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__sha384 => {
                            if !fields.insert(__FieldTag::__sha384) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha384",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.digest.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `digest`, a oneof with full ID .google.cloud.kms.v1.Digest.sha384, latest field was sha384",
                                ));
                            }
                            result.digest =
                                std::option::Option::Some(crate::model::digest::Digest::Sha384(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__sha512 => {
                            if !fields.insert(__FieldTag::__sha512) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha512",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.digest.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `digest`, a oneof with full ID .google.cloud.kms.v1.Digest.sha512, latest field was sha512",
                                ));
                            }
                            result.digest =
                                std::option::Option::Some(crate::model::digest::Digest::Sha512(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Digest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.sha256() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sha256", &__With(value))?;
        }
        if let Some(value) = self.sha384() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sha384", &__With(value))?;
        }
        if let Some(value) = self.sha512() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sha512", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Digest].
pub mod digest {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The message digest.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Digest {
        /// A message digest produced with the SHA-256 algorithm.
        Sha256(::bytes::Bytes),
        /// A message digest produced with the SHA-384 algorithm.
        Sha384(::bytes::Bytes),
        /// A message digest produced with the SHA-512 algorithm.
        Sha512(::bytes::Bytes),
    }
}

/// Cloud KMS metadata for the given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] can be created in this
    /// location.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::ProtectionLevel::Hsm
    pub hsm_available: bool,

    /// Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] can be created in
    /// this location.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::ProtectionLevel::External
    pub ekm_available: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hsm_available][crate::model::LocationMetadata::hsm_available].
    pub fn set_hsm_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hsm_available = v.into();
        self
    }

    /// Sets the value of [ekm_available][crate::model::LocationMetadata::ekm_available].
    pub fn set_ekm_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ekm_available = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hsm_available,
            __ekm_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hsmAvailable" => Ok(__FieldTag::__hsm_available),
                            "hsm_available" => Ok(__FieldTag::__hsm_available),
                            "ekmAvailable" => Ok(__FieldTag::__ekm_available),
                            "ekm_available" => Ok(__FieldTag::__ekm_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hsm_available => {
                            if !fields.insert(__FieldTag::__hsm_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hsm_available",
                                ));
                            }
                            result.hsm_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ekm_available => {
                            if !fields.insert(__FieldTag::__ekm_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_available",
                                ));
                            }
                            result.ekm_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.hsm_available) {
            state.serialize_entry("hsmAvailable", &self.hsm_available)?;
        }
        if !wkt::internal::is_default(&self.ekm_available) {
            state.serialize_entry("ekmAvailable", &self.ekm_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] specifies how
/// cryptographic operations are performed. For more information, see [Protection
/// levels] (<https://cloud.google.com/kms/docs/algorithms#protection_levels>).
///
/// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ProtectionLevel {
    /// Not specified.
    Unspecified,
    /// Crypto operations are performed in software.
    Software,
    /// Crypto operations are performed in a Hardware Security Module.
    Hsm,
    /// Crypto operations are performed by an external key manager.
    External,
    /// Crypto operations are performed in an EKM-over-VPC backend.
    ExternalVpc,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ProtectionLevel::value] or
    /// [ProtectionLevel::name].
    UnknownValue(protection_level::UnknownValue),
}

#[doc(hidden)]
pub mod protection_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ProtectionLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Software => std::option::Option::Some(1),
            Self::Hsm => std::option::Option::Some(2),
            Self::External => std::option::Option::Some(3),
            Self::ExternalVpc => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PROTECTION_LEVEL_UNSPECIFIED"),
            Self::Software => std::option::Option::Some("SOFTWARE"),
            Self::Hsm => std::option::Option::Some("HSM"),
            Self::External => std::option::Option::Some("EXTERNAL"),
            Self::ExternalVpc => std::option::Option::Some("EXTERNAL_VPC"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ProtectionLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ProtectionLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ProtectionLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Software,
            2 => Self::Hsm,
            3 => Self::External,
            4 => Self::ExternalVpc,
            _ => Self::UnknownValue(protection_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ProtectionLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PROTECTION_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "SOFTWARE" => Self::Software,
            "HSM" => Self::Hsm,
            "EXTERNAL" => Self::External,
            "EXTERNAL_VPC" => Self::ExternalVpc,
            _ => Self::UnknownValue(protection_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ProtectionLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Software => serializer.serialize_i32(1),
            Self::Hsm => serializer.serialize_i32(2),
            Self::External => serializer.serialize_i32(3),
            Self::ExternalVpc => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ProtectionLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProtectionLevel>::new(
            ".google.cloud.kms.v1.ProtectionLevel",
        ))
    }
}

/// Describes the reason for a data access. Please refer to
/// <https://cloud.google.com/assured-workloads/key-access-justifications/docs/justification-codes>
/// for the detailed semantic meaning of justification reason codes.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AccessReason {
    /// Unspecified access reason.
    ReasonUnspecified,
    /// Customer-initiated support.
    CustomerInitiatedSupport,
    /// Google-initiated access for system management and troubleshooting.
    GoogleInitiatedService,
    /// Google-initiated access in response to a legal request or legal process.
    ThirdPartyDataRequest,
    /// Google-initiated access for security, fraud, abuse, or compliance purposes.
    GoogleInitiatedReview,
    /// Customer uses their account to perform any access to their own data which
    /// their IAM policy authorizes.
    CustomerInitiatedAccess,
    /// Google systems access customer data to help optimize the structure of the
    /// data or quality for future uses by the customer.
    GoogleInitiatedSystemOperation,
    /// No reason is expected for this key request.
    ReasonNotExpected,
    /// Customer uses their account to perform any access to their own data which
    /// their IAM policy authorizes, and one of the following is true:
    ///
    /// * A Google administrator has reset the root-access account associated with
    ///   the user's organization within the past 7 days.
    /// * A Google-initiated emergency access operation has interacted with a
    ///   resource in the same project or folder as the currently accessed resource
    ///   within the past 7 days.
    ModifiedCustomerInitiatedAccess,
    /// Google systems access customer data to help optimize the structure of the
    /// data or quality for future uses by the customer, and one of the following
    /// is true:
    ///
    /// * A Google administrator has reset the root-access account associated with
    ///   the user's organization within the past 7 days.
    /// * A Google-initiated emergency access operation has interacted with a
    ///   resource in the same project or folder as the currently accessed resource
    ///   within the past 7 days.
    ModifiedGoogleInitiatedSystemOperation,
    /// Google-initiated access to maintain system reliability.
    GoogleResponseToProductionAlert,
    /// One of the following operations is being executed while simultaneously
    /// encountering an internal technical issue which prevented a more precise
    /// justification code from being generated:
    ///
    /// * Your account has been used to perform any access to your own data which
    ///   your IAM policy authorizes.
    /// * An automated Google system operates on encrypted customer data which your
    ///   IAM policy authorizes.
    /// * Customer-initiated Google support access.
    /// * Google-initiated support access to protect system reliability.
    CustomerAuthorizedWorkflowServicing,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AccessReason::value] or
    /// [AccessReason::name].
    UnknownValue(access_reason::UnknownValue),
}

#[doc(hidden)]
pub mod access_reason {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AccessReason {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ReasonUnspecified => std::option::Option::Some(0),
            Self::CustomerInitiatedSupport => std::option::Option::Some(1),
            Self::GoogleInitiatedService => std::option::Option::Some(2),
            Self::ThirdPartyDataRequest => std::option::Option::Some(3),
            Self::GoogleInitiatedReview => std::option::Option::Some(4),
            Self::CustomerInitiatedAccess => std::option::Option::Some(5),
            Self::GoogleInitiatedSystemOperation => std::option::Option::Some(6),
            Self::ReasonNotExpected => std::option::Option::Some(7),
            Self::ModifiedCustomerInitiatedAccess => std::option::Option::Some(8),
            Self::ModifiedGoogleInitiatedSystemOperation => std::option::Option::Some(9),
            Self::GoogleResponseToProductionAlert => std::option::Option::Some(10),
            Self::CustomerAuthorizedWorkflowServicing => std::option::Option::Some(11),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ReasonUnspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
            Self::CustomerInitiatedSupport => {
                std::option::Option::Some("CUSTOMER_INITIATED_SUPPORT")
            }
            Self::GoogleInitiatedService => std::option::Option::Some("GOOGLE_INITIATED_SERVICE"),
            Self::ThirdPartyDataRequest => std::option::Option::Some("THIRD_PARTY_DATA_REQUEST"),
            Self::GoogleInitiatedReview => std::option::Option::Some("GOOGLE_INITIATED_REVIEW"),
            Self::CustomerInitiatedAccess => std::option::Option::Some("CUSTOMER_INITIATED_ACCESS"),
            Self::GoogleInitiatedSystemOperation => {
                std::option::Option::Some("GOOGLE_INITIATED_SYSTEM_OPERATION")
            }
            Self::ReasonNotExpected => std::option::Option::Some("REASON_NOT_EXPECTED"),
            Self::ModifiedCustomerInitiatedAccess => {
                std::option::Option::Some("MODIFIED_CUSTOMER_INITIATED_ACCESS")
            }
            Self::ModifiedGoogleInitiatedSystemOperation => {
                std::option::Option::Some("MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION")
            }
            Self::GoogleResponseToProductionAlert => {
                std::option::Option::Some("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT")
            }
            Self::CustomerAuthorizedWorkflowServicing => {
                std::option::Option::Some("CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AccessReason {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AccessReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AccessReason {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ReasonUnspecified,
            1 => Self::CustomerInitiatedSupport,
            2 => Self::GoogleInitiatedService,
            3 => Self::ThirdPartyDataRequest,
            4 => Self::GoogleInitiatedReview,
            5 => Self::CustomerInitiatedAccess,
            6 => Self::GoogleInitiatedSystemOperation,
            7 => Self::ReasonNotExpected,
            8 => Self::ModifiedCustomerInitiatedAccess,
            9 => Self::ModifiedGoogleInitiatedSystemOperation,
            10 => Self::GoogleResponseToProductionAlert,
            11 => Self::CustomerAuthorizedWorkflowServicing,
            _ => Self::UnknownValue(access_reason::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AccessReason {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REASON_UNSPECIFIED" => Self::ReasonUnspecified,
            "CUSTOMER_INITIATED_SUPPORT" => Self::CustomerInitiatedSupport,
            "GOOGLE_INITIATED_SERVICE" => Self::GoogleInitiatedService,
            "THIRD_PARTY_DATA_REQUEST" => Self::ThirdPartyDataRequest,
            "GOOGLE_INITIATED_REVIEW" => Self::GoogleInitiatedReview,
            "CUSTOMER_INITIATED_ACCESS" => Self::CustomerInitiatedAccess,
            "GOOGLE_INITIATED_SYSTEM_OPERATION" => Self::GoogleInitiatedSystemOperation,
            "REASON_NOT_EXPECTED" => Self::ReasonNotExpected,
            "MODIFIED_CUSTOMER_INITIATED_ACCESS" => Self::ModifiedCustomerInitiatedAccess,
            "MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION" => {
                Self::ModifiedGoogleInitiatedSystemOperation
            }
            "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" => Self::GoogleResponseToProductionAlert,
            "CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING" => Self::CustomerAuthorizedWorkflowServicing,
            _ => Self::UnknownValue(access_reason::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AccessReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ReasonUnspecified => serializer.serialize_i32(0),
            Self::CustomerInitiatedSupport => serializer.serialize_i32(1),
            Self::GoogleInitiatedService => serializer.serialize_i32(2),
            Self::ThirdPartyDataRequest => serializer.serialize_i32(3),
            Self::GoogleInitiatedReview => serializer.serialize_i32(4),
            Self::CustomerInitiatedAccess => serializer.serialize_i32(5),
            Self::GoogleInitiatedSystemOperation => serializer.serialize_i32(6),
            Self::ReasonNotExpected => serializer.serialize_i32(7),
            Self::ModifiedCustomerInitiatedAccess => serializer.serialize_i32(8),
            Self::ModifiedGoogleInitiatedSystemOperation => serializer.serialize_i32(9),
            Self::GoogleResponseToProductionAlert => serializer.serialize_i32(10),
            Self::CustomerAuthorizedWorkflowServicing => serializer.serialize_i32(11),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AccessReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessReason>::new(
            ".google.cloud.kms.v1.AccessReason",
        ))
    }
}
