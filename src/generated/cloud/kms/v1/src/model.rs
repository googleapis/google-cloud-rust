// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [Autokey.CreateKeyHandle][google.cloud.kms.v1.Autokey.CreateKeyHandle].
///
/// [google.cloud.kms.v1.Autokey.CreateKeyHandle]: crate::client::Autokey::create_key_handle
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateKeyHandleRequest {
    /// Required. Name of the resource project and location to create the
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] in, e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Id of the [KeyHandle][google.cloud.kms.v1.KeyHandle]. Must be
    /// unique to the resource project and location. If not provided by the caller,
    /// a new UUID is used.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_handle_id: std::string::String,

    /// Required. [KeyHandle][google.cloud.kms.v1.KeyHandle] to create.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key_handle: std::option::Option<crate::model::KeyHandle>,
}

impl CreateKeyHandleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyHandleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key_handle_id][crate::model::CreateKeyHandleRequest::key_handle_id].
    pub fn set_key_handle_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_handle_id = v.into();
        self
    }

    /// Sets the value of [key_handle][crate::model::CreateKeyHandleRequest::key_handle].
    pub fn set_key_handle<T: std::convert::Into<std::option::Option<crate::model::KeyHandle>>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_handle = v.into();
        self
    }
}

impl wkt::message::Message for CreateKeyHandleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateKeyHandleRequest"
    }
}

/// Request message for [GetKeyHandle][google.cloud.kms.v1.Autokey.GetKeyHandle].
///
/// [google.cloud.kms.v1.Autokey.GetKeyHandle]: crate::client::Autokey::get_key_handle
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetKeyHandleRequest {
    /// Required. Name of the [KeyHandle][google.cloud.kms.v1.KeyHandle] resource,
    /// e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/keyHandles/{KEY_HANDLE_ID}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetKeyHandleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyHandleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyHandleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetKeyHandleRequest"
    }
}

/// Resource-oriented representation of a request to Cloud KMS Autokey and the
/// resulting provisioning of a [CryptoKey][google.cloud.kms.v1.CryptoKey].
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KeyHandle {
    /// Identifier. Name of the [KeyHandle][google.cloud.kms.v1.KeyHandle]
    /// resource, e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}/keyHandles/{KEY_HANDLE_ID}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Name of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that has
    /// been provisioned for Customer Managed Encryption Key (CMEK) use in the
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] project and location for the
    /// requested resource type. The [CryptoKey][google.cloud.kms.v1.CryptoKey]
    /// project will reflect the value configured in the
    /// [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] on the resource
    /// project's ancestor folder at the time of the
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] creation. If more than one
    /// ancestor folder has a configured
    /// [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig], the nearest of these
    /// configurations is used.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Required. Indicates the resource type that the resulting
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] is meant to protect, e.g.
    /// `{SERVICE}.googleapis.com/{TYPE}`. See documentation for supported resource
    /// types.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_type_selector: std::string::String,
}

impl KeyHandle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KeyHandle::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::KeyHandle::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [resource_type_selector][crate::model::KeyHandle::resource_type_selector].
    pub fn set_resource_type_selector<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type_selector = v.into();
        self
    }
}

impl wkt::message::Message for KeyHandle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyHandle"
    }
}

/// Metadata message for
/// [CreateKeyHandle][google.cloud.kms.v1.Autokey.CreateKeyHandle] long-running
/// operation response.
///
/// [google.cloud.kms.v1.Autokey.CreateKeyHandle]: crate::client::Autokey::create_key_handle
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateKeyHandleMetadata {}

impl CreateKeyHandleMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateKeyHandleMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateKeyHandleMetadata"
    }
}

/// Request message for
/// [Autokey.ListKeyHandles][google.cloud.kms.v1.Autokey.ListKeyHandles].
///
/// [google.cloud.kms.v1.Autokey.ListKeyHandles]: crate::client::Autokey::list_key_handles
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKeyHandlesRequest {
    /// Required. Name of the resource project and location from which to list
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle], e.g.
    /// `projects/{PROJECT_ID}/locations/{LOCATION}`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle] to include in the response. The
    /// service may return fewer than this value. Further
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle] can subsequently be obtained by
    /// including the
    /// [ListKeyHandlesResponse.next_page_token][google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token]
    /// in a subsequent request.  If unspecified, at most 100
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle] will be returned.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    /// [google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token]: crate::model::ListKeyHandlesResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListKeyHandlesResponse.next_page_token][google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListKeyHandlesResponse.next_page_token]: crate::model::ListKeyHandlesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter to apply when listing
    /// [KeyHandles][google.cloud.kms.v1.KeyHandle], e.g.
    /// `resource_type_selector="{SERVICE}.googleapis.com/{TYPE}"`.
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListKeyHandlesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeyHandlesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeyHandlesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeyHandlesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKeyHandlesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListKeyHandlesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyHandlesRequest"
    }
}

/// Response message for
/// [Autokey.ListKeyHandles][google.cloud.kms.v1.Autokey.ListKeyHandles].
///
/// [google.cloud.kms.v1.Autokey.ListKeyHandles]: crate::client::Autokey::list_key_handles
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKeyHandlesResponse {
    /// Resulting [KeyHandles][google.cloud.kms.v1.KeyHandle].
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub key_handles: std::vec::Vec<crate::model::KeyHandle>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListKeyHandlesRequest.page_token][google.cloud.kms.v1.ListKeyHandlesRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListKeyHandlesRequest.page_token]: crate::model::ListKeyHandlesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListKeyHandlesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListKeyHandlesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [key_handles][crate::model::ListKeyHandlesResponse::key_handles].
    pub fn set_key_handles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KeyHandle>,
    {
        use std::iter::Iterator;
        self.key_handles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListKeyHandlesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyHandlesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListKeyHandlesResponse {
    type PageItem = crate::model::KeyHandle;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.key_handles
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]: crate::client::AutokeyAdmin::update_autokey_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAutokeyConfigRequest {
    /// Required. [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] with values to
    /// update.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autokey_config: std::option::Option<crate::model::AutokeyConfig>,

    /// Required. Masks which fields of the
    /// [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] to update, e.g.
    /// `keyProject`.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateAutokeyConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [autokey_config][crate::model::UpdateAutokeyConfigRequest::autokey_config].
    pub fn set_autokey_config<
        T: std::convert::Into<std::option::Option<crate::model::AutokeyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autokey_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAutokeyConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAutokeyConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateAutokeyConfigRequest"
    }
}

/// Request message for
/// [GetAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.GetAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.GetAutokeyConfig]: crate::client::AutokeyAdmin::get_autokey_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAutokeyConfigRequest {
    /// Required. Name of the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig]
    /// resource, e.g. `folders/{FOLDER_NUMBER}/autokeyConfig`.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAutokeyConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutokeyConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutokeyConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetAutokeyConfigRequest"
    }
}

/// Cloud KMS Autokey configuration for a folder.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutokeyConfig {
    /// Identifier. Name of the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig]
    /// resource, e.g. `folders/{FOLDER_NUMBER}/autokeyConfig`.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Name of the key project, e.g. `projects/{PROJECT_ID}` or
    /// `projects/{PROJECT_NUMBER}`, where Cloud KMS Autokey will provision a new
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] when a
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] is created. On
    /// [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig],
    /// the caller will require `cloudkms.cryptoKeys.setIamPolicy` permission on
    /// this key project. Once configured, for Cloud KMS Autokey to function
    /// properly, this key project must have the Cloud KMS API activated and the
    /// Cloud KMS Service Agent for this key project must be granted the
    /// `cloudkms.admin` role (or pertinent permissions). A request with an empty
    /// key project field will clear the configuration.
    ///
    /// [google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]: crate::client::AutokeyAdmin::update_autokey_config
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_project: std::string::String,

    /// Output only. The state for the AutokeyConfig.
    pub state: crate::model::autokey_config::State,
}

impl AutokeyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutokeyConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [key_project][crate::model::AutokeyConfig::key_project].
    pub fn set_key_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_project = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutokeyConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::autokey_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for AutokeyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AutokeyConfig"
    }
}

/// Defines additional types related to AutokeyConfig
pub mod autokey_config {
    #[allow(unused_imports)]
    use super::*;

    /// The states AutokeyConfig can be in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The state of the AutokeyConfig is unspecified.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The AutokeyConfig is currently active.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// A previously configured key project has been deleted and the current
        /// AutokeyConfig is unusable.
        pub const KEY_PROJECT_DELETED: State = State::new("KEY_PROJECT_DELETED");

        /// The AutokeyConfig is not yet initialized or has been reset to its default
        /// uninitialized state.
        pub const UNINITIALIZED: State = State::new("UNINITIALIZED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }
}

/// Request message for
/// [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig]: crate::client::AutokeyAdmin::show_effective_autokey_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShowEffectiveAutokeyConfigRequest {
    /// Required. Name of the resource project to the show effective Cloud KMS
    /// Autokey configuration for. This may be helpful for interrogating the effect
    /// of nested folder configurations on a given resource project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,
}

impl ShowEffectiveAutokeyConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ShowEffectiveAutokeyConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ShowEffectiveAutokeyConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ShowEffectiveAutokeyConfigRequest"
    }
}

/// Response message for
/// [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig]: crate::client::AutokeyAdmin::show_effective_autokey_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShowEffectiveAutokeyConfigResponse {
    /// Name of the key project configured in the resource project's folder
    /// ancestry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_project: std::string::String,
}

impl ShowEffectiveAutokeyConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_project][crate::model::ShowEffectiveAutokeyConfigResponse::key_project].
    pub fn set_key_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_project = v.into();
        self
    }
}

impl wkt::message::Message for ShowEffectiveAutokeyConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ShowEffectiveAutokeyConfigResponse"
    }
}

/// Request message for
/// [EkmService.ListEkmConnections][google.cloud.kms.v1.EkmService.ListEkmConnections].
///
/// [google.cloud.kms.v1.EkmService.ListEkmConnections]: crate::client::EkmService::list_ekm_connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEkmConnectionsRequest {
    /// Required. The resource name of the location associated with the
    /// [EkmConnections][google.cloud.kms.v1.EkmConnection] to list, in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [EkmConnections][google.cloud.kms.v1.EkmConnection] to include in the
    /// response. Further [EkmConnections][google.cloud.kms.v1.EkmConnection] can
    /// subsequently be obtained by including the
    /// [ListEkmConnectionsResponse.next_page_token][google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]: crate::model::ListEkmConnectionsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListEkmConnectionsResponse.next_page_token][google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]: crate::model::ListEkmConnectionsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order.  For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListEkmConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEkmConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEkmConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEkmConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEkmConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEkmConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEkmConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListEkmConnectionsRequest"
    }
}

/// Response message for
/// [EkmService.ListEkmConnections][google.cloud.kms.v1.EkmService.ListEkmConnections].
///
/// [google.cloud.kms.v1.EkmService.ListEkmConnections]: crate::client::EkmService::list_ekm_connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEkmConnectionsResponse {
    /// The list of [EkmConnections][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ekm_connections: std::vec::Vec<crate::model::EkmConnection>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListEkmConnectionsRequest.page_token][google.cloud.kms.v1.ListEkmConnectionsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListEkmConnectionsRequest.page_token]: crate::model::ListEkmConnectionsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of [EkmConnections][google.cloud.kms.v1.EkmConnection]
    /// that matched the query.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    pub total_size: i32,
}

impl ListEkmConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEkmConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListEkmConnectionsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [ekm_connections][crate::model::ListEkmConnectionsResponse::ekm_connections].
    pub fn set_ekm_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmConnection>,
    {
        use std::iter::Iterator;
        self.ekm_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEkmConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListEkmConnectionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEkmConnectionsResponse {
    type PageItem = crate::model::EkmConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ekm_connections
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [EkmService.GetEkmConnection][google.cloud.kms.v1.EkmService.GetEkmConnection].
///
/// [google.cloud.kms.v1.EkmService.GetEkmConnection]: crate::client::EkmService::get_ekm_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEkmConnectionRequest {
    /// Required. The [name][google.cloud.kms.v1.EkmConnection.name] of the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] to get.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.name]: crate::model::EkmConnection::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEkmConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetEkmConnectionRequest"
    }
}

/// Request message for
/// [EkmService.CreateEkmConnection][google.cloud.kms.v1.EkmService.CreateEkmConnection].
///
/// [google.cloud.kms.v1.EkmService.CreateEkmConnection]: crate::client::EkmService::create_ekm_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEkmConnectionRequest {
    /// Required. The resource name of the location associated with the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ekm_connection_id: std::string::String,

    /// Required. An [EkmConnection][google.cloud.kms.v1.EkmConnection] with
    /// initial field values.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ekm_connection: std::option::Option<crate::model::EkmConnection>,
}

impl CreateEkmConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEkmConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [ekm_connection_id][crate::model::CreateEkmConnectionRequest::ekm_connection_id].
    pub fn set_ekm_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_connection_id = v.into();
        self
    }

    /// Sets the value of [ekm_connection][crate::model::CreateEkmConnectionRequest::ekm_connection].
    pub fn set_ekm_connection<
        T: std::convert::Into<std::option::Option<crate::model::EkmConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_connection = v.into();
        self
    }
}

impl wkt::message::Message for CreateEkmConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateEkmConnectionRequest"
    }
}

/// Request message for
/// [EkmService.UpdateEkmConnection][google.cloud.kms.v1.EkmService.UpdateEkmConnection].
///
/// [google.cloud.kms.v1.EkmService.UpdateEkmConnection]: crate::client::EkmService::update_ekm_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEkmConnectionRequest {
    /// Required. [EkmConnection][google.cloud.kms.v1.EkmConnection] with updated
    /// values.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ekm_connection: std::option::Option<crate::model::EkmConnection>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEkmConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_connection][crate::model::UpdateEkmConnectionRequest::ekm_connection].
    pub fn set_ekm_connection<
        T: std::convert::Into<std::option::Option<crate::model::EkmConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_connection = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEkmConnectionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEkmConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateEkmConnectionRequest"
    }
}

/// Request message for
/// [EkmService.GetEkmConfig][google.cloud.kms.v1.EkmService.GetEkmConfig].
///
/// [google.cloud.kms.v1.EkmService.GetEkmConfig]: crate::client::EkmService::get_ekm_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEkmConfigRequest {
    /// Required. The [name][google.cloud.kms.v1.EkmConfig.name] of the
    /// [EkmConfig][google.cloud.kms.v1.EkmConfig] to get.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    /// [google.cloud.kms.v1.EkmConfig.name]: crate::model::EkmConfig::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEkmConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetEkmConfigRequest"
    }
}

/// Request message for
/// [EkmService.UpdateEkmConfig][google.cloud.kms.v1.EkmService.UpdateEkmConfig].
///
/// [google.cloud.kms.v1.EkmService.UpdateEkmConfig]: crate::client::EkmService::update_ekm_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEkmConfigRequest {
    /// Required. [EkmConfig][google.cloud.kms.v1.EkmConfig] with updated values.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ekm_config: std::option::Option<crate::model::EkmConfig>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEkmConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_config][crate::model::UpdateEkmConfigRequest::ekm_config].
    pub fn set_ekm_config<T: std::convert::Into<std::option::Option<crate::model::EkmConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEkmConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEkmConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateEkmConfigRequest"
    }
}

/// A [Certificate][google.cloud.kms.v1.Certificate] represents an X.509
/// certificate used to authenticate HTTPS connections to EKM replicas.
///
/// [google.cloud.kms.v1.Certificate]: crate::model::Certificate
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Certificate {
    /// Required. The raw certificate bytes in DER format.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub raw_der: bytes::Bytes,

    /// Output only. True if the certificate was parsed successfully.
    pub parsed: bool,

    /// Output only. The issuer distinguished name in RFC 2253 format. Only present
    /// if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issuer: std::string::String,

    /// Output only. The subject distinguished name in RFC 2253 format. Only
    /// present if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject: std::string::String,

    /// Output only. The subject Alternative DNS names. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject_alternative_dns_names: std::vec::Vec<std::string::String>,

    /// Output only. The certificate is not valid before this time. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub not_before_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The certificate is not valid after this time. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub not_after_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The certificate serial number as a hex string. Only present if
    /// [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serial_number: std::string::String,

    /// Output only. The SHA-256 certificate fingerprint as a hex string. Only
    /// present if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
    ///
    /// [google.cloud.kms.v1.Certificate.parsed]: crate::model::Certificate::parsed
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha256_fingerprint: std::string::String,
}

impl Certificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [raw_der][crate::model::Certificate::raw_der].
    pub fn set_raw_der<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.raw_der = v.into();
        self
    }

    /// Sets the value of [parsed][crate::model::Certificate::parsed].
    pub fn set_parsed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.parsed = v.into();
        self
    }

    /// Sets the value of [issuer][crate::model::Certificate::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::Certificate::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [not_before_time][crate::model::Certificate::not_before_time].
    pub fn set_not_before_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.not_before_time = v.into();
        self
    }

    /// Sets the value of [not_after_time][crate::model::Certificate::not_after_time].
    pub fn set_not_after_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.not_after_time = v.into();
        self
    }

    /// Sets the value of [serial_number][crate::model::Certificate::serial_number].
    pub fn set_serial_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serial_number = v.into();
        self
    }

    /// Sets the value of [sha256_fingerprint][crate::model::Certificate::sha256_fingerprint].
    pub fn set_sha256_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sha256_fingerprint = v.into();
        self
    }

    /// Sets the value of [subject_alternative_dns_names][crate::model::Certificate::subject_alternative_dns_names].
    pub fn set_subject_alternative_dns_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_alternative_dns_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Certificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.Certificate"
    }
}

/// An [EkmConnection][google.cloud.kms.v1.EkmConnection] represents an
/// individual EKM connection. It can be used for creating
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] with a
/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
/// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC], as well as
/// performing cryptographic operations using keys created within the
/// [EkmConnection][google.cloud.kms.v1.EkmConnection].
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
/// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnection {
    /// Output only. The resource name for the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] in the format
    /// `projects/*/locations/*/ekmConnections/*`.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time at which the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] was created.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A list of
    /// [ServiceResolvers][google.cloud.kms.v1.EkmConnection.ServiceResolver] where
    /// the EKM can be reached. There should be one ServiceResolver per EKM
    /// replica. Currently, only a single
    /// [ServiceResolver][google.cloud.kms.v1.EkmConnection.ServiceResolver] is
    /// supported.
    ///
    /// [google.cloud.kms.v1.EkmConnection.ServiceResolver]: crate::model::ekm_connection::ServiceResolver
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_resolvers: std::vec::Vec<crate::model::ekm_connection::ServiceResolver>,

    /// Optional. Etag of the currently stored
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Describes who can perform control plane operations on the EKM. If
    /// unset, this defaults to
    /// [MANUAL][google.cloud.kms.v1.EkmConnection.KeyManagementMode.MANUAL].
    ///
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode.MANUAL]: crate::model::ekm_connection::key_management_mode::MANUAL
    pub key_management_mode: crate::model::ekm_connection::KeyManagementMode,

    /// Optional. Identifies the EKM Crypto Space that this
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] maps to. Note: This
    /// field is required if
    /// [KeyManagementMode][google.cloud.kms.v1.EkmConnection.KeyManagementMode] is
    /// [CLOUD_KMS][google.cloud.kms.v1.EkmConnection.KeyManagementMode.CLOUD_KMS].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode]: crate::model::ekm_connection::KeyManagementMode
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode.CLOUD_KMS]: crate::model::ekm_connection::key_management_mode::CLOUD_KMS
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_space_path: std::string::String,
}

impl EkmConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EkmConnection::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::EkmConnection::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [key_management_mode][crate::model::EkmConnection::key_management_mode].
    pub fn set_key_management_mode<
        T: std::convert::Into<crate::model::ekm_connection::KeyManagementMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_management_mode = v.into();
        self
    }

    /// Sets the value of [crypto_space_path][crate::model::EkmConnection::crypto_space_path].
    pub fn set_crypto_space_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_space_path = v.into();
        self
    }

    /// Sets the value of [service_resolvers][crate::model::EkmConnection::service_resolvers].
    pub fn set_service_resolvers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ekm_connection::ServiceResolver>,
    {
        use std::iter::Iterator;
        self.service_resolvers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EkmConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EkmConnection"
    }
}

/// Defines additional types related to EkmConnection
pub mod ekm_connection {
    #[allow(unused_imports)]
    use super::*;

    /// A [ServiceResolver][google.cloud.kms.v1.EkmConnection.ServiceResolver]
    /// represents an EKM replica that can be reached within an
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.ServiceResolver]: crate::model::ekm_connection::ServiceResolver
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ServiceResolver {
        /// Required. The resource name of the Service Directory service pointing to
        /// an EKM replica, in the format
        /// `projects/*/locations/*/namespaces/*/services/*`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_directory_service: std::string::String,

        /// Optional. The filter applied to the endpoints of the resolved service. If
        /// no filter is specified, all endpoints will be considered. An endpoint
        /// will be chosen arbitrarily from the filtered list for each request.
        ///
        /// For endpoint filter syntax and examples, see
        /// <https://cloud.google.com/service-directory/docs/reference/rpc/google.cloud.servicedirectory.v1#resolveservicerequest>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint_filter: std::string::String,

        /// Required. The hostname of the EKM replica used at TLS and HTTP layers.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub hostname: std::string::String,

        /// Required. A list of leaf server certificates used to authenticate HTTPS
        /// connections to the EKM replica. Currently, a maximum of 10
        /// [Certificate][google.cloud.kms.v1.Certificate] is supported.
        ///
        /// [google.cloud.kms.v1.Certificate]: crate::model::Certificate
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub server_certificates: std::vec::Vec<crate::model::Certificate>,
    }

    impl ServiceResolver {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_directory_service][crate::model::ekm_connection::ServiceResolver::service_directory_service].
        pub fn set_service_directory_service<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_directory_service = v.into();
            self
        }

        /// Sets the value of [endpoint_filter][crate::model::ekm_connection::ServiceResolver::endpoint_filter].
        pub fn set_endpoint_filter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.endpoint_filter = v.into();
            self
        }

        /// Sets the value of [hostname][crate::model::ekm_connection::ServiceResolver::hostname].
        pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.hostname = v.into();
            self
        }

        /// Sets the value of [server_certificates][crate::model::ekm_connection::ServiceResolver::server_certificates].
        pub fn set_server_certificates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Certificate>,
        {
            use std::iter::Iterator;
            self.server_certificates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ServiceResolver {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.kms.v1.EkmConnection.ServiceResolver"
        }
    }

    /// [KeyManagementMode][google.cloud.kms.v1.EkmConnection.KeyManagementMode]
    /// describes who can perform control plane cryptographic operations using this
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.KeyManagementMode]: crate::model::ekm_connection::KeyManagementMode
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct KeyManagementMode(std::borrow::Cow<'static, str>);

    impl KeyManagementMode {
        /// Creates a new KeyManagementMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [KeyManagementMode](KeyManagementMode)
    pub mod key_management_mode {
        use super::KeyManagementMode;

        /// Not specified.
        pub const KEY_MANAGEMENT_MODE_UNSPECIFIED: KeyManagementMode =
            KeyManagementMode::new("KEY_MANAGEMENT_MODE_UNSPECIFIED");

        /// EKM-side key management operations on
        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] created with this
        /// [EkmConnection][google.cloud.kms.v1.EkmConnection] must be initiated from
        /// the EKM directly and cannot be performed from Cloud KMS. This means that:
        ///
        /// * When creating a
        ///   [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] associated with
        ///   this
        ///   [EkmConnection][google.cloud.kms.v1.EkmConnection], the caller must
        ///   supply the key path of pre-existing external key material that will be
        ///   linked to the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
        /// * Destruction of external key material cannot be requested via the
        ///   Cloud KMS API and must be performed directly in the EKM.
        /// * Automatic rotation of key material is not supported.
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
        pub const MANUAL: KeyManagementMode = KeyManagementMode::new("MANUAL");

        /// All [CryptoKeys][google.cloud.kms.v1.CryptoKey] created with this
        /// [EkmConnection][google.cloud.kms.v1.EkmConnection] use EKM-side key
        /// management operations initiated from Cloud KMS. This means that:
        ///
        /// * When a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
        ///   associated with this [EkmConnection][google.cloud.kms.v1.EkmConnection]
        ///   is
        ///   created, the EKM automatically generates new key material and a new
        ///   key path. The caller cannot supply the key path of pre-existing
        ///   external key material.
        /// * Destruction of external key material associated with this
        ///   [EkmConnection][google.cloud.kms.v1.EkmConnection] can be requested by
        ///   calling
        ///   [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
        /// * Automatic rotation of key material is supported.
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
        /// [google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]: crate::client::KeyManagementService::destroy_crypto_key_version
        pub const CLOUD_KMS: KeyManagementMode = KeyManagementMode::new("CLOUD_KMS");
    }

    impl std::convert::From<std::string::String> for KeyManagementMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for KeyManagementMode {
        fn default() -> Self {
            key_management_mode::KEY_MANAGEMENT_MODE_UNSPECIFIED
        }
    }
}

/// An [EkmConfig][google.cloud.kms.v1.EkmConfig] is a singleton resource that
/// represents configuration parameters that apply to all
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] with a
/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
/// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] in a given
/// project and location.
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
/// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConfig {
    /// Output only. The resource name for the
    /// [EkmConfig][google.cloud.kms.v1.EkmConfig] in the format
    /// `projects/*/locations/*/ekmConfig`.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Resource name of the default
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection]. Setting this field to
    /// the empty string removes the default.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_ekm_connection: std::string::String,
}

impl EkmConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [default_ekm_connection][crate::model::EkmConfig::default_ekm_connection].
    pub fn set_default_ekm_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_ekm_connection = v.into();
        self
    }
}

impl wkt::message::Message for EkmConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EkmConfig"
    }
}

/// Request message for
/// [EkmService.VerifyConnectivity][google.cloud.kms.v1.EkmService.VerifyConnectivity].
///
/// [google.cloud.kms.v1.EkmService.VerifyConnectivity]: crate::client::EkmService::verify_connectivity
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyConnectivityRequest {
    /// Required. The [name][google.cloud.kms.v1.EkmConnection.name] of the
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] to verify.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    /// [google.cloud.kms.v1.EkmConnection.name]: crate::model::EkmConnection::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl VerifyConnectivityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyConnectivityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for VerifyConnectivityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.VerifyConnectivityRequest"
    }
}

/// Response message for
/// [EkmService.VerifyConnectivity][google.cloud.kms.v1.EkmService.VerifyConnectivity].
///
/// [google.cloud.kms.v1.EkmService.VerifyConnectivity]: crate::client::EkmService::verify_connectivity
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyConnectivityResponse {}

impl VerifyConnectivityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VerifyConnectivityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.VerifyConnectivityResponse"
    }
}

/// A [KeyRing][google.cloud.kms.v1.KeyRing] is a toplevel logical grouping of
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey].
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KeyRing {
    /// Output only. The resource name for the
    /// [KeyRing][google.cloud.kms.v1.KeyRing] in the format
    /// `projects/*/locations/*/keyRings/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time at which this [KeyRing][google.cloud.kms.v1.KeyRing]
    /// was created.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,
}

impl KeyRing {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KeyRing::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::KeyRing::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }
}

impl wkt::message::Message for KeyRing {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyRing"
    }
}

/// A [CryptoKey][google.cloud.kms.v1.CryptoKey] represents a logical key that
/// can be used for cryptographic operations.
///
/// A [CryptoKey][google.cloud.kms.v1.CryptoKey] is made up of zero or more
/// [versions][google.cloud.kms.v1.CryptoKeyVersion], which represent the actual
/// key material used in cryptographic operations.
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoKey {
    /// Output only. The resource name for this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] in the format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. A copy of the "primary"
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that will be used
    /// by [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] when this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] is given in
    /// [EncryptRequest.name][google.cloud.kms.v1.EncryptRequest.name].
    ///
    /// The [CryptoKey][google.cloud.kms.v1.CryptoKey]'s primary version can be
    /// updated via
    /// [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
    ///
    /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
    /// may have a primary. For other keys, this field will be omitted.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.EncryptRequest.name]: crate::model::EncryptRequest::name
    /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
    /// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]: crate::client::KeyManagementService::update_crypto_key_primary_version
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary: std::option::Option<crate::model::CryptoKeyVersion>,

    /// Immutable. The immutable purpose of this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub purpose: crate::model::crypto_key::CryptoKeyPurpose,

    /// Output only. The time at which this
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] was created.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// At [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time],
    /// the Key Management Service will automatically:
    ///
    /// . Create a new version of this [CryptoKey][google.cloud.kms.v1.CryptoKey].
    /// . Mark the new version as primary.
    ///
    /// Key rotations performed manually via
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// and
    /// [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]
    /// do not affect
    /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time].
    ///
    /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
    /// support automatic rotation. For other keys, this field must be omitted.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.next_rotation_time]: crate::model::CryptoKey::next_rotation_time
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
    /// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]: crate::client::KeyManagementService::update_crypto_key_primary_version
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_rotation_time: std::option::Option<wkt::Timestamp>,

    /// A template describing settings for new
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] instances. The
    /// properties of new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// instances created by either
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// or auto-rotation are controlled by this template.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_template: std::option::Option<crate::model::CryptoKeyVersionTemplate>,

    /// Labels with user-defined metadata. For more information, see
    /// [Labeling Keys](https://cloud.google.com/kms/docs/labeling-keys).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. Whether this key may contain imported versions only.
    pub import_only: bool,

    /// Immutable. The period of time that versions of this key spend in the
    /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
    /// state before transitioning to
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
    /// If not specified at creation time, the default duration is 30 days.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROYED
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROY_SCHEDULED
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destroy_scheduled_duration: std::option::Option<wkt::Duration>,

    /// Immutable. The resource name of the backend environment where the key
    /// material for all [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
    /// associated with this [CryptoKey][google.cloud.kms.v1.CryptoKey] reside and
    /// where all related cryptographic operations are performed. Only applicable
    /// if [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] have a
    /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
    /// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC], with the
    /// resource name in the format `projects/*/locations/*/ekmConnections/*`.
    /// Note, this list is non-exhaustive and may apply to additional
    /// [ProtectionLevels][google.cloud.kms.v1.ProtectionLevel] in the future.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_backend: std::string::String,

    /// Optional. The policy used for Key Access Justifications Policy Enforcement.
    /// If this field is present and this key is enrolled in Key Access
    /// Justifications Policy Enforcement, the policy will be evaluated in encrypt,
    /// decrypt, and sign operations, and the operation will fail if rejected by
    /// the policy. The policy is defined by specifying zero or more allowed
    /// justification codes.
    /// <https://cloud.google.com/assured-workloads/key-access-justifications/docs/justification-codes>
    /// By default, this field is absent, and all justification codes are allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key_access_justifications_policy:
        std::option::Option<crate::model::KeyAccessJustificationsPolicy>,

    /// Controls the rate of automatic rotation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rotation_schedule: std::option::Option<crate::model::crypto_key::RotationSchedule>,
}

impl CryptoKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CryptoKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [primary][crate::model::CryptoKey::primary].
    pub fn set_primary<
        T: std::convert::Into<std::option::Option<crate::model::CryptoKeyVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.primary = v.into();
        self
    }

    /// Sets the value of [purpose][crate::model::CryptoKey::purpose].
    pub fn set_purpose<T: std::convert::Into<crate::model::crypto_key::CryptoKeyPurpose>>(
        mut self,
        v: T,
    ) -> Self {
        self.purpose = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CryptoKey::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [next_rotation_time][crate::model::CryptoKey::next_rotation_time].
    pub fn set_next_rotation_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_rotation_time = v.into();
        self
    }

    /// Sets the value of [version_template][crate::model::CryptoKey::version_template].
    pub fn set_version_template<
        T: std::convert::Into<std::option::Option<crate::model::CryptoKeyVersionTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version_template = v.into();
        self
    }

    /// Sets the value of [import_only][crate::model::CryptoKey::import_only].
    pub fn set_import_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.import_only = v.into();
        self
    }

    /// Sets the value of [destroy_scheduled_duration][crate::model::CryptoKey::destroy_scheduled_duration].
    pub fn set_destroy_scheduled_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destroy_scheduled_duration = v.into();
        self
    }

    /// Sets the value of [crypto_key_backend][crate::model::CryptoKey::crypto_key_backend].
    pub fn set_crypto_key_backend<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_backend = v.into();
        self
    }

    /// Sets the value of [key_access_justifications_policy][crate::model::CryptoKey::key_access_justifications_policy].
    pub fn set_key_access_justifications_policy<
        T: std::convert::Into<std::option::Option<crate::model::KeyAccessJustificationsPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.key_access_justifications_policy = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CryptoKey::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `rotation_schedule`.
    pub fn set_rotation_schedule<
        T: std::convert::Into<std::option::Option<crate::model::crypto_key::RotationSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rotation_schedule = v.into();
        self
    }

    /// The value of [rotation_schedule][crate::model::CryptoKey::rotation_schedule]
    /// if it holds a `RotationPeriod`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rotation_period(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.rotation_schedule.as_ref().and_then(|v| match v {
            crate::model::crypto_key::RotationSchedule::RotationPeriod(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rotation_schedule][crate::model::CryptoKey::rotation_schedule]
    /// to hold a `RotationPeriod`.
    ///
    /// Note that all the setters affecting `rotation_schedule` are
    /// mutually exclusive.
    pub fn set_rotation_period<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rotation_schedule = std::option::Option::Some(
            crate::model::crypto_key::RotationSchedule::RotationPeriod(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CryptoKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CryptoKey"
    }
}

/// Defines additional types related to CryptoKey
pub mod crypto_key {
    #[allow(unused_imports)]
    use super::*;

    /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose]
    /// describes the cryptographic capabilities of a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey]. A given key can only be used
    /// for the operations allowed by its purpose. For more information, see [Key
    /// purposes](https://cloud.google.com/kms/docs/algorithms#key_purposes).
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose]: crate::model::crypto_key::CryptoKeyPurpose
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CryptoKeyPurpose(std::borrow::Cow<'static, str>);

    impl CryptoKeyPurpose {
        /// Creates a new CryptoKeyPurpose instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CryptoKeyPurpose](CryptoKeyPurpose)
    pub mod crypto_key_purpose {
        use super::CryptoKeyPurpose;

        /// Not specified.
        pub const CRYPTO_KEY_PURPOSE_UNSPECIFIED: CryptoKeyPurpose =
            CryptoKeyPurpose::new("CRYPTO_KEY_PURPOSE_UNSPECIFIED");

        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
        /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
        /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
        pub const ENCRYPT_DECRYPT: CryptoKeyPurpose = CryptoKeyPurpose::new("ENCRYPT_DECRYPT");

        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with
        /// [AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign]
        /// and
        /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.AsymmetricSign]: crate::client::KeyManagementService::asymmetric_sign
        /// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
        pub const ASYMMETRIC_SIGN: CryptoKeyPurpose = CryptoKeyPurpose::new("ASYMMETRIC_SIGN");

        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with
        /// [AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]
        /// and
        /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]: crate::client::KeyManagementService::asymmetric_decrypt
        /// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
        pub const ASYMMETRIC_DECRYPT: CryptoKeyPurpose =
            CryptoKeyPurpose::new("ASYMMETRIC_DECRYPT");

        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with [RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt]
        /// and [RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
        /// This purpose is meant to be used for interoperable symmetric
        /// encryption and does not support automatic CryptoKey rotation.
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.RawDecrypt]: crate::client::KeyManagementService::raw_decrypt
        /// [google.cloud.kms.v1.KeyManagementService.RawEncrypt]: crate::client::KeyManagementService::raw_encrypt
        pub const RAW_ENCRYPT_DECRYPT: CryptoKeyPurpose =
            CryptoKeyPurpose::new("RAW_ENCRYPT_DECRYPT");

        /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
        /// with [MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
        ///
        /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
        /// [google.cloud.kms.v1.KeyManagementService.MacSign]: crate::client::KeyManagementService::mac_sign
        pub const MAC: CryptoKeyPurpose = CryptoKeyPurpose::new("MAC");
    }

    impl std::convert::From<std::string::String> for CryptoKeyPurpose {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for CryptoKeyPurpose {
        fn default() -> Self {
            crypto_key_purpose::CRYPTO_KEY_PURPOSE_UNSPECIFIED
        }
    }

    /// Controls the rate of automatic rotation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RotationSchedule {
        /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time]
        /// will be advanced by this period when the service automatically rotates a
        /// key. Must be at least 24 hours and at most 876,000 hours.
        ///
        /// If [rotation_period][google.cloud.kms.v1.CryptoKey.rotation_period] is
        /// set,
        /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time]
        /// must also be set.
        ///
        /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
        /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
        /// support automatic rotation. For other keys, this field must be omitted.
        ///
        /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
        /// [google.cloud.kms.v1.CryptoKey.next_rotation_time]: crate::model::CryptoKey::next_rotation_time
        /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
        /// [google.cloud.kms.v1.CryptoKey.rotation_period]: crate::model::CryptoKey::rotation_schedule
        RotationPeriod(std::boxed::Box<wkt::Duration>),
    }
}

/// A [CryptoKeyVersionTemplate][google.cloud.kms.v1.CryptoKeyVersionTemplate]
/// specifies the properties to use when creating a new
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], either manually
/// with
/// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
/// or automatically as a result of auto-rotation.
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.CryptoKeyVersionTemplate]: crate::model::CryptoKeyVersionTemplate
/// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoKeyVersionTemplate {
    /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when creating
    /// a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this
    /// template. Immutable. Defaults to
    /// [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::protection_level::SOFTWARE
    pub protection_level: crate::model::ProtectionLevel,

    /// Required.
    /// [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// to use when creating a
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this
    /// template.
    ///
    /// For backwards compatibility, GOOGLE_SYMMETRIC_ENCRYPTION is implied if both
    /// this field is omitted and
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] is
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,
}

impl CryptoKeyVersionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protection_level][crate::model::CryptoKeyVersionTemplate::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::CryptoKeyVersionTemplate::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }
}

impl wkt::message::Message for CryptoKeyVersionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CryptoKeyVersionTemplate"
    }
}

/// Contains an HSM-generated attestation about a key operation. For more
/// information, see [Verifying attestations]
/// (<https://cloud.google.com/kms/docs/attest-key>).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KeyOperationAttestation {
    /// Output only. The format of the attestation data.
    pub format: crate::model::key_operation_attestation::AttestationFormat,

    /// Output only. The attestation data provided by the HSM when the key
    /// operation was performed.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub content: bytes::Bytes,

    /// Output only. The certificate chains needed to validate the attestation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cert_chains:
        std::option::Option<crate::model::key_operation_attestation::CertificateChains>,
}

impl KeyOperationAttestation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::KeyOperationAttestation::format].
    pub fn set_format<
        T: std::convert::Into<crate::model::key_operation_attestation::AttestationFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [content][crate::model::KeyOperationAttestation::content].
    pub fn set_content<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [cert_chains][crate::model::KeyOperationAttestation::cert_chains].
    pub fn set_cert_chains<
        T: std::convert::Into<
            std::option::Option<crate::model::key_operation_attestation::CertificateChains>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cert_chains = v.into();
        self
    }
}

impl wkt::message::Message for KeyOperationAttestation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyOperationAttestation"
    }
}

/// Defines additional types related to KeyOperationAttestation
pub mod key_operation_attestation {
    #[allow(unused_imports)]
    use super::*;

    /// Certificate chains needed to verify the attestation.
    /// Certificates in chains are PEM-encoded and are ordered based on
    /// <https://tools.ietf.org/html/rfc5246#section-7.4.2>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CertificateChains {
        /// Cavium certificate chain corresponding to the attestation.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub cavium_certs: std::vec::Vec<std::string::String>,

        /// Google card certificate chain corresponding to the attestation.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub google_card_certs: std::vec::Vec<std::string::String>,

        /// Google partition certificate chain corresponding to the attestation.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub google_partition_certs: std::vec::Vec<std::string::String>,
    }

    impl CertificateChains {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cavium_certs][crate::model::key_operation_attestation::CertificateChains::cavium_certs].
        pub fn set_cavium_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.cavium_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [google_card_certs][crate::model::key_operation_attestation::CertificateChains::google_card_certs].
        pub fn set_google_card_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.google_card_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [google_partition_certs][crate::model::key_operation_attestation::CertificateChains::google_partition_certs].
        pub fn set_google_partition_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.google_partition_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CertificateChains {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.kms.v1.KeyOperationAttestation.CertificateChains"
        }
    }

    /// Attestation formats provided by the HSM.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AttestationFormat(std::borrow::Cow<'static, str>);

    impl AttestationFormat {
        /// Creates a new AttestationFormat instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [AttestationFormat](AttestationFormat)
    pub mod attestation_format {
        use super::AttestationFormat;

        /// Not specified.
        pub const ATTESTATION_FORMAT_UNSPECIFIED: AttestationFormat =
            AttestationFormat::new("ATTESTATION_FORMAT_UNSPECIFIED");

        /// Cavium HSM attestation compressed with gzip. Note that this format is
        /// defined by Cavium and subject to change at any time.
        ///
        /// See
        /// <https://www.marvell.com/products/security-solutions/nitrox-hs-adapters/software-key-attestation.html>.
        pub const CAVIUM_V1_COMPRESSED: AttestationFormat =
            AttestationFormat::new("CAVIUM_V1_COMPRESSED");

        /// Cavium HSM attestation V2 compressed with gzip. This is a new format
        /// introduced in Cavium's version 3.2-08.
        pub const CAVIUM_V2_COMPRESSED: AttestationFormat =
            AttestationFormat::new("CAVIUM_V2_COMPRESSED");
    }

    impl std::convert::From<std::string::String> for AttestationFormat {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for AttestationFormat {
        fn default() -> Self {
            attestation_format::ATTESTATION_FORMAT_UNSPECIFIED
        }
    }
}

/// A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents an
/// individual cryptographic key, and the associated key material.
///
/// An
/// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
/// version can be used for cryptographic operations.
///
/// For security reasons, the raw cryptographic key material represented by a
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] can never be viewed
/// or exported. It can only be used to encrypt, decrypt, or sign data when an
/// authorized user or application invokes Cloud KMS.
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoKeyVersion {
    /// Output only. The resource name for this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current state of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub state: crate::model::crypto_key_version::CryptoKeyVersionState,

    /// Output only. The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel]
    /// describing how crypto operations are performed with this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    /// Output only. The
    /// [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// that this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// supports.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    /// Output only. Statement that was generated and signed by the HSM at key
    /// creation time. Use this statement to verify attributes of the key as stored
    /// on the HSM, independently of Google. Only provided for key versions with
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersion.protection_level]
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.protection_level]: crate::model::CryptoKeyVersion::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attestation: std::option::Option<crate::model::KeyOperationAttestation>,

    /// Output only. The time at which this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] was created.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
    /// generated.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generate_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material is
    /// scheduled for destruction. Only present if
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROY_SCHEDULED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destroy_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this CryptoKeyVersion's key material was
    /// destroyed. Only present if
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROYED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destroy_event_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the [ImportJob][google.cloud.kms.v1.ImportJob]
    /// used in the most recent import of this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Only present if
    /// the underlying key material was imported.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_job: std::string::String,

    /// Output only. The time at which this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
    /// most recently imported.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The root cause of the most recent import failure. Only present
    /// if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]: crate::model::crypto_key_version::crypto_key_version_state::IMPORT_FAILED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_failure_reason: std::string::String,

    /// Output only. The root cause of the most recent generation failure. Only
    /// present if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [GENERATION_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.GENERATION_FAILED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.GENERATION_FAILED]: crate::model::crypto_key_version::crypto_key_version_state::GENERATION_FAILED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub generation_failure_reason: std::string::String,

    /// Output only. The root cause of the most recent external destruction
    /// failure. Only present if
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
    /// [EXTERNAL_DESTRUCTION_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED]: crate::model::crypto_key_version::crypto_key_version_state::EXTERNAL_DESTRUCTION_FAILED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_destruction_failure_reason: std::string::String,

    /// ExternalProtectionLevelOptions stores a group of additional fields for
    /// configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that
    /// are specific to the
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] protection level
    /// and [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]
    /// protection levels.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::protection_level::EXTERNAL
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub external_protection_level_options:
        std::option::Option<crate::model::ExternalProtectionLevelOptions>,

    /// Output only. Whether or not this key version is eligible for reimport, by
    /// being specified as a target in
    /// [ImportCryptoKeyVersionRequest.crypto_key_version][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.crypto_key_version].
    ///
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.crypto_key_version]: crate::model::ImportCryptoKeyVersionRequest::crypto_key_version
    pub reimport_eligible: bool,
}

impl CryptoKeyVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CryptoKeyVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CryptoKeyVersion::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::CryptoKeyVersion::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::CryptoKeyVersion::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [attestation][crate::model::CryptoKeyVersion::attestation].
    pub fn set_attestation<
        T: std::convert::Into<std::option::Option<crate::model::KeyOperationAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attestation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CryptoKeyVersion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [generate_time][crate::model::CryptoKeyVersion::generate_time].
    pub fn set_generate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.generate_time = v.into();
        self
    }

    /// Sets the value of [destroy_time][crate::model::CryptoKeyVersion::destroy_time].
    pub fn set_destroy_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.destroy_time = v.into();
        self
    }

    /// Sets the value of [destroy_event_time][crate::model::CryptoKeyVersion::destroy_event_time].
    pub fn set_destroy_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.destroy_event_time = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::CryptoKeyVersion::import_job].
    pub fn set_import_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job = v.into();
        self
    }

    /// Sets the value of [import_time][crate::model::CryptoKeyVersion::import_time].
    pub fn set_import_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_time = v.into();
        self
    }

    /// Sets the value of [import_failure_reason][crate::model::CryptoKeyVersion::import_failure_reason].
    pub fn set_import_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_failure_reason = v.into();
        self
    }

    /// Sets the value of [generation_failure_reason][crate::model::CryptoKeyVersion::generation_failure_reason].
    pub fn set_generation_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.generation_failure_reason = v.into();
        self
    }

    /// Sets the value of [external_destruction_failure_reason][crate::model::CryptoKeyVersion::external_destruction_failure_reason].
    pub fn set_external_destruction_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_destruction_failure_reason = v.into();
        self
    }

    /// Sets the value of [external_protection_level_options][crate::model::CryptoKeyVersion::external_protection_level_options].
    pub fn set_external_protection_level_options<
        T: std::convert::Into<std::option::Option<crate::model::ExternalProtectionLevelOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.external_protection_level_options = v.into();
        self
    }

    /// Sets the value of [reimport_eligible][crate::model::CryptoKeyVersion::reimport_eligible].
    pub fn set_reimport_eligible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reimport_eligible = v.into();
        self
    }
}

impl wkt::message::Message for CryptoKeyVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CryptoKeyVersion"
    }
}

/// Defines additional types related to CryptoKeyVersion
pub mod crypto_key_version {
    #[allow(unused_imports)]
    use super::*;

    /// The algorithm of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], indicating what
    /// parameters must be used for each cryptographic operation.
    ///
    /// The
    /// [GOOGLE_SYMMETRIC_ENCRYPTION][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION]
    /// algorithm is usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// Algorithms beginning with `RSA_SIGN_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
    ///
    /// The fields in the name after `RSA_SIGN_` correspond to the following
    /// parameters: padding algorithm, modulus bit length, and digest algorithm.
    ///
    /// For PSS, the salt length used is equal to the length of digest
    /// algorithm. For example,
    /// [RSA_SIGN_PSS_2048_SHA256][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256]
    /// will use PSS with a salt length of 256 bits or 32 bytes.
    ///
    /// Algorithms beginning with `RSA_DECRYPT_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
    ///
    /// The fields in the name after `RSA_DECRYPT_` correspond to the following
    /// parameters: padding algorithm, modulus bit length, and digest algorithm.
    ///
    /// Algorithms beginning with `EC_SIGN_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
    ///
    /// The fields in the name after `EC_SIGN_` correspond to the following
    /// parameters: elliptic curve, digest algorithm.
    ///
    /// Algorithms beginning with `HMAC_` are usable with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [MAC][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.MAC].
    ///
    /// The suffix following `HMAC_` corresponds to the hash algorithm being used
    /// (eg. SHA256).
    ///
    /// For more information, see [Key purposes and algorithms]
    /// (<https://cloud.google.com/kms/docs/algorithms>).
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ASYMMETRIC_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]: crate::model::crypto_key::crypto_key_purpose::ASYMMETRIC_SIGN
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.MAC]: crate::model::crypto_key::crypto_key_purpose::MAC
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION]: crate::model::crypto_key_version::crypto_key_version_algorithm::GOOGLE_SYMMETRIC_ENCRYPTION
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256]: crate::model::crypto_key_version::crypto_key_version_algorithm::RSA_SIGN_PSS_2048_SHA256
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CryptoKeyVersionAlgorithm(std::borrow::Cow<'static, str>);

    impl CryptoKeyVersionAlgorithm {
        /// Creates a new CryptoKeyVersionAlgorithm instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CryptoKeyVersionAlgorithm](CryptoKeyVersionAlgorithm)
    pub mod crypto_key_version_algorithm {
        use super::CryptoKeyVersionAlgorithm;

        /// Not specified.
        pub const CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED");

        /// Creates symmetric encryption keys.
        pub const GOOGLE_SYMMETRIC_ENCRYPTION: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("GOOGLE_SYMMETRIC_ENCRYPTION");

        /// AES-GCM (Galois Counter Mode) using 128-bit keys.
        pub const AES_128_GCM: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("AES_128_GCM");

        /// AES-GCM (Galois Counter Mode) using 256-bit keys.
        pub const AES_256_GCM: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("AES_256_GCM");

        /// AES-CBC (Cipher Block Chaining Mode) using 128-bit keys.
        pub const AES_128_CBC: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("AES_128_CBC");

        /// AES-CBC (Cipher Block Chaining Mode) using 256-bit keys.
        pub const AES_256_CBC: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("AES_256_CBC");

        /// AES-CTR (Counter Mode) using 128-bit keys.
        pub const AES_128_CTR: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("AES_128_CTR");

        /// AES-CTR (Counter Mode) using 256-bit keys.
        pub const AES_256_CTR: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("AES_256_CTR");

        /// RSASSA-PSS 2048 bit key with a SHA256 digest.
        pub const RSA_SIGN_PSS_2048_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PSS_2048_SHA256");

        /// RSASSA-PSS 3072 bit key with a SHA256 digest.
        pub const RSA_SIGN_PSS_3072_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PSS_3072_SHA256");

        /// RSASSA-PSS 4096 bit key with a SHA256 digest.
        pub const RSA_SIGN_PSS_4096_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PSS_4096_SHA256");

        /// RSASSA-PSS 4096 bit key with a SHA512 digest.
        pub const RSA_SIGN_PSS_4096_SHA512: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PSS_4096_SHA512");

        /// RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.
        pub const RSA_SIGN_PKCS1_2048_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PKCS1_2048_SHA256");

        /// RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.
        pub const RSA_SIGN_PKCS1_3072_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PKCS1_3072_SHA256");

        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.
        pub const RSA_SIGN_PKCS1_4096_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PKCS1_4096_SHA256");

        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.
        pub const RSA_SIGN_PKCS1_4096_SHA512: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_PKCS1_4096_SHA512");

        /// RSASSA-PKCS1-v1_5 signing without encoding, with a 2048 bit key.
        pub const RSA_SIGN_RAW_PKCS1_2048: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_RAW_PKCS1_2048");

        /// RSASSA-PKCS1-v1_5 signing without encoding, with a 3072 bit key.
        pub const RSA_SIGN_RAW_PKCS1_3072: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_RAW_PKCS1_3072");

        /// RSASSA-PKCS1-v1_5 signing without encoding, with a 4096 bit key.
        pub const RSA_SIGN_RAW_PKCS1_4096: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_SIGN_RAW_PKCS1_4096");

        /// RSAES-OAEP 2048 bit key with a SHA256 digest.
        pub const RSA_DECRYPT_OAEP_2048_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_2048_SHA256");

        /// RSAES-OAEP 3072 bit key with a SHA256 digest.
        pub const RSA_DECRYPT_OAEP_3072_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_3072_SHA256");

        /// RSAES-OAEP 4096 bit key with a SHA256 digest.
        pub const RSA_DECRYPT_OAEP_4096_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_4096_SHA256");

        /// RSAES-OAEP 4096 bit key with a SHA512 digest.
        pub const RSA_DECRYPT_OAEP_4096_SHA512: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_4096_SHA512");

        /// RSAES-OAEP 2048 bit key with a SHA1 digest.
        pub const RSA_DECRYPT_OAEP_2048_SHA1: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_2048_SHA1");

        /// RSAES-OAEP 3072 bit key with a SHA1 digest.
        pub const RSA_DECRYPT_OAEP_3072_SHA1: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_3072_SHA1");

        /// RSAES-OAEP 4096 bit key with a SHA1 digest.
        pub const RSA_DECRYPT_OAEP_4096_SHA1: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("RSA_DECRYPT_OAEP_4096_SHA1");

        /// ECDSA on the NIST P-256 curve with a SHA256 digest.
        /// Other hash functions can also be used:
        /// <https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms>
        pub const EC_SIGN_P256_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("EC_SIGN_P256_SHA256");

        /// ECDSA on the NIST P-384 curve with a SHA384 digest.
        /// Other hash functions can also be used:
        /// <https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms>
        pub const EC_SIGN_P384_SHA384: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("EC_SIGN_P384_SHA384");

        /// ECDSA on the non-NIST secp256k1 curve. This curve is only supported for
        /// HSM protection level.
        /// Other hash functions can also be used:
        /// <https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms>
        pub const EC_SIGN_SECP256K1_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("EC_SIGN_SECP256K1_SHA256");

        /// EdDSA on the Curve25519 in pure mode (taking data as input).
        pub const EC_SIGN_ED25519: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("EC_SIGN_ED25519");

        /// HMAC-SHA256 signing with a 256 bit key.
        pub const HMAC_SHA256: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("HMAC_SHA256");

        /// HMAC-SHA1 signing with a 160 bit key.
        pub const HMAC_SHA1: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("HMAC_SHA1");

        /// HMAC-SHA384 signing with a 384 bit key.
        pub const HMAC_SHA384: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("HMAC_SHA384");

        /// HMAC-SHA512 signing with a 512 bit key.
        pub const HMAC_SHA512: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("HMAC_SHA512");

        /// HMAC-SHA224 signing with a 224 bit key.
        pub const HMAC_SHA224: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("HMAC_SHA224");

        /// Algorithm representing symmetric encryption by an external key manager.
        pub const EXTERNAL_SYMMETRIC_ENCRYPTION: CryptoKeyVersionAlgorithm =
            CryptoKeyVersionAlgorithm::new("EXTERNAL_SYMMETRIC_ENCRYPTION");
    }

    impl std::convert::From<std::string::String> for CryptoKeyVersionAlgorithm {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for CryptoKeyVersionAlgorithm {
        fn default() -> Self {
            crypto_key_version_algorithm::CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED
        }
    }

    /// The state of a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion],
    /// indicating if it can be used.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CryptoKeyVersionState(std::borrow::Cow<'static, str>);

    impl CryptoKeyVersionState {
        /// Creates a new CryptoKeyVersionState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CryptoKeyVersionState](CryptoKeyVersionState)
    pub mod crypto_key_version_state {
        use super::CryptoKeyVersionState;

        /// Not specified.
        pub const CRYPTO_KEY_VERSION_STATE_UNSPECIFIED: CryptoKeyVersionState =
            CryptoKeyVersionState::new("CRYPTO_KEY_VERSION_STATE_UNSPECIFIED");

        /// This version is still being generated. It may not be used, enabled,
        /// disabled, or destroyed yet. Cloud KMS will automatically mark this
        /// version
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// as soon as the version is ready.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
        pub const PENDING_GENERATION: CryptoKeyVersionState =
            CryptoKeyVersionState::new("PENDING_GENERATION");

        /// This version may be used for cryptographic operations.
        pub const ENABLED: CryptoKeyVersionState = CryptoKeyVersionState::new("ENABLED");

        /// This version may not be used, but the key material is still available,
        /// and the version can be placed back into the
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// state.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
        pub const DISABLED: CryptoKeyVersionState = CryptoKeyVersionState::new("DISABLED");

        /// This version is destroyed, and the key material is no longer stored.
        /// This version may only become
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// again if this version is
        /// [reimport_eligible][google.cloud.kms.v1.CryptoKeyVersion.reimport_eligible]
        /// and the original key material is reimported with a call to
        /// [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
        /// [google.cloud.kms.v1.CryptoKeyVersion.reimport_eligible]: crate::model::CryptoKeyVersion::reimport_eligible
        /// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
        pub const DESTROYED: CryptoKeyVersionState = CryptoKeyVersionState::new("DESTROYED");

        /// This version is scheduled for destruction, and will be destroyed soon.
        /// Call
        /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
        /// to put it back into the
        /// [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
        /// state.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]: crate::model::crypto_key_version::crypto_key_version_state::DISABLED
        /// [google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]: crate::client::KeyManagementService::restore_crypto_key_version
        pub const DESTROY_SCHEDULED: CryptoKeyVersionState =
            CryptoKeyVersionState::new("DESTROY_SCHEDULED");

        /// This version is still being imported. It may not be used, enabled,
        /// disabled, or destroyed yet. Cloud KMS will automatically mark this
        /// version
        /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
        /// as soon as the version is ready.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
        pub const PENDING_IMPORT: CryptoKeyVersionState =
            CryptoKeyVersionState::new("PENDING_IMPORT");

        /// This version was not imported successfully. It may not be used, enabled,
        /// disabled, or destroyed. The submitted key material has been discarded.
        /// Additional details can be found in
        /// [CryptoKeyVersion.import_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.import_failure_reason].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.import_failure_reason]: crate::model::CryptoKeyVersion::import_failure_reason
        pub const IMPORT_FAILED: CryptoKeyVersionState =
            CryptoKeyVersionState::new("IMPORT_FAILED");

        /// This version was not generated successfully. It may not be used, enabled,
        /// disabled, or destroyed. Additional details can be found in
        /// [CryptoKeyVersion.generation_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.generation_failure_reason].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.generation_failure_reason]: crate::model::CryptoKeyVersion::generation_failure_reason
        pub const GENERATION_FAILED: CryptoKeyVersionState =
            CryptoKeyVersionState::new("GENERATION_FAILED");

        /// This version was destroyed, and it may not be used or enabled again.
        /// Cloud KMS is waiting for the corresponding key material residing in an
        /// external key manager to be destroyed.
        pub const PENDING_EXTERNAL_DESTRUCTION: CryptoKeyVersionState =
            CryptoKeyVersionState::new("PENDING_EXTERNAL_DESTRUCTION");

        /// This version was destroyed, and it may not be used or enabled again.
        /// However, Cloud KMS could not confirm that the corresponding key material
        /// residing in an external key manager was destroyed. Additional details can
        /// be found in
        /// [CryptoKeyVersion.external_destruction_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.external_destruction_failure_reason].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion.external_destruction_failure_reason]: crate::model::CryptoKeyVersion::external_destruction_failure_reason
        pub const EXTERNAL_DESTRUCTION_FAILED: CryptoKeyVersionState =
            CryptoKeyVersionState::new("EXTERNAL_DESTRUCTION_FAILED");
    }

    impl std::convert::From<std::string::String> for CryptoKeyVersionState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for CryptoKeyVersionState {
        fn default() -> Self {
            crypto_key_version_state::CRYPTO_KEY_VERSION_STATE_UNSPECIFIED
        }
    }

    /// A view for [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]s.
    /// Controls the level of detail returned for
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] in
    /// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]
    /// and
    /// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]: crate::client::KeyManagementService::list_crypto_key_versions
    /// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeys]: crate::client::KeyManagementService::list_crypto_keys
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CryptoKeyVersionView(std::borrow::Cow<'static, str>);

    impl CryptoKeyVersionView {
        /// Creates a new CryptoKeyVersionView instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CryptoKeyVersionView](CryptoKeyVersionView)
    pub mod crypto_key_version_view {
        use super::CryptoKeyVersionView;

        /// Default view for each
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Does not
        /// include the
        /// [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation] field.
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.CryptoKeyVersion.attestation]: crate::model::CryptoKeyVersion::attestation
        pub const CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED: CryptoKeyVersionView =
            CryptoKeyVersionView::new("CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED");

        /// Provides all fields in each
        /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], including the
        /// [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation].
        ///
        /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
        /// [google.cloud.kms.v1.CryptoKeyVersion.attestation]: crate::model::CryptoKeyVersion::attestation
        pub const FULL: CryptoKeyVersionView = CryptoKeyVersionView::new("FULL");
    }

    impl std::convert::From<std::string::String> for CryptoKeyVersionView {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for CryptoKeyVersionView {
        fn default() -> Self {
            crypto_key_version_view::CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED
        }
    }
}

/// The public keys for a given
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Obtained via
/// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PublicKey {
    /// The public key, encoded in PEM format. For more information, see the
    /// [RFC 7468](https://tools.ietf.org/html/rfc7468) sections for
    /// [General Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
    /// [Textual Encoding of Subject Public Key Info]
    /// (<https://tools.ietf.org/html/rfc7468#section-13>).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pem: std::string::String,

    /// The
    /// [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// associated with this key.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem]. An integrity check of
    /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] can be performed by
    /// computing the CRC32C checksum of
    /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] and comparing your
    /// results to this field. Discard the response in case of non-matching
    /// checksum values, and perform a limited number of retries. A persistent
    /// mismatch may indicate an issue in your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// NOTE: This field is in Beta.
    ///
    /// [google.cloud.kms.v1.PublicKey.pem]: crate::model::PublicKey::pem
    #[serde(rename = "pemCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub pem_crc32c: std::option::Option<wkt::Int64Value>,

    /// The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
    /// Provided here for verification.
    ///
    /// NOTE: This field is in Beta.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl PublicKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pem][crate::model::PublicKey::pem].
    pub fn set_pem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::PublicKey::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [pem_crc32c][crate::model::PublicKey::pem_crc32c].
    pub fn set_pem_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pem_crc32c = v.into();
        self
    }

    /// Sets the value of [name][crate::model::PublicKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::PublicKey::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for PublicKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.PublicKey"
    }
}

/// An [ImportJob][google.cloud.kms.v1.ImportJob] can be used to create
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] using pre-existing
/// key material, generated outside of Cloud KMS.
///
/// When an [ImportJob][google.cloud.kms.v1.ImportJob] is created, Cloud KMS will
/// generate a "wrapping key", which is a public/private key pair. You use the
/// wrapping key to encrypt (also known as wrap) the pre-existing key material to
/// protect it during the import process. The nature of the wrapping key depends
/// on the choice of
/// [import_method][google.cloud.kms.v1.ImportJob.import_method]. When the
/// wrapping key generation is complete, the
/// [state][google.cloud.kms.v1.ImportJob.state] will be set to
/// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] and the
/// [public_key][google.cloud.kms.v1.ImportJob.public_key] can be fetched. The
/// fetched public key can then be used to wrap your pre-existing key material.
///
/// Once the key material is wrapped, it can be imported into a new
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in an existing
/// [CryptoKey][google.cloud.kms.v1.CryptoKey] by calling
/// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
/// Multiple [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] can be
/// imported with a single [ImportJob][google.cloud.kms.v1.ImportJob]. Cloud KMS
/// uses the private key portion of the wrapping key to unwrap the key material.
/// Only Cloud KMS has access to the private key.
///
/// An [ImportJob][google.cloud.kms.v1.ImportJob] expires 3 days after it is
/// created. Once expired, Cloud KMS will no longer be able to import or unwrap
/// any key material that was wrapped with the
/// [ImportJob][google.cloud.kms.v1.ImportJob]'s public key.
///
/// For more information, see
/// [Importing a key](https://cloud.google.com/kms/docs/importing-a-key).
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
/// [google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE]: crate::model::import_job::import_job_state::ACTIVE
/// [google.cloud.kms.v1.ImportJob.import_method]: crate::model::ImportJob::import_method
/// [google.cloud.kms.v1.ImportJob.public_key]: crate::model::ImportJob::public_key
/// [google.cloud.kms.v1.ImportJob.state]: crate::model::ImportJob::state
/// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportJob {
    /// Output only. The resource name for this
    /// [ImportJob][google.cloud.kms.v1.ImportJob] in the format
    /// `projects/*/locations/*/keyRings/*/importJobs/*`.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Immutable. The wrapping method to be used for incoming key
    /// material.
    pub import_method: crate::model::import_job::ImportMethod,

    /// Required. Immutable. The protection level of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob]. This must match the
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
    /// of the [version_template][google.cloud.kms.v1.CryptoKey.version_template]
    /// on the [CryptoKey][google.cloud.kms.v1.CryptoKey] you attempt to import
    /// into.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.version_template]: crate::model::CryptoKey::version_template
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub protection_level: crate::model::ProtectionLevel,

    /// Output only. The time at which this
    /// [ImportJob][google.cloud.kms.v1.ImportJob] was created.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]'s key
    /// material was generated.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generate_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [ImportJob][google.cloud.kms.v1.ImportJob] is scheduled for expiration and
    /// can no longer be used to import key material.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]
    /// expired. Only present if [state][google.cloud.kms.v1.ImportJob.state] is
    /// [EXPIRED][google.cloud.kms.v1.ImportJob.ImportJobState.EXPIRED].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.ImportJobState.EXPIRED]: crate::model::import_job::import_job_state::EXPIRED
    /// [google.cloud.kms.v1.ImportJob.state]: crate::model::ImportJob::state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_event_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob], indicating if it can be used.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub state: crate::model::import_job::ImportJobState,

    /// Output only. The public key with which to wrap key material prior to
    /// import. Only returned if [state][google.cloud.kms.v1.ImportJob.state] is
    /// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE].
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE]: crate::model::import_job::import_job_state::ACTIVE
    /// [google.cloud.kms.v1.ImportJob.state]: crate::model::ImportJob::state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub public_key: std::option::Option<crate::model::import_job::WrappingPublicKey>,

    /// Output only. Statement that was generated and signed by the key creator
    /// (for example, an HSM) at key creation time. Use this statement to verify
    /// attributes of the key as stored on the HSM, independently of Google.
    /// Only present if the chosen
    /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] is one with a
    /// protection level of [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportMethod]: crate::model::import_job::ImportMethod
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub attestation: std::option::Option<crate::model::KeyOperationAttestation>,
}

impl ImportJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [import_method][crate::model::ImportJob::import_method].
    pub fn set_import_method<T: std::convert::Into<crate::model::import_job::ImportMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_method = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::ImportJob::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [generate_time][crate::model::ImportJob::generate_time].
    pub fn set_generate_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.generate_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::ImportJob::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [expire_event_time][crate::model::ImportJob::expire_event_time].
    pub fn set_expire_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_event_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ImportJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::import_job::ImportJobState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::ImportJob::public_key].
    pub fn set_public_key<
        T: std::convert::Into<std::option::Option<crate::model::import_job::WrappingPublicKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [attestation][crate::model::ImportJob::attestation].
    pub fn set_attestation<
        T: std::convert::Into<std::option::Option<crate::model::KeyOperationAttestation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attestation = v.into();
        self
    }
}

impl wkt::message::Message for ImportJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ImportJob"
    }
}

/// Defines additional types related to ImportJob
pub mod import_job {
    #[allow(unused_imports)]
    use super::*;

    /// The public key component of the wrapping key. For details of the type of
    /// key this public key corresponds to, see the
    /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod].
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportMethod]: crate::model::import_job::ImportMethod
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WrappingPublicKey {
        /// The public key, encoded in PEM format. For more information, see the [RFC
        /// 7468](https://tools.ietf.org/html/rfc7468) sections for [General
        /// Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
        /// [Textual Encoding of Subject Public Key Info]
        /// (<https://tools.ietf.org/html/rfc7468#section-13>).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pem: std::string::String,
    }

    impl WrappingPublicKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pem][crate::model::import_job::WrappingPublicKey::pem].
        pub fn set_pem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pem = v.into();
            self
        }
    }

    impl wkt::message::Message for WrappingPublicKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.kms.v1.ImportJob.WrappingPublicKey"
        }
    }

    /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] describes the
    /// key wrapping method chosen for this
    /// [ImportJob][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.ImportMethod]: crate::model::import_job::ImportMethod
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ImportMethod(std::borrow::Cow<'static, str>);

    impl ImportMethod {
        /// Creates a new ImportMethod instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ImportMethod](ImportMethod)
    pub mod import_method {
        use super::ImportMethod;

        /// Not specified.
        pub const IMPORT_METHOD_UNSPECIFIED: ImportMethod =
            ImportMethod::new("IMPORT_METHOD_UNSPECIFIED");

        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 3072 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        pub const RSA_OAEP_3072_SHA1_AES_256: ImportMethod =
            ImportMethod::new("RSA_OAEP_3072_SHA1_AES_256");

        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 4096 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        pub const RSA_OAEP_4096_SHA1_AES_256: ImportMethod =
            ImportMethod::new("RSA_OAEP_4096_SHA1_AES_256");

        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 3072 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        pub const RSA_OAEP_3072_SHA256_AES_256: ImportMethod =
            ImportMethod::new("RSA_OAEP_3072_SHA256_AES_256");

        /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
        /// scheme defined in the PKCS #11 standard. In summary, this involves
        /// wrapping the raw key with an ephemeral AES key, and wrapping the
        /// ephemeral AES key with a 4096 bit RSA key. For more details, see
        /// [RSA AES key wrap
        /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
        pub const RSA_OAEP_4096_SHA256_AES_256: ImportMethod =
            ImportMethod::new("RSA_OAEP_4096_SHA256_AES_256");

        /// This ImportMethod represents RSAES-OAEP with a 3072 bit RSA key. The
        /// key material to be imported is wrapped directly with the RSA key. Due
        /// to technical limitations of RSA wrapping, this method cannot be used to
        /// wrap RSA keys for import.
        pub const RSA_OAEP_3072_SHA256: ImportMethod = ImportMethod::new("RSA_OAEP_3072_SHA256");

        /// This ImportMethod represents RSAES-OAEP with a 4096 bit RSA key. The
        /// key material to be imported is wrapped directly with the RSA key. Due
        /// to technical limitations of RSA wrapping, this method cannot be used to
        /// wrap RSA keys for import.
        pub const RSA_OAEP_4096_SHA256: ImportMethod = ImportMethod::new("RSA_OAEP_4096_SHA256");
    }

    impl std::convert::From<std::string::String> for ImportMethod {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for ImportMethod {
        fn default() -> Self {
            import_method::IMPORT_METHOD_UNSPECIFIED
        }
    }

    /// The state of the [ImportJob][google.cloud.kms.v1.ImportJob], indicating if
    /// it can be used.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ImportJobState(std::borrow::Cow<'static, str>);

    impl ImportJobState {
        /// Creates a new ImportJobState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ImportJobState](ImportJobState)
    pub mod import_job_state {
        use super::ImportJobState;

        /// Not specified.
        pub const IMPORT_JOB_STATE_UNSPECIFIED: ImportJobState =
            ImportJobState::new("IMPORT_JOB_STATE_UNSPECIFIED");

        /// The wrapping key for this job is still being generated. It may not be
        /// used. Cloud KMS will automatically mark this job as
        /// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] as soon as
        /// the wrapping key is generated.
        ///
        /// [google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE]: crate::model::import_job::import_job_state::ACTIVE
        pub const PENDING_GENERATION: ImportJobState = ImportJobState::new("PENDING_GENERATION");

        /// This job may be used in
        /// [CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]
        /// and
        /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
        /// requests.
        ///
        /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]: crate::client::KeyManagementService::create_crypto_key
        /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
        pub const ACTIVE: ImportJobState = ImportJobState::new("ACTIVE");

        /// This job can no longer be used and may not leave this state once entered.
        pub const EXPIRED: ImportJobState = ImportJobState::new("EXPIRED");
    }

    impl std::convert::From<std::string::String> for ImportJobState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for ImportJobState {
        fn default() -> Self {
            import_job_state::IMPORT_JOB_STATE_UNSPECIFIED
        }
    }
}

/// ExternalProtectionLevelOptions stores a group of additional fields for
/// configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that
/// are specific to the [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL]
/// protection level and
/// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] protection
/// levels.
///
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::protection_level::EXTERNAL
/// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExternalProtectionLevelOptions {
    /// The URI for an external resource that this
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_key_uri: std::string::String,

    /// The path to the external key material on the EKM when using
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection] e.g., "v0/my/key". Set
    /// this field instead of external_key_uri when using an
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ekm_connection_key_path: std::string::String,
}

impl ExternalProtectionLevelOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_key_uri][crate::model::ExternalProtectionLevelOptions::external_key_uri].
    pub fn set_external_key_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.external_key_uri = v.into();
        self
    }

    /// Sets the value of [ekm_connection_key_path][crate::model::ExternalProtectionLevelOptions::ekm_connection_key_path].
    pub fn set_ekm_connection_key_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_connection_key_path = v.into();
        self
    }
}

impl wkt::message::Message for ExternalProtectionLevelOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ExternalProtectionLevelOptions"
    }
}

/// A
/// [KeyAccessJustificationsPolicy][google.cloud.kms.v1.KeyAccessJustificationsPolicy]
/// specifies zero or more allowed
/// [AccessReason][google.cloud.kms.v1.AccessReason] values for encrypt, decrypt,
/// and sign operations on a [CryptoKey][google.cloud.kms.v1.CryptoKey].
///
/// [google.cloud.kms.v1.AccessReason]: crate::model::AccessReason
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.KeyAccessJustificationsPolicy]: crate::model::KeyAccessJustificationsPolicy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KeyAccessJustificationsPolicy {
    /// The list of allowed reasons for access to a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey]. Zero allowed access reasons
    /// means all encrypt, decrypt, and sign operations for the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with this policy will
    /// fail.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_access_reasons: std::vec::Vec<crate::model::AccessReason>,
}

impl KeyAccessJustificationsPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_access_reasons][crate::model::KeyAccessJustificationsPolicy::allowed_access_reasons].
    pub fn set_allowed_access_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessReason>,
    {
        use std::iter::Iterator;
        self.allowed_access_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for KeyAccessJustificationsPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.KeyAccessJustificationsPolicy"
    }
}

/// Request message for
/// [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
///
/// [google.cloud.kms.v1.KeyManagementService.ListKeyRings]: crate::client::KeyManagementService::list_key_rings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKeyRingsRequest {
    /// Required. The resource name of the location associated with the
    /// [KeyRings][google.cloud.kms.v1.KeyRing], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [KeyRings][google.cloud.kms.v1.KeyRing] to include in the response. Further
    /// [KeyRings][google.cloud.kms.v1.KeyRing] can subsequently be obtained by
    /// including the
    /// [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]
    /// in a subsequent request.  If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]: crate::model::ListKeyRingsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]: crate::model::ListKeyRingsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order.  For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListKeyRingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeyRingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeyRingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeyRingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKeyRingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListKeyRingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListKeyRingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyRingsRequest"
    }
}

/// Request message for
/// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeys]: crate::client::KeyManagementService::list_crypto_keys
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCryptoKeysRequest {
    /// Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
    /// to list, in the format `projects/*/locations/*/keyRings/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] to include in the response.
    /// Further [CryptoKeys][google.cloud.kms.v1.CryptoKey] can subsequently be
    /// obtained by including the
    /// [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]
    /// in a subsequent request.  If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]: crate::model::ListCryptoKeysResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]: crate::model::ListCryptoKeysResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The fields of the primary version to include in the response.
    pub version_view: crate::model::crypto_key_version::CryptoKeyVersionView,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order. For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListCryptoKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCryptoKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCryptoKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCryptoKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [version_view][crate::model::ListCryptoKeysRequest::version_view].
    pub fn set_version_view<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version_view = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCryptoKeysRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCryptoKeysRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCryptoKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeysRequest"
    }
}

/// Request message for
/// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]: crate::client::KeyManagementService::list_crypto_key_versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCryptoKeyVersionsRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to list, in the format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] to include in the
    /// response. Further [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
    /// can subsequently be obtained by including the
    /// [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]: crate::model::ListCryptoKeyVersionsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]: crate::model::ListCryptoKeyVersionsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The fields to include in the response.
    pub view: crate::model::crypto_key_version::CryptoKeyVersionView,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order. For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListCryptoKeyVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCryptoKeyVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCryptoKeyVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCryptoKeyVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListCryptoKeyVersionsRequest::view].
    pub fn set_view<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCryptoKeyVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCryptoKeyVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCryptoKeyVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeyVersionsRequest"
    }
}

/// Request message for
/// [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
///
/// [google.cloud.kms.v1.KeyManagementService.ListImportJobs]: crate::client::KeyManagementService::list_import_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImportJobsRequest {
    /// Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
    /// to list, in the format `projects/*/locations/*/keyRings/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Optional limit on the number of
    /// [ImportJobs][google.cloud.kms.v1.ImportJob] to include in the response.
    /// Further [ImportJobs][google.cloud.kms.v1.ImportJob] can subsequently be
    /// obtained by including the
    /// [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ListImportJobsResponse.next_page_token]: crate::model::ListImportJobsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Optional pagination token, returned earlier via
    /// [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token].
    ///
    /// [google.cloud.kms.v1.ListImportJobsResponse.next_page_token]: crate::model::ListImportJobsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. If not specified, the
    /// results will be sorted in the default order. For more information, see
    /// [Sorting and filtering list
    /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListImportJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImportJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImportJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImportJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImportJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImportJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListImportJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListImportJobsRequest"
    }
}

/// Response message for
/// [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
///
/// [google.cloud.kms.v1.KeyManagementService.ListKeyRings]: crate::client::KeyManagementService::list_key_rings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKeyRingsResponse {
    /// The list of [KeyRings][google.cloud.kms.v1.KeyRing].
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub key_rings: std::vec::Vec<crate::model::KeyRing>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListKeyRingsRequest.page_token][google.cloud.kms.v1.ListKeyRingsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListKeyRingsRequest.page_token]: crate::model::ListKeyRingsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of [KeyRings][google.cloud.kms.v1.KeyRing] that matched
    /// the query.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    pub total_size: i32,
}

impl ListKeyRingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListKeyRingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListKeyRingsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [key_rings][crate::model::ListKeyRingsResponse::key_rings].
    pub fn set_key_rings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KeyRing>,
    {
        use std::iter::Iterator;
        self.key_rings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListKeyRingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListKeyRingsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListKeyRingsResponse {
    type PageItem = crate::model::KeyRing;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.key_rings
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Response message for
/// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeys]: crate::client::KeyManagementService::list_crypto_keys
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCryptoKeysResponse {
    /// The list of [CryptoKeys][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub crypto_keys: std::vec::Vec<crate::model::CryptoKey>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCryptoKeysRequest.page_token][google.cloud.kms.v1.ListCryptoKeysRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListCryptoKeysRequest.page_token]: crate::model::ListCryptoKeysRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of [CryptoKeys][google.cloud.kms.v1.CryptoKey] that
    /// matched the query.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    pub total_size: i32,
}

impl ListCryptoKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCryptoKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListCryptoKeysResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [crypto_keys][crate::model::ListCryptoKeysResponse::crypto_keys].
    pub fn set_crypto_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CryptoKey>,
    {
        use std::iter::Iterator;
        self.crypto_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCryptoKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeysResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCryptoKeysResponse {
    type PageItem = crate::model::CryptoKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crypto_keys
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Response message for
/// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
///
/// [google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]: crate::client::KeyManagementService::list_crypto_key_versions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCryptoKeyVersionsResponse {
    /// The list of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub crypto_key_versions: std::vec::Vec<crate::model::CryptoKeyVersion>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCryptoKeyVersionsRequest.page_token][google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token]: crate::model::ListCryptoKeyVersionsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] that matched the
    /// query.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    pub total_size: i32,
}

impl ListCryptoKeyVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCryptoKeyVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListCryptoKeyVersionsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [crypto_key_versions][crate::model::ListCryptoKeyVersionsResponse::crypto_key_versions].
    pub fn set_crypto_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CryptoKeyVersion>,
    {
        use std::iter::Iterator;
        self.crypto_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCryptoKeyVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListCryptoKeyVersionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCryptoKeyVersionsResponse {
    type PageItem = crate::model::CryptoKeyVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.crypto_key_versions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Response message for
/// [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
///
/// [google.cloud.kms.v1.KeyManagementService.ListImportJobs]: crate::client::KeyManagementService::list_import_jobs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListImportJobsResponse {
    /// The list of [ImportJobs][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub import_jobs: std::vec::Vec<crate::model::ImportJob>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListImportJobsRequest.page_token][google.cloud.kms.v1.ListImportJobsRequest.page_token]
    /// to retrieve the next page of results.
    ///
    /// [google.cloud.kms.v1.ListImportJobsRequest.page_token]: crate::model::ListImportJobsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of [ImportJobs][google.cloud.kms.v1.ImportJob] that
    /// matched the query.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    pub total_size: i32,
}

impl ListImportJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListImportJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListImportJobsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [import_jobs][crate::model::ListImportJobsResponse::import_jobs].
    pub fn set_import_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImportJob>,
    {
        use std::iter::Iterator;
        self.import_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImportJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ListImportJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListImportJobsResponse {
    type PageItem = crate::model::ImportJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.import_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [KeyManagementService.GetKeyRing][google.cloud.kms.v1.KeyManagementService.GetKeyRing].
///
/// [google.cloud.kms.v1.KeyManagementService.GetKeyRing]: crate::client::KeyManagementService::get_key_ring
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetKeyRingRequest {
    /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
    /// [KeyRing][google.cloud.kms.v1.KeyRing] to get.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.KeyRing.name]: crate::model::KeyRing::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetKeyRingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyRingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyRingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetKeyRingRequest"
    }
}

/// Request message for
/// [KeyManagementService.GetCryptoKey][google.cloud.kms.v1.KeyManagementService.GetCryptoKey].
///
/// [google.cloud.kms.v1.KeyManagementService.GetCryptoKey]: crate::client::KeyManagementService::get_crypto_key
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCryptoKeyRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to get.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.name]: crate::model::CryptoKey::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCryptoKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCryptoKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCryptoKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetCryptoKeyRequest"
    }
}

/// Request message for
/// [KeyManagementService.GetCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion]: crate::client::KeyManagementService::get_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCryptoKeyVersionRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to get.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCryptoKeyVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetCryptoKeyVersionRequest"
    }
}

/// Request message for
/// [KeyManagementService.GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
///
/// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPublicKeyRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key to get.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPublicKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPublicKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPublicKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetPublicKeyRequest"
    }
}

/// Request message for
/// [KeyManagementService.GetImportJob][google.cloud.kms.v1.KeyManagementService.GetImportJob].
///
/// [google.cloud.kms.v1.KeyManagementService.GetImportJob]: crate::client::KeyManagementService::get_import_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetImportJobRequest {
    /// Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob] to get.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.name]: crate::model::ImportJob::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GetImportJobRequest"
    }
}

/// Request message for
/// [KeyManagementService.CreateKeyRing][google.cloud.kms.v1.KeyManagementService.CreateKeyRing].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateKeyRing]: crate::client::KeyManagementService::create_key_ring
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateKeyRingRequest {
    /// Required. The resource name of the location associated with the
    /// [KeyRings][google.cloud.kms.v1.KeyRing], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_ring_id: std::string::String,

    /// Required. A [KeyRing][google.cloud.kms.v1.KeyRing] with initial field
    /// values.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key_ring: std::option::Option<crate::model::KeyRing>,
}

impl CreateKeyRingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyRingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key_ring_id][crate::model::CreateKeyRingRequest::key_ring_id].
    pub fn set_key_ring_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_ring_id = v.into();
        self
    }

    /// Sets the value of [key_ring][crate::model::CreateKeyRingRequest::key_ring].
    pub fn set_key_ring<T: std::convert::Into<std::option::Option<crate::model::KeyRing>>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_ring = v.into();
        self
    }
}

impl wkt::message::Message for CreateKeyRingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateKeyRingRequest"
    }
}

/// Request message for
/// [KeyManagementService.CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]: crate::client::KeyManagementService::create_crypto_key
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCryptoKeyRequest {
    /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the KeyRing
    /// associated with the [CryptoKeys][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyRing.name]: crate::model::KeyRing::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. It must be unique within a KeyRing and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_id: std::string::String,

    /// Required. A [CryptoKey][google.cloud.kms.v1.CryptoKey] with initial field
    /// values.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// If set to true, the request will create a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] without any
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. You must
    /// manually call
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// or
    /// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]
    /// before you can use this [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
    /// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
    pub skip_initial_version_creation: bool,
}

impl CreateCryptoKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCryptoKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [crypto_key_id][crate::model::CreateCryptoKeyRequest::crypto_key_id].
    pub fn set_crypto_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_id = v.into();
        self
    }

    /// Sets the value of [crypto_key][crate::model::CreateCryptoKeyRequest::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }

    /// Sets the value of [skip_initial_version_creation][crate::model::CreateCryptoKeyRequest::skip_initial_version_creation].
    pub fn set_skip_initial_version_creation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_initial_version_creation = v.into();
        self
    }
}

impl wkt::message::Message for CreateCryptoKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateCryptoKeyRequest"
    }
}

/// Request message for
/// [KeyManagementService.CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]: crate::client::KeyManagementService::create_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCryptoKeyVersionRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with the
    /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.name]: crate::model::CryptoKey::name
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
    /// initial field values.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key_version: std::option::Option<crate::model::CryptoKeyVersion>,
}

impl CreateCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCryptoKeyVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [crypto_key_version][crate::model::CreateCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_crypto_key_version<
        T: std::convert::Into<std::option::Option<crate::model::CryptoKeyVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_version = v.into();
        self
    }
}

impl wkt::message::Message for CreateCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateCryptoKeyVersionRequest"
    }
}

/// Request message for
/// [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportCryptoKeyVersionRequest {
    /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to be imported into.
    ///
    /// The create permission is only required on this key when creating a new
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.name]: crate::model::CryptoKey::name
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The optional [name][google.cloud.kms.v1.CryptoKeyVersion.name] of
    /// an existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to
    /// target for an import operation. If this field is not present, a new
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] containing the
    /// supplied key material is created.
    ///
    /// If this field is present, the supplied key material is imported into
    /// the existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. To
    /// import into an existing
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] must be a child of
    /// [ImportCryptoKeyVersionRequest.parent][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.parent],
    /// have been previously created via
    /// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion],
    /// and be in
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]
    /// or
    /// [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]
    /// state. The key material and algorithm must match the previous
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] exactly if the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] has ever contained
    /// key material.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROYED
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]: crate::model::crypto_key_version::crypto_key_version_state::IMPORT_FAILED
    /// [google.cloud.kms.v1.CryptoKeyVersion.name]: crate::model::CryptoKeyVersion::name
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.parent]: crate::model::ImportCryptoKeyVersionRequest::parent
    /// [google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]: crate::client::KeyManagementService::import_crypto_key_version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_version: std::string::String,

    /// Required. The
    /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// of the key being imported. This does not need to match the
    /// [version_template][google.cloud.kms.v1.CryptoKey.version_template] of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] this version imports into.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.version_template]: crate::model::CryptoKey::version_template
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm
    pub algorithm: crate::model::crypto_key_version::CryptoKeyVersionAlgorithm,

    /// Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
    /// [ImportJob][google.cloud.kms.v1.ImportJob] that was used to wrap this key
    /// material.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.name]: crate::model::ImportJob::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_job: std::string::String,

    /// Optional. The wrapped key material to import.
    ///
    /// Before wrapping, key material must be formatted. If importing symmetric key
    /// material, the expected key material format is plain bytes. If importing
    /// asymmetric key material, the expected key material format is PKCS#8-encoded
    /// DER (the PrivateKeyInfo structure from RFC 5208).
    ///
    /// When wrapping with import methods
    /// ([RSA_OAEP_3072_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]
    /// or
    /// [RSA_OAEP_4096_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256]
    /// or
    /// [RSA_OAEP_3072_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256_AES_256]
    /// or
    /// [RSA_OAEP_4096_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256_AES_256]),
    ///
    /// this field must contain the concatenation of:
    ///
    /// This format is the same as the format produced by PKCS#11 mechanism
    /// CKM_RSA_AES_KEY_WRAP.
    ///
    /// When wrapping with import methods
    /// ([RSA_OAEP_3072_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256]
    /// or
    /// [RSA_OAEP_4096_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256]),
    ///
    /// this field must contain the formatted key to be imported, wrapped with the
    /// [public_key][google.cloud.kms.v1.ImportJob.public_key] using RSAES-OAEP
    /// with SHA-256, MGF1 with SHA-256, and an empty label.
    ///
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]: crate::model::import_job::import_method::RSA_OAEP_3072_SHA1_AES_256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256]: crate::model::import_job::import_method::RSA_OAEP_3072_SHA256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256_AES_256]: crate::model::import_job::import_method::RSA_OAEP_3072_SHA256_AES_256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256]: crate::model::import_job::import_method::RSA_OAEP_4096_SHA1_AES_256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256]: crate::model::import_job::import_method::RSA_OAEP_4096_SHA256
    /// [google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256_AES_256]: crate::model::import_job::import_method::RSA_OAEP_4096_SHA256_AES_256
    /// [google.cloud.kms.v1.ImportJob.public_key]: crate::model::ImportJob::public_key
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub wrapped_key: bytes::Bytes,

    /// This field is legacy. Use the field
    /// [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]
    /// instead.
    ///
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]: crate::model::ImportCryptoKeyVersionRequest::wrapped_key
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub wrapped_key_material:
        std::option::Option<crate::model::import_crypto_key_version_request::WrappedKeyMaterial>,
}

impl ImportCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportCryptoKeyVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [crypto_key_version][crate::model::ImportCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_crypto_key_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_version = v.into();
        self
    }

    /// Sets the value of [algorithm][crate::model::ImportCryptoKeyVersionRequest::algorithm].
    pub fn set_algorithm<
        T: std::convert::Into<crate::model::crypto_key_version::CryptoKeyVersionAlgorithm>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::ImportCryptoKeyVersionRequest::import_job].
    pub fn set_import_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job = v.into();
        self
    }

    /// Sets the value of [wrapped_key][crate::model::ImportCryptoKeyVersionRequest::wrapped_key].
    pub fn set_wrapped_key<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key = v.into();
        self
    }

    /// Sets the value of `wrapped_key_material`.
    pub fn set_wrapped_key_material<
        T: std::convert::Into<
            std::option::Option<
                crate::model::import_crypto_key_version_request::WrappedKeyMaterial,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapped_key_material = v.into();
        self
    }

    /// The value of [wrapped_key_material][crate::model::ImportCryptoKeyVersionRequest::wrapped_key_material]
    /// if it holds a `RsaAesWrappedKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_rsa_aes_wrapped_key(&self) -> std::option::Option<&bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.wrapped_key_material.as_ref().and_then(|v| match v {
            crate::model::import_crypto_key_version_request::WrappedKeyMaterial::RsaAesWrappedKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [wrapped_key_material][crate::model::ImportCryptoKeyVersionRequest::wrapped_key_material]
    /// to hold a `RsaAesWrappedKey`.
    ///
    /// Note that all the setters affecting `wrapped_key_material` are
    /// mutually exclusive.
    pub fn set_rsa_aes_wrapped_key<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.wrapped_key_material = std::option::Option::Some(
            crate::model::import_crypto_key_version_request::WrappedKeyMaterial::RsaAesWrappedKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ImportCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.ImportCryptoKeyVersionRequest"
    }
}

/// Defines additional types related to ImportCryptoKeyVersionRequest
pub mod import_crypto_key_version_request {
    #[allow(unused_imports)]
    use super::*;

    /// This field is legacy. Use the field
    /// [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]
    /// instead.
    ///
    /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]: crate::model::ImportCryptoKeyVersionRequest::wrapped_key
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum WrappedKeyMaterial {
        /// Optional. This field has the same meaning as
        /// [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key].
        /// Prefer to use that field in new work. Either that field or this field
        /// (but not both) must be specified.
        ///
        /// [google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]: crate::model::ImportCryptoKeyVersionRequest::wrapped_key
        RsaAesWrappedKey(bytes::Bytes),
    }
}

/// Request message for
/// [KeyManagementService.CreateImportJob][google.cloud.kms.v1.KeyManagementService.CreateImportJob].
///
/// [google.cloud.kms.v1.KeyManagementService.CreateImportJob]: crate::client::KeyManagementService::create_import_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateImportJobRequest {
    /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
    /// [KeyRing][google.cloud.kms.v1.KeyRing] associated with the
    /// [ImportJobs][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    /// [google.cloud.kms.v1.KeyRing.name]: crate::model::KeyRing::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. It must be unique within a KeyRing and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_job_id: std::string::String,

    /// Required. An [ImportJob][google.cloud.kms.v1.ImportJob] with initial field
    /// values.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_job: std::option::Option<crate::model::ImportJob>,
}

impl CreateImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImportJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_job_id][crate::model::CreateImportJobRequest::import_job_id].
    pub fn set_import_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_job_id = v.into();
        self
    }

    /// Sets the value of [import_job][crate::model::CreateImportJobRequest::import_job].
    pub fn set_import_job<T: std::convert::Into<std::option::Option<crate::model::ImportJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.import_job = v.into();
        self
    }
}

impl wkt::message::Message for CreateImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.CreateImportJobRequest"
    }
}

/// Request message for
/// [KeyManagementService.UpdateCryptoKey][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey].
///
/// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey]: crate::client::KeyManagementService::update_crypto_key
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCryptoKeyRequest {
    /// Required. [CryptoKey][google.cloud.kms.v1.CryptoKey] with updated values.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key: std::option::Option<crate::model::CryptoKey>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateCryptoKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key][crate::model::UpdateCryptoKeyRequest::crypto_key].
    pub fn set_crypto_key<T: std::convert::Into<std::option::Option<crate::model::CryptoKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCryptoKeyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCryptoKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateCryptoKeyRequest"
    }
}

/// Request message for
/// [KeyManagementService.UpdateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion]: crate::client::KeyManagementService::update_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCryptoKeyVersionRequest {
    /// Required. [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
    /// updated values.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key_version: std::option::Option<crate::model::CryptoKeyVersion>,

    /// Required. List of fields to be updated in this request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crypto_key_version][crate::model::UpdateCryptoKeyVersionRequest::crypto_key_version].
    pub fn set_crypto_key_version<
        T: std::convert::Into<std::option::Option<crate::model::CryptoKeyVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_version = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCryptoKeyVersionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateCryptoKeyVersionRequest"
    }
}

/// Request message for
/// [KeyManagementService.UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]: crate::client::KeyManagementService::update_crypto_key_primary_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCryptoKeyPrimaryVersionRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to update.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The id of the child
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use as primary.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_version_id: std::string::String,
}

impl UpdateCryptoKeyPrimaryVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateCryptoKeyPrimaryVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [crypto_key_version_id][crate::model::UpdateCryptoKeyPrimaryVersionRequest::crypto_key_version_id].
    pub fn set_crypto_key_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.crypto_key_version_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCryptoKeyPrimaryVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.UpdateCryptoKeyPrimaryVersionRequest"
    }
}

/// Request message for
/// [KeyManagementService.DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]: crate::client::KeyManagementService::destroy_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestroyCryptoKeyVersionRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to destroy.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DestroyCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DestroyCryptoKeyVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DestroyCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.DestroyCryptoKeyVersionRequest"
    }
}

/// Request message for
/// [KeyManagementService.RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion].
///
/// [google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]: crate::client::KeyManagementService::restore_crypto_key_version
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreCryptoKeyVersionRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to restore.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RestoreCryptoKeyVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreCryptoKeyVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestoreCryptoKeyVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RestoreCryptoKeyVersionRequest"
    }
}

/// Request message for
/// [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] or
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// encryption.
    ///
    /// If a [CryptoKey][google.cloud.kms.v1.CryptoKey] is specified, the server
    /// will use its [primary version][google.cloud.kms.v1.CryptoKey.primary].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.primary]: crate::model::CryptoKey::primary
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The data to encrypt. Must be no larger than 64KiB.
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
    /// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys, the
    /// plaintext must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::protection_level::EXTERNAL
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::protection_level::SOFTWARE
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plaintext: bytes::Bytes,

    /// Optional. Optional data that, if specified, must also be provided during
    /// decryption through
    /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
    /// [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys the
    /// AAD must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]: crate::model::DecryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::protection_level::EXTERNAL
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]: crate::model::protection_level::EXTERNAL_VPC
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::protection_level::SOFTWARE
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub additional_authenticated_data: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext])
    /// is equal to
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.plaintext]: crate::model::EncryptRequest::plaintext
    /// [google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]: crate::model::EncryptRequest::plaintext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "plaintextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data])
    /// is equal to
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]: crate::model::EncryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]: crate::model::EncryptRequest::additional_authenticated_data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "additionalAuthenticatedDataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,
}

impl EncryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [plaintext][crate::model::EncryptRequest::plaintext].
    pub fn set_plaintext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::EncryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::EncryptRequest::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::EncryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for EncryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EncryptRequest"
    }
}

/// Request message for
/// [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DecryptRequest {
    /// Required. The resource name of the
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] to use for decryption. The
    /// server will choose the appropriate version.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The encrypted data originally returned in
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
    ///
    /// [google.cloud.kms.v1.EncryptResponse.ciphertext]: crate::model::EncryptResponse::ciphertext
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ciphertext: bytes::Bytes,

    /// Optional. Optional data that must match the data originally supplied in
    /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
    ///
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]: crate::model::EncryptRequest::additional_authenticated_data
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub additional_authenticated_data: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext])
    /// is equal to
    /// [DecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.DecryptRequest.ciphertext]: crate::model::DecryptRequest::ciphertext
    /// [google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c]: crate::model::DecryptRequest::ciphertext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "ciphertextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data])
    /// is equal to
    /// [DecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]: crate::model::DecryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c]: crate::model::DecryptRequest::additional_authenticated_data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "additionalAuthenticatedDataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,
}

impl DecryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DecryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::DecryptRequest::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::DecryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::DecryptRequest::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::DecryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for DecryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.DecryptRequest"
    }
}

/// Request message for
/// [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawEncrypt]: crate::client::KeyManagementService::raw_encrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawEncryptRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The data to encrypt. Must be no larger than 64KiB.
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
    /// plaintext must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::protection_level::SOFTWARE
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plaintext: bytes::Bytes,

    /// Optional. Optional data that, if specified, must also be provided during
    /// decryption through
    /// [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
    ///
    /// This field may only be used in conjunction with an
    /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm] that accepts
    /// additional authenticated data (for example, AES-GCM).
    ///
    /// The maximum size depends on the key version's
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
    /// For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
    /// plaintext must be no larger than 64KiB. For
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
    /// the plaintext and additional_authenticated_data fields must be no larger
    /// than 8KiB.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion.algorithm]: crate::model::CryptoKeyVersion::algorithm
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    /// [google.cloud.kms.v1.ProtectionLevel.SOFTWARE]: crate::model::protection_level::SOFTWARE
    /// [google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data]: crate::model::RawDecryptRequest::additional_authenticated_data
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub additional_authenticated_data: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [RawEncryptRequest.plaintext][google.cloud.kms.v1.RawEncryptRequest.plaintext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received plaintext using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that CRC32C(plaintext) is equal
    /// to plaintext_crc32c, and if so, perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.plaintext]: crate::model::RawEncryptRequest::plaintext
    #[serde(rename = "plaintextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received additional_authenticated_data using
    /// this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(additional_authenticated_data) is equal to
    /// additional_authenticated_data_crc32c, and if so, perform
    /// a limited number of retries. A persistent mismatch may indicate an issue in
    /// your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data]: crate::model::RawEncryptRequest::additional_authenticated_data
    #[serde(rename = "additionalAuthenticatedDataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. A customer-supplied initialization vector that will be used for
    /// encryption. If it is not provided for AES-CBC and AES-CTR, one will be
    /// generated. It will be returned in
    /// [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.initialization_vector]: crate::model::RawEncryptResponse::initialization_vector
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub initialization_vector: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [RawEncryptRequest.initialization_vector][google.cloud.kms.v1.RawEncryptRequest.initialization_vector].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received initialization_vector using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(initialization_vector) is equal to
    /// initialization_vector_crc32c, and if so, perform
    /// a limited number of retries. A persistent mismatch may indicate an issue in
    /// your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.initialization_vector]: crate::model::RawEncryptRequest::initialization_vector
    #[serde(rename = "initializationVectorCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub initialization_vector_crc32c: std::option::Option<wkt::Int64Value>,
}

impl RawEncryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RawEncryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [plaintext][crate::model::RawEncryptRequest::plaintext].
    pub fn set_plaintext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::RawEncryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::RawEncryptRequest::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::RawEncryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [initialization_vector][crate::model::RawEncryptRequest::initialization_vector].
    pub fn set_initialization_vector<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.initialization_vector = v.into();
        self
    }

    /// Sets the value of [initialization_vector_crc32c][crate::model::RawEncryptRequest::initialization_vector_crc32c].
    pub fn set_initialization_vector_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initialization_vector_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for RawEncryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawEncryptRequest"
    }
}

/// Request message for
/// [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawDecrypt]: crate::client::KeyManagementService::raw_decrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawDecryptRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The encrypted data originally returned in
    /// [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.ciphertext]: crate::model::RawEncryptResponse::ciphertext
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ciphertext: bytes::Bytes,

    /// Optional. Optional data that must match the data originally supplied in
    /// [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
    ///
    /// [google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data]: crate::model::RawEncryptRequest::additional_authenticated_data
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub additional_authenticated_data: bytes::Bytes,

    /// Required. The initialization vector (IV) used during encryption, which must
    /// match the data originally provided in
    /// [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.initialization_vector]: crate::model::RawEncryptResponse::initialization_vector
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub initialization_vector: bytes::Bytes,

    /// The length of the authentication tag that is appended to the end of
    /// the ciphertext. If unspecified (0), the default value for the key's
    /// algorithm will be used (for AES-GCM, the default value is 16).
    pub tag_length: i32,

    /// Optional. An optional CRC32C checksum of the
    /// [RawDecryptRequest.ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received ciphertext using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that CRC32C(ciphertext) is equal
    /// to ciphertext_crc32c, and if so, perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.ciphertext]: crate::model::RawDecryptRequest::ciphertext
    #[serde(rename = "ciphertextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received additional_authenticated_data using
    /// this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(additional_authenticated_data) is equal to
    /// additional_authenticated_data_crc32c, and if so, perform
    /// a limited number of retries. A persistent mismatch may indicate an issue in
    /// your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data]: crate::model::RawDecryptRequest::additional_authenticated_data
    #[serde(rename = "additionalAuthenticatedDataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub additional_authenticated_data_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. An optional CRC32C checksum of the
    /// [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received initialization_vector using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C(initialization_vector) is equal to initialization_vector_crc32c, and
    /// if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum.
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.initialization_vector]: crate::model::RawDecryptRequest::initialization_vector
    #[serde(rename = "initializationVectorCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub initialization_vector_crc32c: std::option::Option<wkt::Int64Value>,
}

impl RawDecryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RawDecryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::RawDecryptRequest::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data][crate::model::RawDecryptRequest::additional_authenticated_data].
    pub fn set_additional_authenticated_data<T: std::convert::Into<bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data = v.into();
        self
    }

    /// Sets the value of [initialization_vector][crate::model::RawDecryptRequest::initialization_vector].
    pub fn set_initialization_vector<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.initialization_vector = v.into();
        self
    }

    /// Sets the value of [tag_length][crate::model::RawDecryptRequest::tag_length].
    pub fn set_tag_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.tag_length = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::RawDecryptRequest::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [additional_authenticated_data_crc32c][crate::model::RawDecryptRequest::additional_authenticated_data_crc32c].
    pub fn set_additional_authenticated_data_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [initialization_vector_crc32c][crate::model::RawDecryptRequest::initialization_vector_crc32c].
    pub fn set_initialization_vector_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initialization_vector_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for RawDecryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawDecryptRequest"
    }
}

/// Request message for
/// [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricSign]: crate::client::KeyManagementService::asymmetric_sign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsymmetricSignRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The digest of the data to sign. The digest must be produced with
    /// the same digest algorithm as specified by the key version's
    /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm].
    ///
    /// This field may not be supplied if
    /// [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
    /// is supplied.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data]: crate::model::AsymmetricSignRequest::data
    /// [google.cloud.kms.v1.CryptoKeyVersion.algorithm]: crate::model::CryptoKeyVersion::algorithm
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub digest: std::option::Option<crate::model::Digest>,

    /// Optional. An optional CRC32C checksum of the
    /// [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest])
    /// is equal to
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest]: crate::model::AsymmetricSignRequest::digest
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]: crate::model::AsymmetricSignRequest::digest_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "digestCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub digest_crc32c: std::option::Option<wkt::Int64Value>,

    /// Optional. The data to sign.
    /// It can't be supplied if
    /// [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
    /// is supplied.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest]: crate::model::AsymmetricSignRequest::digest
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data])
    /// is equal to
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data]: crate::model::AsymmetricSignRequest::data
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]: crate::model::AsymmetricSignRequest::data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "dataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_crc32c: std::option::Option<wkt::Int64Value>,
}

impl AsymmetricSignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AsymmetricSignRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [digest][crate::model::AsymmetricSignRequest::digest].
    pub fn set_digest<T: std::convert::Into<std::option::Option<crate::model::Digest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.digest = v.into();
        self
    }

    /// Sets the value of [digest_crc32c][crate::model::AsymmetricSignRequest::digest_crc32c].
    pub fn set_digest_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.digest_crc32c = v.into();
        self
    }

    /// Sets the value of [data][crate::model::AsymmetricSignRequest::data].
    pub fn set_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::AsymmetricSignRequest::data_crc32c].
    pub fn set_data_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for AsymmetricSignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricSignRequest"
    }
}

/// Request message for
/// [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]: crate::client::KeyManagementService::asymmetric_decrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsymmetricDecryptRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The data encrypted with the named
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s public key using
    /// OAEP.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ciphertext: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext].
    /// If specified,
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// verify the integrity of the received
    /// [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]
    /// using this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext])
    /// is equal to
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]: crate::model::AsymmetricDecryptRequest::ciphertext
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]: crate::model::AsymmetricDecryptRequest::ciphertext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "ciphertextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,
}

impl AsymmetricDecryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AsymmetricDecryptRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::AsymmetricDecryptRequest::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::AsymmetricDecryptRequest::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ciphertext_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for AsymmetricDecryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricDecryptRequest"
    }
}

/// Request message for
/// [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
///
/// [google.cloud.kms.v1.KeyManagementService.MacSign]: crate::client::KeyManagementService::mac_sign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MacSignRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The data to sign. The MAC tag is computed over this data field
    /// based on the specific algorithm.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]. If
    /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will verify the integrity of the received
    /// [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]) is
    /// equal to
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacSignRequest.data]: crate::model::MacSignRequest::data
    /// [google.cloud.kms.v1.MacSignRequest.data_crc32c]: crate::model::MacSignRequest::data_crc32c
    #[serde(rename = "dataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_crc32c: std::option::Option<wkt::Int64Value>,
}

impl MacSignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacSignRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::MacSignRequest::data].
    pub fn set_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::MacSignRequest::data_crc32c].
    pub fn set_data_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for MacSignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacSignRequest"
    }
}

/// Request message for
/// [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
///
/// [google.cloud.kms.v1.KeyManagementService.MacVerify]: crate::client::KeyManagementService::mac_verify
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MacVerifyRequest {
    /// Required. The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
    /// verification.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The data used previously as a
    /// [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] to generate
    /// the MAC tag.
    ///
    /// [google.cloud.kms.v1.MacSignRequest.data]: crate::model::MacSignRequest::data
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data]. If
    /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will verify the integrity of the received
    /// [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] using
    /// this checksum.
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
    /// report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data])
    /// is equal to
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.data]: crate::model::MacVerifyRequest::data
    /// [google.cloud.kms.v1.MacVerifyRequest.data_crc32c]: crate::model::MacVerifyRequest::data_crc32c
    #[serde(rename = "dataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_crc32c: std::option::Option<wkt::Int64Value>,

    /// Required. The signature to verify.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub mac: bytes::Bytes,

    /// Optional. An optional CRC32C checksum of the
    /// [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac]. If
    /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will verify the integrity of the received
    /// [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] using this
    /// checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
    /// will report an error if the checksum verification fails. If you receive a
    /// checksum error, your client should verify that
    /// CRC32C([MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac]) is
    /// equal to
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c],
    /// and if so, perform a limited number of retries. A persistent mismatch may
    /// indicate an issue in your computation of the CRC32C checksum. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.mac]: crate::model::MacVerifyRequest::mac
    /// [google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]: crate::model::MacVerifyRequest::mac_crc32c
    #[serde(rename = "macCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub mac_crc32c: std::option::Option<wkt::Int64Value>,
}

impl MacVerifyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacVerifyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::MacVerifyRequest::data].
    pub fn set_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::MacVerifyRequest::data_crc32c].
    pub fn set_data_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_crc32c = v.into();
        self
    }

    /// Sets the value of [mac][crate::model::MacVerifyRequest::mac].
    pub fn set_mac<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.mac = v.into();
        self
    }

    /// Sets the value of [mac_crc32c][crate::model::MacVerifyRequest::mac_crc32c].
    pub fn set_mac_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mac_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for MacVerifyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacVerifyRequest"
    }
}

/// Request message for
/// [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
///
/// [google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes]: crate::client::KeyManagementService::generate_random_bytes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateRandomBytesRequest {
    /// The project-specific location in which to generate random bytes.
    /// For example, "projects/my-project/locations/us-central1".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The length in bytes of the amount of randomness to retrieve.  Minimum 8
    /// bytes, maximum 1024 bytes.
    pub length_bytes: i32,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when
    /// generating the random data. Currently, only
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] protection level is
    /// supported.
    ///
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    pub protection_level: crate::model::ProtectionLevel,
}

impl GenerateRandomBytesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::GenerateRandomBytesRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [length_bytes][crate::model::GenerateRandomBytesRequest::length_bytes].
    pub fn set_length_bytes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.length_bytes = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::GenerateRandomBytesRequest::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for GenerateRandomBytesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GenerateRandomBytesRequest"
    }
}

/// Response message for
/// [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptResponse {
    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption. Check this field to verify that the intended resource was used
    /// for encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The encrypted data.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ciphertext: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
    /// An integrity check of
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
    /// can be performed by computing the CRC32C checksum of
    /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.EncryptResponse.ciphertext]: crate::model::EncryptResponse::ciphertext
    #[serde(rename = "ciphertextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]. A false value of
    /// this field indicates either that
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.plaintext]: crate::model::EncryptRequest::plaintext
    /// [google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]: crate::model::EncryptRequest::plaintext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "verifiedPlaintextCrc32c")]
    pub verified_plaintext_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [AAD][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]. A
    /// false value of this field indicates either that
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]: crate::model::EncryptRequest::additional_authenticated_data
    /// [google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]: crate::model::EncryptRequest::additional_authenticated_data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "verifiedAdditionalAuthenticatedDataCrc32c")]
    pub verified_additional_authenticated_data_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl EncryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ciphertext][crate::model::EncryptResponse::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::EncryptResponse::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_plaintext_crc32c][crate::model::EncryptResponse::verified_plaintext_crc32c].
    pub fn set_verified_plaintext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_additional_authenticated_data_crc32c][crate::model::EncryptResponse::verified_additional_authenticated_data_crc32c].
    pub fn set_verified_additional_authenticated_data_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::EncryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for EncryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.EncryptResponse"
    }
}

/// Response message for
/// [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DecryptResponse {
    /// The decrypted data originally supplied in
    /// [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
    ///
    /// [google.cloud.kms.v1.EncryptRequest.plaintext]: crate::model::EncryptRequest::plaintext
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plaintext: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext].
    /// An integrity check of
    /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
    /// can be performed by computing the CRC32C checksum of
    /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: receiving this response message indicates that
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
    /// successfully decrypt the
    /// [ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]. Note: This
    /// field is defined as int64 for reasons of compatibility across different
    /// languages. However, it is a non-negative integer, which will never exceed
    /// 2^32-1, and can be safely downconverted to uint32 in languages that support
    /// this type.
    ///
    /// [google.cloud.kms.v1.DecryptRequest.ciphertext]: crate::model::DecryptRequest::ciphertext
    /// [google.cloud.kms.v1.DecryptResponse.plaintext]: crate::model::DecryptResponse::plaintext
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "plaintextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Whether the Decryption was performed using the primary key version.
    pub used_primary: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl DecryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plaintext][crate::model::DecryptResponse::plaintext].
    pub fn set_plaintext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::DecryptResponse::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [used_primary][crate::model::DecryptResponse::used_primary].
    pub fn set_used_primary<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.used_primary = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::DecryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for DecryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.DecryptResponse"
    }
}

/// Response message for
/// [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawEncrypt]: crate::client::KeyManagementService::raw_encrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawEncryptResponse {
    /// The encrypted data. In the case of AES-GCM, the authentication tag
    /// is the [tag_length][google.cloud.kms.v1.RawEncryptResponse.tag_length]
    /// bytes at the end of this field.
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.tag_length]: crate::model::RawEncryptResponse::tag_length
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub ciphertext: bytes::Bytes,

    /// The initialization vector (IV) generated by the service during
    /// encryption. This value must be stored and provided in
    /// [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector]
    /// at decryption time.
    ///
    /// [google.cloud.kms.v1.RawDecryptRequest.initialization_vector]: crate::model::RawDecryptRequest::initialization_vector
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub initialization_vector: bytes::Bytes,

    /// The length of the authentication tag that is appended to
    /// the end of the ciphertext.
    pub tag_length: i32,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
    /// An integrity check of ciphertext can be performed by computing the CRC32C
    /// checksum of ciphertext and comparing your results to this field. Discard
    /// the response in case of non-matching checksum values, and perform a limited
    /// number of retries. A persistent mismatch may indicate an issue in your
    /// computation of the CRC32C checksum. Note: This field is defined as int64
    /// for reasons of compatibility across different languages. However, it is a
    /// non-negative integer, which will never exceed 2^32-1, and can be safely
    /// downconverted to uint32 in languages that support this type.
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.ciphertext]: crate::model::RawEncryptResponse::ciphertext
    #[serde(rename = "ciphertextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub ciphertext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
    /// An integrity check of initialization_vector can be performed by computing
    /// the CRC32C checksum of initialization_vector and comparing your results to
    /// this field. Discard the response in case of non-matching checksum values,
    /// and perform a limited number of retries. A persistent mismatch may indicate
    /// an issue in your computation of the CRC32C checksum. Note: This field is
    /// defined as int64 for reasons of compatibility across different languages.
    /// However, it is a non-negative integer, which will never exceed 2^32-1, and
    /// can be safely downconverted to uint32 in languages that support this type.
    ///
    /// [google.cloud.kms.v1.RawEncryptResponse.initialization_vector]: crate::model::RawEncryptResponse::initialization_vector
    #[serde(rename = "initializationVectorCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub initialization_vector_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the plaintext. A false value of this
    /// field indicates either that
    /// [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]: crate::model::RawEncryptRequest::plaintext_crc32c
    #[serde(rename = "verifiedPlaintextCrc32c")]
    pub verified_plaintext_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of additional_authenticated_data. A false
    /// value of this field indicates either that //
    /// [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]: crate::model::RawEncryptRequest::additional_authenticated_data_crc32c
    #[serde(rename = "verifiedAdditionalAuthenticatedDataCrc32c")]
    pub verified_additional_authenticated_data_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of initialization_vector. A false value of
    /// this field indicates either that
    /// [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]: crate::model::RawEncryptRequest::initialization_vector_crc32c
    #[serde(rename = "verifiedInitializationVectorCrc32c")]
    pub verified_initialization_vector_crc32c: bool,

    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption. Check this field to verify that the intended resource was used
    /// for encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// encryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl RawEncryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ciphertext][crate::model::RawEncryptResponse::ciphertext].
    pub fn set_ciphertext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.ciphertext = v.into();
        self
    }

    /// Sets the value of [initialization_vector][crate::model::RawEncryptResponse::initialization_vector].
    pub fn set_initialization_vector<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.initialization_vector = v.into();
        self
    }

    /// Sets the value of [tag_length][crate::model::RawEncryptResponse::tag_length].
    pub fn set_tag_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.tag_length = v.into();
        self
    }

    /// Sets the value of [ciphertext_crc32c][crate::model::RawEncryptResponse::ciphertext_crc32c].
    pub fn set_ciphertext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [initialization_vector_crc32c][crate::model::RawEncryptResponse::initialization_vector_crc32c].
    pub fn set_initialization_vector_crc32c<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initialization_vector_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_plaintext_crc32c][crate::model::RawEncryptResponse::verified_plaintext_crc32c].
    pub fn set_verified_plaintext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_additional_authenticated_data_crc32c][crate::model::RawEncryptResponse::verified_additional_authenticated_data_crc32c].
    pub fn set_verified_additional_authenticated_data_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_initialization_vector_crc32c][crate::model::RawEncryptResponse::verified_initialization_vector_crc32c].
    pub fn set_verified_initialization_vector_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_initialization_vector_crc32c = v.into();
        self
    }

    /// Sets the value of [name][crate::model::RawEncryptResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::RawEncryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for RawEncryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawEncryptResponse"
    }
}

/// Response message for
/// [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.RawDecrypt]: crate::client::KeyManagementService::raw_decrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RawDecryptResponse {
    /// The decrypted data.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plaintext: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [RawDecryptResponse.plaintext][google.cloud.kms.v1.RawDecryptResponse.plaintext].
    /// An integrity check of plaintext can be performed by computing the CRC32C
    /// checksum of plaintext and comparing your results to this field. Discard the
    /// response in case of non-matching checksum values, and perform a limited
    /// number of retries. A persistent mismatch may indicate an issue in your
    /// computation of the CRC32C checksum. Note: receiving this response message
    /// indicates that
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
    /// successfully decrypt the
    /// [ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
    /// Note: This field is defined as int64 for reasons of compatibility across
    /// different languages. However, it is a non-negative integer, which will
    /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
    /// that support this type.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.ciphertext]: crate::model::RawDecryptRequest::ciphertext
    /// [google.cloud.kms.v1.RawDecryptResponse.plaintext]: crate::model::RawDecryptResponse::plaintext
    #[serde(rename = "plaintextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,

    /// Integrity verification field. A flag indicating whether
    /// [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the ciphertext. A false value of this
    /// field indicates either that
    /// [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]: crate::model::RawDecryptRequest::ciphertext_crc32c
    #[serde(rename = "verifiedCiphertextCrc32c")]
    pub verified_ciphertext_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of additional_authenticated_data. A false
    /// value of this field indicates either that //
    /// [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]: crate::model::RawDecryptRequest::additional_authenticated_data_crc32c
    #[serde(rename = "verifiedAdditionalAuthenticatedDataCrc32c")]
    pub verified_additional_authenticated_data_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of initialization_vector. A false value of
    /// this field indicates either that
    /// [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]: crate::model::RawDecryptRequest::initialization_vector_crc32c
    #[serde(rename = "verifiedInitializationVectorCrc32c")]
    pub verified_initialization_vector_crc32c: bool,
}

impl RawDecryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plaintext][crate::model::RawDecryptResponse::plaintext].
    pub fn set_plaintext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::RawDecryptResponse::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::RawDecryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }

    /// Sets the value of [verified_ciphertext_crc32c][crate::model::RawDecryptResponse::verified_ciphertext_crc32c].
    pub fn set_verified_ciphertext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_additional_authenticated_data_crc32c][crate::model::RawDecryptResponse::verified_additional_authenticated_data_crc32c].
    pub fn set_verified_additional_authenticated_data_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_additional_authenticated_data_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_initialization_vector_crc32c][crate::model::RawDecryptResponse::verified_initialization_vector_crc32c].
    pub fn set_verified_initialization_vector_crc32c<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.verified_initialization_vector_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for RawDecryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.RawDecryptResponse"
    }
}

/// Response message for
/// [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricSign]: crate::client::KeyManagementService::asymmetric_sign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsymmetricSignResponse {
    /// The created signature.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub signature: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature].
    /// An integrity check of
    /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
    /// can be performed by computing the CRC32C checksum of
    /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignResponse.signature]: crate::model::AsymmetricSignResponse::signature
    #[serde(rename = "signatureCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub signature_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]. A false value
    /// of this field indicates either that
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest]: crate::model::AsymmetricSignRequest::digest
    /// [google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]: crate::model::AsymmetricSignRequest::digest_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "verifiedDigestCrc32c")]
    pub verified_digest_crc32c: bool,

    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    /// Check this field to verify that the intended resource was used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Integrity verification field. A flag indicating whether
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.AsymmetricSignRequest.data]. A false value of
    /// this field indicates either that
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data]: crate::model::AsymmetricSignRequest::data
    /// [google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]: crate::model::AsymmetricSignRequest::data_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "verifiedDataCrc32c")]
    pub verified_data_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl AsymmetricSignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signature][crate::model::AsymmetricSignResponse::signature].
    pub fn set_signature<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [signature_crc32c][crate::model::AsymmetricSignResponse::signature_crc32c].
    pub fn set_signature_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.signature_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_digest_crc32c][crate::model::AsymmetricSignResponse::verified_digest_crc32c].
    pub fn set_verified_digest_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_digest_crc32c = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AsymmetricSignResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [verified_data_crc32c][crate::model::AsymmetricSignResponse::verified_data_crc32c].
    pub fn set_verified_data_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_data_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::AsymmetricSignResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for AsymmetricSignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricSignResponse"
    }
}

/// Response message for
/// [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
///
/// [google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]: crate::client::KeyManagementService::asymmetric_decrypt
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsymmetricDecryptResponse {
    /// The decrypted data originally encrypted with the matching public key.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub plaintext: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext].
    /// An integrity check of
    /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
    /// can be performed by computing the CRC32C checksum of
    /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]: crate::model::AsymmetricDecryptResponse::plaintext
    #[serde(rename = "plaintextCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub plaintext_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]. A
    /// false value of this field indicates either that
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]: crate::model::AsymmetricDecryptRequest::ciphertext
    /// [google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]: crate::model::AsymmetricDecryptRequest::ciphertext_crc32c
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    #[serde(rename = "verifiedCiphertextCrc32c")]
    pub verified_ciphertext_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
    /// decryption.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl AsymmetricDecryptResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [plaintext][crate::model::AsymmetricDecryptResponse::plaintext].
    pub fn set_plaintext<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.plaintext = v.into();
        self
    }

    /// Sets the value of [plaintext_crc32c][crate::model::AsymmetricDecryptResponse::plaintext_crc32c].
    pub fn set_plaintext_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.plaintext_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_ciphertext_crc32c][crate::model::AsymmetricDecryptResponse::verified_ciphertext_crc32c].
    pub fn set_verified_ciphertext_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_ciphertext_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::AsymmetricDecryptResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for AsymmetricDecryptResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.AsymmetricDecryptResponse"
    }
}

/// Response message for
/// [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
///
/// [google.cloud.kms.v1.KeyManagementService.MacSign]: crate::client::KeyManagementService::mac_sign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MacSignResponse {
    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    /// Check this field to verify that the intended resource was used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The created signature.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub mac: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac]. An
    /// integrity check of
    /// [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] can be
    /// performed by computing the CRC32C checksum of
    /// [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] and
    /// comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.MacSignResponse.mac]: crate::model::MacSignResponse::mac
    #[serde(rename = "macCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub mac_crc32c: std::option::Option<wkt::Int64Value>,

    /// Integrity verification field. A flag indicating whether
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.MacSignRequest.data]. A false value of this
    /// field indicates either that
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacSignRequest.data]: crate::model::MacSignRequest::data
    /// [google.cloud.kms.v1.MacSignRequest.data_crc32c]: crate::model::MacSignRequest::data_crc32c
    #[serde(rename = "verifiedDataCrc32c")]
    pub verified_data_crc32c: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl MacSignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacSignResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mac][crate::model::MacSignResponse::mac].
    pub fn set_mac<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.mac = v.into();
        self
    }

    /// Sets the value of [mac_crc32c][crate::model::MacSignResponse::mac_crc32c].
    pub fn set_mac_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mac_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_data_crc32c][crate::model::MacSignResponse::verified_data_crc32c].
    pub fn set_verified_data_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_data_crc32c = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::MacSignResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for MacSignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacSignResponse"
    }
}

/// Response message for
/// [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
///
/// [google.cloud.kms.v1.KeyManagementService.MacVerify]: crate::client::KeyManagementService::mac_verify
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MacVerifyResponse {
    /// The resource name of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
    /// verification. Check this field to verify that the intended resource was
    /// used for verification.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// This field indicates whether or not the verification operation for
    /// [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] over
    /// [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] was
    /// successful.
    ///
    /// [google.cloud.kms.v1.MacVerifyRequest.data]: crate::model::MacVerifyRequest::data
    /// [google.cloud.kms.v1.MacVerifyRequest.mac]: crate::model::MacVerifyRequest::mac
    pub success: bool,

    /// Integrity verification field. A flag indicating whether
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.MacVerifyRequest.data]. A false value of this
    /// field indicates either that
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.data]: crate::model::MacVerifyRequest::data
    /// [google.cloud.kms.v1.MacVerifyRequest.data_crc32c]: crate::model::MacVerifyRequest::data_crc32c
    #[serde(rename = "verifiedDataCrc32c")]
    pub verified_data_crc32c: bool,

    /// Integrity verification field. A flag indicating whether
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
    /// was received by
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
    /// for the integrity verification of the
    /// [data][google.cloud.kms.v1.MacVerifyRequest.mac]. A false value of this
    /// field indicates either that
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
    /// was left unset or that it was not delivered to
    /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
    /// set
    /// [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
    /// but this field is still false, discard the response and perform a limited
    /// number of retries.
    ///
    /// [google.cloud.kms.v1.KeyManagementService]: crate::client::KeyManagementService
    /// [google.cloud.kms.v1.MacVerifyRequest.mac]: crate::model::MacVerifyRequest::mac
    /// [google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]: crate::model::MacVerifyRequest::mac_crc32c
    #[serde(rename = "verifiedMacCrc32c")]
    pub verified_mac_crc32c: bool,

    /// Integrity verification field. This value is used for the integrity
    /// verification of [MacVerifyResponse.success]. If the value of this field
    /// contradicts the value of [MacVerifyResponse.success], discard the response
    /// and perform a limited number of retries.
    pub verified_success_integrity: bool,

    /// The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
    /// verification.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
    pub protection_level: crate::model::ProtectionLevel,
}

impl MacVerifyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MacVerifyResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [success][crate::model::MacVerifyResponse::success].
    pub fn set_success<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.success = v.into();
        self
    }

    /// Sets the value of [verified_data_crc32c][crate::model::MacVerifyResponse::verified_data_crc32c].
    pub fn set_verified_data_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_data_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_mac_crc32c][crate::model::MacVerifyResponse::verified_mac_crc32c].
    pub fn set_verified_mac_crc32c<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_mac_crc32c = v.into();
        self
    }

    /// Sets the value of [verified_success_integrity][crate::model::MacVerifyResponse::verified_success_integrity].
    pub fn set_verified_success_integrity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verified_success_integrity = v.into();
        self
    }

    /// Sets the value of [protection_level][crate::model::MacVerifyResponse::protection_level].
    pub fn set_protection_level<T: std::convert::Into<crate::model::ProtectionLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.protection_level = v.into();
        self
    }
}

impl wkt::message::Message for MacVerifyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.MacVerifyResponse"
    }
}

/// Response message for
/// [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
///
/// [google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes]: crate::client::KeyManagementService::generate_random_bytes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateRandomBytesResponse {
    /// The generated data.
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub data: bytes::Bytes,

    /// Integrity verification field. A CRC32C checksum of the returned
    /// [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data].
    /// An integrity check of
    /// [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
    /// can be performed by computing the CRC32C checksum of
    /// [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
    /// and comparing your results to this field. Discard the response in case of
    /// non-matching checksum values, and perform a limited number of retries. A
    /// persistent mismatch may indicate an issue in your computation of the CRC32C
    /// checksum. Note: This field is defined as int64 for reasons of compatibility
    /// across different languages. However, it is a non-negative integer, which
    /// will never exceed 2^32-1, and can be safely downconverted to uint32 in
    /// languages that support this type.
    ///
    /// [google.cloud.kms.v1.GenerateRandomBytesResponse.data]: crate::model::GenerateRandomBytesResponse::data
    #[serde(rename = "dataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_crc32c: std::option::Option<wkt::Int64Value>,
}

impl GenerateRandomBytesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::GenerateRandomBytesResponse::data].
    pub fn set_data<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::GenerateRandomBytesResponse::data_crc32c].
    pub fn set_data_crc32c<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_crc32c = v.into();
        self
    }
}

impl wkt::message::Message for GenerateRandomBytesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.GenerateRandomBytesResponse"
    }
}

/// A [Digest][google.cloud.kms.v1.Digest] holds a cryptographic message digest.
///
/// [google.cloud.kms.v1.Digest]: crate::model::Digest
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Digest {
    /// Required. The message digest.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub digest: std::option::Option<crate::model::digest::Digest>,
}

impl Digest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `digest`.
    pub fn set_digest<T: std::convert::Into<std::option::Option<crate::model::digest::Digest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.digest = v.into();
        self
    }

    /// The value of [digest][crate::model::Digest::digest]
    /// if it holds a `Sha256`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sha256(&self) -> std::option::Option<&bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.digest.as_ref().and_then(|v| match v {
            crate::model::digest::Digest::Sha256(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [digest][crate::model::Digest::digest]
    /// if it holds a `Sha384`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sha384(&self) -> std::option::Option<&bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.digest.as_ref().and_then(|v| match v {
            crate::model::digest::Digest::Sha384(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [digest][crate::model::Digest::digest]
    /// if it holds a `Sha512`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sha512(&self) -> std::option::Option<&bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.digest.as_ref().and_then(|v| match v {
            crate::model::digest::Digest::Sha512(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [digest][crate::model::Digest::digest]
    /// to hold a `Sha256`.
    ///
    /// Note that all the setters affecting `digest` are
    /// mutually exclusive.
    pub fn set_sha256<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest = std::option::Option::Some(crate::model::digest::Digest::Sha256(v.into()));
        self
    }

    /// Sets the value of [digest][crate::model::Digest::digest]
    /// to hold a `Sha384`.
    ///
    /// Note that all the setters affecting `digest` are
    /// mutually exclusive.
    pub fn set_sha384<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest = std::option::Option::Some(crate::model::digest::Digest::Sha384(v.into()));
        self
    }

    /// Sets the value of [digest][crate::model::Digest::digest]
    /// to hold a `Sha512`.
    ///
    /// Note that all the setters affecting `digest` are
    /// mutually exclusive.
    pub fn set_sha512<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.digest = std::option::Option::Some(crate::model::digest::Digest::Sha512(v.into()));
        self
    }
}

impl wkt::message::Message for Digest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.Digest"
    }
}

/// Defines additional types related to Digest
pub mod digest {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The message digest.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Digest {
        /// A message digest produced with the SHA-256 algorithm.
        Sha256(bytes::Bytes),
        /// A message digest produced with the SHA-384 algorithm.
        Sha384(bytes::Bytes),
        /// A message digest produced with the SHA-512 algorithm.
        Sha512(bytes::Bytes),
    }
}

/// Cloud KMS metadata for the given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
    /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] can be created in this
    /// location.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.HSM]: crate::model::protection_level::HSM
    pub hsm_available: bool,

    /// Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
    /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
    /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] can be created in
    /// this location.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]: crate::model::CryptoKeyVersionTemplate::protection_level
    /// [google.cloud.kms.v1.ProtectionLevel.EXTERNAL]: crate::model::protection_level::EXTERNAL
    pub ekm_available: bool,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hsm_available][crate::model::LocationMetadata::hsm_available].
    pub fn set_hsm_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hsm_available = v.into();
        self
    }

    /// Sets the value of [ekm_available][crate::model::LocationMetadata::ekm_available].
    pub fn set_ekm_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ekm_available = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.kms.v1.LocationMetadata"
    }
}

/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] specifies how
/// cryptographic operations are performed. For more information, see [Protection
/// levels] (<https://cloud.google.com/kms/docs/algorithms#protection_levels>).
///
/// [google.cloud.kms.v1.ProtectionLevel]: crate::model::ProtectionLevel
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ProtectionLevel(std::borrow::Cow<'static, str>);

impl ProtectionLevel {
    /// Creates a new ProtectionLevel instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ProtectionLevel](ProtectionLevel)
pub mod protection_level {
    use super::ProtectionLevel;

    /// Not specified.
    pub const PROTECTION_LEVEL_UNSPECIFIED: ProtectionLevel =
        ProtectionLevel::new("PROTECTION_LEVEL_UNSPECIFIED");

    /// Crypto operations are performed in software.
    pub const SOFTWARE: ProtectionLevel = ProtectionLevel::new("SOFTWARE");

    /// Crypto operations are performed in a Hardware Security Module.
    pub const HSM: ProtectionLevel = ProtectionLevel::new("HSM");

    /// Crypto operations are performed by an external key manager.
    pub const EXTERNAL: ProtectionLevel = ProtectionLevel::new("EXTERNAL");

    /// Crypto operations are performed in an EKM-over-VPC backend.
    pub const EXTERNAL_VPC: ProtectionLevel = ProtectionLevel::new("EXTERNAL_VPC");
}

impl std::convert::From<std::string::String> for ProtectionLevel {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for ProtectionLevel {
    fn default() -> Self {
        protection_level::PROTECTION_LEVEL_UNSPECIFIED
    }
}

/// Describes the reason for a data access. Please refer to
/// <https://cloud.google.com/assured-workloads/key-access-justifications/docs/justification-codes>
/// for the detailed semantic meaning of justification reason codes.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct AccessReason(std::borrow::Cow<'static, str>);

impl AccessReason {
    /// Creates a new AccessReason instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [AccessReason](AccessReason)
pub mod access_reason {
    use super::AccessReason;

    /// Unspecified access reason.
    pub const REASON_UNSPECIFIED: AccessReason = AccessReason::new("REASON_UNSPECIFIED");

    /// Customer-initiated support.
    pub const CUSTOMER_INITIATED_SUPPORT: AccessReason =
        AccessReason::new("CUSTOMER_INITIATED_SUPPORT");

    /// Google-initiated access for system management and troubleshooting.
    pub const GOOGLE_INITIATED_SERVICE: AccessReason =
        AccessReason::new("GOOGLE_INITIATED_SERVICE");

    /// Google-initiated access in response to a legal request or legal process.
    pub const THIRD_PARTY_DATA_REQUEST: AccessReason =
        AccessReason::new("THIRD_PARTY_DATA_REQUEST");

    /// Google-initiated access for security, fraud, abuse, or compliance purposes.
    pub const GOOGLE_INITIATED_REVIEW: AccessReason = AccessReason::new("GOOGLE_INITIATED_REVIEW");

    /// Customer uses their account to perform any access to their own data which
    /// their IAM policy authorizes.
    pub const CUSTOMER_INITIATED_ACCESS: AccessReason =
        AccessReason::new("CUSTOMER_INITIATED_ACCESS");

    /// Google systems access customer data to help optimize the structure of the
    /// data or quality for future uses by the customer.
    pub const GOOGLE_INITIATED_SYSTEM_OPERATION: AccessReason =
        AccessReason::new("GOOGLE_INITIATED_SYSTEM_OPERATION");

    /// No reason is expected for this key request.
    pub const REASON_NOT_EXPECTED: AccessReason = AccessReason::new("REASON_NOT_EXPECTED");

    /// Customer uses their account to perform any access to their own data which
    /// their IAM policy authorizes, and one of the following is true:
    ///
    /// * A Google administrator has reset the root-access account associated with
    ///   the user's organization within the past 7 days.
    /// * A Google-initiated emergency access operation has interacted with a
    ///   resource in the same project or folder as the currently accessed resource
    ///   within the past 7 days.
    pub const MODIFIED_CUSTOMER_INITIATED_ACCESS: AccessReason =
        AccessReason::new("MODIFIED_CUSTOMER_INITIATED_ACCESS");

    /// Google systems access customer data to help optimize the structure of the
    /// data or quality for future uses by the customer, and one of the following
    /// is true:
    ///
    /// * A Google administrator has reset the root-access account associated with
    ///   the user's organization within the past 7 days.
    /// * A Google-initiated emergency access operation has interacted with a
    ///   resource in the same project or folder as the currently accessed resource
    ///   within the past 7 days.
    pub const MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION: AccessReason =
        AccessReason::new("MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION");

    /// Google-initiated access to maintain system reliability.
    pub const GOOGLE_RESPONSE_TO_PRODUCTION_ALERT: AccessReason =
        AccessReason::new("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT");

    /// One of the following operations is being executed while simultaneously
    /// encountering an internal technical issue which prevented a more precise
    /// justification code from being generated:
    ///
    /// * Your account has been used to perform any access to your own data which
    ///   your IAM policy authorizes.
    /// * An automated Google system operates on encrypted customer data which your
    ///   IAM policy authorizes.
    /// * Customer-initiated Google support access.
    /// * Google-initiated support access to protect system reliability.
    pub const CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING: AccessReason =
        AccessReason::new("CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING");
}

impl std::convert::From<std::string::String> for AccessReason {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for AccessReason {
    fn default() -> Self {
        access_reason::REASON_UNSPECIFIED
    }
}
