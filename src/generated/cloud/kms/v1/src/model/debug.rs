// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::CreateKeyHandleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateKeyHandleRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("key_handle_id", &self.key_handle_id);
        debug_struct.field("key_handle", &self.key_handle);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetKeyHandleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetKeyHandleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KeyHandle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KeyHandle");
        debug_struct.field("name", &self.name);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("resource_type_selector", &self.resource_type_selector);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateKeyHandleMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateKeyHandleMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListKeyHandlesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListKeyHandlesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListKeyHandlesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListKeyHandlesResponse");
        debug_struct.field("key_handles", &self.key_handles);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateAutokeyConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAutokeyConfigRequest");
        debug_struct.field("autokey_config", &self.autokey_config);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetAutokeyConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAutokeyConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutokeyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutokeyConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("key_project", &self.key_project);
        debug_struct.field("state", &self.state);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShowEffectiveAutokeyConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShowEffectiveAutokeyConfigRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShowEffectiveAutokeyConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShowEffectiveAutokeyConfigResponse");
        debug_struct.field("key_project", &self.key_project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListEkmConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEkmConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListEkmConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEkmConnectionsResponse");
        debug_struct.field("ekm_connections", &self.ekm_connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetEkmConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEkmConnectionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateEkmConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateEkmConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("ekm_connection_id", &self.ekm_connection_id);
        debug_struct.field("ekm_connection", &self.ekm_connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateEkmConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEkmConnectionRequest");
        debug_struct.field("ekm_connection", &self.ekm_connection);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetEkmConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEkmConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateEkmConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEkmConfigRequest");
        debug_struct.field("ekm_config", &self.ekm_config);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Certificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Certificate");
        debug_struct.field("raw_der", &self.raw_der);
        debug_struct.field("parsed", &self.parsed);
        debug_struct.field("issuer", &self.issuer);
        debug_struct.field("subject", &self.subject);
        debug_struct.field(
            "subject_alternative_dns_names",
            &self.subject_alternative_dns_names,
        );
        debug_struct.field("not_before_time", &self.not_before_time);
        debug_struct.field("not_after_time", &self.not_after_time);
        debug_struct.field("serial_number", &self.serial_number);
        debug_struct.field("sha256_fingerprint", &self.sha256_fingerprint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EkmConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EkmConnection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("service_resolvers", &self.service_resolvers);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("key_management_mode", &self.key_management_mode);
        debug_struct.field("crypto_space_path", &self.crypto_space_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ekm_connection::ServiceResolver {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceResolver");
        debug_struct.field("service_directory_service", &self.service_directory_service);
        debug_struct.field("endpoint_filter", &self.endpoint_filter);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("server_certificates", &self.server_certificates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EkmConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EkmConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("default_ekm_connection", &self.default_ekm_connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VerifyConnectivityRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyConnectivityRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VerifyConnectivityResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyConnectivityResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KeyRing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KeyRing");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CryptoKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CryptoKey");
        debug_struct.field("name", &self.name);
        debug_struct.field("primary", &self.primary);
        debug_struct.field("purpose", &self.purpose);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("next_rotation_time", &self.next_rotation_time);
        debug_struct.field("version_template", &self.version_template);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("import_only", &self.import_only);
        debug_struct.field(
            "destroy_scheduled_duration",
            &self.destroy_scheduled_duration,
        );
        debug_struct.field("crypto_key_backend", &self.crypto_key_backend);
        debug_struct.field(
            "key_access_justifications_policy",
            &self.key_access_justifications_policy,
        );
        debug_struct.field("rotation_schedule", &self.rotation_schedule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CryptoKeyVersionTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CryptoKeyVersionTemplate");
        debug_struct.field("protection_level", &self.protection_level);
        debug_struct.field("algorithm", &self.algorithm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KeyOperationAttestation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KeyOperationAttestation");
        debug_struct.field("format", &self.format);
        debug_struct.field("content", &self.content);
        debug_struct.field("cert_chains", &self.cert_chains);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::key_operation_attestation::CertificateChains {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CertificateChains");
        debug_struct.field("cavium_certs", &self.cavium_certs);
        debug_struct.field("google_card_certs", &self.google_card_certs);
        debug_struct.field("google_partition_certs", &self.google_partition_certs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CryptoKeyVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CryptoKeyVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("protection_level", &self.protection_level);
        debug_struct.field("algorithm", &self.algorithm);
        debug_struct.field("attestation", &self.attestation);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("generate_time", &self.generate_time);
        debug_struct.field("destroy_time", &self.destroy_time);
        debug_struct.field("destroy_event_time", &self.destroy_event_time);
        debug_struct.field("import_job", &self.import_job);
        debug_struct.field("import_time", &self.import_time);
        debug_struct.field("import_failure_reason", &self.import_failure_reason);
        debug_struct.field("generation_failure_reason", &self.generation_failure_reason);
        debug_struct.field(
            "external_destruction_failure_reason",
            &self.external_destruction_failure_reason,
        );
        debug_struct.field(
            "external_protection_level_options",
            &self.external_protection_level_options,
        );
        debug_struct.field("reimport_eligible", &self.reimport_eligible);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ChecksummedData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChecksummedData");
        debug_struct.field("data", &self.data);
        debug_struct.field("crc32c_checksum", &self.crc32c_checksum);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PublicKey");
        debug_struct.field("pem", &self.pem);
        debug_struct.field("algorithm", &self.algorithm);
        debug_struct.field("pem_crc32c", &self.pem_crc32c);
        debug_struct.field("name", &self.name);
        debug_struct.field("protection_level", &self.protection_level);
        debug_struct.field("public_key_format", &self.public_key_format);
        debug_struct.field("public_key", &self.public_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImportJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("import_method", &self.import_method);
        debug_struct.field("protection_level", &self.protection_level);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("generate_time", &self.generate_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("expire_event_time", &self.expire_event_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("public_key", &self.public_key);
        debug_struct.field("attestation", &self.attestation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_job::WrappingPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WrappingPublicKey");
        debug_struct.field("pem", &self.pem);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalProtectionLevelOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalProtectionLevelOptions");
        debug_struct.field("external_key_uri", &self.external_key_uri);
        debug_struct.field("ekm_connection_key_path", &self.ekm_connection_key_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KeyAccessJustificationsPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KeyAccessJustificationsPolicy");
        debug_struct.field("allowed_access_reasons", &self.allowed_access_reasons);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListKeyRingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListKeyRingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListCryptoKeysRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCryptoKeysRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("version_view", &self.version_view);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListCryptoKeyVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCryptoKeyVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("view", &self.view);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListImportJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImportJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListKeyRingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListKeyRingsResponse");
        debug_struct.field("key_rings", &self.key_rings);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListCryptoKeysResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCryptoKeysResponse");
        debug_struct.field("crypto_keys", &self.crypto_keys);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListCryptoKeyVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCryptoKeyVersionsResponse");
        debug_struct.field("crypto_key_versions", &self.crypto_key_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListImportJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImportJobsResponse");
        debug_struct.field("import_jobs", &self.import_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetKeyRingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetKeyRingRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetCryptoKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCryptoKeyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetCryptoKeyVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCryptoKeyVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetPublicKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPublicKeyRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("public_key_format", &self.public_key_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetImportJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateKeyRingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateKeyRingRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("key_ring_id", &self.key_ring_id);
        debug_struct.field("key_ring", &self.key_ring);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateCryptoKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCryptoKeyRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("crypto_key_id", &self.crypto_key_id);
        debug_struct.field("crypto_key", &self.crypto_key);
        debug_struct.field(
            "skip_initial_version_creation",
            &self.skip_initial_version_creation,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateCryptoKeyVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCryptoKeyVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("crypto_key_version", &self.crypto_key_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImportCryptoKeyVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportCryptoKeyVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("crypto_key_version", &self.crypto_key_version);
        debug_struct.field("algorithm", &self.algorithm);
        debug_struct.field("import_job", &self.import_job);
        debug_struct.field("wrapped_key", &self.wrapped_key);
        debug_struct.field("wrapped_key_material", &self.wrapped_key_material);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateImportJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("import_job_id", &self.import_job_id);
        debug_struct.field("import_job", &self.import_job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateCryptoKeyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCryptoKeyRequest");
        debug_struct.field("crypto_key", &self.crypto_key);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateCryptoKeyVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCryptoKeyVersionRequest");
        debug_struct.field("crypto_key_version", &self.crypto_key_version);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateCryptoKeyPrimaryVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCryptoKeyPrimaryVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("crypto_key_version_id", &self.crypto_key_version_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DestroyCryptoKeyVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DestroyCryptoKeyVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestoreCryptoKeyVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreCryptoKeyVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EncryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("plaintext", &self.plaintext);
        debug_struct.field(
            "additional_authenticated_data",
            &self.additional_authenticated_data,
        );
        debug_struct.field("plaintext_crc32c", &self.plaintext_crc32c);
        debug_struct.field(
            "additional_authenticated_data_crc32c",
            &self.additional_authenticated_data_crc32c,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DecryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DecryptRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ciphertext", &self.ciphertext);
        debug_struct.field(
            "additional_authenticated_data",
            &self.additional_authenticated_data,
        );
        debug_struct.field("ciphertext_crc32c", &self.ciphertext_crc32c);
        debug_struct.field(
            "additional_authenticated_data_crc32c",
            &self.additional_authenticated_data_crc32c,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RawEncryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RawEncryptRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("plaintext", &self.plaintext);
        debug_struct.field(
            "additional_authenticated_data",
            &self.additional_authenticated_data,
        );
        debug_struct.field("plaintext_crc32c", &self.plaintext_crc32c);
        debug_struct.field(
            "additional_authenticated_data_crc32c",
            &self.additional_authenticated_data_crc32c,
        );
        debug_struct.field("initialization_vector", &self.initialization_vector);
        debug_struct.field(
            "initialization_vector_crc32c",
            &self.initialization_vector_crc32c,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RawDecryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RawDecryptRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ciphertext", &self.ciphertext);
        debug_struct.field(
            "additional_authenticated_data",
            &self.additional_authenticated_data,
        );
        debug_struct.field("initialization_vector", &self.initialization_vector);
        debug_struct.field("tag_length", &self.tag_length);
        debug_struct.field("ciphertext_crc32c", &self.ciphertext_crc32c);
        debug_struct.field(
            "additional_authenticated_data_crc32c",
            &self.additional_authenticated_data_crc32c,
        );
        debug_struct.field(
            "initialization_vector_crc32c",
            &self.initialization_vector_crc32c,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AsymmetricSignRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsymmetricSignRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("digest", &self.digest);
        debug_struct.field("digest_crc32c", &self.digest_crc32c);
        debug_struct.field("data", &self.data);
        debug_struct.field("data_crc32c", &self.data_crc32c);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AsymmetricDecryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsymmetricDecryptRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ciphertext", &self.ciphertext);
        debug_struct.field("ciphertext_crc32c", &self.ciphertext_crc32c);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MacSignRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MacSignRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("data", &self.data);
        debug_struct.field("data_crc32c", &self.data_crc32c);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MacVerifyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MacVerifyRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("data", &self.data);
        debug_struct.field("data_crc32c", &self.data_crc32c);
        debug_struct.field("mac", &self.mac);
        debug_struct.field("mac_crc32c", &self.mac_crc32c);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DecapsulateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DecapsulateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ciphertext", &self.ciphertext);
        debug_struct.field("ciphertext_crc32c", &self.ciphertext_crc32c);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateRandomBytesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateRandomBytesRequest");
        debug_struct.field("location", &self.location);
        debug_struct.field("length_bytes", &self.length_bytes);
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EncryptResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptResponse");
        debug_struct.field("name", &self.name);
        debug_struct.field("ciphertext", &self.ciphertext);
        debug_struct.field("ciphertext_crc32c", &self.ciphertext_crc32c);
        debug_struct.field("verified_plaintext_crc32c", &self.verified_plaintext_crc32c);
        debug_struct.field(
            "verified_additional_authenticated_data_crc32c",
            &self.verified_additional_authenticated_data_crc32c,
        );
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DecryptResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DecryptResponse");
        debug_struct.field("plaintext", &self.plaintext);
        debug_struct.field("plaintext_crc32c", &self.plaintext_crc32c);
        debug_struct.field("used_primary", &self.used_primary);
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RawEncryptResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RawEncryptResponse");
        debug_struct.field("ciphertext", &self.ciphertext);
        debug_struct.field("initialization_vector", &self.initialization_vector);
        debug_struct.field("tag_length", &self.tag_length);
        debug_struct.field("ciphertext_crc32c", &self.ciphertext_crc32c);
        debug_struct.field(
            "initialization_vector_crc32c",
            &self.initialization_vector_crc32c,
        );
        debug_struct.field("verified_plaintext_crc32c", &self.verified_plaintext_crc32c);
        debug_struct.field(
            "verified_additional_authenticated_data_crc32c",
            &self.verified_additional_authenticated_data_crc32c,
        );
        debug_struct.field(
            "verified_initialization_vector_crc32c",
            &self.verified_initialization_vector_crc32c,
        );
        debug_struct.field("name", &self.name);
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RawDecryptResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RawDecryptResponse");
        debug_struct.field("plaintext", &self.plaintext);
        debug_struct.field("plaintext_crc32c", &self.plaintext_crc32c);
        debug_struct.field("protection_level", &self.protection_level);
        debug_struct.field(
            "verified_ciphertext_crc32c",
            &self.verified_ciphertext_crc32c,
        );
        debug_struct.field(
            "verified_additional_authenticated_data_crc32c",
            &self.verified_additional_authenticated_data_crc32c,
        );
        debug_struct.field(
            "verified_initialization_vector_crc32c",
            &self.verified_initialization_vector_crc32c,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AsymmetricSignResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsymmetricSignResponse");
        debug_struct.field("signature", &self.signature);
        debug_struct.field("signature_crc32c", &self.signature_crc32c);
        debug_struct.field("verified_digest_crc32c", &self.verified_digest_crc32c);
        debug_struct.field("name", &self.name);
        debug_struct.field("verified_data_crc32c", &self.verified_data_crc32c);
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AsymmetricDecryptResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsymmetricDecryptResponse");
        debug_struct.field("plaintext", &self.plaintext);
        debug_struct.field("plaintext_crc32c", &self.plaintext_crc32c);
        debug_struct.field(
            "verified_ciphertext_crc32c",
            &self.verified_ciphertext_crc32c,
        );
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MacSignResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MacSignResponse");
        debug_struct.field("name", &self.name);
        debug_struct.field("mac", &self.mac);
        debug_struct.field("mac_crc32c", &self.mac_crc32c);
        debug_struct.field("verified_data_crc32c", &self.verified_data_crc32c);
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MacVerifyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MacVerifyResponse");
        debug_struct.field("name", &self.name);
        debug_struct.field("success", &self.success);
        debug_struct.field("verified_data_crc32c", &self.verified_data_crc32c);
        debug_struct.field("verified_mac_crc32c", &self.verified_mac_crc32c);
        debug_struct.field(
            "verified_success_integrity",
            &self.verified_success_integrity,
        );
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DecapsulateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DecapsulateResponse");
        debug_struct.field("name", &self.name);
        debug_struct.field("shared_secret", &self.shared_secret);
        debug_struct.field("shared_secret_crc32c", &self.shared_secret_crc32c);
        debug_struct.field(
            "verified_ciphertext_crc32c",
            &self.verified_ciphertext_crc32c,
        );
        debug_struct.field("protection_level", &self.protection_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateRandomBytesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateRandomBytesResponse");
        debug_struct.field("data", &self.data);
        debug_struct.field("data_crc32c", &self.data_crc32c);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Digest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Digest");
        debug_struct.field("digest", &self.digest);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field("hsm_available", &self.hsm_available);
        debug_struct.field("ekm_available", &self.ekm_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
