// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::broken_intra_doc_links)]

use gax::error::Error;

pub(crate) mod dyntraits;

/// Provides interfaces for using [Cloud KMS
/// Autokey](https://cloud.google.com/kms/help/autokey) to provision new
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey], ready for Customer Managed
/// Encryption Key (CMEK) use, on-demand. To support certain client tooling, this
/// feature is modeled around a [KeyHandle][google.cloud.kms.v1.KeyHandle]
/// resource: creating a [KeyHandle][google.cloud.kms.v1.KeyHandle] in a resource
/// project and given location triggers Cloud KMS Autokey to provision a
/// [CryptoKey][google.cloud.kms.v1.CryptoKey] in the configured key project and
/// the same location.
///
/// Prior to use in a given resource project,
/// [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]
/// should have been called on an ancestor folder, setting the key project where
/// Cloud KMS Autokey should create new
/// [CryptoKeys][google.cloud.kms.v1.CryptoKey]. See documentation for additional
/// prerequisites. To check what key project, if any, is currently configured on
/// a resource project's ancestor folder, see
/// [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
///
/// [google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig]: crate::client::AutokeyAdmin::show_effective_autokey_config
/// [google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig]: crate::client::AutokeyAdmin::update_autokey_config
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
///
/// # Mocking
///
/// Application developers may use this trait to mock the cloudkms clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait Autokey: std::fmt::Debug + Send + Sync {
    /// Creates a new [KeyHandle][google.cloud.kms.v1.KeyHandle], triggering the
    /// provisioning of a new [CryptoKey][google.cloud.kms.v1.CryptoKey] for CMEK
    /// use with the given resource type in the configured key project and the same
    /// location. [GetOperation][google.longrunning.Operations.GetOperation] should
    /// be used to resolve the resulting long-running operation and get the
    /// resulting [KeyHandle][google.cloud.kms.v1.KeyHandle] and
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    fn create_key_handle(
        &self,
        _req: crate::model::CreateKeyHandleRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the [KeyHandle][google.cloud.kms.v1.KeyHandle].
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    fn get_key_handle(
        &self,
        _req: crate::model::GetKeyHandleRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::KeyHandle>> + Send {
        std::future::ready::<crate::Result<crate::model::KeyHandle>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Lists [KeyHandles][google.cloud.kms.v1.KeyHandle].
    ///
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    fn list_key_handles(
        &self,
        _req: crate::model::ListKeyHandlesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListKeyHandlesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListKeyHandlesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists information about the supported locations for this service.
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets information about a location.
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Sets the access control policy on the specified resource. Replaces
    /// any existing policy.
    ///
    /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
    /// errors.
    fn set_iam_policy(
        &self,
        _req: iam_v1::model::SetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Gets the access control policy for a resource. Returns an empty policy
    /// if the resource exists and does not have a policy set.
    fn get_iam_policy(
        &self,
        _req: iam_v1::model::GetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns permissions that a caller has on the specified resource. If the
    /// resource does not exist, this will return an empty set of
    /// permissions, not a `NOT_FOUND` error.
    ///
    /// Note: This operation is designed to be used for building
    /// permission-aware UIs and command-line tools, not for authorization
    /// checking. This operation may "fail open" without warning.
    fn test_iam_permissions(
        &self,
        _req: iam_v1::model::TestIamPermissionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::TestIamPermissionsResponse>> + Send
    {
        std::future::ready::<crate::Result<iam_v1::model::TestIamPermissionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling policy.
    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy>;

    /// Returns the polling backoff policy.
    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy>;
}

/// Provides interfaces for managing [Cloud KMS
/// Autokey](https://cloud.google.com/kms/help/autokey) folder-level
/// configurations. A configuration is inherited by all descendent projects. A
/// configuration at one folder overrides any other configurations in its
/// ancestry. Setting a configuration on a folder is a prerequisite for Cloud KMS
/// Autokey, so that users working in a descendant project can request
/// provisioned [CryptoKeys][google.cloud.kms.v1.CryptoKey], ready for Customer
/// Managed Encryption Key (CMEK) use, on-demand.
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
///
/// # Mocking
///
/// Application developers may use this trait to mock the cloudkms clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait AutokeyAdmin: std::fmt::Debug + Send + Sync {
    /// Updates the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
    /// folder. The caller must have both `cloudkms.autokeyConfigs.update`
    /// permission on the parent folder and `cloudkms.cryptoKeys.setIamPolicy`
    /// permission on the provided key project. A
    /// [KeyHandle][google.cloud.kms.v1.KeyHandle] creation in the folder's
    /// descendant projects will use this configuration to determine where to
    /// create the resulting [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.KeyHandle]: crate::model::KeyHandle
    fn update_autokey_config(
        &self,
        _req: crate::model::UpdateAutokeyConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AutokeyConfig>> + Send {
        std::future::ready::<crate::Result<crate::model::AutokeyConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
    /// folder.
    ///
    /// [google.cloud.kms.v1.AutokeyConfig]: crate::model::AutokeyConfig
    fn get_autokey_config(
        &self,
        _req: crate::model::GetAutokeyConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AutokeyConfig>> + Send {
        std::future::ready::<crate::Result<crate::model::AutokeyConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the effective Cloud KMS Autokey configuration for a given project.
    fn show_effective_autokey_config(
        &self,
        _req: crate::model::ShowEffectiveAutokeyConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<crate::model::ShowEffectiveAutokeyConfigResponse>,
    > + Send {
        std::future::ready::<crate::Result<crate::model::ShowEffectiveAutokeyConfigResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists information about the supported locations for this service.
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets information about a location.
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Sets the access control policy on the specified resource. Replaces
    /// any existing policy.
    ///
    /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
    /// errors.
    fn set_iam_policy(
        &self,
        _req: iam_v1::model::SetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Gets the access control policy for a resource. Returns an empty policy
    /// if the resource exists and does not have a policy set.
    fn get_iam_policy(
        &self,
        _req: iam_v1::model::GetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns permissions that a caller has on the specified resource. If the
    /// resource does not exist, this will return an empty set of
    /// permissions, not a `NOT_FOUND` error.
    ///
    /// Note: This operation is designed to be used for building
    /// permission-aware UIs and command-line tools, not for authorization
    /// checking. This operation may "fail open" without warning.
    fn test_iam_permissions(
        &self,
        _req: iam_v1::model::TestIamPermissionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::TestIamPermissionsResponse>> + Send
    {
        std::future::ready::<crate::Result<iam_v1::model::TestIamPermissionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Google Cloud Key Management EKM Service
///
/// Manages external cryptographic keys and operations using those keys.
/// Implements a REST model with the following objects:
///
/// * [EkmConnection][google.cloud.kms.v1.EkmConnection]
///
/// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
///
/// # Mocking
///
/// Application developers may use this trait to mock the cloudkms clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait EkmService: std::fmt::Debug + Send + Sync {
    /// Lists [EkmConnections][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    fn list_ekm_connections(
        &self,
        _req: crate::model::ListEkmConnectionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListEkmConnectionsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListEkmConnectionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Returns metadata for a given
    /// [EkmConnection][google.cloud.kms.v1.EkmConnection].
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    fn get_ekm_connection(
        &self,
        _req: crate::model::GetEkmConnectionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EkmConnection>> + Send {
        std::future::ready::<crate::Result<crate::model::EkmConnection>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Creates a new [EkmConnection][google.cloud.kms.v1.EkmConnection] in a given
    /// Project and Location.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    fn create_ekm_connection(
        &self,
        _req: crate::model::CreateEkmConnectionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EkmConnection>> + Send {
        std::future::ready::<crate::Result<crate::model::EkmConnection>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Updates an [EkmConnection][google.cloud.kms.v1.EkmConnection]'s metadata.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    fn update_ekm_connection(
        &self,
        _req: crate::model::UpdateEkmConnectionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EkmConnection>> + Send {
        std::future::ready::<crate::Result<crate::model::EkmConnection>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
    /// for a given project and location.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    fn get_ekm_config(
        &self,
        _req: crate::model::GetEkmConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EkmConfig>> + Send {
        std::future::ready::<crate::Result<crate::model::EkmConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Updates the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
    /// for a given project and location.
    ///
    /// [google.cloud.kms.v1.EkmConfig]: crate::model::EkmConfig
    fn update_ekm_config(
        &self,
        _req: crate::model::UpdateEkmConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EkmConfig>> + Send {
        std::future::ready::<crate::Result<crate::model::EkmConfig>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Verifies that Cloud KMS can successfully connect to the external key
    /// manager specified by an [EkmConnection][google.cloud.kms.v1.EkmConnection].
    /// If there is an error connecting to the EKM, this method returns a
    /// FAILED_PRECONDITION status containing structured information as described
    /// at <https://cloud.google.com/kms/docs/reference/ekm_errors>.
    ///
    /// [google.cloud.kms.v1.EkmConnection]: crate::model::EkmConnection
    fn verify_connectivity(
        &self,
        _req: crate::model::VerifyConnectivityRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::VerifyConnectivityResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::VerifyConnectivityResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists information about the supported locations for this service.
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets information about a location.
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Sets the access control policy on the specified resource. Replaces
    /// any existing policy.
    ///
    /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
    /// errors.
    fn set_iam_policy(
        &self,
        _req: iam_v1::model::SetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Gets the access control policy for a resource. Returns an empty policy
    /// if the resource exists and does not have a policy set.
    fn get_iam_policy(
        &self,
        _req: iam_v1::model::GetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns permissions that a caller has on the specified resource. If the
    /// resource does not exist, this will return an empty set of
    /// permissions, not a `NOT_FOUND` error.
    ///
    /// Note: This operation is designed to be used for building
    /// permission-aware UIs and command-line tools, not for authorization
    /// checking. This operation may "fail open" without warning.
    fn test_iam_permissions(
        &self,
        _req: iam_v1::model::TestIamPermissionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::TestIamPermissionsResponse>> + Send
    {
        std::future::ready::<crate::Result<iam_v1::model::TestIamPermissionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Google Cloud Key Management Service
///
/// Manages cryptographic keys and operations using those keys. Implements a REST
/// model with the following objects:
///
/// * [KeyRing][google.cloud.kms.v1.KeyRing]
/// * [CryptoKey][google.cloud.kms.v1.CryptoKey]
/// * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
/// * [ImportJob][google.cloud.kms.v1.ImportJob]
///
/// If you are using manual gRPC libraries, see
/// [Using gRPC with Cloud KMS](https://cloud.google.com/kms/docs/grpc).
///
/// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
/// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
/// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
/// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
///
/// # Mocking
///
/// Application developers may use this trait to mock the cloudkms clients.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation for each method. These implementations return an error.
pub trait KeyManagementService: std::fmt::Debug + Send + Sync {
    /// Lists [KeyRings][google.cloud.kms.v1.KeyRing].
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    fn list_key_rings(
        &self,
        _req: crate::model::ListKeyRingsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListKeyRingsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListKeyRingsResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Lists [CryptoKeys][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    fn list_crypto_keys(
        &self,
        _req: crate::model::ListCryptoKeysRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListCryptoKeysResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListCryptoKeysResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn list_crypto_key_versions(
        &self,
        _req: crate::model::ListCryptoKeyVersionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListCryptoKeyVersionsResponse>>
           + Send {
        std::future::ready::<crate::Result<crate::model::ListCryptoKeyVersionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists [ImportJobs][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    fn list_import_jobs(
        &self,
        _req: crate::model::ListImportJobsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ListImportJobsResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::ListImportJobsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Returns metadata for a given [KeyRing][google.cloud.kms.v1.KeyRing].
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    fn get_key_ring(
        &self,
        _req: crate::model::GetKeyRingRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::KeyRing>> + Send {
        std::future::ready::<crate::Result<crate::model::KeyRing>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns metadata for a given [CryptoKey][google.cloud.kms.v1.CryptoKey], as
    /// well as its [primary][google.cloud.kms.v1.CryptoKey.primary]
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.primary]: crate::model::CryptoKey::primary
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn get_crypto_key(
        &self,
        _req: crate::model::GetCryptoKeyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKey>> + Send {
        std::future::ready::<crate::Result<crate::model::CryptoKey>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns metadata for a given
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn get_crypto_key_version(
        &self,
        _req: crate::model::GetCryptoKeyVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKeyVersion>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CryptoKeyVersion>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the public key for the given
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. The
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
    /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]
    /// or
    /// [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ASYMMETRIC_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]: crate::model::crypto_key::crypto_key_purpose::ASYMMETRIC_SIGN
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn get_public_key(
        &self,
        _req: crate::model::GetPublicKeyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::PublicKey>> + Send {
        std::future::ready::<crate::Result<crate::model::PublicKey>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns metadata for a given [ImportJob][google.cloud.kms.v1.ImportJob].
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    fn get_import_job(
        &self,
        _req: crate::model::GetImportJobRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ImportJob>> + Send {
        std::future::ready::<crate::Result<crate::model::ImportJob>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Create a new [KeyRing][google.cloud.kms.v1.KeyRing] in a given Project and
    /// Location.
    ///
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    fn create_key_ring(
        &self,
        _req: crate::model::CreateKeyRingRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::KeyRing>> + Send {
        std::future::ready::<crate::Result<crate::model::KeyRing>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a
    /// [KeyRing][google.cloud.kms.v1.KeyRing].
    ///
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and
    /// [CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]
    /// are required.
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]: crate::model::CryptoKeyVersionTemplate::algorithm
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    fn create_crypto_key(
        &self,
        _req: crate::model::CreateCryptoKeyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKey>> + Send {
        std::future::ready::<crate::Result<crate::model::CryptoKey>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Create a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// The server will assign the next sequential id. If unset,
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
    /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    fn create_crypto_key_version(
        &self,
        _req: crate::model::CreateCryptoKeyVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKeyVersion>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CryptoKeyVersion>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Import wrapped key material into a
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
    ///
    /// All requests must specify a [CryptoKey][google.cloud.kms.v1.CryptoKey]. If
    /// a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] is additionally
    /// specified in the request, key material will be reimported into that
    /// version. Otherwise, a new version will be created, and will be assigned the
    /// next sequential id within the [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn import_crypto_key_version(
        &self,
        _req: crate::model::ImportCryptoKeyVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKeyVersion>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CryptoKeyVersion>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Create a new [ImportJob][google.cloud.kms.v1.ImportJob] within a
    /// [KeyRing][google.cloud.kms.v1.KeyRing].
    ///
    /// [ImportJob.import_method][google.cloud.kms.v1.ImportJob.import_method] is
    /// required.
    ///
    /// [google.cloud.kms.v1.ImportJob]: crate::model::ImportJob
    /// [google.cloud.kms.v1.ImportJob.import_method]: crate::model::ImportJob::import_method
    /// [google.cloud.kms.v1.KeyRing]: crate::model::KeyRing
    fn create_import_job(
        &self,
        _req: crate::model::CreateImportJobRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::ImportJob>> + Send {
        std::future::ready::<crate::Result<crate::model::ImportJob>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Update a [CryptoKey][google.cloud.kms.v1.CryptoKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    fn update_crypto_key(
        &self,
        _req: crate::model::UpdateCryptoKeyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKey>> + Send {
        std::future::ready::<crate::Result<crate::model::CryptoKey>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Update a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s
    /// metadata.
    ///
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] may be changed between
    /// [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
    /// and
    /// [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
    /// using this method. See
    /// [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]
    /// and
    /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
    /// to move between other states.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]: crate::model::crypto_key_version::crypto_key_version_state::DISABLED
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]: crate::model::crypto_key_version::crypto_key_version_state::ENABLED
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    /// [google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]: crate::client::KeyManagementService::destroy_crypto_key_version
    /// [google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]: crate::client::KeyManagementService::restore_crypto_key_version
    fn update_crypto_key_version(
        &self,
        _req: crate::model::UpdateCryptoKeyVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKeyVersion>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CryptoKeyVersion>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Update the version of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that
    /// will be used in
    /// [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
    ///
    /// Returns an error if called on a key whose purpose is not
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey]: crate::model::CryptoKey
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
    fn update_crypto_key_primary_version(
        &self,
        _req: crate::model::UpdateCryptoKeyPrimaryVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKey>> + Send {
        std::future::ready::<crate::Result<crate::model::CryptoKey>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Schedule a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] for
    /// destruction.
    ///
    /// Upon calling this method,
    /// [CryptoKeyVersion.state][google.cloud.kms.v1.CryptoKeyVersion.state] will
    /// be set to
    /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED],
    /// and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
    /// be set to the time
    /// [destroy_scheduled_duration][google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]
    /// in the future. At that time, the
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] will automatically
    /// change to
    /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED],
    /// and the key material will be irrevocably destroyed.
    ///
    /// Before the
    /// [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] is
    /// reached,
    /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
    /// may be called to reverse the process.
    ///
    /// [google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]: crate::model::CryptoKey::destroy_scheduled_duration
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROYED
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROY_SCHEDULED
    /// [google.cloud.kms.v1.CryptoKeyVersion.destroy_time]: crate::model::CryptoKeyVersion::destroy_time
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    /// [google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]: crate::client::KeyManagementService::restore_crypto_key_version
    fn destroy_crypto_key_version(
        &self,
        _req: crate::model::DestroyCryptoKeyVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKeyVersion>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CryptoKeyVersion>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Restore a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the
    /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
    /// state.
    ///
    /// Upon restoration of the CryptoKeyVersion,
    /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
    /// [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED],
    /// and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
    /// be cleared.
    ///
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]: crate::model::crypto_key_version::crypto_key_version_state::DESTROY_SCHEDULED
    /// [google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]: crate::model::crypto_key_version::crypto_key_version_state::DISABLED
    /// [google.cloud.kms.v1.CryptoKeyVersion.destroy_time]: crate::model::CryptoKeyVersion::destroy_time
    /// [google.cloud.kms.v1.CryptoKeyVersion.state]: crate::model::CryptoKeyVersion::state
    fn restore_crypto_key_version(
        &self,
        _req: crate::model::RestoreCryptoKeyVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::CryptoKeyVersion>> + Send
    {
        std::future::ready::<crate::Result<crate::model::CryptoKeyVersion>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Encrypts data, so that it can only be recovered by a call to
    /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt]. The
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
    fn encrypt(
        &self,
        _req: crate::model::EncryptRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::EncryptResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::EncryptResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Decrypts data that was protected by
    /// [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt]. The
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
    fn decrypt(
        &self,
        _req: crate::model::DecryptRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::DecryptResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::DecryptResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Encrypts data using portable cryptographic primitives. Most users should
    /// choose [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
    /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt] rather than
    /// their raw counterparts. The
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
    /// [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::RAW_ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.KeyManagementService.Decrypt]: crate::client::KeyManagementService::decrypt
    /// [google.cloud.kms.v1.KeyManagementService.Encrypt]: crate::client::KeyManagementService::encrypt
    fn raw_encrypt(
        &self,
        _req: crate::model::RawEncryptRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::RawEncryptResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::RawEncryptResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Decrypts data that was originally encrypted using a raw cryptographic
    /// mechanism. The [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// must be
    /// [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
    ///
    /// [google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT]: crate::model::crypto_key::crypto_key_purpose::RAW_ENCRYPT_DECRYPT
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    fn raw_decrypt(
        &self,
        _req: crate::model::RawDecryptRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::RawDecryptResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::RawDecryptResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// ASYMMETRIC_SIGN, producing a signature that can be verified with the public
    /// key retrieved from
    /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
    ///
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
    fn asymmetric_sign(
        &self,
        _req: crate::model::AsymmetricSignRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AsymmetricSignResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::AsymmetricSignResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Decrypts data that was encrypted with a public key retrieved from
    /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey]
    /// corresponding to a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// ASYMMETRIC_DECRYPT.
    ///
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    /// [google.cloud.kms.v1.KeyManagementService.GetPublicKey]: crate::client::KeyManagementService::get_public_key
    fn asymmetric_decrypt(
        &self,
        _req: crate::model::AsymmetricDecryptRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::AsymmetricDecryptResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::AsymmetricDecryptResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
    /// with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC,
    /// producing a tag that can be verified by another source with the same key.
    ///
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn mac_sign(
        &self,
        _req: crate::model::MacSignRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::MacSignResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::MacSignResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Verifies MAC tag using a
    /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
    /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC, and returns
    /// a response that indicates whether or not the verification was successful.
    ///
    /// [google.cloud.kms.v1.CryptoKey.purpose]: crate::model::CryptoKey::purpose
    /// [google.cloud.kms.v1.CryptoKeyVersion]: crate::model::CryptoKeyVersion
    fn mac_verify(
        &self,
        _req: crate::model::MacVerifyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::MacVerifyResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::MacVerifyResponse>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Generate random bytes using the Cloud KMS randomness source in the provided
    /// location.
    fn generate_random_bytes(
        &self,
        _req: crate::model::GenerateRandomBytesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<crate::model::GenerateRandomBytesResponse>> + Send
    {
        std::future::ready::<crate::Result<crate::model::GenerateRandomBytesResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Lists information about the supported locations for this service.
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::ListLocationsResponse>> + Send
    {
        std::future::ready::<crate::Result<location::model::ListLocationsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Gets information about a location.
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<location::model::Location>> + Send {
        std::future::ready::<crate::Result<location::model::Location>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Sets the access control policy on the specified resource. Replaces
    /// any existing policy.
    ///
    /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
    /// errors.
    fn set_iam_policy(
        &self,
        _req: iam_v1::model::SetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Gets the access control policy for a resource. Returns an empty policy
    /// if the resource exists and does not have a policy set.
    fn get_iam_policy(
        &self,
        _req: iam_v1::model::GetIamPolicyRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::Policy>> + Send {
        std::future::ready::<crate::Result<iam_v1::model::Policy>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns permissions that a caller has on the specified resource. If the
    /// resource does not exist, this will return an empty set of
    /// permissions, not a `NOT_FOUND` error.
    ///
    /// Note: This operation is designed to be used for building
    /// permission-aware UIs and command-line tools, not for authorization
    /// checking. This operation may "fail open" without warning.
    fn test_iam_permissions(
        &self,
        _req: iam_v1::model::TestIamPermissionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<iam_v1::model::TestIamPermissionsResponse>> + Send
    {
        std::future::ready::<crate::Result<iam_v1::model::TestIamPermissionsResponse>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<longrunning::model::Operation>> + Send
    {
        std::future::ready::<crate::Result<longrunning::model::Operation>>(Err(Error::other(
            "unimplemented",
        )))
    }
}
