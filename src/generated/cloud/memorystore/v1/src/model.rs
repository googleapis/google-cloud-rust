// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Memorystore instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Identifier. Unique name of the instance.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation timestamp of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Latest update timestamp of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels to represent user-provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Current state of the instance.
    pub state: crate::model::instance::State,

    /// Output only. Additional information about the state of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_info: std::option::Option<crate::model::instance::StateInfo>,

    /// Output only. System assigned, unique identifier for the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. Number of replica nodes per shard. If omitted the default is 0
    /// replicas.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_count: std::option::Option<i32>,

    /// Optional. Immutable. Authorization mode of the instance.
    pub authorization_mode: crate::model::instance::AuthorizationMode,

    /// Optional. Immutable. In-transit encryption mode of the instance.
    pub transit_encryption_mode: crate::model::instance::TransitEncryptionMode,

    /// Optional. Number of shards for the instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub shard_count: i32,

    /// Output only. Deprecated: Use the endpoints.connections.psc_auto_connection
    /// or endpoints.connections.psc_connection values instead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub discovery_endpoints: std::vec::Vec<crate::model::DiscoveryEndpoint>,

    /// Optional. Machine type for individual nodes of the instance.
    pub node_type: crate::model::instance::NodeType,

    /// Optional. Persistence configuration of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistence_config: std::option::Option<crate::model::PersistenceConfig>,

    /// Optional. Engine version of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_version: std::string::String,

    /// Optional. User-provided engine configurations for the instance.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub engine_configs: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Configuration of individual nodes of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// Optional. Immutable. Zone distribution configuration of the instance for
    /// node allocation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zone_distribution_config: std::option::Option<crate::model::ZoneDistributionConfig>,

    /// Optional. If set to true deletion of the instance will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_protection_enabled: std::option::Option<bool>,

    /// Optional. Immutable. Deprecated: Use the
    /// endpoints.connections.psc_auto_connection value instead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub psc_auto_connections: std::vec::Vec<crate::model::PscAutoConnection>,

    /// Output only. Service attachment details to configure PSC connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_attachment_details: std::vec::Vec<crate::model::PscAttachmentDetail>,

    /// Optional. Endpoints for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub endpoints: std::vec::Vec<crate::model::instance::InstanceEndpoint>,

    /// Optional. The mode config for the instance.
    pub mode: crate::model::instance::Mode,

    /// Optional. Input only. Ondemand maintenance for the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ondemand_maintenance: std::option::Option<bool>,

    /// Optional. The maintenance policy for the instance. If not provided,
    /// the maintenance event will be performed based on Memorystore
    /// internal rollout schedule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// Output only. Published maintenance schedule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_schedule: std::option::Option<crate::model::MaintenanceSchedule>,

    /// Optional. The config for cross instance replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cross_instance_replication_config:
        std::option::Option<crate::model::CrossInstanceReplicationConfig>,

    /// Optional. If true, instance endpoints that are created and registered by
    /// customers can be deleted asynchronously. That is, such an instance endpoint
    /// can be de-registered before the forwarding rules in the instance endpoint
    /// are deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub async_instance_endpoints_deletion_enabled: std::option::Option<bool>,

    /// Output only. The backup collection full resource name. Example:
    /// projects/{project}/locations/{location}/backupCollections/{collection}
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_collection: std::option::Option<std::string::String>,

    /// Optional. The automated backup config for the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automated_backup_config: std::option::Option<crate::model::AutomatedBackupConfig>,

    /// The source to import from.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub import_sources: std::option::Option<crate::model::instance::ImportSources>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_info][crate::model::Instance::state_info].
    pub fn set_state_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::StateInfo>,
    {
        self.state_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_info][crate::model::Instance::state_info].
    pub fn set_or_clear_state_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::StateInfo>,
    {
        self.state_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uid][crate::model::Instance::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Instance::replica_count].
    pub fn set_replica_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.replica_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replica_count][crate::model::Instance::replica_count].
    pub fn set_or_clear_replica_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.replica_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization_mode][crate::model::Instance::authorization_mode].
    pub fn set_authorization_mode<
        T: std::convert::Into<crate::model::instance::AuthorizationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_mode = v.into();
        self
    }

    /// Sets the value of [transit_encryption_mode][crate::model::Instance::transit_encryption_mode].
    pub fn set_transit_encryption_mode<
        T: std::convert::Into<crate::model::instance::TransitEncryptionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transit_encryption_mode = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Instance::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [discovery_endpoints][crate::model::Instance::discovery_endpoints].
    #[deprecated]
    pub fn set_discovery_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryEndpoint>,
    {
        use std::iter::Iterator;
        self.discovery_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_type][crate::model::Instance::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::instance::NodeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [persistence_config][crate::model::Instance::persistence_config].
    pub fn set_persistence_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PersistenceConfig>,
    {
        self.persistence_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [persistence_config][crate::model::Instance::persistence_config].
    pub fn set_or_clear_persistence_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PersistenceConfig>,
    {
        self.persistence_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [engine_version][crate::model::Instance::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [engine_configs][crate::model::Instance::engine_configs].
    pub fn set_engine_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.engine_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [node_config][crate::model::Instance::node_config].
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::Instance::node_config].
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone_distribution_config][crate::model::Instance::zone_distribution_config].
    pub fn set_zone_distribution_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ZoneDistributionConfig>,
    {
        self.zone_distribution_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone_distribution_config][crate::model::Instance::zone_distribution_config].
    pub fn set_or_clear_zone_distribution_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ZoneDistributionConfig>,
    {
        self.zone_distribution_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Instance::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_protection_enabled][crate::model::Instance::deletion_protection_enabled].
    pub fn set_or_clear_deletion_protection_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [psc_auto_connections][crate::model::Instance::psc_auto_connections].
    #[deprecated]
    pub fn set_psc_auto_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscAutoConnection>,
    {
        use std::iter::Iterator;
        self.psc_auto_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_attachment_details][crate::model::Instance::psc_attachment_details].
    pub fn set_psc_attachment_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscAttachmentDetail>,
    {
        use std::iter::Iterator;
        self.psc_attachment_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [endpoints][crate::model::Instance::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::InstanceEndpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mode][crate::model::Instance::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::instance::Mode>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [ondemand_maintenance][crate::model::Instance::ondemand_maintenance].
    pub fn set_ondemand_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.ondemand_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ondemand_maintenance][crate::model::Instance::ondemand_maintenance].
    pub fn set_or_clear_ondemand_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.ondemand_maintenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Instance::maintenance_policy].
    pub fn set_maintenance_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_policy][crate::model::Instance::maintenance_policy].
    pub fn set_or_clear_maintenance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_schedule][crate::model::Instance::maintenance_schedule].
    pub fn set_maintenance_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceSchedule>,
    {
        self.maintenance_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_schedule][crate::model::Instance::maintenance_schedule].
    pub fn set_or_clear_maintenance_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceSchedule>,
    {
        self.maintenance_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cross_instance_replication_config][crate::model::Instance::cross_instance_replication_config].
    pub fn set_cross_instance_replication_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CrossInstanceReplicationConfig>,
    {
        self.cross_instance_replication_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cross_instance_replication_config][crate::model::Instance::cross_instance_replication_config].
    pub fn set_or_clear_cross_instance_replication_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CrossInstanceReplicationConfig>,
    {
        self.cross_instance_replication_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [async_instance_endpoints_deletion_enabled][crate::model::Instance::async_instance_endpoints_deletion_enabled].
    pub fn set_async_instance_endpoints_deletion_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.async_instance_endpoints_deletion_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [async_instance_endpoints_deletion_enabled][crate::model::Instance::async_instance_endpoints_deletion_enabled].
    pub fn set_or_clear_async_instance_endpoints_deletion_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.async_instance_endpoints_deletion_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_collection][crate::model::Instance::backup_collection].
    pub fn set_backup_collection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_collection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_collection][crate::model::Instance::backup_collection].
    pub fn set_or_clear_backup_collection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_collection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_backup_config][crate::model::Instance::automated_backup_config].
    pub fn set_automated_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupConfig>,
    {
        self.automated_backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_backup_config][crate::model::Instance::automated_backup_config].
    pub fn set_or_clear_automated_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupConfig>,
    {
        self.automated_backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_sources][crate::model::Instance::import_sources].
    ///
    /// Note that all the setters affecting `import_sources` are mutually
    /// exclusive.
    pub fn set_import_sources<
        T: std::convert::Into<std::option::Option<crate::model::instance::ImportSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources = v.into();
        self
    }

    /// The value of [import_sources][crate::model::Instance::import_sources]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::instance::GcsBackupSource>> {
        #[allow(unreachable_patterns)]
        self.import_sources.as_ref().and_then(|v| match v {
            crate::model::instance::ImportSources::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_sources][crate::model::Instance::import_sources]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `import_sources` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::instance::GcsBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources =
            std::option::Option::Some(crate::model::instance::ImportSources::GcsSource(v.into()));
        self
    }

    /// The value of [import_sources][crate::model::Instance::import_sources]
    /// if it holds a `ManagedBackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::instance::ManagedBackupSource>> {
        #[allow(unreachable_patterns)]
        self.import_sources.as_ref().and_then(|v| match v {
            crate::model::instance::ImportSources::ManagedBackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_sources][crate::model::Instance::import_sources]
    /// to hold a `ManagedBackupSource`.
    ///
    /// Note that all the setters affecting `import_sources` are
    /// mutually exclusive.
    pub fn set_managed_backup_source<
        T: std::convert::Into<std::boxed::Box<crate::model::instance::ManagedBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources = std::option::Option::Some(
            crate::model::instance::ImportSources::ManagedBackupSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Additional information about the state of the instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StateInfo {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub info: std::option::Option<crate::model::instance::state_info::Info>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StateInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info][crate::model::instance::StateInfo::info].
        ///
        /// Note that all the setters affecting `info` are mutually
        /// exclusive.
        pub fn set_info<
            T: std::convert::Into<std::option::Option<crate::model::instance::state_info::Info>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = v.into();
            self
        }

        /// The value of [info][crate::model::instance::StateInfo::info]
        /// if it holds a `UpdateInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn update_info(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::instance::state_info::UpdateInfo>>
        {
            #[allow(unreachable_patterns)]
            self.info.as_ref().and_then(|v| match v {
                crate::model::instance::state_info::Info::UpdateInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [info][crate::model::instance::StateInfo::info]
        /// to hold a `UpdateInfo`.
        ///
        /// Note that all the setters affecting `info` are
        /// mutually exclusive.
        pub fn set_update_info<
            T: std::convert::Into<std::boxed::Box<crate::model::instance::state_info::UpdateInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = std::option::Option::Some(
                crate::model::instance::state_info::Info::UpdateInfo(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for StateInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.StateInfo"
        }
    }

    /// Defines additional types related to [StateInfo].
    pub mod state_info {
        #[allow(unused_imports)]
        use super::*;

        /// Represents information about instance with state UPDATING.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct UpdateInfo {
            /// Output only. Target number of shards for the instance.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_shard_count: std::option::Option<i32>,

            /// Output only. Target number of replica nodes per shard for the instance.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_replica_count: std::option::Option<i32>,

            /// Output only. Target engine version for the instance.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_engine_version: std::option::Option<std::string::String>,

            /// Output only. Target node type for the instance.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_node_type: std::option::Option<crate::model::instance::NodeType>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UpdateInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [target_shard_count][crate::model::instance::state_info::UpdateInfo::target_shard_count].
            pub fn set_target_shard_count<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_shard_count = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target_shard_count][crate::model::instance::state_info::UpdateInfo::target_shard_count].
            pub fn set_or_clear_target_shard_count<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_shard_count = v.map(|x| x.into());
                self
            }

            /// Sets the value of [target_replica_count][crate::model::instance::state_info::UpdateInfo::target_replica_count].
            pub fn set_target_replica_count<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_replica_count = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target_replica_count][crate::model::instance::state_info::UpdateInfo::target_replica_count].
            pub fn set_or_clear_target_replica_count<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_replica_count = v.map(|x| x.into());
                self
            }

            /// Sets the value of [target_engine_version][crate::model::instance::state_info::UpdateInfo::target_engine_version].
            pub fn set_target_engine_version<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.target_engine_version = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target_engine_version][crate::model::instance::state_info::UpdateInfo::target_engine_version].
            pub fn set_or_clear_target_engine_version<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.target_engine_version = v.map(|x| x.into());
                self
            }

            /// Sets the value of [target_node_type][crate::model::instance::state_info::UpdateInfo::target_node_type].
            pub fn set_target_node_type<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::instance::NodeType>,
            {
                self.target_node_type = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target_node_type][crate::model::instance::state_info::UpdateInfo::target_node_type].
            pub fn set_or_clear_target_node_type<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::instance::NodeType>,
            {
                self.target_node_type = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for UpdateInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.memorystore.v1.Instance.StateInfo.UpdateInfo"
            }
        }

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Info {
            /// Output only. Describes ongoing update when instance state is UPDATING.
            UpdateInfo(std::boxed::Box<crate::model::instance::state_info::UpdateInfo>),
        }
    }

    /// Backups that stored in Cloud Storage buckets.
    /// The Cloud Storage buckets need to be the same region as the instances.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsBackupSource {
        /// Optional. Example: gs://bucket1/object1, gs://bucket2/folder2/object2
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub uris: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsBackupSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uris][crate::model::instance::GcsBackupSource::uris].
        pub fn set_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcsBackupSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.GcsBackupSource"
        }
    }

    /// Backups that generated and managed by memorystore.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagedBackupSource {
        /// Optional. Example:
        /// //memorystore.googleapis.com/projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup}
        /// A shorter version (without the prefix) of the backup name is also
        /// supported, like
        /// projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup_id}
        /// In this case, it assumes the backup is under memorystore.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub backup: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManagedBackupSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup][crate::model::instance::ManagedBackupSource::backup].
        pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.backup = v.into();
            self
        }
    }

    impl wkt::message::Message for ManagedBackupSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.ManagedBackupSource"
        }
    }

    /// InstanceEndpoint consists of PSC connections that are created
    /// as a group in each VPC network for accessing the instance. In each group,
    /// there shall be one connection for each service attachment in the cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceEndpoint {
        /// Optional. A group of PSC connections. They are created in the same VPC
        /// network, one for each service attachment in the cluster.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub connections: std::vec::Vec<crate::model::instance::ConnectionDetail>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connections][crate::model::instance::InstanceEndpoint::connections].
        pub fn set_connections<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance::ConnectionDetail>,
        {
            use std::iter::Iterator;
            self.connections = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InstanceEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.InstanceEndpoint"
        }
    }

    /// Information of each PSC connection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectionDetail {
        /// A PSC connection to an instance could either be created through Service
        /// Connectivity Automation (auto connection) during the cluster creation,
        /// or it could be created by customer themeslves (user-created connection).
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub connection: std::option::Option<crate::model::instance::connection_detail::Connection>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectionDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection][crate::model::instance::ConnectionDetail::connection].
        ///
        /// Note that all the setters affecting `connection` are mutually
        /// exclusive.
        pub fn set_connection<
            T: std::convert::Into<
                    std::option::Option<crate::model::instance::connection_detail::Connection>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.connection = v.into();
            self
        }

        /// The value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// if it holds a `PscAutoConnection`, `None` if the field is not set or
        /// holds a different branch.
        pub fn psc_auto_connection(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PscAutoConnection>> {
            #[allow(unreachable_patterns)]
            self.connection.as_ref().and_then(|v| match v {
                crate::model::instance::connection_detail::Connection::PscAutoConnection(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// to hold a `PscAutoConnection`.
        ///
        /// Note that all the setters affecting `connection` are
        /// mutually exclusive.
        pub fn set_psc_auto_connection<
            T: std::convert::Into<std::boxed::Box<crate::model::PscAutoConnection>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.connection = std::option::Option::Some(
                crate::model::instance::connection_detail::Connection::PscAutoConnection(v.into()),
            );
            self
        }

        /// The value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// if it holds a `PscConnection`, `None` if the field is not set or
        /// holds a different branch.
        pub fn psc_connection(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PscConnection>> {
            #[allow(unreachable_patterns)]
            self.connection.as_ref().and_then(|v| match v {
                crate::model::instance::connection_detail::Connection::PscConnection(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// to hold a `PscConnection`.
        ///
        /// Note that all the setters affecting `connection` are
        /// mutually exclusive.
        pub fn set_psc_connection<
            T: std::convert::Into<std::boxed::Box<crate::model::PscConnection>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.connection = std::option::Option::Some(
                crate::model::instance::connection_detail::Connection::PscConnection(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ConnectionDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.ConnectionDetail"
        }
    }

    /// Defines additional types related to [ConnectionDetail].
    pub mod connection_detail {
        #[allow(unused_imports)]
        use super::*;

        /// A PSC connection to an instance could either be created through Service
        /// Connectivity Automation (auto connection) during the cluster creation,
        /// or it could be created by customer themeslves (user-created connection).
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Connection {
            /// Immutable. Detailed information of a PSC connection that is created
            /// through service connectivity automation.
            PscAutoConnection(std::boxed::Box<crate::model::PscAutoConnection>),
            /// Detailed information of a PSC connection that is created by the user.
            PscConnection(std::boxed::Box<crate::model::PscConnection>),
        }
    }

    /// Possible states of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// Instance is being created.
        Creating,
        /// Instance has been created and is usable.
        Active,
        /// Instance is being updated.
        Updating,
        /// Instance is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.memorystore.v1.Instance.State",
            ))
        }
    }

    /// Possible authorization modes of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthorizationMode {
        /// Not set.
        Unspecified,
        /// Authorization disabled.
        AuthDisabled,
        /// IAM basic authorization.
        IamAuth,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AuthorizationMode::value] or
        /// [AuthorizationMode::name].
        UnknownValue(authorization_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authorization_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AuthorizationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AuthDisabled => std::option::Option::Some(1),
                Self::IamAuth => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHORIZATION_MODE_UNSPECIFIED"),
                Self::AuthDisabled => std::option::Option::Some("AUTH_DISABLED"),
                Self::IamAuth => std::option::Option::Some("IAM_AUTH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AuthorizationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AuthorizationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AuthorizationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AuthDisabled,
                2 => Self::IamAuth,
                _ => Self::UnknownValue(authorization_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AuthorizationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHORIZATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTH_DISABLED" => Self::AuthDisabled,
                "IAM_AUTH" => Self::IamAuth,
                _ => Self::UnknownValue(authorization_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AuthorizationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AuthDisabled => serializer.serialize_i32(1),
                Self::IamAuth => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AuthorizationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthorizationMode>::new(
                ".google.cloud.memorystore.v1.Instance.AuthorizationMode",
            ))
        }
    }

    /// Possible in-transit encryption modes of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransitEncryptionMode {
        /// Not set.
        Unspecified,
        /// In-transit encryption is disabled.
        TransitEncryptionDisabled,
        /// Server-managed encryption is used for in-transit encryption.
        ServerAuthentication,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransitEncryptionMode::value] or
        /// [TransitEncryptionMode::name].
        UnknownValue(transit_encryption_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transit_encryption_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransitEncryptionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TransitEncryptionDisabled => std::option::Option::Some(1),
                Self::ServerAuthentication => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSIT_ENCRYPTION_MODE_UNSPECIFIED")
                }
                Self::TransitEncryptionDisabled => {
                    std::option::Option::Some("TRANSIT_ENCRYPTION_DISABLED")
                }
                Self::ServerAuthentication => std::option::Option::Some("SERVER_AUTHENTICATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransitEncryptionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransitEncryptionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransitEncryptionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TransitEncryptionDisabled,
                2 => Self::ServerAuthentication,
                _ => Self::UnknownValue(transit_encryption_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransitEncryptionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSIT_ENCRYPTION_MODE_UNSPECIFIED" => Self::Unspecified,
                "TRANSIT_ENCRYPTION_DISABLED" => Self::TransitEncryptionDisabled,
                "SERVER_AUTHENTICATION" => Self::ServerAuthentication,
                _ => Self::UnknownValue(transit_encryption_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransitEncryptionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TransitEncryptionDisabled => serializer.serialize_i32(1),
                Self::ServerAuthentication => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransitEncryptionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransitEncryptionMode>::new(
                ".google.cloud.memorystore.v1.Instance.TransitEncryptionMode",
            ))
        }
    }

    /// Possible node types of the instance. See
    /// <https://cloud.google.com/memorystore/docs/valkey/instance-node-specification>
    /// for more information.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NodeType {
        /// Not set.
        Unspecified,
        /// Shared core nano.
        SharedCoreNano,
        /// High memory medium.
        HighmemMedium,
        /// High memory extra large.
        HighmemXlarge,
        /// Standard small.
        StandardSmall,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NodeType::value] or
        /// [NodeType::name].
        UnknownValue(node_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod node_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NodeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SharedCoreNano => std::option::Option::Some(1),
                Self::HighmemMedium => std::option::Option::Some(2),
                Self::HighmemXlarge => std::option::Option::Some(3),
                Self::StandardSmall => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NODE_TYPE_UNSPECIFIED"),
                Self::SharedCoreNano => std::option::Option::Some("SHARED_CORE_NANO"),
                Self::HighmemMedium => std::option::Option::Some("HIGHMEM_MEDIUM"),
                Self::HighmemXlarge => std::option::Option::Some("HIGHMEM_XLARGE"),
                Self::StandardSmall => std::option::Option::Some("STANDARD_SMALL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NodeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NodeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NodeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SharedCoreNano,
                2 => Self::HighmemMedium,
                3 => Self::HighmemXlarge,
                4 => Self::StandardSmall,
                _ => Self::UnknownValue(node_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NodeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NODE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SHARED_CORE_NANO" => Self::SharedCoreNano,
                "HIGHMEM_MEDIUM" => Self::HighmemMedium,
                "HIGHMEM_XLARGE" => Self::HighmemXlarge,
                "STANDARD_SMALL" => Self::StandardSmall,
                _ => Self::UnknownValue(node_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NodeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SharedCoreNano => serializer.serialize_i32(1),
                Self::HighmemMedium => serializer.serialize_i32(2),
                Self::HighmemXlarge => serializer.serialize_i32(3),
                Self::StandardSmall => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NodeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeType>::new(
                ".google.cloud.memorystore.v1.Instance.NodeType",
            ))
        }
    }

    /// The mode config, which is used to enable/disable cluster mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode is not specified.
        Unspecified,
        /// Deprecated: Use CLUSTER_DISABLED instead.
        #[deprecated]
        Standalone,
        /// Instance is in cluster mode.
        Cluster,
        /// Cluster mode is disabled for the instance.
        ClusterDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standalone => std::option::Option::Some(1),
                Self::Cluster => std::option::Option::Some(2),
                Self::ClusterDisabled => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Standalone => std::option::Option::Some("STANDALONE"),
                Self::Cluster => std::option::Option::Some("CLUSTER"),
                Self::ClusterDisabled => std::option::Option::Some("CLUSTER_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standalone,
                2 => Self::Cluster,
                4 => Self::ClusterDisabled,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "STANDALONE" => Self::Standalone,
                "CLUSTER" => Self::Cluster,
                "CLUSTER_DISABLED" => Self::ClusterDisabled,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standalone => serializer.serialize_i32(1),
                Self::Cluster => serializer.serialize_i32(2),
                Self::ClusterDisabled => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.memorystore.v1.Instance.Mode",
            ))
        }
    }

    /// The source to import from.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ImportSources {
        /// Optional. Immutable. Backups that stored in Cloud Storage buckets.
        /// The Cloud Storage buckets need to be the same region as the instances.
        /// Read permission is required to import from the provided Cloud Storage
        /// Objects.
        GcsSource(std::boxed::Box<crate::model::instance::GcsBackupSource>),
        /// Optional. Immutable. Backups that generated and managed by memorystore
        /// service.
        ManagedBackupSource(std::boxed::Box<crate::model::instance::ManagedBackupSource>),
    }
}

/// The automated backup config for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomatedBackupConfig {
    /// Optional. The automated backup mode. If the mode is disabled, the other
    /// fields will be ignored.
    pub automated_backup_mode: crate::model::automated_backup_config::AutomatedBackupMode,

    /// Optional. How long to keep automated backups before the backups are
    /// deleted. The value should be between 1 day and 365 days. If not specified,
    /// the default value is 35 days.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention: std::option::Option<wkt::Duration>,

    /// The schedule of automated backups.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::automated_backup_config::Schedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomatedBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automated_backup_mode][crate::model::AutomatedBackupConfig::automated_backup_mode].
    pub fn set_automated_backup_mode<
        T: std::convert::Into<crate::model::automated_backup_config::AutomatedBackupMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_mode = v.into();
        self
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupConfig::retention].
    pub fn set_retention<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention][crate::model::AutomatedBackupConfig::retention].
    pub fn set_or_clear_retention<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupConfig::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_config::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::AutomatedBackupConfig::schedule]
    /// if it holds a `FixedFrequencySchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed_frequency_schedule(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
    > {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupConfig::schedule]
    /// to hold a `FixedFrequencySchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_fixed_frequency_schedule<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomatedBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.AutomatedBackupConfig"
    }
}

/// Defines additional types related to [AutomatedBackupConfig].
pub mod automated_backup_config {
    #[allow(unused_imports)]
    use super::*;

    /// This schedule allows the backup to be triggered at a fixed frequency
    /// (currently only daily is supported).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FixedFrequencySchedule {
        /// Required. The start time of every automated backup in UTC. It must be set
        /// to the start of an hour. This field is required.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<gtype::model::TimeOfDay>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FixedFrequencySchedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::automated_backup_config::FixedFrequencySchedule::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::automated_backup_config::FixedFrequencySchedule::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for FixedFrequencySchedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.AutomatedBackupConfig.FixedFrequencySchedule"
        }
    }

    /// The automated backup mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutomatedBackupMode {
        /// Default value. Automated backup config is not specified.
        Unspecified,
        /// Automated backup config disabled.
        Disabled,
        /// Automated backup config enabled.
        Enabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutomatedBackupMode::value] or
        /// [AutomatedBackupMode::name].
        UnknownValue(automated_backup_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod automated_backup_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutomatedBackupMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTOMATED_BACKUP_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutomatedBackupMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutomatedBackupMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutomatedBackupMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Enabled,
                _ => Self::UnknownValue(automated_backup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutomatedBackupMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTOMATED_BACKUP_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "ENABLED" => Self::Enabled,
                _ => Self::UnknownValue(automated_backup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutomatedBackupMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutomatedBackupMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutomatedBackupMode>::new(
                ".google.cloud.memorystore.v1.AutomatedBackupConfig.AutomatedBackupMode",
            ))
        }
    }

    /// The schedule of automated backups.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Schedule {
        /// Optional. Trigger automated backups at a fixed frequency.
        FixedFrequencySchedule(
            std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
        ),
    }
}

/// BackupCollection of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupCollection {
    /// Identifier. Full resource path of the backup collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The instance uid of the backup collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_uid: std::string::String,

    /// Output only. The full resource path of the instance the backup collection
    /// belongs to. Example:
    /// projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Output only. The KMS key used to encrypt the backups under this backup
    /// collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Output only. System assigned unique identifier of the backup collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the backup collection was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupCollection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_uid][crate::model::BackupCollection::instance_uid].
    pub fn set_instance_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uid = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::BackupCollection::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::BackupCollection::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupCollection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupCollection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupCollection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.BackupCollection"
    }
}

/// Backup of an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Identifier. Full resource path of the backup. the last part of the name is
    /// the backup id with the following format: [YYYYMMDDHHMMSS]_[Shorted Instance
    /// UID] OR customer specified while backup instance. Example:
    /// 20240515123000_1234
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time when the backup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instance resource path of this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Output only. Instance uid of this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_uid: std::string::String,

    /// Output only. Total size of the backup in bytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_size_bytes: i64,

    /// Output only. The time when the backup will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. valkey-7.5/valkey-8.0, etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_version: std::string::String,

    /// Output only. List of backup files of the backup.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_files: std::vec::Vec<crate::model::BackupFile>,

    /// Output only. Node type of the instance.
    pub node_type: crate::model::instance::NodeType,

    /// Output only. Number of replicas for the instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub replica_count: i32,

    /// Output only. Number of shards for the instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub shard_count: i32,

    /// Output only. Type of the backup.
    pub backup_type: crate::model::backup::BackupType,

    /// Output only. State of the backup.
    pub state: crate::model::backup::State,

    /// Output only. System assigned unique identifier of the backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::Backup::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [instance_uid][crate::model::Backup::instance_uid].
    pub fn set_instance_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uid = v.into();
        self
    }

    /// Sets the value of [total_size_bytes][crate::model::Backup::total_size_bytes].
    pub fn set_total_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_size_bytes = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [engine_version][crate::model::Backup::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [backup_files][crate::model::Backup::backup_files].
    pub fn set_backup_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupFile>,
    {
        use std::iter::Iterator;
        self.backup_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_type][crate::model::Backup::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::instance::NodeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Backup::replica_count].
    pub fn set_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Backup::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.Backup"
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// The default value, not set.
        Unspecified,
        /// On-demand backup.
        OnDemand,
        /// Automated backup.
        Automated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Automated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Automated => std::option::Option::Some("AUTOMATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Automated,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "AUTOMATED" => Self::Automated,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Automated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.cloud.memorystore.v1.Backup.BackupType",
            ))
        }
    }

    /// State of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value, not set.
        Unspecified,
        /// The backup is being created.
        Creating,
        /// The backup is active to be used.
        Active,
        /// The backup is being deleted.
        Deleting,
        /// The backup is currently suspended due to reasons like project deletion,
        /// billing account closure, etc.
        Suspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Suspended => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Suspended,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "SUSPENDED" => Self::Suspended,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Suspended => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.memorystore.v1.Backup.State",
            ))
        }
    }
}

/// Backup is consisted of multiple backup files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupFile {
    /// Output only. e.g: \<shard-id\>.rdb
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_name: std::string::String,

    /// Output only. Size of the backup file in bytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,

    /// Output only. The time when the backup file was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_name][crate::model::BackupFile::file_name].
    pub fn set_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_name = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::BackupFile::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupFile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupFile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.BackupFile"
    }
}

/// Cross instance replication config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CrossInstanceReplicationConfig {
    /// Required. The role of the instance in cross instance replication.
    pub instance_role: crate::model::cross_instance_replication_config::InstanceRole,

    /// Optional. Details of the primary instance that is used as the replication
    /// source for this secondary instance.
    ///
    /// This field is only set for a secondary instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_instance:
        std::option::Option<crate::model::cross_instance_replication_config::RemoteInstance>,

    /// Optional. List of secondary instances that are replicating from this
    /// primary instance.
    ///
    /// This field is only set for a primary instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secondary_instances:
        std::vec::Vec<crate::model::cross_instance_replication_config::RemoteInstance>,

    /// Output only. The last time cross instance replication config was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. An output only view of all the member instances participating
    /// in the cross instance replication. This view will be provided by every
    /// member instance irrespective of its instance role(primary or secondary).
    ///
    /// A primary instance can provide information about all the secondary
    /// instances replicating from it. However, a secondary instance only knows
    /// about the primary instance from which it is replicating. However, for
    /// scenarios, where the primary instance is unavailable(e.g. regional outage),
    /// a Getinstance request can be sent to any other member instance and this
    /// field will list all the member instances participating in cross instance
    /// replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub membership:
        std::option::Option<crate::model::cross_instance_replication_config::Membership>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrossInstanceReplicationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_role][crate::model::CrossInstanceReplicationConfig::instance_role].
    pub fn set_instance_role<
        T: std::convert::Into<crate::model::cross_instance_replication_config::InstanceRole>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_role = v.into();
        self
    }

    /// Sets the value of [primary_instance][crate::model::CrossInstanceReplicationConfig::primary_instance].
    pub fn set_primary_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cross_instance_replication_config::RemoteInstance>,
    {
        self.primary_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_instance][crate::model::CrossInstanceReplicationConfig::primary_instance].
    pub fn set_or_clear_primary_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cross_instance_replication_config::RemoteInstance>,
    {
        self.primary_instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_instances][crate::model::CrossInstanceReplicationConfig::secondary_instances].
    pub fn set_secondary_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cross_instance_replication_config::RemoteInstance>,
    {
        use std::iter::Iterator;
        self.secondary_instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::CrossInstanceReplicationConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CrossInstanceReplicationConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [membership][crate::model::CrossInstanceReplicationConfig::membership].
    pub fn set_membership<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cross_instance_replication_config::Membership>,
    {
        self.membership = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [membership][crate::model::CrossInstanceReplicationConfig::membership].
    pub fn set_or_clear_membership<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cross_instance_replication_config::Membership>,
    {
        self.membership = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CrossInstanceReplicationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.CrossInstanceReplicationConfig"
    }
}

/// Defines additional types related to [CrossInstanceReplicationConfig].
pub mod cross_instance_replication_config {
    #[allow(unused_imports)]
    use super::*;

    /// Details of the remote instance associated with this instance in a cross
    /// instance replication setup.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RemoteInstance {
        /// Optional. The full resource path of the remote instance in
        /// the format: projects/\<project\>/locations/\<region\>/instances/\<instance-id\>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub instance: std::string::String,

        /// Output only. The unique identifier of the remote instance.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uid: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RemoteInstance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::cross_instance_replication_config::RemoteInstance::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [uid][crate::model::cross_instance_replication_config::RemoteInstance::uid].
        pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uid = v.into();
            self
        }
    }

    impl wkt::message::Message for RemoteInstance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.CrossInstanceReplicationConfig.RemoteInstance"
        }
    }

    /// An output only view of all the member instances participating in the cross
    /// instance replication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Membership {
        /// Output only. The primary instance that acts as the source of replication
        /// for the secondary instances.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub primary_instance:
            std::option::Option<crate::model::cross_instance_replication_config::RemoteInstance>,

        /// Output only. The list of secondary instances replicating from the primary
        /// instance.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub secondary_instances:
            std::vec::Vec<crate::model::cross_instance_replication_config::RemoteInstance>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Membership {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_instance][crate::model::cross_instance_replication_config::Membership::primary_instance].
        pub fn set_primary_instance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::cross_instance_replication_config::RemoteInstance>,
        {
            self.primary_instance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [primary_instance][crate::model::cross_instance_replication_config::Membership::primary_instance].
        pub fn set_or_clear_primary_instance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::cross_instance_replication_config::RemoteInstance>,
        {
            self.primary_instance = v.map(|x| x.into());
            self
        }

        /// Sets the value of [secondary_instances][crate::model::cross_instance_replication_config::Membership::secondary_instances].
        pub fn set_secondary_instances<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::cross_instance_replication_config::RemoteInstance>,
        {
            use std::iter::Iterator;
            self.secondary_instances = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Membership {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.CrossInstanceReplicationConfig.Membership"
        }
    }

    /// The role of the instance in cross instance replication.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceRole {
        /// instance role is not set.
        /// The behavior is equivalent to NONE.
        Unspecified,
        /// This instance does not participate in cross instance replication. It is
        /// an independent instance and does not replicate to or from any other
        /// instances.
        None,
        /// A instance that allows both reads and writes. Any data written to this
        /// instance is also replicated to the attached secondary instances.
        Primary,
        /// A instance that allows only reads and replicates data from a primary
        /// instance.
        Secondary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceRole::value] or
        /// [InstanceRole::name].
        UnknownValue(instance_role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceRole {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Primary => std::option::Option::Some(2),
                Self::Secondary => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_ROLE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Secondary => std::option::Option::Some("SECONDARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceRole {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceRole {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Primary,
                3 => Self::Secondary,
                _ => Self::UnknownValue(instance_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceRole {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_ROLE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "PRIMARY" => Self::Primary,
                "SECONDARY" => Self::Secondary,
                _ => Self::UnknownValue(instance_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceRole {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Primary => serializer.serialize_i32(2),
                Self::Secondary => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceRole {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceRole>::new(
                ".google.cloud.memorystore.v1.CrossInstanceReplicationConfig.InstanceRole",
            ))
        }
    }
}

/// Maintenance policy per instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenancePolicy {
    /// Output only. The time when the policy was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the policy was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Maintenance window that is applied to resources covered by this
    /// policy. Minimum 1. For the current version, the maximum number of
    /// weekly_window is expected to be one.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub weekly_maintenance_window: std::vec::Vec<crate::model::WeeklyMaintenanceWindow>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::MaintenancePolicy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MaintenancePolicy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MaintenancePolicy::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MaintenancePolicy::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [weekly_maintenance_window][crate::model::MaintenancePolicy::weekly_maintenance_window].
    pub fn set_weekly_maintenance_window<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WeeklyMaintenanceWindow>,
    {
        use std::iter::Iterator;
        self.weekly_maintenance_window = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.MaintenancePolicy"
    }
}

/// Time window specified for weekly operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeeklyMaintenanceWindow {
    /// Optional. Allows to define schedule that runs specified day of the week.
    pub day: gtype::model::DayOfWeek,

    /// Optional. Start time of the window in UTC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklyMaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day][crate::model::WeeklyMaintenanceWindow::day].
    pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::WeeklyMaintenanceWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::WeeklyMaintenanceWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WeeklyMaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.WeeklyMaintenanceWindow"
    }
}

/// Upcoming maintenance schedule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceSchedule {
    /// Output only. The start time of any upcoming scheduled maintenance for this
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of any upcoming scheduled maintenance for this
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::MaintenanceSchedule::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::MaintenanceSchedule::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaintenanceSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.MaintenanceSchedule"
    }
}

/// Configuration of a service attachment of the cluster, for creating PSC
/// connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscAttachmentDetail {
    /// Output only. Service attachment URI which your self-created PscConnection
    /// should use as target.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. Type of Psc endpoint.
    pub connection_type: crate::model::ConnectionType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscAttachmentDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_attachment][crate::model::PscAttachmentDetail::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscAttachmentDetail::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscAttachmentDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PscAttachmentDetail"
    }
}

/// Details of consumer resources in a PSC connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscAutoConnection {
    /// Output only. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_connection_id: std::string::String,

    /// Output only. The IP allocated on the consumer network for the PSC
    /// forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Output only. The URI of the consumer side forwarding rule.
    /// Format:
    /// projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Required. The consumer project_id where PSC connections are established.
    /// This should be the same project_id that the instance is being created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The network where the PSC endpoints are created, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Output only. The service attachment which is the target of the PSC
    /// connection, in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection: whether a connection exists
    /// and ACTIVE or it no longer exists. Please note that this value is updated
    /// periodically. Please use Private Service Connect APIs for the latest
    /// status.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,

    /// Ports of the exposed endpoint.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub ports: std::option::Option<crate::model::psc_auto_connection::Ports>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscAutoConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscAutoConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::PscAutoConnection::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscAutoConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscAutoConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscAutoConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscAutoConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscAutoConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscAutoConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }

    /// Sets the value of [ports][crate::model::PscAutoConnection::ports].
    ///
    /// Note that all the setters affecting `ports` are mutually
    /// exclusive.
    pub fn set_ports<
        T: std::convert::Into<std::option::Option<crate::model::psc_auto_connection::Ports>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ports = v.into();
        self
    }

    /// The value of [ports][crate::model::PscAutoConnection::ports]
    /// if it holds a `Port`, `None` if the field is not set or
    /// holds a different branch.
    pub fn port(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.ports.as_ref().and_then(|v| match v {
            crate::model::psc_auto_connection::Ports::Port(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ports][crate::model::PscAutoConnection::ports]
    /// to hold a `Port`.
    ///
    /// Note that all the setters affecting `ports` are
    /// mutually exclusive.
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ports =
            std::option::Option::Some(crate::model::psc_auto_connection::Ports::Port(v.into()));
        self
    }
}

impl wkt::message::Message for PscAutoConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PscAutoConnection"
    }
}

/// Defines additional types related to [PscAutoConnection].
pub mod psc_auto_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Ports of the exposed endpoint.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Ports {
        /// Optional. port will only be set for Primary/Reader or Discovery endpoint.
        Port(i32),
    }
}

/// User created Psc connection configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscConnection {
    /// Required. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_connection_id: std::string::String,

    /// Required. The IP allocated on the consumer network for the PSC forwarding
    /// rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Required. The URI of the consumer side forwarding rule.
    /// Format:
    /// projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Output only. The consumer project_id where the forwarding rule is created
    /// from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The consumer network where the IP address resides, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Required. The service attachment which is the target of the PSC connection,
    /// in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection: whether a connection exists
    /// and ACTIVE or it no longer exists. Please note that this value is updated
    /// periodically. Please use Private Service Connect APIs for the latest
    /// status.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,

    /// Ports of the exposed endpoint.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub ports: std::option::Option<crate::model::psc_connection::Ports>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::PscConnection::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }

    /// Sets the value of [ports][crate::model::PscConnection::ports].
    ///
    /// Note that all the setters affecting `ports` are mutually
    /// exclusive.
    pub fn set_ports<
        T: std::convert::Into<std::option::Option<crate::model::psc_connection::Ports>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ports = v.into();
        self
    }

    /// The value of [ports][crate::model::PscConnection::ports]
    /// if it holds a `Port`, `None` if the field is not set or
    /// holds a different branch.
    pub fn port(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.ports.as_ref().and_then(|v| match v {
            crate::model::psc_connection::Ports::Port(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ports][crate::model::PscConnection::ports]
    /// to hold a `Port`.
    ///
    /// Note that all the setters affecting `ports` are
    /// mutually exclusive.
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ports = std::option::Option::Some(crate::model::psc_connection::Ports::Port(v.into()));
        self
    }
}

impl wkt::message::Message for PscConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PscConnection"
    }
}

/// Defines additional types related to [PscConnection].
pub mod psc_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Ports of the exposed endpoint.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Ports {
        /// Optional. port will only be set for Primary/Reader or Discovery endpoint.
        Port(i32),
    }
}

/// Represents an endpoint for clients to connect to the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryEndpoint {
    /// Output only. IP address of the exposed endpoint clients connect to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub address: std::string::String,

    /// Output only. The port number of the exposed endpoint.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    /// Output only. The network where the IP address of the discovery endpoint
    /// will be reserved, in the form of
    /// projects/{network_project}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [address][crate::model::DiscoveryEndpoint::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::DiscoveryEndpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [network][crate::model::DiscoveryEndpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.DiscoveryEndpoint"
    }
}

/// Represents persistence configuration for a instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersistenceConfig {
    /// Optional. Current persistence mode.
    pub mode: crate::model::persistence_config::PersistenceMode,

    /// Optional. RDB configuration. This field will be ignored if mode is not RDB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rdb_config: std::option::Option<crate::model::persistence_config::RDBConfig>,

    /// Optional. AOF configuration. This field will be ignored if mode is not AOF.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aof_config: std::option::Option<crate::model::persistence_config::AOFConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PersistenceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::PersistenceConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::persistence_config::PersistenceMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [rdb_config][crate::model::PersistenceConfig::rdb_config].
    pub fn set_rdb_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::persistence_config::RDBConfig>,
    {
        self.rdb_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rdb_config][crate::model::PersistenceConfig::rdb_config].
    pub fn set_or_clear_rdb_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::persistence_config::RDBConfig>,
    {
        self.rdb_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aof_config][crate::model::PersistenceConfig::aof_config].
    pub fn set_aof_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::persistence_config::AOFConfig>,
    {
        self.aof_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aof_config][crate::model::PersistenceConfig::aof_config].
    pub fn set_or_clear_aof_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::persistence_config::AOFConfig>,
    {
        self.aof_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PersistenceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PersistenceConfig"
    }
}

/// Defines additional types related to [PersistenceConfig].
pub mod persistence_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for RDB based persistence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RDBConfig {
        /// Optional. Period between RDB snapshots.
        pub rdb_snapshot_period: crate::model::persistence_config::rdb_config::SnapshotPeriod,

        /// Optional. Time that the first snapshot was/will be attempted, and to
        /// which future snapshots will be aligned. If not provided, the current time
        /// will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub rdb_snapshot_start_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RDBConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rdb_snapshot_period][crate::model::persistence_config::RDBConfig::rdb_snapshot_period].
        pub fn set_rdb_snapshot_period<
            T: std::convert::Into<crate::model::persistence_config::rdb_config::SnapshotPeriod>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rdb_snapshot_period = v.into();
            self
        }

        /// Sets the value of [rdb_snapshot_start_time][crate::model::persistence_config::RDBConfig::rdb_snapshot_start_time].
        pub fn set_rdb_snapshot_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.rdb_snapshot_start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [rdb_snapshot_start_time][crate::model::persistence_config::RDBConfig::rdb_snapshot_start_time].
        pub fn set_or_clear_rdb_snapshot_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.rdb_snapshot_start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RDBConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.PersistenceConfig.RDBConfig"
        }
    }

    /// Defines additional types related to [RDBConfig].
    pub mod rdb_config {
        #[allow(unused_imports)]
        use super::*;

        /// Possible snapshot periods.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SnapshotPeriod {
            /// Not set.
            Unspecified,
            /// One hour.
            OneHour,
            /// Six hours.
            SixHours,
            /// Twelve hours.
            TwelveHours,
            /// Twenty four hours.
            TwentyFourHours,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SnapshotPeriod::value] or
            /// [SnapshotPeriod::name].
            UnknownValue(snapshot_period::UnknownValue),
        }

        #[doc(hidden)]
        pub mod snapshot_period {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SnapshotPeriod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::OneHour => std::option::Option::Some(1),
                    Self::SixHours => std::option::Option::Some(2),
                    Self::TwelveHours => std::option::Option::Some(3),
                    Self::TwentyFourHours => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SNAPSHOT_PERIOD_UNSPECIFIED"),
                    Self::OneHour => std::option::Option::Some("ONE_HOUR"),
                    Self::SixHours => std::option::Option::Some("SIX_HOURS"),
                    Self::TwelveHours => std::option::Option::Some("TWELVE_HOURS"),
                    Self::TwentyFourHours => std::option::Option::Some("TWENTY_FOUR_HOURS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SnapshotPeriod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SnapshotPeriod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SnapshotPeriod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::OneHour,
                    2 => Self::SixHours,
                    3 => Self::TwelveHours,
                    4 => Self::TwentyFourHours,
                    _ => Self::UnknownValue(snapshot_period::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SnapshotPeriod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SNAPSHOT_PERIOD_UNSPECIFIED" => Self::Unspecified,
                    "ONE_HOUR" => Self::OneHour,
                    "SIX_HOURS" => Self::SixHours,
                    "TWELVE_HOURS" => Self::TwelveHours,
                    "TWENTY_FOUR_HOURS" => Self::TwentyFourHours,
                    _ => Self::UnknownValue(snapshot_period::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SnapshotPeriod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::OneHour => serializer.serialize_i32(1),
                    Self::SixHours => serializer.serialize_i32(2),
                    Self::TwelveHours => serializer.serialize_i32(3),
                    Self::TwentyFourHours => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SnapshotPeriod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SnapshotPeriod>::new(
                    ".google.cloud.memorystore.v1.PersistenceConfig.RDBConfig.SnapshotPeriod",
                ))
            }
        }
    }

    /// Configuration for AOF based persistence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AOFConfig {
        /// Optional. The fsync mode.
        pub append_fsync: crate::model::persistence_config::aof_config::AppendFsync,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AOFConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [append_fsync][crate::model::persistence_config::AOFConfig::append_fsync].
        pub fn set_append_fsync<
            T: std::convert::Into<crate::model::persistence_config::aof_config::AppendFsync>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.append_fsync = v.into();
            self
        }
    }

    impl wkt::message::Message for AOFConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.PersistenceConfig.AOFConfig"
        }
    }

    /// Defines additional types related to [AOFConfig].
    pub mod aof_config {
        #[allow(unused_imports)]
        use super::*;

        /// Possible fsync modes.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AppendFsync {
            /// Not set. Default: EVERY_SEC
            Unspecified,
            /// Never fsync. Normally Linux will flush data every 30 seconds with this
            /// configuration, but it's up to the kernel's exact tuning.
            Never,
            /// Fsync every second. You may lose 1 second of data if there is a
            /// disaster.
            EverySec,
            /// Fsync every time new write commands are appended to the AOF. The best
            /// data loss protection at the cost of performance.
            Always,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [AppendFsync::value] or
            /// [AppendFsync::name].
            UnknownValue(append_fsync::UnknownValue),
        }

        #[doc(hidden)]
        pub mod append_fsync {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl AppendFsync {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Never => std::option::Option::Some(1),
                    Self::EverySec => std::option::Option::Some(2),
                    Self::Always => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("APPEND_FSYNC_UNSPECIFIED"),
                    Self::Never => std::option::Option::Some("NEVER"),
                    Self::EverySec => std::option::Option::Some("EVERY_SEC"),
                    Self::Always => std::option::Option::Some("ALWAYS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for AppendFsync {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for AppendFsync {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for AppendFsync {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Never,
                    2 => Self::EverySec,
                    3 => Self::Always,
                    _ => Self::UnknownValue(append_fsync::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for AppendFsync {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "APPEND_FSYNC_UNSPECIFIED" => Self::Unspecified,
                    "NEVER" => Self::Never,
                    "EVERY_SEC" => Self::EverySec,
                    "ALWAYS" => Self::Always,
                    _ => Self::UnknownValue(append_fsync::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for AppendFsync {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Never => serializer.serialize_i32(1),
                    Self::EverySec => serializer.serialize_i32(2),
                    Self::Always => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for AppendFsync {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AppendFsync>::new(
                    ".google.cloud.memorystore.v1.PersistenceConfig.AOFConfig.AppendFsync",
                ))
            }
        }
    }

    /// Possible persistence modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PersistenceMode {
        /// Not set.
        Unspecified,
        /// Persistence is disabled, and any snapshot data is deleted.
        Disabled,
        /// RDB based persistence is enabled.
        Rdb,
        /// AOF based persistence is enabled.
        Aof,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PersistenceMode::value] or
        /// [PersistenceMode::name].
        UnknownValue(persistence_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod persistence_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PersistenceMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Rdb => std::option::Option::Some(2),
                Self::Aof => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERSISTENCE_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Rdb => std::option::Option::Some("RDB"),
                Self::Aof => std::option::Option::Some("AOF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PersistenceMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PersistenceMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PersistenceMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Rdb,
                3 => Self::Aof,
                _ => Self::UnknownValue(persistence_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PersistenceMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERSISTENCE_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "RDB" => Self::Rdb,
                "AOF" => Self::Aof,
                _ => Self::UnknownValue(persistence_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PersistenceMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Rdb => serializer.serialize_i32(2),
                Self::Aof => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PersistenceMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PersistenceMode>::new(
                ".google.cloud.memorystore.v1.PersistenceConfig.PersistenceMode",
            ))
        }
    }
}

/// Represents configuration for nodes of the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeConfig {
    /// Output only. Memory size in GB of the node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub size_gb: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_gb][crate::model::NodeConfig::size_gb].
    pub fn set_size_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.NodeConfig"
    }
}

/// Zone distribution configuration for allocation of instance resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZoneDistributionConfig {
    /// Optional. Defines zone where all resources will be allocated with
    /// SINGLE_ZONE mode. Ignored for MULTI_ZONE mode.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Optional. Current zone distribution mode. Defaults to MULTI_ZONE.
    pub mode: crate::model::zone_distribution_config::ZoneDistributionMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZoneDistributionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone][crate::model::ZoneDistributionConfig::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::ZoneDistributionConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::zone_distribution_config::ZoneDistributionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for ZoneDistributionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ZoneDistributionConfig"
    }
}

/// Defines additional types related to [ZoneDistributionConfig].
pub mod zone_distribution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible zone distribution modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ZoneDistributionMode {
        /// Not Set. Default: MULTI_ZONE
        Unspecified,
        /// Distribute resources across 3 zones picked at random within the
        /// region.
        MultiZone,
        /// Provision resources in a single zone. Zone field must be specified.
        SingleZone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ZoneDistributionMode::value] or
        /// [ZoneDistributionMode::name].
        UnknownValue(zone_distribution_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod zone_distribution_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ZoneDistributionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MultiZone => std::option::Option::Some(1),
                Self::SingleZone => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("ZONE_DISTRIBUTION_MODE_UNSPECIFIED")
                }
                Self::MultiZone => std::option::Option::Some("MULTI_ZONE"),
                Self::SingleZone => std::option::Option::Some("SINGLE_ZONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ZoneDistributionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ZoneDistributionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ZoneDistributionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MultiZone,
                2 => Self::SingleZone,
                _ => Self::UnknownValue(zone_distribution_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ZoneDistributionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ZONE_DISTRIBUTION_MODE_UNSPECIFIED" => Self::Unspecified,
                "MULTI_ZONE" => Self::MultiZone,
                "SINGLE_ZONE" => Self::SingleZone,
                _ => Self::UnknownValue(zone_distribution_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ZoneDistributionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MultiZone => serializer.serialize_i32(1),
                Self::SingleZone => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ZoneDistributionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ZoneDistributionMode>::new(
                ".google.cloud.memorystore.v1.ZoneDistributionConfig.ZoneDistributionMode",
            ))
        }
    }
}

/// Request for rescheduling instance maintenance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RescheduleMaintenanceRequest {
    /// Required. Name of the instance to reschedule maintenance for:
    /// `projects/{project}/locations/{location_id}/instances/{instance}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. If reschedule type is SPECIFIC_TIME, schedule_time must be set.
    pub reschedule_type: crate::model::reschedule_maintenance_request::RescheduleType,

    /// Optional. Timestamp when the maintenance shall be rescheduled to if
    /// reschedule_type=SPECIFIC_TIME, in RFC 3339 format.
    /// Example: `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RescheduleMaintenanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RescheduleMaintenanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reschedule_type][crate::model::RescheduleMaintenanceRequest::reschedule_type].
    pub fn set_reschedule_type<
        T: std::convert::Into<crate::model::reschedule_maintenance_request::RescheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reschedule_type = v.into();
        self
    }

    /// Sets the value of [schedule_time][crate::model::RescheduleMaintenanceRequest::schedule_time].
    pub fn set_schedule_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_time][crate::model::RescheduleMaintenanceRequest::schedule_time].
    pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RescheduleMaintenanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.RescheduleMaintenanceRequest"
    }
}

/// Defines additional types related to [RescheduleMaintenanceRequest].
pub mod reschedule_maintenance_request {
    #[allow(unused_imports)]
    use super::*;

    /// Reschedule options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RescheduleType {
        /// Not set.
        Unspecified,
        /// If the user wants to schedule the maintenance to happen now.
        Immediate,
        /// If the user wants to reschedule the maintenance to a specific time.
        SpecificTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RescheduleType::value] or
        /// [RescheduleType::name].
        UnknownValue(reschedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reschedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RescheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Immediate => std::option::Option::Some(1),
                Self::SpecificTime => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESCHEDULE_TYPE_UNSPECIFIED"),
                Self::Immediate => std::option::Option::Some("IMMEDIATE"),
                Self::SpecificTime => std::option::Option::Some("SPECIFIC_TIME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RescheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RescheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RescheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Immediate,
                3 => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RescheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMMEDIATE" => Self::Immediate,
                "SPECIFIC_TIME" => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RescheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Immediate => serializer.serialize_i32(1),
                Self::SpecificTime => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RescheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RescheduleType>::new(
                ".google.cloud.memorystore.v1.RescheduleMaintenanceRequest.RescheduleType",
            ))
        }
    }
}

/// Request message for [ListInstances][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The parent to list instances from.
    /// Format: projects/{project}/locations/{location}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Expression for filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Sort results by a defined order. Supported values: "name",
    /// "create_time".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListInstancesRequest"
    }
}

/// Response message for [ListInstances][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// If the {location} requested was "-" the response contains a list of
    /// instances from all locations. Instances in unreachable locations will be
    /// omitted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for [GetInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the instance to retrieve.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.GetInstanceRequest"
    }
}

/// Request message for [CreateInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The parent resource where this instance will be created.
    /// Format: projects/{project}/locations/{location}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the instance, which will become the final
    /// component of the instance's resource name.
    ///
    /// This value is subject to the following restrictions:
    ///
    /// * Must be 4-63 characters in length
    /// * Must begin with a letter or digit
    /// * Must contain only lowercase letters, digits, and hyphens
    /// * Must not end with a hyphen
    /// * Must be unique within a location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The instance to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.CreateInstanceRequest"
    }
}

/// Request message for [UpdateInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Optional. The list of fields to be updated on the instance. At least one
    /// field must be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The instance to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.UpdateInstanceRequest"
    }
}

/// Request message for [DeleteInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the instance to delete.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.DeleteInstanceRequest"
    }
}

/// Request for [ListBackupCollections]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupCollectionsRequest {
    /// Required. The resource name of the backupCollection location using the
    /// form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.memorystore.v1.ListBackupCollectionsResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.memorystore.v1.ListBackupCollectionsResponse.next_page_token]: crate::model::ListBackupCollectionsResponse::next_page_token
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous
    /// [ListBackupCollections] request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupCollectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupCollectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupCollectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupCollectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupCollectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListBackupCollectionsRequest"
    }
}

/// Response for [ListBackupCollections].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupCollectionsResponse {
    /// A list of backupCollections in the project.
    ///
    /// If the `location_id` in the parent field of the request is "-", all regions
    /// available to the project are queried, and the results aggregated.
    /// If in such an aggregated query a location is unavailable, a placeholder
    /// backupCollection entry is included in the response with the `name` field
    /// set to a value of the form
    /// `projects/{project_id}/locations/{location_id}/backupCollections/`- and the
    /// `status` field set to ERROR and `status_message` field set to "location not
    /// available for ListBackupCollections".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_collections: std::vec::Vec<crate::model::BackupCollection>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupCollectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_collections][crate::model::ListBackupCollectionsResponse::backup_collections].
    pub fn set_backup_collections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupCollection>,
    {
        use std::iter::Iterator;
        self.backup_collections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupCollectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupCollectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupCollectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListBackupCollectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupCollectionsResponse {
    type PageItem = crate::model::BackupCollection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_collections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for [GetBackupCollection].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupCollectionRequest {
    /// Required. Instance backupCollection resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupCollectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupCollectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupCollectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.GetBackupCollectionRequest"
    }
}

/// Request for [ListBackups].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The resource name of the backupCollection using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.memorystore.v1.ListBackupsResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.memorystore.v1.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous
    /// [ListBackupCollections] request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListBackupsRequest"
    }
}

/// Response for [ListBackups].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Backups that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for [GetBackup].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Instance backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.GetBackupRequest"
    }
}

/// Request for [DeleteBackup].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Instance backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.DeleteBackupRequest"
    }
}

/// Request for [ExportBackup].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportBackupRequest {
    /// Required. Instance backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Specify destination to export a backup.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_backup_request::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportBackupRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_backup_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportBackupRequest::destination]
    /// if it holds a `GcsBucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_bucket(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_backup_request::Destination::GcsBucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportBackupRequest::destination]
    /// to hold a `GcsBucket`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_backup_request::Destination::GcsBucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ExportBackupRequest"
    }
}

/// Defines additional types related to [ExportBackupRequest].
pub mod export_backup_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify destination to export a backup.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage bucket, like "my-bucket".
        GcsBucket(std::string::String),
    }
}

/// Request for [BackupInstance].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupInstanceRequest {
    /// Required. Instance resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. TTL for the backup to expire. Value range is 1 day to 100 years.
    /// If not specified, the default value is 100 years.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<wkt::Duration>,

    /// Optional. The id of the backup to be created. If not specified, the
    /// default value ([YYYYMMDDHHMMSS]_[Shortened Instance UID] is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_id: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::BackupInstanceRequest::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::BackupInstanceRequest::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_id][crate::model::BackupInstanceRequest::backup_id].
    pub fn set_backup_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_id][crate::model::BackupInstanceRequest::backup_id].
    pub fn set_or_clear_backup_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.BackupInstanceRequest"
    }
}

/// Request message for [GetCertificateAuthority][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCertificateAuthorityRequest {
    /// Required. The name of the certificate authority.
    /// Format:
    /// projects/{project}/locations/{location}/instances/{instance}/certificateAuthority
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.GetCertificateAuthorityRequest"
    }
}

/// A certificate authority for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateAuthority {
    /// Identifier. Unique name of the certificate authority.
    /// Format:
    /// projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Information about the server certificate authority.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca: std::option::Option<crate::model::certificate_authority::ServerCa>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateAuthority {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateAuthority::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [server_ca][crate::model::CertificateAuthority::server_ca].
    ///
    /// Note that all the setters affecting `server_ca` are mutually
    /// exclusive.
    pub fn set_server_ca<
        T: std::convert::Into<std::option::Option<crate::model::certificate_authority::ServerCa>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = v.into();
        self
    }

    /// The value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// if it holds a `ManagedServerCa`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_server_ca(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
    > {
        #[allow(unreachable_patterns)]
        self.server_ca.as_ref().and_then(|v| match v {
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// to hold a `ManagedServerCa`.
    ///
    /// Note that all the setters affecting `server_ca` are
    /// mutually exclusive.
    pub fn set_managed_server_ca<
        T: std::convert::Into<
                std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = std::option::Option::Some(
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CertificateAuthority {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.CertificateAuthority"
    }
}

/// Defines additional types related to [CertificateAuthority].
pub mod certificate_authority {
    #[allow(unused_imports)]
    use super::*;

    /// A managed certificate authority.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagedCertificateAuthority {
        /// PEM encoded CA certificate chains for managed server authentication.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub ca_certs: std::vec::Vec<
            crate::model::certificate_authority::managed_certificate_authority::CertChain,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManagedCertificateAuthority {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certs][crate::model::certificate_authority::ManagedCertificateAuthority::ca_certs].
        pub fn set_ca_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::certificate_authority::managed_certificate_authority::CertChain,
                >,
        {
            use std::iter::Iterator;
            self.ca_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ManagedCertificateAuthority {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.CertificateAuthority.ManagedCertificateAuthority"
        }
    }

    /// Defines additional types related to [ManagedCertificateAuthority].
    pub mod managed_certificate_authority {
        #[allow(unused_imports)]
        use super::*;

        /// A certificate chain.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CertChain {
            /// The certificates that form the CA chain in order of leaf to root.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub certificates: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CertChain {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [certificates][crate::model::certificate_authority::managed_certificate_authority::CertChain::certificates].
            pub fn set_certificates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.certificates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CertChain {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.memorystore.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain"
            }
        }
    }

    /// Information about the server certificate authority.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ServerCa {
        /// A managed server certificate authority.
        ManagedServerCa(
            std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
        ),
    }
}

/// Represents the metadata of a long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.OperationMetadata"
    }
}

/// Status of the PSC connection.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PscConnectionStatus {
    /// PSC connection status is not specified.
    Unspecified,
    /// The connection is active
    Active,
    /// Connection not found
    NotFound,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PscConnectionStatus::value] or
    /// [PscConnectionStatus::name].
    UnknownValue(psc_connection_status::UnknownValue),
}

#[doc(hidden)]
pub mod psc_connection_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PscConnectionStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::NotFound => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PSC_CONNECTION_STATUS_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::NotFound => std::option::Option::Some("NOT_FOUND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PscConnectionStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PscConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PscConnectionStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::NotFound,
            _ => Self::UnknownValue(psc_connection_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PscConnectionStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PSC_CONNECTION_STATUS_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "NOT_FOUND" => Self::NotFound,
            _ => Self::UnknownValue(psc_connection_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PscConnectionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::NotFound => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PscConnectionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PscConnectionStatus>::new(
            ".google.cloud.memorystore.v1.PscConnectionStatus",
        ))
    }
}

/// Type of a PSC connection
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectionType {
    /// Connection Type is not set
    Unspecified,
    /// Connection that will be used for topology discovery.
    Discovery,
    /// Connection that will be used as primary endpoint to access primary.
    Primary,
    /// Connection that will be used as reader endpoint to access replicas.
    Reader,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectionType::value] or
    /// [ConnectionType::name].
    UnknownValue(connection_type::UnknownValue),
}

#[doc(hidden)]
pub mod connection_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Discovery => std::option::Option::Some(1),
            Self::Primary => std::option::Option::Some(2),
            Self::Reader => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTION_TYPE_UNSPECIFIED"),
            Self::Discovery => std::option::Option::Some("CONNECTION_TYPE_DISCOVERY"),
            Self::Primary => std::option::Option::Some("CONNECTION_TYPE_PRIMARY"),
            Self::Reader => std::option::Option::Some("CONNECTION_TYPE_READER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Discovery,
            2 => Self::Primary,
            3 => Self::Reader,
            _ => Self::UnknownValue(connection_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "CONNECTION_TYPE_DISCOVERY" => Self::Discovery,
            "CONNECTION_TYPE_PRIMARY" => Self::Primary,
            "CONNECTION_TYPE_READER" => Self::Reader,
            _ => Self::UnknownValue(connection_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Discovery => serializer.serialize_i32(1),
            Self::Primary => serializer.serialize_i32(2),
            Self::Reader => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionType>::new(
            ".google.cloud.memorystore.v1.ConnectionType",
        ))
    }
}
