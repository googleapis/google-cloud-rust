// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Memorystore instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Identifier. Unique name of the instance.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Creation timestamp of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Latest update timestamp of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels to represent user-provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Current state of the instance.
    pub state: crate::model::instance::State,

    /// Output only. Additional information about the state of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_info: std::option::Option<crate::model::instance::StateInfo>,

    /// Output only. System assigned, unique identifier for the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. Number of replica nodes per shard. If omitted the default is 0
    /// replicas.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_count: std::option::Option<i32>,

    /// Optional. Immutable. Authorization mode of the instance.
    pub authorization_mode: crate::model::instance::AuthorizationMode,

    /// Optional. Immutable. In-transit encryption mode of the instance.
    pub transit_encryption_mode: crate::model::instance::TransitEncryptionMode,

    /// Optional. Number of shards for the instance.
    pub shard_count: i32,

    /// Output only. Endpoints clients can connect to the instance through.
    /// Currently only one discovery endpoint is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub discovery_endpoints: std::vec::Vec<crate::model::DiscoveryEndpoint>,

    /// Optional. Immutable. Machine type for individual nodes of the instance.
    pub node_type: crate::model::instance::NodeType,

    /// Optional. Persistence configuration of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistence_config: std::option::Option<crate::model::PersistenceConfig>,

    /// Optional. Immutable. Engine version of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_version: std::string::String,

    /// Optional. User-provided engine configurations for the instance.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub engine_configs: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Configuration of individual nodes of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// Optional. Immutable. Zone distribution configuration of the instance for
    /// node allocation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zone_distribution_config: std::option::Option<crate::model::ZoneDistributionConfig>,

    /// Optional. If set to true deletion of the instance will fail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_protection_enabled: std::option::Option<bool>,

    /// Required. Immutable. User inputs and resource details of the auto-created
    /// PSC connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_auto_connections: std::vec::Vec<crate::model::PscAutoConnection>,

    /// Optional. Endpoints for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub endpoints: std::vec::Vec<crate::model::instance::InstanceEndpoint>,

    /// Optional. The mode config for the instance.
    pub mode: crate::model::instance::Mode,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_info][crate::model::Instance::state_info].
    pub fn set_state_info<
        T: std::convert::Into<std::option::Option<crate::model::instance::StateInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state_info = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Instance::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Instance::replica_count].
    pub fn set_replica_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [authorization_mode][crate::model::Instance::authorization_mode].
    pub fn set_authorization_mode<
        T: std::convert::Into<crate::model::instance::AuthorizationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_mode = v.into();
        self
    }

    /// Sets the value of [transit_encryption_mode][crate::model::Instance::transit_encryption_mode].
    pub fn set_transit_encryption_mode<
        T: std::convert::Into<crate::model::instance::TransitEncryptionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transit_encryption_mode = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Instance::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [node_type][crate::model::Instance::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::instance::NodeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [persistence_config][crate::model::Instance::persistence_config].
    pub fn set_persistence_config<
        T: std::convert::Into<std::option::Option<crate::model::PersistenceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.persistence_config = v.into();
        self
    }

    /// Sets the value of [engine_version][crate::model::Instance::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::Instance::node_config].
    pub fn set_node_config<T: std::convert::Into<std::option::Option<crate::model::NodeConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_config = v.into();
        self
    }

    /// Sets the value of [zone_distribution_config][crate::model::Instance::zone_distribution_config].
    pub fn set_zone_distribution_config<
        T: std::convert::Into<std::option::Option<crate::model::ZoneDistributionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.zone_distribution_config = v.into();
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Instance::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deletion_protection_enabled = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::Instance::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::instance::Mode>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [discovery_endpoints][crate::model::Instance::discovery_endpoints].
    pub fn set_discovery_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryEndpoint>,
    {
        use std::iter::Iterator;
        self.discovery_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_auto_connections][crate::model::Instance::psc_auto_connections].
    pub fn set_psc_auto_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscAutoConnection>,
    {
        use std::iter::Iterator;
        self.psc_auto_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [endpoints][crate::model::Instance::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::InstanceEndpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [engine_configs][crate::model::Instance::engine_configs].
    pub fn set_engine_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.engine_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Additional information about the state of the instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StateInfo {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub info: std::option::Option<crate::model::instance::state_info::Info>,
    }

    impl StateInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `info`.
        pub fn set_info<
            T: std::convert::Into<std::option::Option<crate::model::instance::state_info::Info>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = v.into();
            self
        }

        /// The value of [info][crate::model::instance::StateInfo::info]
        /// if it holds a `UpdateInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_update_info(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::instance::state_info::UpdateInfo>>
        {
            #[allow(unreachable_patterns)]
            self.info.as_ref().and_then(|v| match v {
                crate::model::instance::state_info::Info::UpdateInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [info][crate::model::instance::StateInfo::info]
        /// to hold a `UpdateInfo`.
        ///
        /// Note that all the setters affecting `info` are
        /// mutually exclusive.
        pub fn set_update_info<
            T: std::convert::Into<std::boxed::Box<crate::model::instance::state_info::UpdateInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = std::option::Option::Some(
                crate::model::instance::state_info::Info::UpdateInfo(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for StateInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.StateInfo"
        }
    }

    /// Defines additional types related to StateInfo
    pub mod state_info {
        #[allow(unused_imports)]
        use super::*;

        /// Represents information about instance with state UPDATING.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct UpdateInfo {
            /// Output only. Target number of shards for the instance.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_shard_count: std::option::Option<i32>,

            /// Output only. Target number of replica nodes per shard for the instance.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_replica_count: std::option::Option<i32>,
        }

        impl UpdateInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [target_shard_count][crate::model::instance::state_info::UpdateInfo::target_shard_count].
            pub fn set_target_shard_count<T: std::convert::Into<std::option::Option<i32>>>(
                mut self,
                v: T,
            ) -> Self {
                self.target_shard_count = v.into();
                self
            }

            /// Sets the value of [target_replica_count][crate::model::instance::state_info::UpdateInfo::target_replica_count].
            pub fn set_target_replica_count<T: std::convert::Into<std::option::Option<i32>>>(
                mut self,
                v: T,
            ) -> Self {
                self.target_replica_count = v.into();
                self
            }
        }

        impl wkt::message::Message for UpdateInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.memorystore.v1.Instance.StateInfo.UpdateInfo"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Info {
            /// Output only. Describes ongoing update when instance state is UPDATING.
            UpdateInfo(std::boxed::Box<crate::model::instance::state_info::UpdateInfo>),
        }
    }

    /// InstanceEndpoint consists of PSC connections that are created
    /// as a group in each VPC network for accessing the instance. In each group,
    /// there shall be one connection for each service attachment in the cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceEndpoint {
        /// Optional. A group of PSC connections. They are created in the same VPC
        /// network, one for each service attachment in the cluster.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub connections: std::vec::Vec<crate::model::instance::ConnectionDetail>,
    }

    impl InstanceEndpoint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connections][crate::model::instance::InstanceEndpoint::connections].
        pub fn set_connections<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance::ConnectionDetail>,
        {
            use std::iter::Iterator;
            self.connections = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InstanceEndpoint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.InstanceEndpoint"
        }
    }

    /// Information of each PSC connection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectionDetail {
        /// A PSC connection to an instance could either be created through Service
        /// Connectivity Automation (auto connection) during the cluster creation,
        /// or it could be created by customer themeslves (user-created connection).
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub connection: std::option::Option<crate::model::instance::connection_detail::Connection>,
    }

    impl ConnectionDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `connection`.
        pub fn set_connection<
            T: std::convert::Into<
                std::option::Option<crate::model::instance::connection_detail::Connection>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.connection = v.into();
            self
        }

        /// The value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// if it holds a `PscAutoConnection`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_psc_auto_connection(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PscAutoConnection>> {
            #[allow(unreachable_patterns)]
            self.connection.as_ref().and_then(|v| match v {
                crate::model::instance::connection_detail::Connection::PscAutoConnection(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// if it holds a `PscConnection`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_psc_connection(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PscConnection>> {
            #[allow(unreachable_patterns)]
            self.connection.as_ref().and_then(|v| match v {
                crate::model::instance::connection_detail::Connection::PscConnection(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// to hold a `PscAutoConnection`.
        ///
        /// Note that all the setters affecting `connection` are
        /// mutually exclusive.
        pub fn set_psc_auto_connection<
            T: std::convert::Into<std::boxed::Box<crate::model::PscAutoConnection>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.connection = std::option::Option::Some(
                crate::model::instance::connection_detail::Connection::PscAutoConnection(v.into()),
            );
            self
        }

        /// Sets the value of [connection][crate::model::instance::ConnectionDetail::connection]
        /// to hold a `PscConnection`.
        ///
        /// Note that all the setters affecting `connection` are
        /// mutually exclusive.
        pub fn set_psc_connection<
            T: std::convert::Into<std::boxed::Box<crate::model::PscConnection>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.connection = std::option::Option::Some(
                crate::model::instance::connection_detail::Connection::PscConnection(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ConnectionDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.Instance.ConnectionDetail"
        }
    }

    /// Defines additional types related to ConnectionDetail
    pub mod connection_detail {
        #[allow(unused_imports)]
        use super::*;

        /// A PSC connection to an instance could either be created through Service
        /// Connectivity Automation (auto connection) during the cluster creation,
        /// or it could be created by customer themeslves (user-created connection).
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Connection {
            /// Detailed information of a PSC connection that is created through
            /// service connectivity automation.
            PscAutoConnection(std::boxed::Box<crate::model::PscAutoConnection>),
            /// Detailed information of a PSC connection that is created by the user.
            PscConnection(std::boxed::Box<crate::model::PscConnection>),
        }
    }

    /// Possible states of the instance.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Instance is being created.
        pub const CREATING: State = State::new("CREATING");

        /// Instance has been created and is usable.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// Instance is being updated.
        pub const UPDATING: State = State::new("UPDATING");

        /// Instance is being deleted.
        pub const DELETING: State = State::new("DELETING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Possible authorization modes of the instance.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AuthorizationMode(std::borrow::Cow<'static, str>);

    impl AuthorizationMode {
        /// Creates a new AuthorizationMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [AuthorizationMode](AuthorizationMode)
    pub mod authorization_mode {
        use super::AuthorizationMode;

        /// Not set.
        pub const AUTHORIZATION_MODE_UNSPECIFIED: AuthorizationMode =
            AuthorizationMode::new("AUTHORIZATION_MODE_UNSPECIFIED");

        /// Authorization disabled.
        pub const AUTH_DISABLED: AuthorizationMode = AuthorizationMode::new("AUTH_DISABLED");

        /// IAM basic authorization.
        pub const IAM_AUTH: AuthorizationMode = AuthorizationMode::new("IAM_AUTH");
    }

    impl std::convert::From<std::string::String> for AuthorizationMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Possible in-transit encryption modes of the instance.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TransitEncryptionMode(std::borrow::Cow<'static, str>);

    impl TransitEncryptionMode {
        /// Creates a new TransitEncryptionMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [TransitEncryptionMode](TransitEncryptionMode)
    pub mod transit_encryption_mode {
        use super::TransitEncryptionMode;

        /// Not set.
        pub const TRANSIT_ENCRYPTION_MODE_UNSPECIFIED: TransitEncryptionMode =
            TransitEncryptionMode::new("TRANSIT_ENCRYPTION_MODE_UNSPECIFIED");

        /// In-transit encryption is disabled.
        pub const TRANSIT_ENCRYPTION_DISABLED: TransitEncryptionMode =
            TransitEncryptionMode::new("TRANSIT_ENCRYPTION_DISABLED");

        /// Server-managed encryption is used for in-transit encryption.
        pub const SERVER_AUTHENTICATION: TransitEncryptionMode =
            TransitEncryptionMode::new("SERVER_AUTHENTICATION");
    }

    impl std::convert::From<std::string::String> for TransitEncryptionMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// Possible node types of the instance. See
    /// <https://cloud.google.com/memorystore/docs/valkey/instance-node-specification>
    /// for more information.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct NodeType(std::borrow::Cow<'static, str>);

    impl NodeType {
        /// Creates a new NodeType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [NodeType](NodeType)
    pub mod node_type {
        use super::NodeType;

        /// Not set.
        pub const NODE_TYPE_UNSPECIFIED: NodeType = NodeType::new("NODE_TYPE_UNSPECIFIED");

        /// Shared core nano.
        pub const SHARED_CORE_NANO: NodeType = NodeType::new("SHARED_CORE_NANO");

        /// High memory medium.
        pub const HIGHMEM_MEDIUM: NodeType = NodeType::new("HIGHMEM_MEDIUM");

        /// High memory extra large.
        pub const HIGHMEM_XLARGE: NodeType = NodeType::new("HIGHMEM_XLARGE");

        /// Standard small.
        pub const STANDARD_SMALL: NodeType = NodeType::new("STANDARD_SMALL");
    }

    impl std::convert::From<std::string::String> for NodeType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    /// The mode config, which is used to enable/disable cluster mode.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Mode(std::borrow::Cow<'static, str>);

    impl Mode {
        /// Creates a new Mode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Mode](Mode)
    pub mod mode {
        use super::Mode;

        /// Mode is not specified.
        pub const MODE_UNSPECIFIED: Mode = Mode::new("MODE_UNSPECIFIED");

        /// Deprecated: Use CLUSTER_DISABLED instead.
        pub const STANDALONE: Mode = Mode::new("STANDALONE");

        /// Instance is in cluster mode.
        pub const CLUSTER: Mode = Mode::new("CLUSTER");

        /// Cluster mode is disabled for the instance.
        pub const CLUSTER_DISABLED: Mode = Mode::new("CLUSTER_DISABLED");
    }

    impl std::convert::From<std::string::String> for Mode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Details of consumer resources in a PSC connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscAutoConnection {
    /// Output only. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_connection_id: std::string::String,

    /// Output only. The IP allocated on the consumer network for the PSC
    /// forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Output only. The URI of the consumer side forwarding rule.
    /// Format:
    /// projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Required. The consumer project_id where PSC connections are established.
    /// This should be the same project_id that the instance is being created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The network where the PSC endpoints are created, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Output only. The service attachment which is the target of the PSC
    /// connection, in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection: whether a connection exists
    /// and ACTIVE or it no longer exists. Please note that this value is updated
    /// periodically. Please use Private Service Connect APIs for the latest
    /// status.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,

    /// Ports of the exposed endpoint.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub ports: std::option::Option<crate::model::psc_auto_connection::Ports>,
}

impl PscAutoConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscAutoConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::PscAutoConnection::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscAutoConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscAutoConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscAutoConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscAutoConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscAutoConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscAutoConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }

    /// Sets the value of `ports`.
    pub fn set_ports<
        T: std::convert::Into<std::option::Option<crate::model::psc_auto_connection::Ports>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ports = v.into();
        self
    }

    /// The value of [ports][crate::model::PscAutoConnection::ports]
    /// if it holds a `Port`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_port(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.ports.as_ref().and_then(|v| match v {
            crate::model::psc_auto_connection::Ports::Port(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ports][crate::model::PscAutoConnection::ports]
    /// to hold a `Port`.
    ///
    /// Note that all the setters affecting `ports` are
    /// mutually exclusive.
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ports =
            std::option::Option::Some(crate::model::psc_auto_connection::Ports::Port(v.into()));
        self
    }
}

impl wkt::message::Message for PscAutoConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PscAutoConnection"
    }
}

/// Defines additional types related to PscAutoConnection
pub mod psc_auto_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Ports of the exposed endpoint.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Ports {
        /// Optional. Output only. port will only be set for Primary/Reader or
        /// Discovery endpoint.
        Port(i32),
    }
}

/// User created Psc connection configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscConnection {
    /// Output only. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_connection_id: std::string::String,

    /// Required. The IP allocated on the consumer network for the PSC forwarding
    /// rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Required. The URI of the consumer side forwarding rule.
    /// Format:
    /// projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Output only. The consumer project_id where the forwarding rule is created
    /// from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The consumer network where the IP address resides, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Required. The service attachment which is the target of the PSC connection,
    /// in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection: whether a connection exists
    /// and ACTIVE or it no longer exists. Please note that this value is updated
    /// periodically. Please use Private Service Connect APIs for the latest
    /// status.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,
}

impl PscConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::PscConnection::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PscConnection"
    }
}

/// Represents an endpoint for clients to connect to the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryEndpoint {
    /// Output only. IP address of the exposed endpoint clients connect to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub address: std::string::String,

    /// Output only. The port number of the exposed endpoint.
    pub port: i32,

    /// Output only. The network where the IP address of the discovery endpoint
    /// will be reserved, in the form of
    /// projects/{network_project}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,
}

impl DiscoveryEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [address][crate::model::DiscoveryEndpoint::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::DiscoveryEndpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [network][crate::model::DiscoveryEndpoint::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.DiscoveryEndpoint"
    }
}

/// Represents persistence configuration for a instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PersistenceConfig {
    /// Optional. Current persistence mode.
    pub mode: crate::model::persistence_config::PersistenceMode,

    /// Optional. RDB configuration. This field will be ignored if mode is not RDB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rdb_config: std::option::Option<crate::model::persistence_config::RDBConfig>,

    /// Optional. AOF configuration. This field will be ignored if mode is not AOF.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aof_config: std::option::Option<crate::model::persistence_config::AOFConfig>,
}

impl PersistenceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::PersistenceConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::persistence_config::PersistenceMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [rdb_config][crate::model::PersistenceConfig::rdb_config].
    pub fn set_rdb_config<
        T: std::convert::Into<std::option::Option<crate::model::persistence_config::RDBConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rdb_config = v.into();
        self
    }

    /// Sets the value of [aof_config][crate::model::PersistenceConfig::aof_config].
    pub fn set_aof_config<
        T: std::convert::Into<std::option::Option<crate::model::persistence_config::AOFConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aof_config = v.into();
        self
    }
}

impl wkt::message::Message for PersistenceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.PersistenceConfig"
    }
}

/// Defines additional types related to PersistenceConfig
pub mod persistence_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for RDB based persistence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RDBConfig {
        /// Optional. Period between RDB snapshots.
        pub rdb_snapshot_period: crate::model::persistence_config::rdb_config::SnapshotPeriod,

        /// Optional. Time that the first snapshot was/will be attempted, and to
        /// which future snapshots will be aligned. If not provided, the current time
        /// will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub rdb_snapshot_start_time: std::option::Option<wkt::Timestamp>,
    }

    impl RDBConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rdb_snapshot_period][crate::model::persistence_config::RDBConfig::rdb_snapshot_period].
        pub fn set_rdb_snapshot_period<
            T: std::convert::Into<crate::model::persistence_config::rdb_config::SnapshotPeriod>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rdb_snapshot_period = v.into();
            self
        }

        /// Sets the value of [rdb_snapshot_start_time][crate::model::persistence_config::RDBConfig::rdb_snapshot_start_time].
        pub fn set_rdb_snapshot_start_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rdb_snapshot_start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for RDBConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.PersistenceConfig.RDBConfig"
        }
    }

    /// Defines additional types related to RDBConfig
    pub mod rdb_config {
        #[allow(unused_imports)]
        use super::*;

        /// Possible snapshot periods.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct SnapshotPeriod(std::borrow::Cow<'static, str>);

        impl SnapshotPeriod {
            /// Creates a new SnapshotPeriod instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [SnapshotPeriod](SnapshotPeriod)
        pub mod snapshot_period {
            use super::SnapshotPeriod;

            /// Not set.
            pub const SNAPSHOT_PERIOD_UNSPECIFIED: SnapshotPeriod =
                SnapshotPeriod::new("SNAPSHOT_PERIOD_UNSPECIFIED");

            /// One hour.
            pub const ONE_HOUR: SnapshotPeriod = SnapshotPeriod::new("ONE_HOUR");

            /// Six hours.
            pub const SIX_HOURS: SnapshotPeriod = SnapshotPeriod::new("SIX_HOURS");

            /// Twelve hours.
            pub const TWELVE_HOURS: SnapshotPeriod = SnapshotPeriod::new("TWELVE_HOURS");

            /// Twenty four hours.
            pub const TWENTY_FOUR_HOURS: SnapshotPeriod = SnapshotPeriod::new("TWENTY_FOUR_HOURS");
        }

        impl std::convert::From<std::string::String> for SnapshotPeriod {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Configuration for AOF based persistence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AOFConfig {
        /// Optional. The fsync mode.
        pub append_fsync: crate::model::persistence_config::aof_config::AppendFsync,
    }

    impl AOFConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [append_fsync][crate::model::persistence_config::AOFConfig::append_fsync].
        pub fn set_append_fsync<
            T: std::convert::Into<crate::model::persistence_config::aof_config::AppendFsync>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.append_fsync = v.into();
            self
        }
    }

    impl wkt::message::Message for AOFConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.PersistenceConfig.AOFConfig"
        }
    }

    /// Defines additional types related to AOFConfig
    pub mod aof_config {
        #[allow(unused_imports)]
        use super::*;

        /// Possible fsync modes.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct AppendFsync(std::borrow::Cow<'static, str>);

        impl AppendFsync {
            /// Creates a new AppendFsync instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [AppendFsync](AppendFsync)
        pub mod append_fsync {
            use super::AppendFsync;

            /// Not set. Default: EVERY_SEC
            pub const APPEND_FSYNC_UNSPECIFIED: AppendFsync =
                AppendFsync::new("APPEND_FSYNC_UNSPECIFIED");

            /// Never fsync. Normally Linux will flush data every 30 seconds with this
            /// configuration, but it's up to the kernel's exact tuning.
            pub const NEVER: AppendFsync = AppendFsync::new("NEVER");

            /// Fsync every second. You may lose 1 second of data if there is a
            /// disaster.
            pub const EVERY_SEC: AppendFsync = AppendFsync::new("EVERY_SEC");

            /// Fsync every time new write commands are appended to the AOF. The best
            /// data loss protection at the cost of performance.
            pub const ALWAYS: AppendFsync = AppendFsync::new("ALWAYS");
        }

        impl std::convert::From<std::string::String> for AppendFsync {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }
    }

    /// Possible persistence modes.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PersistenceMode(std::borrow::Cow<'static, str>);

    impl PersistenceMode {
        /// Creates a new PersistenceMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [PersistenceMode](PersistenceMode)
    pub mod persistence_mode {
        use super::PersistenceMode;

        /// Not set.
        pub const PERSISTENCE_MODE_UNSPECIFIED: PersistenceMode =
            PersistenceMode::new("PERSISTENCE_MODE_UNSPECIFIED");

        /// Persistence is disabled, and any snapshot data is deleted.
        pub const DISABLED: PersistenceMode = PersistenceMode::new("DISABLED");

        /// RDB based persistence is enabled.
        pub const RDB: PersistenceMode = PersistenceMode::new("RDB");

        /// AOF based persistence is enabled.
        pub const AOF: PersistenceMode = PersistenceMode::new("AOF");
    }

    impl std::convert::From<std::string::String> for PersistenceMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Represents configuration for nodes of the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeConfig {
    /// Output only. Memory size in GB of the node.
    pub size_gb: f64,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [size_gb][crate::model::NodeConfig::size_gb].
    pub fn set_size_gb<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.NodeConfig"
    }
}

/// Zone distribution configuration for allocation of instance resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZoneDistributionConfig {
    /// Optional. Defines zone where all resources will be allocated with
    /// SINGLE_ZONE mode. Ignored for MULTI_ZONE mode.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Optional. Current zone distribution mode. Defaults to MULTI_ZONE.
    pub mode: crate::model::zone_distribution_config::ZoneDistributionMode,
}

impl ZoneDistributionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone][crate::model::ZoneDistributionConfig::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::ZoneDistributionConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::zone_distribution_config::ZoneDistributionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for ZoneDistributionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ZoneDistributionConfig"
    }
}

/// Defines additional types related to ZoneDistributionConfig
pub mod zone_distribution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible zone distribution modes.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ZoneDistributionMode(std::borrow::Cow<'static, str>);

    impl ZoneDistributionMode {
        /// Creates a new ZoneDistributionMode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ZoneDistributionMode](ZoneDistributionMode)
    pub mod zone_distribution_mode {
        use super::ZoneDistributionMode;

        /// Not Set. Default: MULTI_ZONE
        pub const ZONE_DISTRIBUTION_MODE_UNSPECIFIED: ZoneDistributionMode =
            ZoneDistributionMode::new("ZONE_DISTRIBUTION_MODE_UNSPECIFIED");

        /// Distribute resources across 3 zones picked at random within the
        /// region.
        pub const MULTI_ZONE: ZoneDistributionMode = ZoneDistributionMode::new("MULTI_ZONE");

        /// Provision resources in a single zone. Zone field must be specified.
        pub const SINGLE_ZONE: ZoneDistributionMode = ZoneDistributionMode::new("SINGLE_ZONE");
    }

    impl std::convert::From<std::string::String> for ZoneDistributionMode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Request message for [ListInstances][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The parent to list instances from.
    /// Format: projects/{project}/locations/{location}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Expression for filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Sort results by a defined order. Supported values: "name",
    /// "create_time".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListInstancesRequest"
    }
}

/// Response message for [ListInstances][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// If the {location} requested was "-" the response contains a list of
    /// instances from all locations. Instances in unreachable locations will be
    /// omitted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.ListInstancesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for [GetInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the instance to retrieve.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.GetInstanceRequest"
    }
}

/// Request message for [CreateInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The parent resource where this instance will be created.
    /// Format: projects/{project}/locations/{location}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the instance, which will become the final
    /// component of the instance's resource name.
    ///
    /// This value is subject to the following restrictions:
    ///
    /// * Must be 4-63 characters in length
    /// * Must begin with a letter or digit
    /// * Must contain only lowercase letters, digits, and hyphens
    /// * Must not end with a hyphen
    /// * Must be unique within a location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The instance to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.CreateInstanceRequest"
    }
}

/// Request message for [UpdateInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Optional. The list of fields to be updated on the instance. At least one
    /// field must be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The instance to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.UpdateInstanceRequest"
    }
}

/// Request message for [DeleteInstance][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the instance to delete.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.DeleteInstanceRequest"
    }
}

/// Request message for [GetCertificateAuthority][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCertificateAuthorityRequest {
    /// Required. The name of the certificate authority.
    /// Format:
    /// projects/{project}/locations/{location}/instances/{instance}/certificateAuthority
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.GetCertificateAuthorityRequest"
    }
}

/// A certificate authority for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateAuthority {
    /// Identifier. Unique name of the certificate authority.
    /// Format:
    /// projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Information about the server certificate authority.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca: std::option::Option<crate::model::certificate_authority::ServerCa>,
}

impl CertificateAuthority {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateAuthority::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `server_ca`.
    pub fn set_server_ca<
        T: std::convert::Into<std::option::Option<crate::model::certificate_authority::ServerCa>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = v.into();
        self
    }

    /// The value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// if it holds a `ManagedServerCa`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_managed_server_ca(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
    > {
        #[allow(unreachable_patterns)]
        self.server_ca.as_ref().and_then(|v| match v {
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// to hold a `ManagedServerCa`.
    ///
    /// Note that all the setters affecting `server_ca` are
    /// mutually exclusive.
    pub fn set_managed_server_ca<
        T: std::convert::Into<
            std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = std::option::Option::Some(
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CertificateAuthority {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.CertificateAuthority"
    }
}

/// Defines additional types related to CertificateAuthority
pub mod certificate_authority {
    #[allow(unused_imports)]
    use super::*;

    /// A managed certificate authority.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagedCertificateAuthority {
        /// PEM encoded CA certificate chains for managed server authentication.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub ca_certs: std::vec::Vec<
            crate::model::certificate_authority::managed_certificate_authority::CertChain,
        >,
    }

    impl ManagedCertificateAuthority {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certs][crate::model::certificate_authority::ManagedCertificateAuthority::ca_certs].
        pub fn set_ca_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::certificate_authority::managed_certificate_authority::CertChain,
            >,
        {
            use std::iter::Iterator;
            self.ca_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ManagedCertificateAuthority {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.memorystore.v1.CertificateAuthority.ManagedCertificateAuthority"
        }
    }

    /// Defines additional types related to ManagedCertificateAuthority
    pub mod managed_certificate_authority {
        #[allow(unused_imports)]
        use super::*;

        /// A certificate chain.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CertChain {
            /// The certificates that form the CA chain in order of leaf to root.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub certificates: std::vec::Vec<std::string::String>,
        }

        impl CertChain {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [certificates][crate::model::certificate_authority::managed_certificate_authority::CertChain::certificates].
            pub fn set_certificates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.certificates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CertChain {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.memorystore.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain"
            }
        }
    }

    /// Information about the server certificate authority.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ServerCa {
        /// A managed server certificate authority.
        ManagedServerCa(
            std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
        ),
    }
}

/// Represents the metadata of a long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.memorystore.v1.OperationMetadata"
    }
}

/// Status of the PSC connection.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PscConnectionStatus(std::borrow::Cow<'static, str>);

impl PscConnectionStatus {
    /// Creates a new PscConnectionStatus instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [PscConnectionStatus](PscConnectionStatus)
pub mod psc_connection_status {
    use super::PscConnectionStatus;

    /// PSC connection status is not specified.
    pub const PSC_CONNECTION_STATUS_UNSPECIFIED: PscConnectionStatus =
        PscConnectionStatus::new("PSC_CONNECTION_STATUS_UNSPECIFIED");

    /// The connection is active
    pub const ACTIVE: PscConnectionStatus = PscConnectionStatus::new("ACTIVE");

    /// Connection not found
    pub const NOT_FOUND: PscConnectionStatus = PscConnectionStatus::new("NOT_FOUND");
}

impl std::convert::From<std::string::String> for PscConnectionStatus {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

/// Type of a PSC connection
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ConnectionType(std::borrow::Cow<'static, str>);

impl ConnectionType {
    /// Creates a new ConnectionType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ConnectionType](ConnectionType)
pub mod connection_type {
    use super::ConnectionType;

    /// Connection Type is not set
    pub const CONNECTION_TYPE_UNSPECIFIED: ConnectionType =
        ConnectionType::new("CONNECTION_TYPE_UNSPECIFIED");

    /// Connection that will be used for topology discovery.
    pub const CONNECTION_TYPE_DISCOVERY: ConnectionType =
        ConnectionType::new("CONNECTION_TYPE_DISCOVERY");

    /// Connection that will be used as primary endpoint to access primary.
    pub const CONNECTION_TYPE_PRIMARY: ConnectionType =
        ConnectionType::new("CONNECTION_TYPE_PRIMARY");

    /// Connection that will be used as reader endpoint to access replicas.
    pub const CONNECTION_TYPE_READER: ConnectionType =
        ConnectionType::new("CONNECTION_TYPE_READER");
}

impl std::convert::From<std::string::String> for ConnectionType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}
