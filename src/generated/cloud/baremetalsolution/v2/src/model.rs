// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Represents the metadata from a long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the action executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user requested the cancellation
    /// of the operation. Operations that have been successfully cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used with the operation.
    pub api_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.OperationMetadata"
    }
}

/// Response message from resetting a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetInstanceResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResetInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResetInstanceResponse"
    }
}

/// A server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Immutable. The resource name of this `Instance`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}`
    pub name: std::string::String,

    /// Output only. An identifier for the `Instance`, generated by the backend.
    pub id: std::string::String,

    /// Output only. Create a time stamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update a time stamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Immutable. The server type.
    /// [Available server
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub machine_type: std::string::String,

    /// Output only. The state of the server.
    pub state: crate::model::instance::State,

    /// True if you enable hyperthreading for the server, otherwise false.
    /// The default value is false.
    pub hyperthreading_enabled: bool,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. List of LUNs associated with this server.
    pub luns: std::vec::Vec<crate::model::Lun>,

    /// Input only. List of Volumes to attach to this Instance on creation.
    /// This field won't be populated in Get/List responses.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Output only. List of networks associated with this server.
    pub networks: std::vec::Vec<crate::model::Network>,

    /// Output only. True if the interactive serial console feature is enabled for
    /// the instance, false otherwise. The default value is false.
    pub interactive_serial_console_enabled: bool,

    /// The OS image currently installed on the server.
    pub os_image: std::string::String,

    /// Immutable. Pod name.
    /// Pod is an independent part of infrastructure.
    /// Instance can be connected to the assets (networks, volumes) allocated
    /// in the same pod only.
    pub pod: std::string::String,

    /// Instance network template name. For eg, bondaa-bondaa, bondab-nic, etc.
    /// Generally, the template name follows the syntax of
    /// "bond<bond_mode>" or "nic".
    pub network_template: std::string::String,

    /// List of logical interfaces for the instance. The number of logical
    /// interfaces will be the same as number of hardware bond/nic on the chosen
    /// network template. For the non-multivlan configurations (for eg, existing
    /// servers) that use existing default network template (bondaa-bondaa), both
    /// the Instance.networks field and the Instance.logical_interfaces fields will
    /// be filled to ensure backward compatibility. For the others, only
    /// Instance.logical_interfaces will be filled.
    pub logical_interfaces: std::vec::Vec<crate::model::LogicalInterface>,

    /// Output only. Text field about info for logging in.
    pub login_info: std::string::String,

    /// The workload profile for the instance.
    pub workload_profile: crate::model::WorkloadProfile,

    /// Output only. The firmware version for the instance.
    pub firmware_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [hyperthreading_enabled][crate::model::Instance::hyperthreading_enabled].
    pub fn set_hyperthreading_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hyperthreading_enabled = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [luns][crate::model::Instance::luns].
    pub fn set_luns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lun>,
    {
        use std::iter::Iterator;
        self.luns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Instance::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Instance::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [interactive_serial_console_enabled][crate::model::Instance::interactive_serial_console_enabled].
    pub fn set_interactive_serial_console_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.interactive_serial_console_enabled = v.into();
        self
    }

    /// Sets the value of [os_image][crate::model::Instance::os_image].
    pub fn set_os_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_image = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Instance::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [network_template][crate::model::Instance::network_template].
    pub fn set_network_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_template = v.into();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::Instance::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [login_info][crate::model::Instance::login_info].
    pub fn set_login_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.login_info = v.into();
        self
    }

    /// Sets the value of [workload_profile][crate::model::Instance::workload_profile].
    pub fn set_workload_profile<T: std::convert::Into<crate::model::WorkloadProfile>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_profile = v.into();
        self
    }

    /// Sets the value of [firmware_version][crate::model::Instance::firmware_version].
    pub fn set_firmware_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware_version = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for this server.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The server is in an unknown state.
        Unspecified,
        /// The server is being provisioned.
        Provisioning,
        /// The server is running.
        Running,
        /// The server has been deleted.
        Deleted,
        /// The server is being updated.
        Updating,
        /// The server is starting.
        Starting,
        /// The server is stopping.
        Stopping,
        /// The server is shutdown.
        Shutdown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Starting => std::option::Option::Some(5),
                Self::Stopping => std::option::Option::Some(6),
                Self::Shutdown => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Shutdown => std::option::Option::Some("SHUTDOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Deleted,
                4 => Self::Updating,
                5 => Self::Starting,
                6 => Self::Stopping,
                7 => Self::Shutdown,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                "STARTING" => Self::Starting,
                "STOPPING" => Self::Stopping,
                "SHUTDOWN" => Self::Shutdown,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Starting => serializer.serialize_i32(5),
                Self::Stopping => serializer.serialize_i32(6),
                Self::Shutdown => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Instance.State",
            ))
        }
    }
}

/// Message for requesting server information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetInstanceRequest"
    }
}

/// Message for requesting the list of servers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. Parent value for ListInstancesRequest.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListInstancesRequest"
    }
}

/// Response message for the list of servers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of servers.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message requesting to updating a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. The server to update.
    ///
    /// The `name` field is used to identify the instance to update.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    pub instance: std::option::Option<crate::model::Instance>,

    /// The list of fields to update.
    /// The currently supported fields are:
    /// `labels`
    /// `hyperthreading_enabled`
    /// `os_image`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateInstanceRequest"
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameInstanceRequest {
    /// Required. The `name` field is used to identify the instance.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    pub name: std::string::String,

    /// Required. The new `id` of the instance.
    pub new_instance_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_instance_id][crate::model::RenameInstanceRequest::new_instance_id].
    pub fn set_new_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_instance_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameInstanceRequest"
    }
}

/// Message requesting to reset a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResetInstanceRequest"
    }
}

/// Message requesting to start a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StartInstanceRequest"
    }
}

/// Response message from starting a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartInstanceResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StartInstanceResponse"
    }
}

/// Message requesting to stop a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StopInstanceRequest"
    }
}

/// Response message from stopping a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopInstanceResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StopInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StopInstanceResponse"
    }
}

/// Message for enabling the interactive serial console on an instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableInteractiveSerialConsoleRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableInteractiveSerialConsoleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableInteractiveSerialConsoleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableInteractiveSerialConsoleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EnableInteractiveSerialConsoleRequest"
    }
}

/// Message for response of EnableInteractiveSerialConsole.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableInteractiveSerialConsoleResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableInteractiveSerialConsoleResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableInteractiveSerialConsoleResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EnableInteractiveSerialConsoleResponse"
    }
}

/// Message for disabling the interactive serial console on an instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableInteractiveSerialConsoleRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableInteractiveSerialConsoleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableInteractiveSerialConsoleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisableInteractiveSerialConsoleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DisableInteractiveSerialConsoleRequest"
    }
}

/// Message for response of DisableInteractiveSerialConsole.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableInteractiveSerialConsoleResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableInteractiveSerialConsoleResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisableInteractiveSerialConsoleResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DisableInteractiveSerialConsoleResponse"
    }
}

/// Message for detach specific LUN from an Instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachLunRequest {
    /// Required. Name of the instance.
    pub instance: std::string::String,

    /// Required. Name of the Lun to detach.
    pub lun: std::string::String,

    /// If true, performs lun unmapping without instance reboot.
    pub skip_reboot: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::DetachLunRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [lun][crate::model::DetachLunRequest::lun].
    pub fn set_lun<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lun = v.into();
        self
    }

    /// Sets the value of [skip_reboot][crate::model::DetachLunRequest::skip_reboot].
    pub fn set_skip_reboot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_reboot = v.into();
        self
    }
}

impl wkt::message::Message for DetachLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DetachLunRequest"
    }
}

/// Network template.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerNetworkTemplate {
    /// Output only. Template's unique name. The full resource name follows the
    /// pattern:
    /// `projects/{project}/locations/{location}/serverNetworkTemplate/{server_network_template}`
    /// Generally, the {server_network_template} follows the syntax of
    /// "bond<interface_type_index><bond_mode>" or "nic<interface_type_index>".
    pub name: std::string::String,

    /// Instance types this template is applicable to.
    pub applicable_instance_types: std::vec::Vec<std::string::String>,

    /// Logical interfaces.
    pub logical_interfaces: std::vec::Vec<crate::model::server_network_template::LogicalInterface>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerNetworkTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServerNetworkTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [applicable_instance_types][crate::model::ServerNetworkTemplate::applicable_instance_types].
    pub fn set_applicable_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::ServerNetworkTemplate::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::server_network_template::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServerNetworkTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ServerNetworkTemplate"
    }
}

/// Defines additional types related to [ServerNetworkTemplate].
pub mod server_network_template {
    #[allow(unused_imports)]
    use super::*;

    /// Logical interface.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LogicalInterface {
        /// Interface name.
        /// This is not a globally unique identifier.
        /// Name is unique only inside the ServerNetworkTemplate. This is of syntax
        /// \<bond\><interface_type_index><bond_mode> or \<nic\><interface_type_index>
        /// and forms part of the network template name.
        pub name: std::string::String,

        /// Interface type.
        pub r#type: crate::model::server_network_template::logical_interface::InterfaceType,

        /// If true, interface must have network connected.
        pub required: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LogicalInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::server_network_template::LogicalInterface::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::server_network_template::LogicalInterface::type].
        pub fn set_type<
            T: std::convert::Into<
                    crate::model::server_network_template::logical_interface::InterfaceType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [required][crate::model::server_network_template::LogicalInterface::required].
        pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.required = v.into();
            self
        }
    }

    impl wkt::message::Message for LogicalInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.ServerNetworkTemplate.LogicalInterface"
        }
    }

    /// Defines additional types related to [LogicalInterface].
    pub mod logical_interface {
        #[allow(unused_imports)]
        use super::*;

        /// Interface type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum InterfaceType {
            /// Unspecified value.
            Unspecified,
            /// Bond interface type.
            Bond,
            /// NIC interface type.
            Nic,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [InterfaceType::value] or
            /// [InterfaceType::name].
            UnknownValue(interface_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod interface_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl InterfaceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Bond => std::option::Option::Some(1),
                    Self::Nic => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("INTERFACE_TYPE_UNSPECIFIED"),
                    Self::Bond => std::option::Option::Some("BOND"),
                    Self::Nic => std::option::Option::Some("NIC"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for InterfaceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for InterfaceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for InterfaceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Bond,
                    2 => Self::Nic,
                    _ => Self::UnknownValue(interface_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for InterfaceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "INTERFACE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "BOND" => Self::Bond,
                    "NIC" => Self::Nic,
                    _ => Self::UnknownValue(interface_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for InterfaceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Bond => serializer.serialize_i32(1),
                    Self::Nic => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for InterfaceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterfaceType>::new(
                    ".google.cloud.baremetalsolution.v2.ServerNetworkTemplate.LogicalInterface.InterfaceType"))
            }
        }
    }
}

/// A storage volume logical unit number (LUN).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Lun {
    /// Output only. The name of the LUN.
    pub name: std::string::String,

    /// An identifier for the LUN, generated by the backend.
    pub id: std::string::String,

    /// The state of this storage volume.
    pub state: crate::model::lun::State,

    /// The size of this LUN, in gigabytes.
    pub size_gb: i64,

    /// The LUN multiprotocol type ensures the characteristics of the LUN are
    /// optimized for each operating system.
    pub multiprotocol_type: crate::model::lun::MultiprotocolType,

    /// Display the storage volume for this LUN.
    pub storage_volume: std::string::String,

    /// Display if this LUN can be shared between multiple physical servers.
    pub shareable: bool,

    /// Display if this LUN is a boot LUN.
    pub boot_lun: bool,

    /// The storage type for this LUN.
    pub storage_type: crate::model::lun::StorageType,

    /// The WWID for this LUN.
    pub wwid: std::string::String,

    /// Output only. Time after which LUN will be fully deleted.
    /// It is filled only for LUNs in COOL_OFF state.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instances this Lun is attached to.
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Lun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Lun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Lun::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Lun::state].
    pub fn set_state<T: std::convert::Into<crate::model::lun::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Lun::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [multiprotocol_type][crate::model::Lun::multiprotocol_type].
    pub fn set_multiprotocol_type<T: std::convert::Into<crate::model::lun::MultiprotocolType>>(
        mut self,
        v: T,
    ) -> Self {
        self.multiprotocol_type = v.into();
        self
    }

    /// Sets the value of [storage_volume][crate::model::Lun::storage_volume].
    pub fn set_storage_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_volume = v.into();
        self
    }

    /// Sets the value of [shareable][crate::model::Lun::shareable].
    pub fn set_shareable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.shareable = v.into();
        self
    }

    /// Sets the value of [boot_lun][crate::model::Lun::boot_lun].
    pub fn set_boot_lun<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.boot_lun = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::Lun::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::lun::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [wwid][crate::model::Lun::wwid].
    pub fn set_wwid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.wwid = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Lun::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Lun::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::Lun::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Lun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Lun"
    }
}

/// Defines additional types related to [Lun].
pub mod lun {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for the LUN.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The LUN is in an unknown state.
        Unspecified,
        /// The LUN is being created.
        Creating,
        /// The LUN is being updated.
        Updating,
        /// The LUN is ready for use.
        Ready,
        /// The LUN has been requested to be deleted.
        Deleting,
        /// The LUN is in cool off state. It will be deleted after `expire_time`.
        CoolOff,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::CoolOff => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::CoolOff => std::option::Option::Some("COOL_OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Updating,
                3 => Self::Ready,
                4 => Self::Deleting,
                5 => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "COOL_OFF" => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::CoolOff => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Lun.State",
            ))
        }
    }

    /// Display the operating systems present for the LUN multiprotocol type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MultiprotocolType {
        /// Server has no OS specified.
        Unspecified,
        /// Server with Linux OS.
        Linux,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MultiprotocolType::value] or
        /// [MultiprotocolType::name].
        UnknownValue(multiprotocol_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod multiprotocol_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MultiprotocolType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Linux => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MULTIPROTOCOL_TYPE_UNSPECIFIED"),
                Self::Linux => std::option::Option::Some("LINUX"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MultiprotocolType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MultiprotocolType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MultiprotocolType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Linux,
                _ => Self::UnknownValue(multiprotocol_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MultiprotocolType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MULTIPROTOCOL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LINUX" => Self::Linux,
                _ => Self::UnknownValue(multiprotocol_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MultiprotocolType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Linux => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MultiprotocolType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MultiprotocolType>::new(
                ".google.cloud.baremetalsolution.v2.Lun.MultiprotocolType",
            ))
        }
    }

    /// The storage types for a LUN.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The storage type for this LUN is unknown.
        Unspecified,
        /// This storage type for this LUN is SSD.
        Ssd,
        /// This storage type for this LUN is HDD.
        Hdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ssd => std::option::Option::Some(1),
                Self::Hdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Ssd => std::option::Option::Some("SSD"),
                Self::Hdd => std::option::Option::Some("HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ssd,
                2 => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SSD" => Self::Ssd,
                "HDD" => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ssd => serializer.serialize_i32(1),
                Self::Hdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.baremetalsolution.v2.Lun.StorageType",
            ))
        }
    }
}

/// Message for requesting storage lun information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLunRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetLunRequest"
    }
}

/// Message for requesting a list of storage volume luns.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLunsRequest {
    /// Required. Parent value for ListLunsRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListLunsRequest"
    }
}

/// Response message containing the list of storage volume luns.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLunsResponse {
    /// The list of luns.
    pub luns: std::vec::Vec<crate::model::Lun>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [luns][crate::model::ListLunsResponse::luns].
    pub fn set_luns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lun>,
    {
        use std::iter::Iterator;
        self.luns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListLunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListLunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLunsResponse {
    type PageItem = crate::model::Lun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.luns
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for skip lun cooloff and delete it.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictLunRequest {
    /// Required. The name of the lun.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EvictLunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EvictLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EvictLunRequest"
    }
}

/// A Network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Network {
    /// Output only. The resource name of this `Network`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/networks/{network}`
    pub name: std::string::String,

    /// An identifier for the `Network`, generated by the backend.
    pub id: std::string::String,

    /// The type of this network.
    pub r#type: crate::model::network::Type,

    /// IP address configured.
    pub ip_address: std::string::String,

    /// List of physical interfaces.
    pub mac_address: std::vec::Vec<std::string::String>,

    /// The Network state.
    pub state: crate::model::network::State,

    /// The vlan id of the Network.
    pub vlan_id: std::string::String,

    /// The cidr of the Network.
    pub cidr: std::string::String,

    /// The vrf for the Network.
    pub vrf: std::option::Option<crate::model::Vrf>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// IP range for reserved for services (e.g. NFS).
    pub services_cidr: std::string::String,

    /// List of IP address reservations in this network.
    /// When updating this field, an error will be generated if a reservation
    /// conflicts with an IP address already allocated to a physical server.
    pub reservations: std::vec::Vec<crate::model::NetworkAddressReservation>,

    /// Output only. Pod name.
    pub pod: std::string::String,

    /// Input only. List of mount points to attach the network to.
    pub mount_points: std::vec::Vec<crate::model::NetworkMountPoint>,

    /// Whether network uses standard frames or jumbo ones.
    pub jumbo_frames_enabled: bool,

    /// Output only. Gateway ip address.
    pub gateway_ip: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Network::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Network::type].
    pub fn set_type<T: std::convert::Into<crate::model::network::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::Network::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [mac_address][crate::model::Network::mac_address].
    pub fn set_mac_address<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mac_address = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Network::state].
    pub fn set_state<T: std::convert::Into<crate::model::network::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [vlan_id][crate::model::Network::vlan_id].
    pub fn set_vlan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vlan_id = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::Network::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [vrf][crate::model::Network::vrf].
    pub fn set_vrf<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Vrf>,
    {
        self.vrf = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vrf][crate::model::Network::vrf].
    pub fn set_or_clear_vrf<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Vrf>,
    {
        self.vrf = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Network::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [services_cidr][crate::model::Network::services_cidr].
    pub fn set_services_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.services_cidr = v.into();
        self
    }

    /// Sets the value of [reservations][crate::model::Network::reservations].
    pub fn set_reservations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAddressReservation>,
    {
        use std::iter::Iterator;
        self.reservations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod][crate::model::Network::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [mount_points][crate::model::Network::mount_points].
    pub fn set_mount_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkMountPoint>,
    {
        use std::iter::Iterator;
        self.mount_points = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jumbo_frames_enabled][crate::model::Network::jumbo_frames_enabled].
    pub fn set_jumbo_frames_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.jumbo_frames_enabled = v.into();
        self
    }

    /// Sets the value of [gateway_ip][crate::model::Network::gateway_ip].
    pub fn set_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gateway_ip = v.into();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Network"
    }
}

/// Defines additional types related to [Network].
pub mod network {
    #[allow(unused_imports)]
    use super::*;

    /// Network type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified value.
        Unspecified,
        /// Client network, a network peered to a Google Cloud VPC.
        Client,
        /// Private network, a network local to the Bare Metal Solution environment.
        Private,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Client => std::option::Option::Some(1),
                Self::Private => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Client => std::option::Option::Some("CLIENT"),
                Self::Private => std::option::Option::Some("PRIVATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Client,
                2 => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLIENT" => Self::Client,
                "PRIVATE" => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Client => serializer.serialize_i32(1),
                Self::Private => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.baremetalsolution.v2.Network.Type",
            ))
        }
    }

    /// The possible states for this Network.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Network is in an unknown state.
        Unspecified,
        /// The Network is provisioning.
        Provisioning,
        /// The Network has been provisioned.
        Provisioned,
        /// The Network is being deprovisioned.
        Deprovisioning,
        /// The Network is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Provisioned => std::option::Option::Some(2),
                Self::Deprovisioning => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::Deprovisioning => std::option::Option::Some("DEPROVISIONING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Provisioned,
                3 => Self::Deprovisioning,
                4 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "PROVISIONED" => Self::Provisioned,
                "DEPROVISIONING" => Self::Deprovisioning,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Provisioned => serializer.serialize_i32(2),
                Self::Deprovisioning => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Network.State",
            ))
        }
    }
}

/// A reservation of one or more addresses in a network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkAddressReservation {
    /// The first address of this reservation block.
    /// Must be specified as a single IPv4 address, e.g. 10.1.2.2.
    pub start_address: std::string::String,

    /// The last address of this reservation block, inclusive. I.e., for cases when
    /// reservations are only single addresses, end_address and start_address will
    /// be the same.
    /// Must be specified as a single IPv4 address, e.g. 10.1.2.2.
    pub end_address: std::string::String,

    /// A note about this reservation, intended for human consumption.
    pub note: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkAddressReservation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_address][crate::model::NetworkAddressReservation::start_address].
    pub fn set_start_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_address = v.into();
        self
    }

    /// Sets the value of [end_address][crate::model::NetworkAddressReservation::end_address].
    pub fn set_end_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_address = v.into();
        self
    }

    /// Sets the value of [note][crate::model::NetworkAddressReservation::note].
    pub fn set_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note = v.into();
        self
    }
}

impl wkt::message::Message for NetworkAddressReservation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkAddressReservation"
    }
}

/// A network VRF.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Vrf {
    /// The name of the VRF.
    pub name: std::string::String,

    /// The possible state of VRF.
    pub state: crate::model::vrf::State,

    /// The QOS policy applied to this VRF.
    /// The value is only meaningful when all the vlan attachments have the same
    /// QoS. This field should not be used for new integrations, use vlan
    /// attachment level qos instead. The field is left for backward-compatibility.
    pub qos_policy: std::option::Option<crate::model::vrf::QosPolicy>,

    /// The list of VLAN attachments for the VRF.
    pub vlan_attachments: std::vec::Vec<crate::model::vrf::VlanAttachment>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vrf {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Vrf::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Vrf::state].
    pub fn set_state<T: std::convert::Into<crate::model::vrf::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [qos_policy][crate::model::Vrf::qos_policy].
    pub fn set_qos_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vrf::QosPolicy>,
    {
        self.qos_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qos_policy][crate::model::Vrf::qos_policy].
    pub fn set_or_clear_qos_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vrf::QosPolicy>,
    {
        self.qos_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vlan_attachments][crate::model::Vrf::vlan_attachments].
    pub fn set_vlan_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vrf::VlanAttachment>,
    {
        use std::iter::Iterator;
        self.vlan_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Vrf {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF"
    }
}

/// Defines additional types related to [Vrf].
pub mod vrf {
    #[allow(unused_imports)]
    use super::*;

    /// QOS policy parameters.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QosPolicy {
        /// The bandwidth permitted by the QOS policy, in gbps.
        pub bandwidth_gbps: f64,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QosPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bandwidth_gbps][crate::model::vrf::QosPolicy::bandwidth_gbps].
        pub fn set_bandwidth_gbps<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.bandwidth_gbps = v.into();
            self
        }
    }

    impl wkt::message::Message for QosPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF.QosPolicy"
        }
    }

    /// VLAN attachment details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VlanAttachment {
        /// The peer vlan ID of the attachment.
        pub peer_vlan_id: i64,

        /// The peer IP of the attachment.
        pub peer_ip: std::string::String,

        /// The router IP of the attachment.
        pub router_ip: std::string::String,

        /// Input only. Pairing key.
        pub pairing_key: std::string::String,

        /// The QOS policy applied to this VLAN attachment.
        /// This value should be preferred to using qos at vrf level.
        pub qos_policy: std::option::Option<crate::model::vrf::QosPolicy>,

        /// Immutable. The identifier of the attachment within vrf.
        pub id: std::string::String,

        /// Optional. The name of the vlan attachment within vrf. This is of the form
        /// projects/{project_number}/regions/{region}/interconnectAttachments/{interconnect_attachment}
        pub interconnect_attachment: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VlanAttachment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peer_vlan_id][crate::model::vrf::VlanAttachment::peer_vlan_id].
        pub fn set_peer_vlan_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.peer_vlan_id = v.into();
            self
        }

        /// Sets the value of [peer_ip][crate::model::vrf::VlanAttachment::peer_ip].
        pub fn set_peer_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.peer_ip = v.into();
            self
        }

        /// Sets the value of [router_ip][crate::model::vrf::VlanAttachment::router_ip].
        pub fn set_router_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.router_ip = v.into();
            self
        }

        /// Sets the value of [pairing_key][crate::model::vrf::VlanAttachment::pairing_key].
        pub fn set_pairing_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pairing_key = v.into();
            self
        }

        /// Sets the value of [qos_policy][crate::model::vrf::VlanAttachment::qos_policy].
        pub fn set_qos_policy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::vrf::QosPolicy>,
        {
            self.qos_policy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [qos_policy][crate::model::vrf::VlanAttachment::qos_policy].
        pub fn set_or_clear_qos_policy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::vrf::QosPolicy>,
        {
            self.qos_policy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [id][crate::model::vrf::VlanAttachment::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [interconnect_attachment][crate::model::vrf::VlanAttachment::interconnect_attachment].
        pub fn set_interconnect_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.interconnect_attachment = v.into();
            self
        }
    }

    impl wkt::message::Message for VlanAttachment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF.VlanAttachment"
        }
    }

    /// The possible states for this VRF.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The unspecified state.
        Unspecified,
        /// The vrf is provisioning.
        Provisioning,
        /// The vrf is provisioned.
        Provisioned,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Provisioned => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Provisioned,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "PROVISIONED" => Self::Provisioned,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Provisioned => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.VRF.State",
            ))
        }
    }
}

/// Each logical interface represents a logical abstraction of the underlying
/// physical interface (for eg. bond, nic) of the instance. Each logical
/// interface can effectively map to multiple network-IP pairs and still be
/// mapped to one underlying physical interface.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LogicalInterface {
    /// List of logical network interfaces within a logical interface.
    pub logical_network_interfaces:
        std::vec::Vec<crate::model::logical_interface::LogicalNetworkInterface>,

    /// Interface name. This is of syntax \<bond\><bond_mode> or \<nic\> and
    /// forms part of the network template name.
    pub name: std::string::String,

    /// The index of the logical interface mapping to the index of the hardware
    /// bond or nic on the chosen network template. This field is deprecated.
    #[deprecated]
    pub interface_index: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogicalInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [logical_network_interfaces][crate::model::LogicalInterface::logical_network_interfaces].
    pub fn set_logical_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logical_interface::LogicalNetworkInterface>,
    {
        use std::iter::Iterator;
        self.logical_network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::LogicalInterface::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [interface_index][crate::model::LogicalInterface::interface_index].
    #[deprecated]
    pub fn set_interface_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.interface_index = v.into();
        self
    }
}

impl wkt::message::Message for LogicalInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.LogicalInterface"
    }
}

/// Defines additional types related to [LogicalInterface].
pub mod logical_interface {
    #[allow(unused_imports)]
    use super::*;

    /// Each logical network interface is effectively a network and IP pair.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LogicalNetworkInterface {
        /// Name of the network
        pub network: std::string::String,

        /// IP address in the network
        pub ip_address: std::string::String,

        /// Whether this interface is the default gateway for the instance. Only
        /// one interface can be the default gateway for the instance.
        pub default_gateway: bool,

        /// Type of network.
        pub network_type: crate::model::network::Type,

        /// An identifier for the `Network`, generated by the backend.
        pub id: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LogicalNetworkInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::logical_interface::LogicalNetworkInterface::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [ip_address][crate::model::logical_interface::LogicalNetworkInterface::ip_address].
        pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip_address = v.into();
            self
        }

        /// Sets the value of [default_gateway][crate::model::logical_interface::LogicalNetworkInterface::default_gateway].
        pub fn set_default_gateway<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.default_gateway = v.into();
            self
        }

        /// Sets the value of [network_type][crate::model::logical_interface::LogicalNetworkInterface::network_type].
        pub fn set_network_type<T: std::convert::Into<crate::model::network::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_type = v.into();
            self
        }

        /// Sets the value of [id][crate::model::logical_interface::LogicalNetworkInterface::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for LogicalNetworkInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.LogicalInterface.LogicalNetworkInterface"
        }
    }
}

/// Message for requesting network information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNetworkRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetNetworkRequest"
    }
}

/// Message for requesting a list of networks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworksRequest {
    /// Required. Parent value for ListNetworksRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworksRequest"
    }
}

/// Response message containing the list of networks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworksResponse {
    /// The list of networks.
    pub networks: std::vec::Vec<crate::model::Network>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [networks][crate::model::ListNetworksResponse::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNetworksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNetworksResponse {
    type PageItem = crate::model::Network;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.networks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message requesting to updating a network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNetworkRequest {
    /// Required. The network to update.
    ///
    /// The `name` field is used to identify the instance to update.
    /// Format: projects/{project}/locations/{location}/networks/{network}
    pub network: std::option::Option<crate::model::Network>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// `labels`, `reservations`, `vrf.vlan_attachments`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::UpdateNetworkRequest::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::UpdateNetworkRequest::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNetworkRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNetworkRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateNetworkRequest"
    }
}

/// Network with all used IP addresses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkUsage {
    /// Network.
    pub network: std::option::Option<crate::model::Network>,

    /// All used IP addresses in this network.
    pub used_ips: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkUsage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkUsage::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::NetworkUsage::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [used_ips][crate::model::NetworkUsage::used_ips].
    pub fn set_used_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.used_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkUsage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkUsage"
    }
}

/// Request to get networks with IPs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworkUsageRequest {
    /// Required. Parent value (project and location).
    pub location: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkUsageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ListNetworkUsageRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworkUsageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworkUsageRequest"
    }
}

/// Response with Networks with IPs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworkUsageResponse {
    /// Networks with IPs.
    pub networks: std::vec::Vec<crate::model::NetworkUsage>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkUsageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [networks][crate::model::ListNetworkUsageResponse::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkUsage>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworkUsageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworkUsageResponse"
    }
}

/// Mount point for a network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkMountPoint {
    /// Instance to attach network to.
    pub instance: std::string::String,

    /// Logical interface to detach from.
    pub logical_interface: std::string::String,

    /// Network should be a default gateway.
    pub default_gateway: bool,

    /// Ip address of the server.
    pub ip_address: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkMountPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::NetworkMountPoint::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [logical_interface][crate::model::NetworkMountPoint::logical_interface].
    pub fn set_logical_interface<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.logical_interface = v.into();
        self
    }

    /// Sets the value of [default_gateway][crate::model::NetworkMountPoint::default_gateway].
    pub fn set_default_gateway<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_gateway = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::NetworkMountPoint::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for NetworkMountPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkMountPoint"
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameNetworkRequest {
    /// Required. The `name` field is used to identify the network.
    /// Format: projects/{project}/locations/{location}/networks/{network}
    pub name: std::string::String,

    /// Required. The new `id` of the network.
    pub new_network_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_network_id][crate::model::RenameNetworkRequest::new_network_id].
    pub fn set_new_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_network_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameNetworkRequest"
    }
}

/// An NFS share.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NfsShare {
    /// Immutable. The name of the NFS share.
    pub name: std::string::String,

    /// Output only. An identifier for the NFS share, generated by the backend.
    /// This field will be deprecated in the future, use `id` instead.
    pub nfs_share_id: std::string::String,

    /// Output only. An identifier for the NFS share, generated by the backend.
    /// This is the same value as nfs_share_id and will replace it in the future.
    pub id: std::string::String,

    /// Output only. The state of the NFS share.
    pub state: crate::model::nfs_share::State,

    /// Output only. The underlying volume of the share. Created automatically
    /// during provisioning.
    pub volume: std::string::String,

    /// List of allowed access points.
    pub allowed_clients: std::vec::Vec<crate::model::nfs_share::AllowedClient>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The requested size, in GiB.
    pub requested_size_gib: i64,

    /// Immutable. The storage type of the underlying volume.
    pub storage_type: crate::model::nfs_share::StorageType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NfsShare {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NfsShare::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [nfs_share_id][crate::model::NfsShare::nfs_share_id].
    pub fn set_nfs_share_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nfs_share_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::NfsShare::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NfsShare::state].
    pub fn set_state<T: std::convert::Into<crate::model::nfs_share::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [volume][crate::model::NfsShare::volume].
    pub fn set_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [allowed_clients][crate::model::NfsShare::allowed_clients].
    pub fn set_allowed_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nfs_share::AllowedClient>,
    {
        use std::iter::Iterator;
        self.allowed_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NfsShare::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [requested_size_gib][crate::model::NfsShare::requested_size_gib].
    pub fn set_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.requested_size_gib = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::NfsShare::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::nfs_share::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }
}

impl wkt::message::Message for NfsShare {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NfsShare"
    }
}

/// Defines additional types related to [NfsShare].
pub mod nfs_share {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an 'access point' for the share.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowedClient {
        /// The network the access point sits on.
        pub network: std::string::String,

        /// Output only. The IP address of the share on this network. Assigned
        /// automatically during provisioning based on the network's services_cidr.
        pub share_ip: std::string::String,

        /// The subnet of IP addresses permitted to access the share.
        pub allowed_clients_cidr: std::string::String,

        /// Mount permissions.
        pub mount_permissions: crate::model::nfs_share::MountPermissions,

        /// Allow dev flag.  Which controls whether to allow creation of devices.
        pub allow_dev: bool,

        /// Allow the setuid flag.
        pub allow_suid: bool,

        /// Disable root squashing, which is a feature of NFS.
        /// Root squash is a special mapping of the remote superuser (root) identity
        /// when using identity authentication.
        pub no_root_squash: bool,

        /// Output only. The path to access NFS, in format shareIP:/InstanceID
        /// InstanceID is the generated ID instead of customer provided name.
        /// example like "10.0.0.0:/g123456789-nfs001"
        pub nfs_path: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowedClient {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::nfs_share::AllowedClient::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [share_ip][crate::model::nfs_share::AllowedClient::share_ip].
        pub fn set_share_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.share_ip = v.into();
            self
        }

        /// Sets the value of [allowed_clients_cidr][crate::model::nfs_share::AllowedClient::allowed_clients_cidr].
        pub fn set_allowed_clients_cidr<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allowed_clients_cidr = v.into();
            self
        }

        /// Sets the value of [mount_permissions][crate::model::nfs_share::AllowedClient::mount_permissions].
        pub fn set_mount_permissions<
            T: std::convert::Into<crate::model::nfs_share::MountPermissions>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mount_permissions = v.into();
            self
        }

        /// Sets the value of [allow_dev][crate::model::nfs_share::AllowedClient::allow_dev].
        pub fn set_allow_dev<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_dev = v.into();
            self
        }

        /// Sets the value of [allow_suid][crate::model::nfs_share::AllowedClient::allow_suid].
        pub fn set_allow_suid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_suid = v.into();
            self
        }

        /// Sets the value of [no_root_squash][crate::model::nfs_share::AllowedClient::no_root_squash].
        pub fn set_no_root_squash<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_root_squash = v.into();
            self
        }

        /// Sets the value of [nfs_path][crate::model::nfs_share::AllowedClient::nfs_path].
        pub fn set_nfs_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.nfs_path = v.into();
            self
        }
    }

    impl wkt::message::Message for AllowedClient {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.NfsShare.AllowedClient"
        }
    }

    /// The possible states for this NFS share.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The share is in an unknown state.
        Unspecified,
        /// The share has been provisioned.
        Provisioned,
        /// The NFS Share is being created.
        Creating,
        /// The NFS Share is being updated.
        Updating,
        /// The NFS Share has been requested to be deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioned => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioned,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONED" => Self::Provisioned,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioned => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.NfsShare.State",
            ))
        }
    }

    /// The possible mount permissions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MountPermissions {
        /// Permissions were not specified.
        Unspecified,
        /// NFS share can be mount with read-only permissions.
        Read,
        /// NFS share can be mount with read-write permissions.
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MountPermissions::value] or
        /// [MountPermissions::name].
        UnknownValue(mount_permissions::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mount_permissions {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MountPermissions {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Read => std::option::Option::Some(1),
                Self::ReadWrite => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MOUNT_PERMISSIONS_UNSPECIFIED"),
                Self::Read => std::option::Option::Some("READ"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MountPermissions {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MountPermissions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MountPermissions {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Read,
                2 => Self::ReadWrite,
                _ => Self::UnknownValue(mount_permissions::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MountPermissions {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MOUNT_PERMISSIONS_UNSPECIFIED" => Self::Unspecified,
                "READ" => Self::Read,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(mount_permissions::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MountPermissions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Read => serializer.serialize_i32(1),
                Self::ReadWrite => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MountPermissions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MountPermissions>::new(
                ".google.cloud.baremetalsolution.v2.NfsShare.MountPermissions",
            ))
        }
    }

    /// The storage type for a volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The storage type for this volume is unknown.
        Unspecified,
        /// The storage type for this volume is SSD.
        Ssd,
        /// This storage type for this volume is HDD.
        Hdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ssd => std::option::Option::Some(1),
                Self::Hdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Ssd => std::option::Option::Some("SSD"),
                Self::Hdd => std::option::Option::Some("HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ssd,
                2 => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SSD" => Self::Ssd,
                "HDD" => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ssd => serializer.serialize_i32(1),
                Self::Hdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.baremetalsolution.v2.NfsShare.StorageType",
            ))
        }
    }
}

/// Message for requesting NFS share information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNfsShareRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetNfsShareRequest"
    }
}

/// Message for requesting a list of NFS shares.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNfsSharesRequest {
    /// Required. Parent value for ListNfsSharesRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNfsSharesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNfsSharesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNfsSharesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNfsSharesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNfsSharesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNfsSharesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNfsSharesRequest"
    }
}

/// Response message containing the list of NFS shares.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNfsSharesResponse {
    /// The list of NFS shares.
    pub nfs_shares: std::vec::Vec<crate::model::NfsShare>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNfsSharesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nfs_shares][crate::model::ListNfsSharesResponse::nfs_shares].
    pub fn set_nfs_shares<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsShare>,
    {
        use std::iter::Iterator;
        self.nfs_shares = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNfsSharesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNfsSharesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNfsSharesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNfsSharesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNfsSharesResponse {
    type PageItem = crate::model::NfsShare;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nfs_shares
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message requesting to updating an NFS share.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNfsShareRequest {
    /// Required. The NFS share to update.
    ///
    /// The `name` field is used to identify the NFS share to update.
    /// Format: projects/{project}/locations/{location}/nfsShares/{nfs_share}
    pub nfs_share: std::option::Option<crate::model::NfsShare>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// `labels`
    /// `allowed_clients`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nfs_share][crate::model::UpdateNfsShareRequest::nfs_share].
    pub fn set_nfs_share<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfs_share][crate::model::UpdateNfsShareRequest::nfs_share].
    pub fn set_or_clear_nfs_share<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNfsShareRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNfsShareRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateNfsShareRequest"
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameNfsShareRequest {
    /// Required. The `name` field is used to identify the nfsshare.
    /// Format: projects/{project}/locations/{location}/nfsshares/{nfsshare}
    pub name: std::string::String,

    /// Required. The new `id` of the nfsshare.
    pub new_nfsshare_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_nfsshare_id][crate::model::RenameNfsShareRequest::new_nfsshare_id].
    pub fn set_new_nfsshare_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_nfsshare_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameNfsShareRequest"
    }
}

/// Message for creating an NFS share.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNfsShareRequest {
    /// Required. The parent project and location.
    pub parent: std::string::String,

    /// Required. The NfsShare to create.
    pub nfs_share: std::option::Option<crate::model::NfsShare>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNfsShareRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [nfs_share][crate::model::CreateNfsShareRequest::nfs_share].
    pub fn set_nfs_share<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfs_share][crate::model::CreateNfsShareRequest::nfs_share].
    pub fn set_or_clear_nfs_share<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateNfsShareRequest"
    }
}

/// Message for deleting an NFS share.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNfsShareRequest {
    /// Required. The name of the NFS share to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteNfsShareRequest"
    }
}

/// Operation System image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OSImage {
    /// Output only. OS Image's unique name.
    pub name: std::string::String,

    /// OS Image code.
    pub code: std::string::String,

    /// OS Image description.
    pub description: std::string::String,

    /// Instance types this image is applicable to.
    /// [Available
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub applicable_instance_types: std::vec::Vec<std::string::String>,

    /// Network templates that can be used with this OS Image.
    pub supported_network_templates: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::OSImage::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSImage::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [applicable_instance_types][crate::model::OSImage::applicable_instance_types].
    pub fn set_applicable_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_network_templates][crate::model::OSImage::supported_network_templates].
    pub fn set_supported_network_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_network_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OSImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.OSImage"
    }
}

/// Request for getting all available OS images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSImagesRequest {
    /// Required. Parent value for ListProvisioningQuotasRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    /// Notice that page_size field is not supported and won't be respected in
    /// the API request for now, will be updated when pagination is supported.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSImagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSImagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListOSImagesRequest"
    }
}

/// Request for getting all available OS images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSImagesResponse {
    /// The OS images available.
    pub os_images: std::vec::Vec<crate::model::OSImage>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_images][crate::model::ListOSImagesResponse::os_images].
    pub fn set_os_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSImage>,
    {
        use std::iter::Iterator;
        self.os_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSImagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListOSImagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSImagesResponse {
    type PageItem = crate::model::OSImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_images
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A provisioning configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProvisioningConfig {
    /// Output only. The system-generated name of the provisioning config. This
    /// follows the UUID format.
    pub name: std::string::String,

    /// Instances to be created.
    pub instances: std::vec::Vec<crate::model::InstanceConfig>,

    /// Networks to be created.
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Volumes to be created.
    pub volumes: std::vec::Vec<crate::model::VolumeConfig>,

    /// A generated ticket id to track provisioning request.
    pub ticket_id: std::string::String,

    /// A service account to enable customers to access instance credentials upon
    /// handover.
    pub handover_service_account: std::string::String,

    /// Email provided to send a confirmation with provisioning config to.
    /// Deprecated in favour of email field in request messages.
    #[deprecated]
    pub email: std::string::String,

    /// Output only. State of ProvisioningConfig.
    pub state: crate::model::provisioning_config::State,

    /// Optional. Location name of this ProvisioningConfig.
    /// It is optional only for Intake UI transition period.
    pub location: std::string::String,

    /// Output only. Last update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. URI to Cloud Console UI view of this provisioning config.
    pub cloud_console_uri: std::string::String,

    /// If true, VPC SC is enabled for the cluster.
    pub vpc_sc_enabled: bool,

    /// Optional status messages associated with the FAILED state.
    pub status_message: std::string::String,

    /// Optional. The user-defined identifier of the provisioning config.
    pub custom_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisioningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisioningConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ProvisioningConfig::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceConfig>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::ProvisioningConfig::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::ProvisioningConfig::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeConfig>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ticket_id][crate::model::ProvisioningConfig::ticket_id].
    pub fn set_ticket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ticket_id = v.into();
        self
    }

    /// Sets the value of [handover_service_account][crate::model::ProvisioningConfig::handover_service_account].
    pub fn set_handover_service_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.handover_service_account = v.into();
        self
    }

    /// Sets the value of [email][crate::model::ProvisioningConfig::email].
    #[deprecated]
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ProvisioningConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::provisioning_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ProvisioningConfig::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ProvisioningConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ProvisioningConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_console_uri][crate::model::ProvisioningConfig::cloud_console_uri].
    pub fn set_cloud_console_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_console_uri = v.into();
        self
    }

    /// Sets the value of [vpc_sc_enabled][crate::model::ProvisioningConfig::vpc_sc_enabled].
    pub fn set_vpc_sc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vpc_sc_enabled = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::ProvisioningConfig::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [custom_id][crate::model::ProvisioningConfig::custom_id].
    pub fn set_custom_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_id = v.into();
        self
    }
}

impl wkt::message::Message for ProvisioningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ProvisioningConfig"
    }
}

/// Defines additional types related to [ProvisioningConfig].
pub mod provisioning_config {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for this ProvisioningConfig.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State wasn't specified.
        Unspecified,
        /// ProvisioningConfig is a draft and can be freely modified.
        Draft,
        /// ProvisioningConfig was already submitted and cannot be modified.
        Submitted,
        /// ProvisioningConfig was in the provisioning state.  Initially this state
        /// comes from the work order table in big query when SNOW is used.  Later
        /// this field can be set by the work order API.
        Provisioning,
        /// ProvisioningConfig was provisioned, meaning the resources exist.
        Provisioned,
        /// ProvisioningConfig was validated.  A validation tool will be run to
        /// set this state.
        Validated,
        /// ProvisioningConfig was canceled.
        Cancelled,
        /// The request is submitted for provisioning, with error return.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Submitted => std::option::Option::Some(2),
                Self::Provisioning => std::option::Option::Some(3),
                Self::Provisioned => std::option::Option::Some(4),
                Self::Validated => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Submitted => std::option::Option::Some("SUBMITTED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::Validated => std::option::Option::Some("VALIDATED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Submitted,
                3 => Self::Provisioning,
                4 => Self::Provisioned,
                5 => Self::Validated,
                6 => Self::Cancelled,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "SUBMITTED" => Self::Submitted,
                "PROVISIONING" => Self::Provisioning,
                "PROVISIONED" => Self::Provisioned,
                "VALIDATED" => Self::Validated,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Submitted => serializer.serialize_i32(2),
                Self::Provisioning => serializer.serialize_i32(3),
                Self::Provisioned => serializer.serialize_i32(4),
                Self::Validated => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.ProvisioningConfig.State",
            ))
        }
    }
}

/// Request for SubmitProvisioningConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitProvisioningConfigRequest {
    /// Required. The parent project and location containing the
    /// ProvisioningConfig.
    pub parent: std::string::String,

    /// Required. The ProvisioningConfig to create.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    pub email: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitProvisioningConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [provisioning_config][crate::model::SubmitProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::SubmitProvisioningConfigRequest::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [email][crate::model::SubmitProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for SubmitProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SubmitProvisioningConfigRequest"
    }
}

/// Response for SubmitProvisioningConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitProvisioningConfigResponse {
    /// The submitted provisioning config.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitProvisioningConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_config][crate::model::SubmitProvisioningConfigResponse::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::SubmitProvisioningConfigResponse::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitProvisioningConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SubmitProvisioningConfigResponse"
    }
}

/// A provisioning quota for a given project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProvisioningQuota {
    /// Output only. The name of the provisioning quota.
    pub name: std::string::String,

    /// The asset type of this provisioning quota.
    pub asset_type: crate::model::provisioning_quota::AssetType,

    /// The gcp service of the provisioning quota.
    pub gcp_service: std::string::String,

    /// The specific location of the provisioining quota.
    pub location: std::string::String,

    /// The available count of the provisioning quota.
    pub available_count: i32,

    /// The quota of one asset type.
    pub quota: std::option::Option<crate::model::provisioning_quota::Quota>,

    /// Available quantity based on asset type.
    pub availability: std::option::Option<crate::model::provisioning_quota::Availability>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisioningQuota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisioningQuota::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::ProvisioningQuota::asset_type].
    pub fn set_asset_type<T: std::convert::Into<crate::model::provisioning_quota::AssetType>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::ProvisioningQuota::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ProvisioningQuota::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [available_count][crate::model::ProvisioningQuota::available_count].
    pub fn set_available_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_count = v.into();
        self
    }

    /// Sets the value of [quota][crate::model::ProvisioningQuota::quota].
    ///
    /// Note that all the setters affecting `quota` are mutually
    /// exclusive.
    pub fn set_quota<
        T: std::convert::Into<std::option::Option<crate::model::provisioning_quota::Quota>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quota = v.into();
        self
    }

    /// The value of [quota][crate::model::ProvisioningQuota::quota]
    /// if it holds a `InstanceQuota`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instance_quota(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstanceQuota>> {
        #[allow(unreachable_patterns)]
        self.quota.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Quota::InstanceQuota(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [quota][crate::model::ProvisioningQuota::quota]
    /// to hold a `InstanceQuota`.
    ///
    /// Note that all the setters affecting `quota` are
    /// mutually exclusive.
    pub fn set_instance_quota<
        T: std::convert::Into<std::boxed::Box<crate::model::InstanceQuota>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quota = std::option::Option::Some(
            crate::model::provisioning_quota::Quota::InstanceQuota(v.into()),
        );
        self
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability].
    ///
    /// Note that all the setters affecting `availability` are mutually
    /// exclusive.
    pub fn set_availability<
        T: std::convert::Into<std::option::Option<crate::model::provisioning_quota::Availability>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `ServerCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn server_count(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::ServerCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `ServerCount`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_server_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::ServerCount(v.into()),
        );
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `NetworkBandwidth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn network_bandwidth(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::NetworkBandwidth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `NetworkBandwidth`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_network_bandwidth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::NetworkBandwidth(v.into()),
        );
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `StorageGib`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_gib(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::StorageGib(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `StorageGib`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_storage_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::StorageGib(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ProvisioningQuota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ProvisioningQuota"
    }
}

/// Defines additional types related to [ProvisioningQuota].
pub mod provisioning_quota {
    #[allow(unused_imports)]
    use super::*;

    /// The available asset types for intake.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AssetType {
        /// The unspecified type.
        Unspecified,
        /// The server asset type.
        Server,
        /// The storage asset type.
        Storage,
        /// The network asset type.
        Network,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AssetType::value] or
        /// [AssetType::name].
        UnknownValue(asset_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod asset_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AssetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Server => std::option::Option::Some(1),
                Self::Storage => std::option::Option::Some(2),
                Self::Network => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ASSET_TYPE_UNSPECIFIED"),
                Self::Server => std::option::Option::Some("ASSET_TYPE_SERVER"),
                Self::Storage => std::option::Option::Some("ASSET_TYPE_STORAGE"),
                Self::Network => std::option::Option::Some("ASSET_TYPE_NETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AssetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AssetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AssetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Server,
                2 => Self::Storage,
                3 => Self::Network,
                _ => Self::UnknownValue(asset_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AssetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ASSET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ASSET_TYPE_SERVER" => Self::Server,
                "ASSET_TYPE_STORAGE" => Self::Storage,
                "ASSET_TYPE_NETWORK" => Self::Network,
                _ => Self::UnknownValue(asset_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AssetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Server => serializer.serialize_i32(1),
                Self::Storage => serializer.serialize_i32(2),
                Self::Network => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AssetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AssetType>::new(
                ".google.cloud.baremetalsolution.v2.ProvisioningQuota.AssetType",
            ))
        }
    }

    /// The quota of one asset type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Quota {
        /// Instance quota.
        InstanceQuota(std::boxed::Box<crate::model::InstanceQuota>),
    }

    /// Available quantity based on asset type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Availability {
        /// Server count.
        ServerCount(i64),
        /// Network bandwidth, Gbps
        NetworkBandwidth(i64),
        /// Storage size (GB).
        StorageGib(i64),
    }
}

/// Message for requesting the list of provisioning quotas.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvisioningQuotasRequest {
    /// Required. Parent value for ListProvisioningQuotasRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    /// Notice that page_size field is not supported and won't be respected in
    /// the API request for now, will be updated when pagination is supported.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvisioningQuotasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvisioningQuotasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvisioningQuotasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvisioningQuotasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvisioningQuotasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListProvisioningQuotasRequest"
    }
}

/// Response message for the list of provisioning quotas.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvisioningQuotasResponse {
    /// The provisioning quotas registered in this project.
    pub provisioning_quotas: std::vec::Vec<crate::model::ProvisioningQuota>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvisioningQuotasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_quotas][crate::model::ListProvisioningQuotasResponse::provisioning_quotas].
    pub fn set_provisioning_quotas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProvisioningQuota>,
    {
        use std::iter::Iterator;
        self.provisioning_quotas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProvisioningQuotasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvisioningQuotasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListProvisioningQuotasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProvisioningQuotasResponse {
    type PageItem = crate::model::ProvisioningQuota;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.provisioning_quotas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Configuration parameters for a new instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceConfig {
    /// Output only. The name of the instance config.
    pub name: std::string::String,

    /// A transient unique identifier to idenfity an instance within an
    /// ProvisioningConfig request.
    pub id: std::string::String,

    /// Instance type.
    /// [Available
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub instance_type: std::string::String,

    /// Whether the instance should be provisioned with Hyperthreading enabled.
    pub hyperthreading: bool,

    /// OS image to initialize the instance.
    /// [Available
    /// images](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub os_image: std::string::String,

    /// Client network address. Filled if InstanceConfig.multivlan_config is false.
    #[deprecated]
    pub client_network: std::option::Option<crate::model::instance_config::NetworkAddress>,

    /// Private network address, if any. Filled if InstanceConfig.multivlan_config
    /// is false.
    #[deprecated]
    pub private_network: std::option::Option<crate::model::instance_config::NetworkAddress>,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    pub user_note: std::string::String,

    /// If true networks can be from different projects of the same vendor account.
    pub account_networks_enabled: bool,

    /// The type of network configuration on the instance.
    pub network_config: crate::model::instance_config::NetworkConfig,

    /// Server network template name. Filled if InstanceConfig.multivlan_config is
    /// true.
    pub network_template: std::string::String,

    /// List of logical interfaces for the instance. The number of logical
    /// interfaces will be the same as number of hardware bond/nic on the chosen
    /// network template. Filled if InstanceConfig.multivlan_config is true.
    pub logical_interfaces: std::vec::Vec<crate::model::LogicalInterface>,

    /// List of names of ssh keys used to provision the instance.
    pub ssh_key_names: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::InstanceConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::InstanceConfig::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [hyperthreading][crate::model::InstanceConfig::hyperthreading].
    pub fn set_hyperthreading<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hyperthreading = v.into();
        self
    }

    /// Sets the value of [os_image][crate::model::InstanceConfig::os_image].
    pub fn set_os_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_image = v.into();
        self
    }

    /// Sets the value of [client_network][crate::model::InstanceConfig::client_network].
    #[deprecated]
    pub fn set_client_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.client_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_network][crate::model::InstanceConfig::client_network].
    #[deprecated]
    pub fn set_or_clear_client_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.client_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_network][crate::model::InstanceConfig::private_network].
    #[deprecated]
    pub fn set_private_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.private_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_network][crate::model::InstanceConfig::private_network].
    #[deprecated]
    pub fn set_or_clear_private_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.private_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_note][crate::model::InstanceConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [account_networks_enabled][crate::model::InstanceConfig::account_networks_enabled].
    pub fn set_account_networks_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.account_networks_enabled = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::InstanceConfig::network_config].
    pub fn set_network_config<
        T: std::convert::Into<crate::model::instance_config::NetworkConfig>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [network_template][crate::model::InstanceConfig::network_template].
    pub fn set_network_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_template = v.into();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::InstanceConfig::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ssh_key_names][crate::model::InstanceConfig::ssh_key_names].
    pub fn set_ssh_key_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_key_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceConfig"
    }
}

/// Defines additional types related to [InstanceConfig].
pub mod instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// A network.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkAddress {
        /// Id of the network to use, within the same ProvisioningConfig request.
        pub network_id: std::string::String,

        /// IPv4 address to be assigned to the server.
        pub address: std::string::String,

        /// Name of the existing network to use.
        pub existing_network_id: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkAddress {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_id][crate::model::instance_config::NetworkAddress::network_id].
        pub fn set_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network_id = v.into();
            self
        }

        /// Sets the value of [address][crate::model::instance_config::NetworkAddress::address].
        pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.address = v.into();
            self
        }

        /// Sets the value of [existing_network_id][crate::model::instance_config::NetworkAddress::existing_network_id].
        pub fn set_existing_network_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.existing_network_id = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkAddress {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceConfig.NetworkAddress"
        }
    }

    /// The network configuration of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkConfig {
        /// The unspecified network configuration.
        NetworkconfigUnspecified,
        /// Instance part of single client network and single private network.
        SingleVlan,
        /// Instance part of multiple (or single) client networks and private
        /// networks.
        MultiVlan,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkConfig::value] or
        /// [NetworkConfig::name].
        UnknownValue(network_config::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_config {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkConfig {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NetworkconfigUnspecified => std::option::Option::Some(0),
                Self::SingleVlan => std::option::Option::Some(1),
                Self::MultiVlan => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NetworkconfigUnspecified => {
                    std::option::Option::Some("NETWORKCONFIG_UNSPECIFIED")
                }
                Self::SingleVlan => std::option::Option::Some("SINGLE_VLAN"),
                Self::MultiVlan => std::option::Option::Some("MULTI_VLAN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkConfig {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkConfig {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NetworkconfigUnspecified,
                1 => Self::SingleVlan,
                2 => Self::MultiVlan,
                _ => Self::UnknownValue(network_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkConfig {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORKCONFIG_UNSPECIFIED" => Self::NetworkconfigUnspecified,
                "SINGLE_VLAN" => Self::SingleVlan,
                "MULTI_VLAN" => Self::MultiVlan,
                _ => Self::UnknownValue(network_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NetworkconfigUnspecified => serializer.serialize_i32(0),
                Self::SingleVlan => serializer.serialize_i32(1),
                Self::MultiVlan => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkConfig>::new(
                ".google.cloud.baremetalsolution.v2.InstanceConfig.NetworkConfig",
            ))
        }
    }
}

/// Configuration parameters for a new volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeConfig {
    /// Output only. The name of the volume config.
    pub name: std::string::String,

    /// A transient unique identifier to identify a volume within an
    /// ProvisioningConfig request.
    pub id: std::string::String,

    /// Whether snapshots should be enabled.
    pub snapshots_enabled: bool,

    /// The type of this Volume.
    pub r#type: crate::model::volume_config::Type,

    /// Volume protocol.
    pub protocol: crate::model::volume_config::Protocol,

    /// The requested size of this volume, in GB.
    pub size_gb: i32,

    /// LUN ranges to be configured. Set only when protocol is PROTOCOL_FC.
    pub lun_ranges: std::vec::Vec<crate::model::volume_config::LunRange>,

    /// Machine ids connected to this volume. Set only when protocol is
    /// PROTOCOL_FC.
    pub machine_ids: std::vec::Vec<std::string::String>,

    /// NFS exports. Set only when protocol is PROTOCOL_NFS.
    pub nfs_exports: std::vec::Vec<crate::model::volume_config::NfsExport>,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    pub user_note: std::string::String,

    /// The GCP service of the storage volume. Available gcp_service are in
    /// <https://cloud.google.com/bare-metal/docs/bms-planning>.
    pub gcp_service: std::string::String,

    /// Performance tier of the Volume.
    /// Default is SHARED.
    pub performance_tier: crate::model::VolumePerformanceTier,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::VolumeConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [snapshots_enabled][crate::model::VolumeConfig::snapshots_enabled].
    pub fn set_snapshots_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshots_enabled = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VolumeConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::volume_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::VolumeConfig::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::volume_config::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::VolumeConfig::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [lun_ranges][crate::model::VolumeConfig::lun_ranges].
    pub fn set_lun_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::volume_config::LunRange>,
    {
        use std::iter::Iterator;
        self.lun_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [machine_ids][crate::model::VolumeConfig::machine_ids].
    pub fn set_machine_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.machine_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nfs_exports][crate::model::VolumeConfig::nfs_exports].
    pub fn set_nfs_exports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::volume_config::NfsExport>,
    {
        use std::iter::Iterator;
        self.nfs_exports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_note][crate::model::VolumeConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::VolumeConfig::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [performance_tier][crate::model::VolumeConfig::performance_tier].
    pub fn set_performance_tier<T: std::convert::Into<crate::model::VolumePerformanceTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.performance_tier = v.into();
        self
    }
}

impl wkt::message::Message for VolumeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig"
    }
}

/// Defines additional types related to [VolumeConfig].
pub mod volume_config {
    #[allow(unused_imports)]
    use super::*;

    /// A LUN(Logical Unit Number) range.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LunRange {
        /// Number of LUNs to create.
        pub quantity: i32,

        /// The requested size of each LUN, in GB.
        pub size_gb: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LunRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quantity][crate::model::volume_config::LunRange::quantity].
        pub fn set_quantity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.quantity = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::volume_config::LunRange::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for LunRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig.LunRange"
        }
    }

    /// A NFS export entry.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NfsExport {
        /// Network to use to publish the export.
        pub network_id: std::string::String,

        /// Export permissions.
        pub permissions: crate::model::volume_config::nfs_export::Permissions,

        /// Disable root squashing, which is a feature of NFS.
        /// Root squash is a special mapping of the remote superuser (root) identity
        /// when using identity authentication.
        pub no_root_squash: bool,

        /// Allow the setuid flag.
        pub allow_suid: bool,

        /// Allow dev flag in NfsShare AllowedClientsRequest.
        pub allow_dev: bool,

        /// A client object.
        pub client: std::option::Option<crate::model::volume_config::nfs_export::Client>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NfsExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_id][crate::model::volume_config::NfsExport::network_id].
        pub fn set_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network_id = v.into();
            self
        }

        /// Sets the value of [permissions][crate::model::volume_config::NfsExport::permissions].
        pub fn set_permissions<
            T: std::convert::Into<crate::model::volume_config::nfs_export::Permissions>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.permissions = v.into();
            self
        }

        /// Sets the value of [no_root_squash][crate::model::volume_config::NfsExport::no_root_squash].
        pub fn set_no_root_squash<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_root_squash = v.into();
            self
        }

        /// Sets the value of [allow_suid][crate::model::volume_config::NfsExport::allow_suid].
        pub fn set_allow_suid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_suid = v.into();
            self
        }

        /// Sets the value of [allow_dev][crate::model::volume_config::NfsExport::allow_dev].
        pub fn set_allow_dev<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_dev = v.into();
            self
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client].
        ///
        /// Note that all the setters affecting `client` are mutually
        /// exclusive.
        pub fn set_client<
            T: std::convert::Into<
                    std::option::Option<crate::model::volume_config::nfs_export::Client>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.client = v.into();
            self
        }

        /// The value of [client][crate::model::volume_config::NfsExport::client]
        /// if it holds a `MachineId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn machine_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.client.as_ref().and_then(|v| match v {
                crate::model::volume_config::nfs_export::Client::MachineId(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client]
        /// to hold a `MachineId`.
        ///
        /// Note that all the setters affecting `client` are
        /// mutually exclusive.
        pub fn set_machine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client = std::option::Option::Some(
                crate::model::volume_config::nfs_export::Client::MachineId(v.into()),
            );
            self
        }

        /// The value of [client][crate::model::volume_config::NfsExport::client]
        /// if it holds a `Cidr`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cidr(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.client.as_ref().and_then(|v| match v {
                crate::model::volume_config::nfs_export::Client::Cidr(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client]
        /// to hold a `Cidr`.
        ///
        /// Note that all the setters affecting `client` are
        /// mutually exclusive.
        pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client = std::option::Option::Some(
                crate::model::volume_config::nfs_export::Client::Cidr(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for NfsExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport"
        }
    }

    /// Defines additional types related to [NfsExport].
    pub mod nfs_export {
        #[allow(unused_imports)]
        use super::*;

        /// Permissions that can granted for an export.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Permissions {
            /// Unspecified value.
            Unspecified,
            /// Read-only permission.
            ReadOnly,
            /// Read-write permission.
            ReadWrite,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Permissions::value] or
            /// [Permissions::name].
            UnknownValue(permissions::UnknownValue),
        }

        #[doc(hidden)]
        pub mod permissions {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Permissions {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ReadOnly => std::option::Option::Some(1),
                    Self::ReadWrite => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PERMISSIONS_UNSPECIFIED"),
                    Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                    Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Permissions {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Permissions {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Permissions {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ReadOnly,
                    2 => Self::ReadWrite,
                    _ => Self::UnknownValue(permissions::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Permissions {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PERMISSIONS_UNSPECIFIED" => Self::Unspecified,
                    "READ_ONLY" => Self::ReadOnly,
                    "READ_WRITE" => Self::ReadWrite,
                    _ => Self::UnknownValue(permissions::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Permissions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ReadOnly => serializer.serialize_i32(1),
                    Self::ReadWrite => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Permissions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Permissions>::new(
                    ".google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport.Permissions",
                ))
            }
        }

        /// A client object.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Client {
            /// Either a single machine, identified by an ID, or a comma-separated
            /// list of machine IDs.
            MachineId(std::string::String),
            /// A CIDR range.
            Cidr(std::string::String),
        }
    }

    /// The types of Volumes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The unspecified type.
        Unspecified,
        /// This Volume is on flash.
        Flash,
        /// This Volume is on disk.
        Disk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Flash => std::option::Option::Some(1),
                Self::Disk => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Flash => std::option::Option::Some("FLASH"),
                Self::Disk => std::option::Option::Some("DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Flash,
                2 => Self::Disk,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "FLASH" => Self::Flash,
                "DISK" => Self::Disk,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Flash => serializer.serialize_i32(1),
                Self::Disk => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.baremetalsolution.v2.VolumeConfig.Type",
            ))
        }
    }

    /// The protocol used to access the volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Unspecified value.
        Unspecified,
        /// Fibre channel.
        Fc,
        /// Network file system.
        Nfs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fc => std::option::Option::Some(1),
                Self::Nfs => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Fc => std::option::Option::Some("PROTOCOL_FC"),
                Self::Nfs => std::option::Option::Some("PROTOCOL_NFS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fc,
                2 => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "PROTOCOL_FC" => Self::Fc,
                "PROTOCOL_NFS" => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fc => serializer.serialize_i32(1),
                Self::Nfs => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.baremetalsolution.v2.VolumeConfig.Protocol",
            ))
        }
    }
}

/// Configuration parameters for a new network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Output only. The name of the network config.
    pub name: std::string::String,

    /// A transient unique identifier to identify a volume within an
    /// ProvisioningConfig request.
    pub id: std::string::String,

    /// The type of this network, either Client or Private.
    pub r#type: crate::model::network_config::Type,

    /// Interconnect bandwidth. Set only when type is CLIENT.
    pub bandwidth: crate::model::network_config::Bandwidth,

    /// List of VLAN attachments. As of now there are always 2 attachments, but it
    /// is going to change in  the future (multi vlan).
    pub vlan_attachments: std::vec::Vec<crate::model::network_config::IntakeVlanAttachment>,

    /// CIDR range of the network.
    pub cidr: std::string::String,

    /// Service CIDR, if any.
    pub service_cidr: crate::model::network_config::ServiceCidr,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    pub user_note: std::string::String,

    /// The GCP service of the network. Available gcp_service are in
    /// <https://cloud.google.com/bare-metal/docs/bms-planning>.
    pub gcp_service: std::string::String,

    /// Whether the VLAN attachment pair is located in the same project.
    pub vlan_same_project: bool,

    /// The JumboFramesEnabled option for customer to set.
    pub jumbo_frames_enabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NetworkConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::NetworkConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::NetworkConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::network_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [bandwidth][crate::model::NetworkConfig::bandwidth].
    pub fn set_bandwidth<T: std::convert::Into<crate::model::network_config::Bandwidth>>(
        mut self,
        v: T,
    ) -> Self {
        self.bandwidth = v.into();
        self
    }

    /// Sets the value of [vlan_attachments][crate::model::NetworkConfig::vlan_attachments].
    pub fn set_vlan_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::network_config::IntakeVlanAttachment>,
    {
        use std::iter::Iterator;
        self.vlan_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cidr][crate::model::NetworkConfig::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [service_cidr][crate::model::NetworkConfig::service_cidr].
    pub fn set_service_cidr<T: std::convert::Into<crate::model::network_config::ServiceCidr>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_cidr = v.into();
        self
    }

    /// Sets the value of [user_note][crate::model::NetworkConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::NetworkConfig::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [vlan_same_project][crate::model::NetworkConfig::vlan_same_project].
    pub fn set_vlan_same_project<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vlan_same_project = v.into();
        self
    }

    /// Sets the value of [jumbo_frames_enabled][crate::model::NetworkConfig::jumbo_frames_enabled].
    pub fn set_jumbo_frames_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.jumbo_frames_enabled = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkConfig"
    }
}

/// Defines additional types related to [NetworkConfig].
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// A GCP vlan attachment.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntakeVlanAttachment {
        /// Identifier of the VLAN attachment.
        pub id: std::string::String,

        /// Attachment pairing key.
        pub pairing_key: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntakeVlanAttachment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::network_config::IntakeVlanAttachment::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [pairing_key][crate::model::network_config::IntakeVlanAttachment::pairing_key].
        pub fn set_pairing_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pairing_key = v.into();
            self
        }
    }

    impl wkt::message::Message for IntakeVlanAttachment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkConfig.IntakeVlanAttachment"
        }
    }

    /// Network type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified value.
        Unspecified,
        /// Client network, that is a network peered to a GCP VPC.
        Client,
        /// Private network, that is a network local to the BMS POD.
        Private,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Client => std::option::Option::Some(1),
                Self::Private => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Client => std::option::Option::Some("CLIENT"),
                Self::Private => std::option::Option::Some("PRIVATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Client,
                2 => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLIENT" => Self::Client,
                "PRIVATE" => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Client => serializer.serialize_i32(1),
                Self::Private => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.baremetalsolution.v2.NetworkConfig.Type",
            ))
        }
    }

    /// Interconnect bandwidth.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Bandwidth {
        /// Unspecified value.
        Unspecified,
        /// 1 Gbps.
        Bw1Gbps,
        /// 2 Gbps.
        Bw2Gbps,
        /// 5 Gbps.
        Bw5Gbps,
        /// 10 Gbps.
        Bw10Gbps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Bandwidth::value] or
        /// [Bandwidth::name].
        UnknownValue(bandwidth::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bandwidth {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Bandwidth {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bw1Gbps => std::option::Option::Some(1),
                Self::Bw2Gbps => std::option::Option::Some(2),
                Self::Bw5Gbps => std::option::Option::Some(3),
                Self::Bw10Gbps => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BANDWIDTH_UNSPECIFIED"),
                Self::Bw1Gbps => std::option::Option::Some("BW_1_GBPS"),
                Self::Bw2Gbps => std::option::Option::Some("BW_2_GBPS"),
                Self::Bw5Gbps => std::option::Option::Some("BW_5_GBPS"),
                Self::Bw10Gbps => std::option::Option::Some("BW_10_GBPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Bandwidth {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Bandwidth {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Bandwidth {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bw1Gbps,
                2 => Self::Bw2Gbps,
                3 => Self::Bw5Gbps,
                4 => Self::Bw10Gbps,
                _ => Self::UnknownValue(bandwidth::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Bandwidth {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BANDWIDTH_UNSPECIFIED" => Self::Unspecified,
                "BW_1_GBPS" => Self::Bw1Gbps,
                "BW_2_GBPS" => Self::Bw2Gbps,
                "BW_5_GBPS" => Self::Bw5Gbps,
                "BW_10_GBPS" => Self::Bw10Gbps,
                _ => Self::UnknownValue(bandwidth::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Bandwidth {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bw1Gbps => serializer.serialize_i32(1),
                Self::Bw2Gbps => serializer.serialize_i32(2),
                Self::Bw5Gbps => serializer.serialize_i32(3),
                Self::Bw10Gbps => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Bandwidth {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Bandwidth>::new(
                ".google.cloud.baremetalsolution.v2.NetworkConfig.Bandwidth",
            ))
        }
    }

    /// Service network block.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServiceCidr {
        /// Unspecified value.
        Unspecified,
        /// Services are disabled for the given network.
        Disabled,
        /// Use the highest /26 block of the network to host services.
        High26,
        /// Use the highest /27 block of the network to host services.
        High27,
        /// Use the highest /28 block of the network to host services.
        High28,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ServiceCidr::value] or
        /// [ServiceCidr::name].
        UnknownValue(service_cidr::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service_cidr {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ServiceCidr {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::High26 => std::option::Option::Some(2),
                Self::High27 => std::option::Option::Some(3),
                Self::High28 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_CIDR_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::High26 => std::option::Option::Some("HIGH_26"),
                Self::High27 => std::option::Option::Some("HIGH_27"),
                Self::High28 => std::option::Option::Some("HIGH_28"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ServiceCidr {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ServiceCidr {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ServiceCidr {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::High26,
                3 => Self::High27,
                4 => Self::High28,
                _ => Self::UnknownValue(service_cidr::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ServiceCidr {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_CIDR_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "HIGH_26" => Self::High26,
                "HIGH_27" => Self::High27,
                "HIGH_28" => Self::High28,
                _ => Self::UnknownValue(service_cidr::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ServiceCidr {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::High26 => serializer.serialize_i32(2),
                Self::High27 => serializer.serialize_i32(3),
                Self::High28 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ServiceCidr {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceCidr>::new(
                ".google.cloud.baremetalsolution.v2.NetworkConfig.ServiceCidr",
            ))
        }
    }
}

/// A resource budget.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceQuota {
    /// Output only. The name of the instance quota.
    pub name: std::string::String,

    /// Instance type.
    /// Deprecated: use gcp_service.
    #[deprecated]
    pub instance_type: std::string::String,

    /// The gcp service of the provisioning quota.
    pub gcp_service: std::string::String,

    /// Location where the quota applies.
    pub location: std::string::String,

    /// Number of machines than can be created for the given location and
    /// instance_type.
    pub available_machine_count: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceQuota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceQuota::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::InstanceQuota::instance_type].
    #[deprecated]
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::InstanceQuota::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::InstanceQuota::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [available_machine_count][crate::model::InstanceQuota::available_machine_count].
    pub fn set_available_machine_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_machine_count = v.into();
        self
    }
}

impl wkt::message::Message for InstanceQuota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceQuota"
    }
}

/// Request for GetProvisioningConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProvisioningConfigRequest {
    /// Required. Name of the ProvisioningConfig.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProvisioningConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetProvisioningConfigRequest"
    }
}

/// Request for CreateProvisioningConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateProvisioningConfigRequest {
    /// Required. The parent project and location containing the
    /// ProvisioningConfig.
    pub parent: std::string::String,

    /// Required. The ProvisioningConfig to create.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    pub email: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProvisioningConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [provisioning_config][crate::model::CreateProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::CreateProvisioningConfigRequest::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [email][crate::model::CreateProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CreateProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateProvisioningConfigRequest"
    }
}

/// Message for updating a ProvisioningConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProvisioningConfigRequest {
    /// Required. The ProvisioningConfig to update.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    pub email: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_config][crate::model::UpdateProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::UpdateProvisioningConfigRequest::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProvisioningConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateProvisioningConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [email][crate::model::UpdateProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateProvisioningConfigRequest"
    }
}

/// An SSH key, used for authorizing with the interactive serial console feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SSHKey {
    /// Output only. The name of this SSH key.
    /// Currently, the only valid value for the location is "global".
    pub name: std::string::String,

    /// The public SSH key. This must be in OpenSSH .authorized_keys format.
    pub public_key: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SSHKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SSHKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::SSHKey::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }
}

impl wkt::message::Message for SSHKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SSHKey"
    }
}

/// Message for listing the public SSH keys in a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSSHKeysRequest {
    /// Required. The parent containing the SSH keys.
    /// Currently, the only valid value for the location is "global".
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSSHKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSSHKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSSHKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSSHKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSSHKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListSSHKeysRequest"
    }
}

/// Message for response of ListSSHKeys.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSSHKeysResponse {
    /// The SSH keys registered in the project.
    pub ssh_keys: std::vec::Vec<crate::model::SSHKey>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSSHKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssh_keys][crate::model::ListSSHKeysResponse::ssh_keys].
    pub fn set_ssh_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SSHKey>,
    {
        use std::iter::Iterator;
        self.ssh_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSSHKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSSHKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListSSHKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSSHKeysResponse {
    type PageItem = crate::model::SSHKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ssh_keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for registering a public SSH key in a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSSHKeyRequest {
    /// Required. The parent containing the SSH keys.
    pub parent: std::string::String,

    /// Required. The SSH key to register.
    pub ssh_key: std::option::Option<crate::model::SSHKey>,

    /// Required. The ID to use for the key, which will become the final component
    /// of the key's resource name.
    ///
    /// This value must match the regex:
    /// [a-zA-Z0-9@.\-_]{1,64}
    pub ssh_key_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSSHKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSSHKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [ssh_key][crate::model::CreateSSHKeyRequest::ssh_key].
    pub fn set_ssh_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SSHKey>,
    {
        self.ssh_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssh_key][crate::model::CreateSSHKeyRequest::ssh_key].
    pub fn set_or_clear_ssh_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SSHKey>,
    {
        self.ssh_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssh_key_id][crate::model::CreateSSHKeyRequest::ssh_key_id].
    pub fn set_ssh_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssh_key_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSSHKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateSSHKeyRequest"
    }
}

/// Message for deleting an SSH key from a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSSHKeyRequest {
    /// Required. The name of the SSH key to delete.
    /// Currently, the only valid value for the location is "global".
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSSHKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSSHKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSSHKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteSSHKeyRequest"
    }
}

/// A storage volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Volume {
    /// Output only. The resource name of this `Volume`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/volumes/{volume}`
    pub name: std::string::String,

    /// An identifier for the `Volume`, generated by the backend.
    pub id: std::string::String,

    /// The storage type for this volume.
    pub storage_type: crate::model::volume::StorageType,

    /// The state of this storage volume.
    pub state: crate::model::volume::State,

    /// The requested size of this storage volume, in GiB.
    pub requested_size_gib: i64,

    /// Originally requested size, in GiB.
    pub originally_requested_size_gib: i64,

    /// The current size of this storage volume, in GiB, including space reserved
    /// for snapshots. This size might be different than the requested size if the
    /// storage volume has been configured with auto grow or auto shrink.
    pub current_size_gib: i64,

    /// Additional emergency size that was requested for this Volume, in GiB.
    /// current_size_gib includes this value.
    pub emergency_size_gib: i64,

    /// Maximum size volume can be expanded to in case of evergency, in GiB.
    pub max_size_gib: i64,

    /// The size, in GiB, that this storage volume has expanded as a result of an
    /// auto grow policy. In the absence of auto-grow, the value is 0.
    pub auto_grown_size_gib: i64,

    /// The space remaining in the storage volume for new LUNs, in GiB, excluding
    /// space reserved for snapshots.
    pub remaining_space_gib: i64,

    /// Details about snapshot space reservation and usage on the storage volume.
    pub snapshot_reservation_detail:
        std::option::Option<crate::model::volume::SnapshotReservationDetail>,

    /// The behavior to use when snapshot reserved space is full.
    pub snapshot_auto_delete_behavior: crate::model::volume::SnapshotAutoDeleteBehavior,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Whether snapshots are enabled.
    pub snapshot_enabled: bool,

    /// Immutable. Pod name.
    pub pod: std::string::String,

    /// Output only. Storage protocol for the Volume.
    pub protocol: crate::model::volume::Protocol,

    /// Output only. Whether this volume is a boot volume. A boot volume is one
    /// which contains a boot LUN.
    pub boot_volume: bool,

    /// Immutable. Performance tier of the Volume.
    /// Default is SHARED.
    pub performance_tier: crate::model::VolumePerformanceTier,

    /// Input only. User-specified notes for new Volume.
    /// Used to provision Volumes that require manual intervention.
    pub notes: std::string::String,

    /// The workload profile for the volume.
    pub workload_profile: crate::model::volume::WorkloadProfile,

    /// Output only. Time after which volume will be fully deleted.
    /// It is filled only for volumes in COOLOFF state.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instances this Volume is attached to.
    /// This field is set only in Get requests.
    pub instances: std::vec::Vec<std::string::String>,

    /// Output only. Is the Volume attached at at least one instance.
    /// This field is a lightweight counterpart of `instances` field.
    /// It is filled in List responses as well.
    pub attached: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Volume::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::Volume::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::volume::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Volume::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [requested_size_gib][crate::model::Volume::requested_size_gib].
    pub fn set_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.requested_size_gib = v.into();
        self
    }

    /// Sets the value of [originally_requested_size_gib][crate::model::Volume::originally_requested_size_gib].
    pub fn set_originally_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.originally_requested_size_gib = v.into();
        self
    }

    /// Sets the value of [current_size_gib][crate::model::Volume::current_size_gib].
    pub fn set_current_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.current_size_gib = v.into();
        self
    }

    /// Sets the value of [emergency_size_gib][crate::model::Volume::emergency_size_gib].
    pub fn set_emergency_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.emergency_size_gib = v.into();
        self
    }

    /// Sets the value of [max_size_gib][crate::model::Volume::max_size_gib].
    pub fn set_max_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_size_gib = v.into();
        self
    }

    /// Sets the value of [auto_grown_size_gib][crate::model::Volume::auto_grown_size_gib].
    pub fn set_auto_grown_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.auto_grown_size_gib = v.into();
        self
    }

    /// Sets the value of [remaining_space_gib][crate::model::Volume::remaining_space_gib].
    pub fn set_remaining_space_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.remaining_space_gib = v.into();
        self
    }

    /// Sets the value of [snapshot_reservation_detail][crate::model::Volume::snapshot_reservation_detail].
    pub fn set_snapshot_reservation_detail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::volume::SnapshotReservationDetail>,
    {
        self.snapshot_reservation_detail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_reservation_detail][crate::model::Volume::snapshot_reservation_detail].
    pub fn set_or_clear_snapshot_reservation_detail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::volume::SnapshotReservationDetail>,
    {
        self.snapshot_reservation_detail = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snapshot_auto_delete_behavior][crate::model::Volume::snapshot_auto_delete_behavior].
    pub fn set_snapshot_auto_delete_behavior<
        T: std::convert::Into<crate::model::volume::SnapshotAutoDeleteBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_auto_delete_behavior = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Volume::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [snapshot_enabled][crate::model::Volume::snapshot_enabled].
    pub fn set_snapshot_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshot_enabled = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Volume::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::Volume::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::volume::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [boot_volume][crate::model::Volume::boot_volume].
    pub fn set_boot_volume<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.boot_volume = v.into();
        self
    }

    /// Sets the value of [performance_tier][crate::model::Volume::performance_tier].
    pub fn set_performance_tier<T: std::convert::Into<crate::model::VolumePerformanceTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.performance_tier = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::Volume::notes].
    pub fn set_notes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.notes = v.into();
        self
    }

    /// Sets the value of [workload_profile][crate::model::Volume::workload_profile].
    pub fn set_workload_profile<T: std::convert::Into<crate::model::volume::WorkloadProfile>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_profile = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Volume::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Volume::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::Volume::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attached][crate::model::Volume::attached].
    pub fn set_attached<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.attached = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Volume"
    }
}

/// Defines additional types related to [Volume].
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    /// Details about snapshot space reservation and usage on the storage volume.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SnapshotReservationDetail {
        /// The space on this storage volume reserved for snapshots, shown in GiB.
        pub reserved_space_gib: i64,

        /// The percent of snapshot space on this storage volume actually being used
        /// by the snapshot copies. This value might be higher than 100% if the
        /// snapshot copies have overflowed into the data portion of the storage
        /// volume.
        pub reserved_space_used_percent: i32,

        /// The amount, in GiB, of available space in this storage volume's reserved
        /// snapshot space.
        pub reserved_space_remaining_gib: i64,

        /// Percent of the total Volume size reserved for snapshot copies.
        /// Enabling snapshots requires reserving 20% or more of
        /// the storage volume space for snapshots. Maximum reserved space for
        /// snapshots is 40%.
        /// Setting this field will effectively set snapshot_enabled to true.
        pub reserved_space_percent: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SnapshotReservationDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reserved_space_gib][crate::model::volume::SnapshotReservationDetail::reserved_space_gib].
        pub fn set_reserved_space_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.reserved_space_gib = v.into();
            self
        }

        /// Sets the value of [reserved_space_used_percent][crate::model::volume::SnapshotReservationDetail::reserved_space_used_percent].
        pub fn set_reserved_space_used_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.reserved_space_used_percent = v.into();
            self
        }

        /// Sets the value of [reserved_space_remaining_gib][crate::model::volume::SnapshotReservationDetail::reserved_space_remaining_gib].
        pub fn set_reserved_space_remaining_gib<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.reserved_space_remaining_gib = v.into();
            self
        }

        /// Sets the value of [reserved_space_percent][crate::model::volume::SnapshotReservationDetail::reserved_space_percent].
        pub fn set_reserved_space_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.reserved_space_percent = v.into();
            self
        }
    }

    impl wkt::message::Message for SnapshotReservationDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.Volume.SnapshotReservationDetail"
        }
    }

    /// The storage type for a volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The storage type for this volume is unknown.
        Unspecified,
        /// The storage type for this volume is SSD.
        Ssd,
        /// This storage type for this volume is HDD.
        Hdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ssd => std::option::Option::Some(1),
                Self::Hdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Ssd => std::option::Option::Some("SSD"),
                Self::Hdd => std::option::Option::Some("HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ssd,
                2 => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SSD" => Self::Ssd,
                "HDD" => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ssd => serializer.serialize_i32(1),
                Self::Hdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.baremetalsolution.v2.Volume.StorageType",
            ))
        }
    }

    /// The possible states for a storage volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The storage volume is in an unknown state.
        Unspecified,
        /// The storage volume is being created.
        Creating,
        /// The storage volume is ready for use.
        Ready,
        /// The storage volume has been requested to be deleted.
        Deleting,
        /// The storage volume is being updated.
        Updating,
        /// The storage volume is in cool off state. It will be deleted after
        /// `expire_time`.
        CoolOff,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::CoolOff => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::CoolOff => std::option::Option::Some("COOL_OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "COOL_OFF" => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::CoolOff => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Volume.State",
            ))
        }
    }

    /// The kinds of auto delete behavior to use when snapshot reserved space is
    /// full.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SnapshotAutoDeleteBehavior {
        /// The unspecified behavior.
        Unspecified,
        /// Don't delete any snapshots. This disables new snapshot creation, as
        /// long as the snapshot reserved space is full.
        Disabled,
        /// Delete the oldest snapshots first.
        OldestFirst,
        /// Delete the newest snapshots first.
        NewestFirst,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SnapshotAutoDeleteBehavior::value] or
        /// [SnapshotAutoDeleteBehavior::name].
        UnknownValue(snapshot_auto_delete_behavior::UnknownValue),
    }

    #[doc(hidden)]
    pub mod snapshot_auto_delete_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SnapshotAutoDeleteBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::OldestFirst => std::option::Option::Some(2),
                Self::NewestFirst => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED")
                }
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::OldestFirst => std::option::Option::Some("OLDEST_FIRST"),
                Self::NewestFirst => std::option::Option::Some("NEWEST_FIRST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SnapshotAutoDeleteBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SnapshotAutoDeleteBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SnapshotAutoDeleteBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::OldestFirst,
                3 => Self::NewestFirst,
                _ => Self::UnknownValue(snapshot_auto_delete_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SnapshotAutoDeleteBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "OLDEST_FIRST" => Self::OldestFirst,
                "NEWEST_FIRST" => Self::NewestFirst,
                _ => Self::UnknownValue(snapshot_auto_delete_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SnapshotAutoDeleteBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::OldestFirst => serializer.serialize_i32(2),
                Self::NewestFirst => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SnapshotAutoDeleteBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<SnapshotAutoDeleteBehavior>::new(
                    ".google.cloud.baremetalsolution.v2.Volume.SnapshotAutoDeleteBehavior",
                ),
            )
        }
    }

    /// Storage protocol.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Value is not specified.
        Unspecified,
        /// Fibre Channel protocol.
        FibreChannel,
        /// NFS protocol means Volume is a NFS Share volume.
        /// Such volumes cannot be manipulated via Volumes API.
        Nfs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FibreChannel => std::option::Option::Some(1),
                Self::Nfs => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::FibreChannel => std::option::Option::Some("FIBRE_CHANNEL"),
                Self::Nfs => std::option::Option::Some("NFS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FibreChannel,
                2 => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "FIBRE_CHANNEL" => Self::FibreChannel,
                "NFS" => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FibreChannel => serializer.serialize_i32(1),
                Self::Nfs => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.baremetalsolution.v2.Volume.Protocol",
            ))
        }
    }

    /// The possible values for a workload profile.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WorkloadProfile {
        /// The workload profile is in an unknown state.
        Unspecified,
        /// The workload profile is generic.
        Generic,
        /// The workload profile is hana.
        Hana,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WorkloadProfile::value] or
        /// [WorkloadProfile::name].
        UnknownValue(workload_profile::UnknownValue),
    }

    #[doc(hidden)]
    pub mod workload_profile {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WorkloadProfile {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Generic => std::option::Option::Some(1),
                Self::Hana => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WORKLOAD_PROFILE_UNSPECIFIED"),
                Self::Generic => std::option::Option::Some("GENERIC"),
                Self::Hana => std::option::Option::Some("HANA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WorkloadProfile {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WorkloadProfile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WorkloadProfile {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Generic,
                2 => Self::Hana,
                _ => Self::UnknownValue(workload_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WorkloadProfile {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WORKLOAD_PROFILE_UNSPECIFIED" => Self::Unspecified,
                "GENERIC" => Self::Generic,
                "HANA" => Self::Hana,
                _ => Self::UnknownValue(workload_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WorkloadProfile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Generic => serializer.serialize_i32(1),
                Self::Hana => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WorkloadProfile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WorkloadProfile>::new(
                ".google.cloud.baremetalsolution.v2.Volume.WorkloadProfile",
            ))
        }
    }
}

/// Message for requesting storage volume information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetVolumeRequest"
    }
}

/// Message for requesting a list of storage volumes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumesRequest {
    /// Required. Parent value for ListVolumesRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumesRequest"
    }
}

/// Response message containing the list of storage volumes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumesResponse {
    /// The list of storage volumes.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volumes][crate::model::ListVolumesResponse::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumesResponse {
    type PageItem = crate::model::Volume;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volumes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for updating a volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVolumeRequest {
    /// Required. The volume to update.
    ///
    /// The `name` field is used to identify the volume to update.
    /// Format: projects/{project}/locations/{location}/volumes/{volume}
    pub volume: std::option::Option<crate::model::Volume>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// 'labels'
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_or_clear_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateVolumeRequest"
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameVolumeRequest {
    /// Required. The `name` field is used to identify the volume.
    /// Format: projects/{project}/locations/{location}/volumes/{volume}
    pub name: std::string::String,

    /// Required. The new `id` of the volume.
    pub new_volume_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_volume_id][crate::model::RenameVolumeRequest::new_volume_id].
    pub fn set_new_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_volume_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameVolumeRequest"
    }
}

/// Request for skip volume cooloff and delete it.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictVolumeRequest {
    /// Required. The name of the Volume.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EvictVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EvictVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EvictVolumeRequest"
    }
}

/// Request for emergency resize Volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResizeVolumeRequest {
    /// Required. Volume to resize.
    pub volume: std::string::String,

    /// New Volume size, in GiB.
    pub size_gib: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResizeVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume][crate::model::ResizeVolumeRequest::volume].
    pub fn set_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [size_gib][crate::model::ResizeVolumeRequest::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }
}

impl wkt::message::Message for ResizeVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResizeVolumeRequest"
    }
}

/// A snapshot of a volume. Only boot volumes can have snapshots.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeSnapshot {
    /// The name of the snapshot.
    pub name: std::string::String,

    /// Output only. An identifier for the snapshot, generated by the backend.
    pub id: std::string::String,

    /// The description of the snapshot.
    pub description: std::string::String,

    /// Output only. The creation time of the snapshot.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the volume which this snapshot belongs to.
    pub storage_volume: std::string::String,

    /// Output only. The type of the snapshot which indicates whether it was
    /// scheduled or manual/ad-hoc.
    pub r#type: crate::model::volume_snapshot::SnapshotType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeSnapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::VolumeSnapshot::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VolumeSnapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VolumeSnapshot::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VolumeSnapshot::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_volume][crate::model::VolumeSnapshot::storage_volume].
    pub fn set_storage_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_volume = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VolumeSnapshot::type].
    pub fn set_type<T: std::convert::Into<crate::model::volume_snapshot::SnapshotType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for VolumeSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeSnapshot"
    }
}

/// Defines additional types related to [VolumeSnapshot].
pub mod volume_snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the type of a snapshot.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SnapshotType {
        /// Type is not specified.
        Unspecified,
        /// Snapshot was taken manually by user.
        AdHoc,
        /// Snapshot was taken automatically as a part of a snapshot schedule.
        Scheduled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SnapshotType::value] or
        /// [SnapshotType::name].
        UnknownValue(snapshot_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod snapshot_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SnapshotType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AdHoc => std::option::Option::Some(1),
                Self::Scheduled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SNAPSHOT_TYPE_UNSPECIFIED"),
                Self::AdHoc => std::option::Option::Some("AD_HOC"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SnapshotType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SnapshotType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SnapshotType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AdHoc,
                2 => Self::Scheduled,
                _ => Self::UnknownValue(snapshot_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SnapshotType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SNAPSHOT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AD_HOC" => Self::AdHoc,
                "SCHEDULED" => Self::Scheduled,
                _ => Self::UnknownValue(snapshot_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SnapshotType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AdHoc => serializer.serialize_i32(1),
                Self::Scheduled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SnapshotType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SnapshotType>::new(
                ".google.cloud.baremetalsolution.v2.VolumeSnapshot.SnapshotType",
            ))
        }
    }
}

/// Message for requesting volume snapshot information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeSnapshotRequest {
    /// Required. The name of the snapshot.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetVolumeSnapshotRequest"
    }
}

/// Message for requesting a list of volume snapshots.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeSnapshotsRequest {
    /// Required. Parent value for ListVolumesRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumeSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumeSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumeSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumeSnapshotsRequest"
    }
}

/// Response message containing the list of volume snapshots.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeSnapshotsResponse {
    /// The list of snapshots.
    pub volume_snapshots: std::vec::Vec<crate::model::VolumeSnapshot>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_snapshots][crate::model::ListVolumeSnapshotsResponse::volume_snapshots].
    pub fn set_volume_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        use std::iter::Iterator;
        self.volume_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumeSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumeSnapshotsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumeSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumeSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumeSnapshotsResponse {
    type PageItem = crate::model::VolumeSnapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volume_snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for deleting named Volume snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVolumeSnapshotRequest {
    /// Required. The name of the snapshot to delete.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVolumeSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteVolumeSnapshotRequest"
    }
}

/// Message for creating a volume snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVolumeSnapshotRequest {
    /// Required. The volume to snapshot.
    pub parent: std::string::String,

    /// Required. The snapshot to create.
    pub volume_snapshot: std::option::Option<crate::model::VolumeSnapshot>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVolumeSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [volume_snapshot][crate::model::CreateVolumeSnapshotRequest::volume_snapshot].
    pub fn set_volume_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        self.volume_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [volume_snapshot][crate::model::CreateVolumeSnapshotRequest::volume_snapshot].
    pub fn set_or_clear_volume_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        self.volume_snapshot = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateVolumeSnapshotRequest"
    }
}

/// Message for restoring a volume snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreVolumeSnapshotRequest {
    /// Required. Name of the snapshot which will be used to restore its parent
    /// volume.
    pub volume_snapshot: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_snapshot][crate::model::RestoreVolumeSnapshotRequest::volume_snapshot].
    pub fn set_volume_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_snapshot = v.into();
        self
    }
}

impl wkt::message::Message for RestoreVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RestoreVolumeSnapshotRequest"
    }
}

/// Performance tier of the Volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum VolumePerformanceTier {
    /// Value is not specified.
    Unspecified,
    /// Regular volumes, shared aggregates.
    Shared,
    /// Assigned aggregates.
    Assigned,
    /// High throughput aggregates.
    Ht,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [VolumePerformanceTier::value] or
    /// [VolumePerformanceTier::name].
    UnknownValue(volume_performance_tier::UnknownValue),
}

#[doc(hidden)]
pub mod volume_performance_tier {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl VolumePerformanceTier {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Shared => std::option::Option::Some(1),
            Self::Assigned => std::option::Option::Some(2),
            Self::Ht => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_UNSPECIFIED"),
            Self::Shared => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_SHARED"),
            Self::Assigned => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_ASSIGNED"),
            Self::Ht => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_HT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for VolumePerformanceTier {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for VolumePerformanceTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for VolumePerformanceTier {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Shared,
            2 => Self::Assigned,
            3 => Self::Ht,
            _ => Self::UnknownValue(volume_performance_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for VolumePerformanceTier {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VOLUME_PERFORMANCE_TIER_UNSPECIFIED" => Self::Unspecified,
            "VOLUME_PERFORMANCE_TIER_SHARED" => Self::Shared,
            "VOLUME_PERFORMANCE_TIER_ASSIGNED" => Self::Assigned,
            "VOLUME_PERFORMANCE_TIER_HT" => Self::Ht,
            _ => Self::UnknownValue(volume_performance_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for VolumePerformanceTier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Shared => serializer.serialize_i32(1),
            Self::Assigned => serializer.serialize_i32(2),
            Self::Ht => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for VolumePerformanceTier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumePerformanceTier>::new(
            ".google.cloud.baremetalsolution.v2.VolumePerformanceTier",
        ))
    }
}

/// The possible values for a workload profile.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum WorkloadProfile {
    /// The workload profile is in an unknown state.
    Unspecified,
    /// The workload profile is generic.
    Generic,
    /// The workload profile is hana.
    Hana,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [WorkloadProfile::value] or
    /// [WorkloadProfile::name].
    UnknownValue(workload_profile::UnknownValue),
}

#[doc(hidden)]
pub mod workload_profile {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl WorkloadProfile {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Generic => std::option::Option::Some(1),
            Self::Hana => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("WORKLOAD_PROFILE_UNSPECIFIED"),
            Self::Generic => std::option::Option::Some("WORKLOAD_PROFILE_GENERIC"),
            Self::Hana => std::option::Option::Some("WORKLOAD_PROFILE_HANA"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for WorkloadProfile {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for WorkloadProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for WorkloadProfile {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Generic,
            2 => Self::Hana,
            _ => Self::UnknownValue(workload_profile::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for WorkloadProfile {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "WORKLOAD_PROFILE_UNSPECIFIED" => Self::Unspecified,
            "WORKLOAD_PROFILE_GENERIC" => Self::Generic,
            "WORKLOAD_PROFILE_HANA" => Self::Hana,
            _ => Self::UnknownValue(workload_profile::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for WorkloadProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Generic => serializer.serialize_i32(1),
            Self::Hana => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for WorkloadProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<WorkloadProfile>::new(
            ".google.cloud.baremetalsolution.v2.WorkloadProfile",
        ))
    }
}
