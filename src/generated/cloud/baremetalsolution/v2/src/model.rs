// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the metadata from a long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the action executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user requested the cancellation
    /// of the operation. Operations that have been successfully cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used with the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.OperationMetadata"
    }
}

/// Response message from resetting a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetInstanceResponse {}

impl ResetInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResetInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResetInstanceResponse"
    }
}

/// A server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Immutable. The resource name of this `Instance`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. An identifier for the `Instance`, generated by the backend.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. Create a time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update a time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Immutable. The server type.
    /// [Available server
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Output only. The state of the server.
    pub state: crate::model::instance::State,

    /// True if you enable hyperthreading for the server, otherwise false.
    /// The default value is false.
    pub hyperthreading_enabled: bool,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. List of LUNs associated with this server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub luns: std::vec::Vec<crate::model::Lun>,

    /// Input only. List of Volumes to attach to this Instance on creation.
    /// This field won't be populated in Get/List responses.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Output only. List of networks associated with this server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::Network>,

    /// Output only. True if the interactive serial console feature is enabled for
    /// the instance, false otherwise. The default value is false.
    pub interactive_serial_console_enabled: bool,

    /// The OS image currently installed on the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_image: std::string::String,

    /// Immutable. Pod name.
    /// Pod is an independent part of infrastructure.
    /// Instance can be connected to the assets (networks, volumes) allocated
    /// in the same pod only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod: std::string::String,

    /// Instance network template name. For eg, bondaa-bondaa, bondab-nic, etc.
    /// Generally, the template name follows the syntax of
    /// "bond<bond_mode>" or "nic".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_template: std::string::String,

    /// List of logical interfaces for the instance. The number of logical
    /// interfaces will be the same as number of hardware bond/nic on the chosen
    /// network template. For the non-multivlan configurations (for eg, existing
    /// servers) that use existing default network template (bondaa-bondaa), both
    /// the Instance.networks field and the Instance.logical_interfaces fields will
    /// be filled to ensure backward compatibility. For the others, only
    /// Instance.logical_interfaces will be filled.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub logical_interfaces: std::vec::Vec<crate::model::LogicalInterface>,

    /// Output only. Text field about info for logging in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub login_info: std::string::String,

    /// The workload profile for the instance.
    pub workload_profile: crate::model::WorkloadProfile,

    /// Output only. The firmware version for the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub firmware_version: std::string::String,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [hyperthreading_enabled][crate::model::Instance::hyperthreading_enabled].
    pub fn set_hyperthreading_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hyperthreading_enabled = v.into();
        self
    }

    /// Sets the value of [interactive_serial_console_enabled][crate::model::Instance::interactive_serial_console_enabled].
    pub fn set_interactive_serial_console_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.interactive_serial_console_enabled = v.into();
        self
    }

    /// Sets the value of [os_image][crate::model::Instance::os_image].
    pub fn set_os_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_image = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Instance::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [network_template][crate::model::Instance::network_template].
    pub fn set_network_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_template = v.into();
        self
    }

    /// Sets the value of [login_info][crate::model::Instance::login_info].
    pub fn set_login_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.login_info = v.into();
        self
    }

    /// Sets the value of [workload_profile][crate::model::Instance::workload_profile].
    pub fn set_workload_profile<T: std::convert::Into<crate::model::WorkloadProfile>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_profile = v.into();
        self
    }

    /// Sets the value of [firmware_version][crate::model::Instance::firmware_version].
    pub fn set_firmware_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware_version = v.into();
        self
    }

    /// Sets the value of [luns][crate::model::Instance::luns].
    pub fn set_luns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lun>,
    {
        use std::iter::Iterator;
        self.luns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Instance::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Instance::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::Instance::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for this server.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The server is in an unknown state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The server is being provisioned.
        pub const PROVISIONING: State = State::new(1);

        /// The server is running.
        pub const RUNNING: State = State::new(2);

        /// The server has been deleted.
        pub const DELETED: State = State::new(3);

        /// The server is being updated.
        pub const UPDATING: State = State::new(4);

        /// The server is starting.
        pub const STARTING: State = State::new(5);

        /// The server is stopping.
        pub const STOPPING: State = State::new(6);

        /// The server is shutdown.
        pub const SHUTDOWN: State = State::new(7);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("RUNNING"),
                3 => std::borrow::Cow::Borrowed("DELETED"),
                4 => std::borrow::Cow::Borrowed("UPDATING"),
                5 => std::borrow::Cow::Borrowed("STARTING"),
                6 => std::borrow::Cow::Borrowed("STOPPING"),
                7 => std::borrow::Cow::Borrowed("SHUTDOWN"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "DELETED" => std::option::Option::Some(Self::DELETED),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "STARTING" => std::option::Option::Some(Self::STARTING),
                "STOPPING" => std::option::Option::Some(Self::STOPPING),
                "SHUTDOWN" => std::option::Option::Some(Self::SHUTDOWN),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting server information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetInstanceRequest"
    }
}

/// Message for requesting the list of servers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. Parent value for ListInstancesRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListInstancesRequest"
    }
}

/// Response message for the list of servers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of servers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListInstancesResponse"
    }
}

impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message requesting to updating a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. The server to update.
    ///
    /// The `name` field is used to identify the instance to update.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// The list of fields to update.
    /// The currently supported fields are:
    /// `labels`
    /// `hyperthreading_enabled`
    /// `os_image`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateInstanceRequest"
    }
}

/// Message requesting rename of a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenameInstanceRequest {
    /// Required. The `name` field is used to identify the instance.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new `id` of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_instance_id: std::string::String,
}

impl RenameInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_instance_id][crate::model::RenameInstanceRequest::new_instance_id].
    pub fn set_new_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_instance_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameInstanceRequest"
    }
}

/// Message requesting to reset a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetInstanceRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ResetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResetInstanceRequest"
    }
}

/// Message requesting to start a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartInstanceRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StartInstanceRequest"
    }
}

/// Response message from starting a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartInstanceResponse {}

impl StartInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StartInstanceResponse"
    }
}

/// Message requesting to stop a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopInstanceRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StopInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StopInstanceRequest"
    }
}

/// Response message from stopping a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopInstanceResponse {}

impl StopInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StopInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StopInstanceResponse"
    }
}

/// Message for enabling the interactive serial console on an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableInteractiveSerialConsoleRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl EnableInteractiveSerialConsoleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableInteractiveSerialConsoleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableInteractiveSerialConsoleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EnableInteractiveSerialConsoleRequest"
    }
}

/// Message for response of EnableInteractiveSerialConsole.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableInteractiveSerialConsoleResponse {}

impl EnableInteractiveSerialConsoleResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableInteractiveSerialConsoleResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EnableInteractiveSerialConsoleResponse"
    }
}

/// Message for disabling the interactive serial console on an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableInteractiveSerialConsoleRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DisableInteractiveSerialConsoleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableInteractiveSerialConsoleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisableInteractiveSerialConsoleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DisableInteractiveSerialConsoleRequest"
    }
}

/// Message for response of DisableInteractiveSerialConsole.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableInteractiveSerialConsoleResponse {}

impl DisableInteractiveSerialConsoleResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisableInteractiveSerialConsoleResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DisableInteractiveSerialConsoleResponse"
    }
}

/// Message for detach specific LUN from an Instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DetachLunRequest {
    /// Required. Name of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. Name of the Lun to detach.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lun: std::string::String,

    /// If true, performs lun unmapping without instance reboot.
    pub skip_reboot: bool,
}

impl DetachLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::DetachLunRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [lun][crate::model::DetachLunRequest::lun].
    pub fn set_lun<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lun = v.into();
        self
    }

    /// Sets the value of [skip_reboot][crate::model::DetachLunRequest::skip_reboot].
    pub fn set_skip_reboot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_reboot = v.into();
        self
    }
}

impl wkt::message::Message for DetachLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DetachLunRequest"
    }
}

/// Network template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServerNetworkTemplate {
    /// Output only. Template's unique name. The full resource name follows the
    /// pattern:
    /// `projects/{project}/locations/{location}/serverNetworkTemplate/{server_network_template}`
    /// Generally, the {server_network_template} follows the syntax of
    /// "bond<interface_type_index><bond_mode>" or "nic<interface_type_index>".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Instance types this template is applicable to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub applicable_instance_types: std::vec::Vec<std::string::String>,

    /// Logical interfaces.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub logical_interfaces: std::vec::Vec<crate::model::server_network_template::LogicalInterface>,
}

impl ServerNetworkTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServerNetworkTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [applicable_instance_types][crate::model::ServerNetworkTemplate::applicable_instance_types].
    pub fn set_applicable_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::ServerNetworkTemplate::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::server_network_template::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServerNetworkTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ServerNetworkTemplate"
    }
}

/// Defines additional types related to ServerNetworkTemplate
pub mod server_network_template {
    #[allow(unused_imports)]
    use super::*;

    /// Logical interface.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LogicalInterface {
        /// Interface name.
        /// This is not a globally unique identifier.
        /// Name is unique only inside the ServerNetworkTemplate. This is of syntax
        /// \<bond\><interface_type_index><bond_mode> or \<nic\><interface_type_index>
        /// and forms part of the network template name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Interface type.
        #[serde(rename = "type")]
        pub r#type: crate::model::server_network_template::logical_interface::InterfaceType,

        /// If true, interface must have network connected.
        pub required: bool,
    }

    impl LogicalInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::server_network_template::LogicalInterface::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::server_network_template::LogicalInterface::type].
        pub fn set_type<
            T: std::convert::Into<
                crate::model::server_network_template::logical_interface::InterfaceType,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [required][crate::model::server_network_template::LogicalInterface::required].
        pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.required = v.into();
            self
        }
    }

    impl wkt::message::Message for LogicalInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.ServerNetworkTemplate.LogicalInterface"
        }
    }

    /// Defines additional types related to LogicalInterface
    pub mod logical_interface {
        #[allow(unused_imports)]
        use super::*;

        /// Interface type.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct InterfaceType(i32);

        impl InterfaceType {
            /// Unspecified value.
            pub const INTERFACE_TYPE_UNSPECIFIED: InterfaceType = InterfaceType::new(0);

            /// Bond interface type.
            pub const BOND: InterfaceType = InterfaceType::new(1);

            /// NIC interface type.
            pub const NIC: InterfaceType = InterfaceType::new(2);

            /// Creates a new InterfaceType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("INTERFACE_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("BOND"),
                    2 => std::borrow::Cow::Borrowed("NIC"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "INTERFACE_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::INTERFACE_TYPE_UNSPECIFIED)
                    }
                    "BOND" => std::option::Option::Some(Self::BOND),
                    "NIC" => std::option::Option::Some(Self::NIC),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for InterfaceType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for InterfaceType {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }
}

/// A storage volume logical unit number (LUN).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Lun {
    /// Output only. The name of the LUN.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An identifier for the LUN, generated by the backend.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The state of this storage volume.
    pub state: crate::model::lun::State,

    /// The size of this LUN, in gigabytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_gb: i64,

    /// The LUN multiprotocol type ensures the characteristics of the LUN are
    /// optimized for each operating system.
    pub multiprotocol_type: crate::model::lun::MultiprotocolType,

    /// Display the storage volume for this LUN.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_volume: std::string::String,

    /// Display if this LUN can be shared between multiple physical servers.
    pub shareable: bool,

    /// Display if this LUN is a boot LUN.
    pub boot_lun: bool,

    /// The storage type for this LUN.
    pub storage_type: crate::model::lun::StorageType,

    /// The WWID for this LUN.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub wwid: std::string::String,

    /// Output only. Time after which LUN will be fully deleted.
    /// It is filled only for LUNs in COOL_OFF state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instances this Lun is attached to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<std::string::String>,
}

impl Lun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Lun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Lun::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Lun::state].
    pub fn set_state<T: std::convert::Into<crate::model::lun::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Lun::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [multiprotocol_type][crate::model::Lun::multiprotocol_type].
    pub fn set_multiprotocol_type<T: std::convert::Into<crate::model::lun::MultiprotocolType>>(
        mut self,
        v: T,
    ) -> Self {
        self.multiprotocol_type = v.into();
        self
    }

    /// Sets the value of [storage_volume][crate::model::Lun::storage_volume].
    pub fn set_storage_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_volume = v.into();
        self
    }

    /// Sets the value of [shareable][crate::model::Lun::shareable].
    pub fn set_shareable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.shareable = v.into();
        self
    }

    /// Sets the value of [boot_lun][crate::model::Lun::boot_lun].
    pub fn set_boot_lun<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.boot_lun = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::Lun::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::lun::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [wwid][crate::model::Lun::wwid].
    pub fn set_wwid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.wwid = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Lun::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::Lun::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Lun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Lun"
    }
}

/// Defines additional types related to Lun
pub mod lun {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for the LUN.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The LUN is in an unknown state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The LUN is being created.
        pub const CREATING: State = State::new(1);

        /// The LUN is being updated.
        pub const UPDATING: State = State::new(2);

        /// The LUN is ready for use.
        pub const READY: State = State::new(3);

        /// The LUN has been requested to be deleted.
        pub const DELETING: State = State::new(4);

        /// The LUN is in cool off state. It will be deleted after `expire_time`.
        pub const COOL_OFF: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("UPDATING"),
                3 => std::borrow::Cow::Borrowed("READY"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("COOL_OFF"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "COOL_OFF" => std::option::Option::Some(Self::COOL_OFF),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Display the operating systems present for the LUN multiprotocol type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MultiprotocolType(i32);

    impl MultiprotocolType {
        /// Server has no OS specified.
        pub const MULTIPROTOCOL_TYPE_UNSPECIFIED: MultiprotocolType = MultiprotocolType::new(0);

        /// Server with Linux OS.
        pub const LINUX: MultiprotocolType = MultiprotocolType::new(1);

        /// Creates a new MultiprotocolType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MULTIPROTOCOL_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LINUX"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MULTIPROTOCOL_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MULTIPROTOCOL_TYPE_UNSPECIFIED)
                }
                "LINUX" => std::option::Option::Some(Self::LINUX),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MultiprotocolType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MultiprotocolType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The storage types for a LUN.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StorageType(i32);

    impl StorageType {
        /// The storage type for this LUN is unknown.
        pub const STORAGE_TYPE_UNSPECIFIED: StorageType = StorageType::new(0);

        /// This storage type for this LUN is SSD.
        pub const SSD: StorageType = StorageType::new(1);

        /// This storage type for this LUN is HDD.
        pub const HDD: StorageType = StorageType::new(2);

        /// Creates a new StorageType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STORAGE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SSD"),
                2 => std::borrow::Cow::Borrowed("HDD"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STORAGE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::STORAGE_TYPE_UNSPECIFIED)
                }
                "SSD" => std::option::Option::Some(Self::SSD),
                "HDD" => std::option::Option::Some(Self::HDD),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting storage lun information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLunRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetLunRequest"
    }
}

/// Message for requesting a list of storage volume luns.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLunsRequest {
    /// Required. Parent value for ListLunsRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListLunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListLunsRequest"
    }
}

/// Response message containing the list of storage volume luns.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLunsResponse {
    /// The list of luns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub luns: std::vec::Vec<crate::model::Lun>,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListLunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListLunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [luns][crate::model::ListLunsResponse::luns].
    pub fn set_luns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lun>,
    {
        use std::iter::Iterator;
        self.luns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListLunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListLunsResponse"
    }
}

impl gax::paginator::PageableResponse for ListLunsResponse {
    type PageItem = crate::model::Lun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.luns
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for skip lun cooloff and delete it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvictLunRequest {
    /// Required. The name of the lun.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl EvictLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EvictLunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EvictLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EvictLunRequest"
    }
}

/// A Network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Network {
    /// Output only. The resource name of this `Network`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/networks/{network}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An identifier for the `Network`, generated by the backend.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of this network.
    #[serde(rename = "type")]
    pub r#type: crate::model::network::Type,

    /// IP address configured.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// List of physical interfaces.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mac_address: std::vec::Vec<std::string::String>,

    /// The Network state.
    pub state: crate::model::network::State,

    /// The vlan id of the Network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vlan_id: std::string::String,

    /// The cidr of the Network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cidr: std::string::String,

    /// The vrf for the Network.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vrf: std::option::Option<crate::model::Vrf>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// IP range for reserved for services (e.g. NFS).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_cidr: std::string::String,

    /// List of IP address reservations in this network.
    /// When updating this field, an error will be generated if a reservation
    /// conflicts with an IP address already allocated to a physical server.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reservations: std::vec::Vec<crate::model::NetworkAddressReservation>,

    /// Output only. Pod name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod: std::string::String,

    /// Input only. List of mount points to attach the network to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mount_points: std::vec::Vec<crate::model::NetworkMountPoint>,

    /// Whether network uses standard frames or jumbo ones.
    pub jumbo_frames_enabled: bool,

    /// Output only. Gateway ip address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gateway_ip: std::string::String,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Network::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Network::type].
    pub fn set_type<T: std::convert::Into<crate::model::network::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::Network::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Network::state].
    pub fn set_state<T: std::convert::Into<crate::model::network::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [vlan_id][crate::model::Network::vlan_id].
    pub fn set_vlan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vlan_id = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::Network::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [vrf][crate::model::Network::vrf].
    pub fn set_vrf<T: std::convert::Into<std::option::Option<crate::model::Vrf>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vrf = v.into();
        self
    }

    /// Sets the value of [services_cidr][crate::model::Network::services_cidr].
    pub fn set_services_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.services_cidr = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Network::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [jumbo_frames_enabled][crate::model::Network::jumbo_frames_enabled].
    pub fn set_jumbo_frames_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.jumbo_frames_enabled = v.into();
        self
    }

    /// Sets the value of [gateway_ip][crate::model::Network::gateway_ip].
    pub fn set_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gateway_ip = v.into();
        self
    }

    /// Sets the value of [mac_address][crate::model::Network::mac_address].
    pub fn set_mac_address<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mac_address = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reservations][crate::model::Network::reservations].
    pub fn set_reservations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAddressReservation>,
    {
        use std::iter::Iterator;
        self.reservations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mount_points][crate::model::Network::mount_points].
    pub fn set_mount_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkMountPoint>,
    {
        use std::iter::Iterator;
        self.mount_points = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Network::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Network"
    }
}

/// Defines additional types related to Network
pub mod network {
    #[allow(unused_imports)]
    use super::*;

    /// Network type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Unspecified value.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// Client network, a network peered to a Google Cloud VPC.
        pub const CLIENT: Type = Type::new(1);

        /// Private network, a network local to the Bare Metal Solution environment.
        pub const PRIVATE: Type = Type::new(2);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLIENT"),
                2 => std::borrow::Cow::Borrowed("PRIVATE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "CLIENT" => std::option::Option::Some(Self::CLIENT),
                "PRIVATE" => std::option::Option::Some(Self::PRIVATE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The possible states for this Network.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The Network is in an unknown state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The Network is provisioning.
        pub const PROVISIONING: State = State::new(1);

        /// The Network has been provisioned.
        pub const PROVISIONED: State = State::new(2);

        /// The Network is being deprovisioned.
        pub const DEPROVISIONING: State = State::new(3);

        /// The Network is being updated.
        pub const UPDATING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("PROVISIONED"),
                3 => std::borrow::Cow::Borrowed("DEPROVISIONING"),
                4 => std::borrow::Cow::Borrowed("UPDATING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "PROVISIONED" => std::option::Option::Some(Self::PROVISIONED),
                "DEPROVISIONING" => std::option::Option::Some(Self::DEPROVISIONING),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A reservation of one or more addresses in a network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkAddressReservation {
    /// The first address of this reservation block.
    /// Must be specified as a single IPv4 address, e.g. 10.1.2.2.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_address: std::string::String,

    /// The last address of this reservation block, inclusive. I.e., for cases when
    /// reservations are only single addresses, end_address and start_address will
    /// be the same.
    /// Must be specified as a single IPv4 address, e.g. 10.1.2.2.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub end_address: std::string::String,

    /// A note about this reservation, intended for human consumption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub note: std::string::String,
}

impl NetworkAddressReservation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_address][crate::model::NetworkAddressReservation::start_address].
    pub fn set_start_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_address = v.into();
        self
    }

    /// Sets the value of [end_address][crate::model::NetworkAddressReservation::end_address].
    pub fn set_end_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_address = v.into();
        self
    }

    /// Sets the value of [note][crate::model::NetworkAddressReservation::note].
    pub fn set_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note = v.into();
        self
    }
}

impl wkt::message::Message for NetworkAddressReservation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkAddressReservation"
    }
}

/// A network VRF.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Vrf {
    /// The name of the VRF.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The possible state of VRF.
    pub state: crate::model::vrf::State,

    /// The QOS policy applied to this VRF.
    /// The value is only meaningful when all the vlan attachments have the same
    /// QoS. This field should not be used for new integrations, use vlan
    /// attachment level qos instead. The field is left for backward-compatibility.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qos_policy: std::option::Option<crate::model::vrf::QosPolicy>,

    /// The list of VLAN attachments for the VRF.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vlan_attachments: std::vec::Vec<crate::model::vrf::VlanAttachment>,
}

impl Vrf {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Vrf::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Vrf::state].
    pub fn set_state<T: std::convert::Into<crate::model::vrf::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [qos_policy][crate::model::Vrf::qos_policy].
    pub fn set_qos_policy<
        T: std::convert::Into<std::option::Option<crate::model::vrf::QosPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.qos_policy = v.into();
        self
    }

    /// Sets the value of [vlan_attachments][crate::model::Vrf::vlan_attachments].
    pub fn set_vlan_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vrf::VlanAttachment>,
    {
        use std::iter::Iterator;
        self.vlan_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Vrf {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF"
    }
}

/// Defines additional types related to VRF
pub mod vrf {
    #[allow(unused_imports)]
    use super::*;

    /// QOS policy parameters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QosPolicy {
        /// The bandwidth permitted by the QOS policy, in gbps.
        pub bandwidth_gbps: f64,
    }

    impl QosPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bandwidth_gbps][crate::model::vrf::QosPolicy::bandwidth_gbps].
        pub fn set_bandwidth_gbps<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.bandwidth_gbps = v.into();
            self
        }
    }

    impl wkt::message::Message for QosPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF.QosPolicy"
        }
    }

    /// VLAN attachment details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VlanAttachment {
        /// The peer vlan ID of the attachment.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub peer_vlan_id: i64,

        /// The peer IP of the attachment.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub peer_ip: std::string::String,

        /// The router IP of the attachment.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub router_ip: std::string::String,

        /// Input only. Pairing key.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pairing_key: std::string::String,

        /// The QOS policy applied to this VLAN attachment.
        /// This value should be preferred to using qos at vrf level.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub qos_policy: std::option::Option<crate::model::vrf::QosPolicy>,

        /// Immutable. The identifier of the attachment within vrf.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Optional. The name of the vlan attachment within vrf. This is of the form
        /// projects/{project_number}/regions/{region}/interconnectAttachments/{interconnect_attachment}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub interconnect_attachment: std::string::String,
    }

    impl VlanAttachment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peer_vlan_id][crate::model::vrf::VlanAttachment::peer_vlan_id].
        pub fn set_peer_vlan_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.peer_vlan_id = v.into();
            self
        }

        /// Sets the value of [peer_ip][crate::model::vrf::VlanAttachment::peer_ip].
        pub fn set_peer_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.peer_ip = v.into();
            self
        }

        /// Sets the value of [router_ip][crate::model::vrf::VlanAttachment::router_ip].
        pub fn set_router_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.router_ip = v.into();
            self
        }

        /// Sets the value of [pairing_key][crate::model::vrf::VlanAttachment::pairing_key].
        pub fn set_pairing_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pairing_key = v.into();
            self
        }

        /// Sets the value of [qos_policy][crate::model::vrf::VlanAttachment::qos_policy].
        pub fn set_qos_policy<
            T: std::convert::Into<std::option::Option<crate::model::vrf::QosPolicy>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.qos_policy = v.into();
            self
        }

        /// Sets the value of [id][crate::model::vrf::VlanAttachment::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [interconnect_attachment][crate::model::vrf::VlanAttachment::interconnect_attachment].
        pub fn set_interconnect_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.interconnect_attachment = v.into();
            self
        }
    }

    impl wkt::message::Message for VlanAttachment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF.VlanAttachment"
        }
    }

    /// The possible states for this VRF.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The vrf is provisioning.
        pub const PROVISIONING: State = State::new(1);

        /// The vrf is provisioned.
        pub const PROVISIONED: State = State::new(2);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONING"),
                2 => std::borrow::Cow::Borrowed("PROVISIONED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "PROVISIONED" => std::option::Option::Some(Self::PROVISIONED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Each logical interface represents a logical abstraction of the underlying
/// physical interface (for eg. bond, nic) of the instance. Each logical
/// interface can effectively map to multiple network-IP pairs and still be
/// mapped to one underlying physical interface.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogicalInterface {
    /// List of logical network interfaces within a logical interface.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub logical_network_interfaces:
        std::vec::Vec<crate::model::logical_interface::LogicalNetworkInterface>,

    /// Interface name. This is of syntax \<bond\><bond_mode> or \<nic\> and
    /// forms part of the network template name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The index of the logical interface mapping to the index of the hardware
    /// bond or nic on the chosen network template. This field is deprecated.
    pub interface_index: i32,
}

impl LogicalInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogicalInterface::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [interface_index][crate::model::LogicalInterface::interface_index].
    pub fn set_interface_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.interface_index = v.into();
        self
    }

    /// Sets the value of [logical_network_interfaces][crate::model::LogicalInterface::logical_network_interfaces].
    pub fn set_logical_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logical_interface::LogicalNetworkInterface>,
    {
        use std::iter::Iterator;
        self.logical_network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LogicalInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.LogicalInterface"
    }
}

/// Defines additional types related to LogicalInterface
pub mod logical_interface {
    #[allow(unused_imports)]
    use super::*;

    /// Each logical network interface is effectively a network and IP pair.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LogicalNetworkInterface {
        /// Name of the network
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network: std::string::String,

        /// IP address in the network
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ip_address: std::string::String,

        /// Whether this interface is the default gateway for the instance. Only
        /// one interface can be the default gateway for the instance.
        pub default_gateway: bool,

        /// Type of network.
        pub network_type: crate::model::network::Type,

        /// An identifier for the `Network`, generated by the backend.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,
    }

    impl LogicalNetworkInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::logical_interface::LogicalNetworkInterface::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [ip_address][crate::model::logical_interface::LogicalNetworkInterface::ip_address].
        pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip_address = v.into();
            self
        }

        /// Sets the value of [default_gateway][crate::model::logical_interface::LogicalNetworkInterface::default_gateway].
        pub fn set_default_gateway<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.default_gateway = v.into();
            self
        }

        /// Sets the value of [network_type][crate::model::logical_interface::LogicalNetworkInterface::network_type].
        pub fn set_network_type<T: std::convert::Into<crate::model::network::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_type = v.into();
            self
        }

        /// Sets the value of [id][crate::model::logical_interface::LogicalNetworkInterface::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for LogicalNetworkInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.LogicalInterface.LogicalNetworkInterface"
        }
    }
}

/// Message for requesting network information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNetworkRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetNetworkRequest"
    }
}

/// Message for requesting a list of networks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworksRequest {
    /// Required. Parent value for ListNetworksRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListNetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworksRequest"
    }
}

/// Response message containing the list of networks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworksResponse {
    /// The list of networks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::Network>,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListNetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [networks][crate::model::ListNetworksResponse::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNetworksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworksResponse"
    }
}

impl gax::paginator::PageableResponse for ListNetworksResponse {
    type PageItem = crate::model::Network;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.networks
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message requesting to updating a network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNetworkRequest {
    /// Required. The network to update.
    ///
    /// The `name` field is used to identify the instance to update.
    /// Format: projects/{project}/locations/{location}/networks/{network}
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::Network>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// `labels`, `reservations`, `vrf.vlan_attachments`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::UpdateNetworkRequest::network].
    pub fn set_network<T: std::convert::Into<std::option::Option<crate::model::Network>>>(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNetworkRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateNetworkRequest"
    }
}

/// Network with all used IP addresses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkUsage {
    /// Network.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::Network>,

    /// All used IP addresses in this network.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub used_ips: std::vec::Vec<std::string::String>,
}

impl NetworkUsage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkUsage::network].
    pub fn set_network<T: std::convert::Into<std::option::Option<crate::model::Network>>>(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [used_ips][crate::model::NetworkUsage::used_ips].
    pub fn set_used_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.used_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkUsage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkUsage"
    }
}

/// Request to get networks with IPs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworkUsageRequest {
    /// Required. Parent value (project and location).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,
}

impl ListNetworkUsageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ListNetworkUsageRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworkUsageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworkUsageRequest"
    }
}

/// Response with Networks with IPs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNetworkUsageResponse {
    /// Networks with IPs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::NetworkUsage>,
}

impl ListNetworkUsageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [networks][crate::model::ListNetworkUsageResponse::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkUsage>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworkUsageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworkUsageResponse"
    }
}

/// Mount point for a network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkMountPoint {
    /// Instance to attach network to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Logical interface to detach from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub logical_interface: std::string::String,

    /// Network should be a default gateway.
    pub default_gateway: bool,

    /// Ip address of the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,
}

impl NetworkMountPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::NetworkMountPoint::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [logical_interface][crate::model::NetworkMountPoint::logical_interface].
    pub fn set_logical_interface<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.logical_interface = v.into();
        self
    }

    /// Sets the value of [default_gateway][crate::model::NetworkMountPoint::default_gateway].
    pub fn set_default_gateway<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_gateway = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::NetworkMountPoint::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for NetworkMountPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkMountPoint"
    }
}

/// Message requesting rename of a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenameNetworkRequest {
    /// Required. The `name` field is used to identify the network.
    /// Format: projects/{project}/locations/{location}/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new `id` of the network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_network_id: std::string::String,
}

impl RenameNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_network_id][crate::model::RenameNetworkRequest::new_network_id].
    pub fn set_new_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_network_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameNetworkRequest"
    }
}

/// An NFS share.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NfsShare {
    /// Immutable. The name of the NFS share.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. An identifier for the NFS share, generated by the backend.
    /// This field will be deprecated in the future, use `id` instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nfs_share_id: std::string::String,

    /// Output only. An identifier for the NFS share, generated by the backend.
    /// This is the same value as nfs_share_id and will replace it in the future.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The state of the NFS share.
    pub state: crate::model::nfs_share::State,

    /// Output only. The underlying volume of the share. Created automatically
    /// during provisioning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume: std::string::String,

    /// List of allowed access points.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_clients: std::vec::Vec<crate::model::nfs_share::AllowedClient>,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The requested size, in GiB.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub requested_size_gib: i64,

    /// Immutable. The storage type of the underlying volume.
    pub storage_type: crate::model::nfs_share::StorageType,
}

impl NfsShare {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NfsShare::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [nfs_share_id][crate::model::NfsShare::nfs_share_id].
    pub fn set_nfs_share_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nfs_share_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::NfsShare::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NfsShare::state].
    pub fn set_state<T: std::convert::Into<crate::model::nfs_share::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [volume][crate::model::NfsShare::volume].
    pub fn set_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [requested_size_gib][crate::model::NfsShare::requested_size_gib].
    pub fn set_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.requested_size_gib = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::NfsShare::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::nfs_share::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [allowed_clients][crate::model::NfsShare::allowed_clients].
    pub fn set_allowed_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nfs_share::AllowedClient>,
    {
        use std::iter::Iterator;
        self.allowed_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NfsShare::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NfsShare {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NfsShare"
    }
}

/// Defines additional types related to NfsShare
pub mod nfs_share {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an 'access point' for the share.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AllowedClient {
        /// The network the access point sits on.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network: std::string::String,

        /// Output only. The IP address of the share on this network. Assigned
        /// automatically during provisioning based on the network's services_cidr.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub share_ip: std::string::String,

        /// The subnet of IP addresses permitted to access the share.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub allowed_clients_cidr: std::string::String,

        /// Mount permissions.
        pub mount_permissions: crate::model::nfs_share::MountPermissions,

        /// Allow dev flag.  Which controls whether to allow creation of devices.
        pub allow_dev: bool,

        /// Allow the setuid flag.
        pub allow_suid: bool,

        /// Disable root squashing, which is a feature of NFS.
        /// Root squash is a special mapping of the remote superuser (root) identity
        /// when using identity authentication.
        pub no_root_squash: bool,

        /// Output only. The path to access NFS, in format shareIP:/InstanceID
        /// InstanceID is the generated ID instead of customer provided name.
        /// example like "10.0.0.0:/g123456789-nfs001"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub nfs_path: std::string::String,
    }

    impl AllowedClient {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::nfs_share::AllowedClient::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [share_ip][crate::model::nfs_share::AllowedClient::share_ip].
        pub fn set_share_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.share_ip = v.into();
            self
        }

        /// Sets the value of [allowed_clients_cidr][crate::model::nfs_share::AllowedClient::allowed_clients_cidr].
        pub fn set_allowed_clients_cidr<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allowed_clients_cidr = v.into();
            self
        }

        /// Sets the value of [mount_permissions][crate::model::nfs_share::AllowedClient::mount_permissions].
        pub fn set_mount_permissions<
            T: std::convert::Into<crate::model::nfs_share::MountPermissions>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mount_permissions = v.into();
            self
        }

        /// Sets the value of [allow_dev][crate::model::nfs_share::AllowedClient::allow_dev].
        pub fn set_allow_dev<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_dev = v.into();
            self
        }

        /// Sets the value of [allow_suid][crate::model::nfs_share::AllowedClient::allow_suid].
        pub fn set_allow_suid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_suid = v.into();
            self
        }

        /// Sets the value of [no_root_squash][crate::model::nfs_share::AllowedClient::no_root_squash].
        pub fn set_no_root_squash<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_root_squash = v.into();
            self
        }

        /// Sets the value of [nfs_path][crate::model::nfs_share::AllowedClient::nfs_path].
        pub fn set_nfs_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.nfs_path = v.into();
            self
        }
    }

    impl wkt::message::Message for AllowedClient {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.NfsShare.AllowedClient"
        }
    }

    /// The possible states for this NFS share.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The share is in an unknown state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The share has been provisioned.
        pub const PROVISIONED: State = State::new(1);

        /// The NFS Share is being created.
        pub const CREATING: State = State::new(2);

        /// The NFS Share is being updated.
        pub const UPDATING: State = State::new(3);

        /// The NFS Share has been requested to be deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROVISIONED"),
                2 => std::borrow::Cow::Borrowed("CREATING"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PROVISIONED" => std::option::Option::Some(Self::PROVISIONED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The possible mount permissions.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MountPermissions(i32);

    impl MountPermissions {
        /// Permissions were not specified.
        pub const MOUNT_PERMISSIONS_UNSPECIFIED: MountPermissions = MountPermissions::new(0);

        /// NFS share can be mount with read-only permissions.
        pub const READ: MountPermissions = MountPermissions::new(1);

        /// NFS share can be mount with read-write permissions.
        pub const READ_WRITE: MountPermissions = MountPermissions::new(2);

        /// Creates a new MountPermissions instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MOUNT_PERMISSIONS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READ"),
                2 => std::borrow::Cow::Borrowed("READ_WRITE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MOUNT_PERMISSIONS_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MOUNT_PERMISSIONS_UNSPECIFIED)
                }
                "READ" => std::option::Option::Some(Self::READ),
                "READ_WRITE" => std::option::Option::Some(Self::READ_WRITE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MountPermissions {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MountPermissions {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The storage type for a volume.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StorageType(i32);

    impl StorageType {
        /// The storage type for this volume is unknown.
        pub const STORAGE_TYPE_UNSPECIFIED: StorageType = StorageType::new(0);

        /// The storage type for this volume is SSD.
        pub const SSD: StorageType = StorageType::new(1);

        /// This storage type for this volume is HDD.
        pub const HDD: StorageType = StorageType::new(2);

        /// Creates a new StorageType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STORAGE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SSD"),
                2 => std::borrow::Cow::Borrowed("HDD"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STORAGE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::STORAGE_TYPE_UNSPECIFIED)
                }
                "SSD" => std::option::Option::Some(Self::SSD),
                "HDD" => std::option::Option::Some(Self::HDD),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting NFS share information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNfsShareRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetNfsShareRequest"
    }
}

/// Message for requesting a list of NFS shares.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNfsSharesRequest {
    /// Required. Parent value for ListNfsSharesRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListNfsSharesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNfsSharesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNfsSharesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNfsSharesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNfsSharesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNfsSharesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNfsSharesRequest"
    }
}

/// Response message containing the list of NFS shares.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNfsSharesResponse {
    /// The list of NFS shares.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_shares: std::vec::Vec<crate::model::NfsShare>,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListNfsSharesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNfsSharesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [nfs_shares][crate::model::ListNfsSharesResponse::nfs_shares].
    pub fn set_nfs_shares<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsShare>,
    {
        use std::iter::Iterator;
        self.nfs_shares = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNfsSharesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNfsSharesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNfsSharesResponse"
    }
}

impl gax::paginator::PageableResponse for ListNfsSharesResponse {
    type PageItem = crate::model::NfsShare;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nfs_shares
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message requesting to updating an NFS share.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNfsShareRequest {
    /// Required. The NFS share to update.
    ///
    /// The `name` field is used to identify the NFS share to update.
    /// Format: projects/{project}/locations/{location}/nfsShares/{nfs_share}
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nfs_share: std::option::Option<crate::model::NfsShare>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// `labels`
    /// `allowed_clients`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nfs_share][crate::model::UpdateNfsShareRequest::nfs_share].
    pub fn set_nfs_share<T: std::convert::Into<std::option::Option<crate::model::NfsShare>>>(
        mut self,
        v: T,
    ) -> Self {
        self.nfs_share = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNfsShareRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateNfsShareRequest"
    }
}

/// Message requesting rename of a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenameNfsShareRequest {
    /// Required. The `name` field is used to identify the nfsshare.
    /// Format: projects/{project}/locations/{location}/nfsshares/{nfsshare}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new `id` of the nfsshare.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_nfsshare_id: std::string::String,
}

impl RenameNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_nfsshare_id][crate::model::RenameNfsShareRequest::new_nfsshare_id].
    pub fn set_new_nfsshare_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_nfsshare_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameNfsShareRequest"
    }
}

/// Message for creating an NFS share.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNfsShareRequest {
    /// Required. The parent project and location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The NfsShare to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nfs_share: std::option::Option<crate::model::NfsShare>,
}

impl CreateNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNfsShareRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [nfs_share][crate::model::CreateNfsShareRequest::nfs_share].
    pub fn set_nfs_share<T: std::convert::Into<std::option::Option<crate::model::NfsShare>>>(
        mut self,
        v: T,
    ) -> Self {
        self.nfs_share = v.into();
        self
    }
}

impl wkt::message::Message for CreateNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateNfsShareRequest"
    }
}

/// Message for deleting an NFS share.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNfsShareRequest {
    /// Required. The name of the NFS share to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteNfsShareRequest"
    }
}

/// Operation System image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OSImage {
    /// Output only. OS Image's unique name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// OS Image code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// OS Image description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Instance types this image is applicable to.
    /// [Available
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub applicable_instance_types: std::vec::Vec<std::string::String>,

    /// Network templates that can be used with this OS Image.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_network_templates: std::vec::Vec<std::string::String>,
}

impl OSImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::OSImage::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSImage::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [applicable_instance_types][crate::model::OSImage::applicable_instance_types].
    pub fn set_applicable_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_network_templates][crate::model::OSImage::supported_network_templates].
    pub fn set_supported_network_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_network_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OSImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.OSImage"
    }
}

/// Request for getting all available OS images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSImagesRequest {
    /// Required. Parent value for ListProvisioningQuotasRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    /// Notice that page_size field is not supported and won't be respected in
    /// the API request for now, will be updated when pagination is supported.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListOSImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSImagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSImagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListOSImagesRequest"
    }
}

/// Request for getting all available OS images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSImagesResponse {
    /// The OS images available.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub os_images: std::vec::Vec<crate::model::OSImage>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListOSImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListOSImagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [os_images][crate::model::ListOSImagesResponse::os_images].
    pub fn set_os_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSImage>,
    {
        use std::iter::Iterator;
        self.os_images = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOSImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListOSImagesResponse"
    }
}

impl gax::paginator::PageableResponse for ListOSImagesResponse {
    type PageItem = crate::model::OSImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_images
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A provisioning configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProvisioningConfig {
    /// Output only. The system-generated name of the provisioning config. This
    /// follows the UUID format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Instances to be created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::InstanceConfig>,

    /// Networks to be created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Volumes to be created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::VolumeConfig>,

    /// A generated ticket id to track provisioning request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ticket_id: std::string::String,

    /// A service account to enable customers to access instance credentials upon
    /// handover.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub handover_service_account: std::string::String,

    /// Email provided to send a confirmation with provisioning config to.
    /// Deprecated in favour of email field in request messages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,

    /// Output only. State of ProvisioningConfig.
    pub state: crate::model::provisioning_config::State,

    /// Optional. Location name of this ProvisioningConfig.
    /// It is optional only for Intake UI transition period.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Output only. Last update timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. URI to Cloud Console UI view of this provisioning config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_console_uri: std::string::String,

    /// If true, VPC SC is enabled for the cluster.
    pub vpc_sc_enabled: bool,

    /// Optional status messages associated with the FAILED state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Optional. The user-defined identifier of the provisioning config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub custom_id: std::string::String,
}

impl ProvisioningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisioningConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ticket_id][crate::model::ProvisioningConfig::ticket_id].
    pub fn set_ticket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ticket_id = v.into();
        self
    }

    /// Sets the value of [handover_service_account][crate::model::ProvisioningConfig::handover_service_account].
    pub fn set_handover_service_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.handover_service_account = v.into();
        self
    }

    /// Sets the value of [email][crate::model::ProvisioningConfig::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ProvisioningConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::provisioning_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ProvisioningConfig::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ProvisioningConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [cloud_console_uri][crate::model::ProvisioningConfig::cloud_console_uri].
    pub fn set_cloud_console_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_console_uri = v.into();
        self
    }

    /// Sets the value of [vpc_sc_enabled][crate::model::ProvisioningConfig::vpc_sc_enabled].
    pub fn set_vpc_sc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vpc_sc_enabled = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::ProvisioningConfig::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [custom_id][crate::model::ProvisioningConfig::custom_id].
    pub fn set_custom_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_id = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ProvisioningConfig::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceConfig>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::ProvisioningConfig::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::ProvisioningConfig::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeConfig>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProvisioningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ProvisioningConfig"
    }
}

/// Defines additional types related to ProvisioningConfig
pub mod provisioning_config {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for this ProvisioningConfig.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State wasn't specified.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// ProvisioningConfig is a draft and can be freely modified.
        pub const DRAFT: State = State::new(1);

        /// ProvisioningConfig was already submitted and cannot be modified.
        pub const SUBMITTED: State = State::new(2);

        /// ProvisioningConfig was in the provisioning state.  Initially this state
        /// comes from the work order table in big query when SNOW is used.  Later
        /// this field can be set by the work order API.
        pub const PROVISIONING: State = State::new(3);

        /// ProvisioningConfig was provisioned, meaning the resources exist.
        pub const PROVISIONED: State = State::new(4);

        /// ProvisioningConfig was validated.  A validation tool will be run to
        /// set this state.
        pub const VALIDATED: State = State::new(5);

        /// ProvisioningConfig was canceled.
        pub const CANCELLED: State = State::new(6);

        /// The request is submitted for provisioning, with error return.
        pub const FAILED: State = State::new(7);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DRAFT"),
                2 => std::borrow::Cow::Borrowed("SUBMITTED"),
                3 => std::borrow::Cow::Borrowed("PROVISIONING"),
                4 => std::borrow::Cow::Borrowed("PROVISIONED"),
                5 => std::borrow::Cow::Borrowed("VALIDATED"),
                6 => std::borrow::Cow::Borrowed("CANCELLED"),
                7 => std::borrow::Cow::Borrowed("FAILED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "DRAFT" => std::option::Option::Some(Self::DRAFT),
                "SUBMITTED" => std::option::Option::Some(Self::SUBMITTED),
                "PROVISIONING" => std::option::Option::Some(Self::PROVISIONING),
                "PROVISIONED" => std::option::Option::Some(Self::PROVISIONED),
                "VALIDATED" => std::option::Option::Some(Self::VALIDATED),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for SubmitProvisioningConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitProvisioningConfigRequest {
    /// Required. The parent project and location containing the
    /// ProvisioningConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ProvisioningConfig to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,
}

impl SubmitProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitProvisioningConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [provisioning_config][crate::model::SubmitProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<
        T: std::convert::Into<std::option::Option<crate::model::ProvisioningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_config = v.into();
        self
    }

    /// Sets the value of [email][crate::model::SubmitProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for SubmitProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SubmitProvisioningConfigRequest"
    }
}

/// Response for SubmitProvisioningConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitProvisioningConfigResponse {
    /// The submitted provisioning config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,
}

impl SubmitProvisioningConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_config][crate::model::SubmitProvisioningConfigResponse::provisioning_config].
    pub fn set_provisioning_config<
        T: std::convert::Into<std::option::Option<crate::model::ProvisioningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_config = v.into();
        self
    }
}

impl wkt::message::Message for SubmitProvisioningConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SubmitProvisioningConfigResponse"
    }
}

/// A provisioning quota for a given project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProvisioningQuota {
    /// Output only. The name of the provisioning quota.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The asset type of this provisioning quota.
    pub asset_type: crate::model::provisioning_quota::AssetType,

    /// The gcp service of the provisioning quota.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_service: std::string::String,

    /// The specific location of the provisioining quota.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The available count of the provisioning quota.
    pub available_count: i32,

    /// The quota of one asset type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub quota: std::option::Option<crate::model::provisioning_quota::Quota>,

    /// Available quantity based on asset type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub availability: std::option::Option<crate::model::provisioning_quota::Availability>,
}

impl ProvisioningQuota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisioningQuota::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::ProvisioningQuota::asset_type].
    pub fn set_asset_type<T: std::convert::Into<crate::model::provisioning_quota::AssetType>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::ProvisioningQuota::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ProvisioningQuota::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [available_count][crate::model::ProvisioningQuota::available_count].
    pub fn set_available_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_count = v.into();
        self
    }

    /// Sets the value of `quota`.
    pub fn set_quota<
        T: std::convert::Into<std::option::Option<crate::model::provisioning_quota::Quota>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quota = v.into();
        self
    }

    /// The value of [quota][crate::model::ProvisioningQuota::quota]
    /// if it holds a `InstanceQuota`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_instance_quota(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstanceQuota>> {
        #[allow(unreachable_patterns)]
        self.quota.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Quota::InstanceQuota(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [quota][crate::model::ProvisioningQuota::quota]
    /// to hold a `InstanceQuota`.
    ///
    /// Note that all the setters affecting `quota` are
    /// mutually exclusive.
    pub fn set_instance_quota<
        T: std::convert::Into<std::boxed::Box<crate::model::InstanceQuota>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quota = std::option::Option::Some(
            crate::model::provisioning_quota::Quota::InstanceQuota(v.into()),
        );
        self
    }

    /// Sets the value of `availability`.
    pub fn set_availability<
        T: std::convert::Into<std::option::Option<crate::model::provisioning_quota::Availability>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `ServerCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_server_count(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::ServerCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `NetworkBandwidth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_network_bandwidth(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::NetworkBandwidth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `StorageGib`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_storage_gib(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::StorageGib(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `ServerCount`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_server_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::ServerCount(v.into()),
        );
        self
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `NetworkBandwidth`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_network_bandwidth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::NetworkBandwidth(v.into()),
        );
        self
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `StorageGib`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_storage_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::StorageGib(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ProvisioningQuota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ProvisioningQuota"
    }
}

/// Defines additional types related to ProvisioningQuota
pub mod provisioning_quota {
    #[allow(unused_imports)]
    use super::*;

    /// The available asset types for intake.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AssetType(i32);

    impl AssetType {
        /// The unspecified type.
        pub const ASSET_TYPE_UNSPECIFIED: AssetType = AssetType::new(0);

        /// The server asset type.
        pub const ASSET_TYPE_SERVER: AssetType = AssetType::new(1);

        /// The storage asset type.
        pub const ASSET_TYPE_STORAGE: AssetType = AssetType::new(2);

        /// The network asset type.
        pub const ASSET_TYPE_NETWORK: AssetType = AssetType::new(3);

        /// Creates a new AssetType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ASSET_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ASSET_TYPE_SERVER"),
                2 => std::borrow::Cow::Borrowed("ASSET_TYPE_STORAGE"),
                3 => std::borrow::Cow::Borrowed("ASSET_TYPE_NETWORK"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ASSET_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::ASSET_TYPE_UNSPECIFIED),
                "ASSET_TYPE_SERVER" => std::option::Option::Some(Self::ASSET_TYPE_SERVER),
                "ASSET_TYPE_STORAGE" => std::option::Option::Some(Self::ASSET_TYPE_STORAGE),
                "ASSET_TYPE_NETWORK" => std::option::Option::Some(Self::ASSET_TYPE_NETWORK),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AssetType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AssetType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The quota of one asset type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Quota {
        /// Instance quota.
        InstanceQuota(std::boxed::Box<crate::model::InstanceQuota>),
    }

    /// Available quantity based on asset type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Availability {
        /// Server count.
        ServerCount(i64),
        /// Network bandwidth, Gbps
        NetworkBandwidth(i64),
        /// Storage size (GB).
        StorageGib(i64),
    }
}

/// Message for requesting the list of provisioning quotas.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProvisioningQuotasRequest {
    /// Required. Parent value for ListProvisioningQuotasRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    /// Notice that page_size field is not supported and won't be respected in
    /// the API request for now, will be updated when pagination is supported.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListProvisioningQuotasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvisioningQuotasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvisioningQuotasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvisioningQuotasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvisioningQuotasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListProvisioningQuotasRequest"
    }
}

/// Response message for the list of provisioning quotas.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProvisioningQuotasResponse {
    /// The provisioning quotas registered in this project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub provisioning_quotas: std::vec::Vec<crate::model::ProvisioningQuota>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListProvisioningQuotasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListProvisioningQuotasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [provisioning_quotas][crate::model::ListProvisioningQuotasResponse::provisioning_quotas].
    pub fn set_provisioning_quotas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProvisioningQuota>,
    {
        use std::iter::Iterator;
        self.provisioning_quotas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProvisioningQuotasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListProvisioningQuotasResponse"
    }
}

impl gax::paginator::PageableResponse for ListProvisioningQuotasResponse {
    type PageItem = crate::model::ProvisioningQuota;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.provisioning_quotas
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Configuration parameters for a new instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceConfig {
    /// Output only. The name of the instance config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A transient unique identifier to idenfity an instance within an
    /// ProvisioningConfig request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Instance type.
    /// [Available
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_type: std::string::String,

    /// Whether the instance should be provisioned with Hyperthreading enabled.
    pub hyperthreading: bool,

    /// OS image to initialize the instance.
    /// [Available
    /// images](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_image: std::string::String,

    /// Client network address. Filled if InstanceConfig.multivlan_config is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_network: std::option::Option<crate::model::instance_config::NetworkAddress>,

    /// Private network address, if any. Filled if InstanceConfig.multivlan_config
    /// is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_network: std::option::Option<crate::model::instance_config::NetworkAddress>,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_note: std::string::String,

    /// If true networks can be from different projects of the same vendor account.
    pub account_networks_enabled: bool,

    /// The type of network configuration on the instance.
    pub network_config: crate::model::instance_config::NetworkConfig,

    /// Server network template name. Filled if InstanceConfig.multivlan_config is
    /// true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_template: std::string::String,

    /// List of logical interfaces for the instance. The number of logical
    /// interfaces will be the same as number of hardware bond/nic on the chosen
    /// network template. Filled if InstanceConfig.multivlan_config is true.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub logical_interfaces: std::vec::Vec<crate::model::LogicalInterface>,

    /// List of names of ssh keys used to provision the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ssh_key_names: std::vec::Vec<std::string::String>,
}

impl InstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::InstanceConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::InstanceConfig::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [hyperthreading][crate::model::InstanceConfig::hyperthreading].
    pub fn set_hyperthreading<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hyperthreading = v.into();
        self
    }

    /// Sets the value of [os_image][crate::model::InstanceConfig::os_image].
    pub fn set_os_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_image = v.into();
        self
    }

    /// Sets the value of [client_network][crate::model::InstanceConfig::client_network].
    pub fn set_client_network<
        T: std::convert::Into<std::option::Option<crate::model::instance_config::NetworkAddress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_network = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::InstanceConfig::private_network].
    pub fn set_private_network<
        T: std::convert::Into<std::option::Option<crate::model::instance_config::NetworkAddress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [user_note][crate::model::InstanceConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [account_networks_enabled][crate::model::InstanceConfig::account_networks_enabled].
    pub fn set_account_networks_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.account_networks_enabled = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::InstanceConfig::network_config].
    pub fn set_network_config<
        T: std::convert::Into<crate::model::instance_config::NetworkConfig>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [network_template][crate::model::InstanceConfig::network_template].
    pub fn set_network_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_template = v.into();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::InstanceConfig::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ssh_key_names][crate::model::InstanceConfig::ssh_key_names].
    pub fn set_ssh_key_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_key_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceConfig"
    }
}

/// Defines additional types related to InstanceConfig
pub mod instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// A network.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkAddress {
        /// Id of the network to use, within the same ProvisioningConfig request.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network_id: std::string::String,

        /// IPv4 address to be assigned to the server.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub address: std::string::String,

        /// Name of the existing network to use.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub existing_network_id: std::string::String,
    }

    impl NetworkAddress {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_id][crate::model::instance_config::NetworkAddress::network_id].
        pub fn set_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network_id = v.into();
            self
        }

        /// Sets the value of [address][crate::model::instance_config::NetworkAddress::address].
        pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.address = v.into();
            self
        }

        /// Sets the value of [existing_network_id][crate::model::instance_config::NetworkAddress::existing_network_id].
        pub fn set_existing_network_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.existing_network_id = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkAddress {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceConfig.NetworkAddress"
        }
    }

    /// The network configuration of the instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct NetworkConfig(i32);

    impl NetworkConfig {
        /// The unspecified network configuration.
        pub const NETWORKCONFIG_UNSPECIFIED: NetworkConfig = NetworkConfig::new(0);

        /// Instance part of single client network and single private network.
        pub const SINGLE_VLAN: NetworkConfig = NetworkConfig::new(1);

        /// Instance part of multiple (or single) client networks and private
        /// networks.
        pub const MULTI_VLAN: NetworkConfig = NetworkConfig::new(2);

        /// Creates a new NetworkConfig instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("NETWORKCONFIG_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SINGLE_VLAN"),
                2 => std::borrow::Cow::Borrowed("MULTI_VLAN"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "NETWORKCONFIG_UNSPECIFIED" => {
                    std::option::Option::Some(Self::NETWORKCONFIG_UNSPECIFIED)
                }
                "SINGLE_VLAN" => std::option::Option::Some(Self::SINGLE_VLAN),
                "MULTI_VLAN" => std::option::Option::Some(Self::MULTI_VLAN),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for NetworkConfig {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for NetworkConfig {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration parameters for a new volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VolumeConfig {
    /// Output only. The name of the volume config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A transient unique identifier to identify a volume within an
    /// ProvisioningConfig request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Whether snapshots should be enabled.
    pub snapshots_enabled: bool,

    /// The type of this Volume.
    #[serde(rename = "type")]
    pub r#type: crate::model::volume_config::Type,

    /// Volume protocol.
    pub protocol: crate::model::volume_config::Protocol,

    /// The requested size of this volume, in GB.
    pub size_gb: i32,

    /// LUN ranges to be configured. Set only when protocol is PROTOCOL_FC.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub lun_ranges: std::vec::Vec<crate::model::volume_config::LunRange>,

    /// Machine ids connected to this volume. Set only when protocol is
    /// PROTOCOL_FC.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub machine_ids: std::vec::Vec<std::string::String>,

    /// NFS exports. Set only when protocol is PROTOCOL_NFS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nfs_exports: std::vec::Vec<crate::model::volume_config::NfsExport>,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_note: std::string::String,

    /// The GCP service of the storage volume. Available gcp_service are in
    /// <https://cloud.google.com/bare-metal/docs/bms-planning>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_service: std::string::String,

    /// Performance tier of the Volume.
    /// Default is SHARED.
    pub performance_tier: crate::model::VolumePerformanceTier,
}

impl VolumeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::VolumeConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [snapshots_enabled][crate::model::VolumeConfig::snapshots_enabled].
    pub fn set_snapshots_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshots_enabled = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VolumeConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::volume_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::VolumeConfig::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::volume_config::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::VolumeConfig::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [user_note][crate::model::VolumeConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::VolumeConfig::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [performance_tier][crate::model::VolumeConfig::performance_tier].
    pub fn set_performance_tier<T: std::convert::Into<crate::model::VolumePerformanceTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.performance_tier = v.into();
        self
    }

    /// Sets the value of [lun_ranges][crate::model::VolumeConfig::lun_ranges].
    pub fn set_lun_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::volume_config::LunRange>,
    {
        use std::iter::Iterator;
        self.lun_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [machine_ids][crate::model::VolumeConfig::machine_ids].
    pub fn set_machine_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.machine_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nfs_exports][crate::model::VolumeConfig::nfs_exports].
    pub fn set_nfs_exports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::volume_config::NfsExport>,
    {
        use std::iter::Iterator;
        self.nfs_exports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VolumeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig"
    }
}

/// Defines additional types related to VolumeConfig
pub mod volume_config {
    #[allow(unused_imports)]
    use super::*;

    /// A LUN(Logical Unit Number) range.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LunRange {
        /// Number of LUNs to create.
        pub quantity: i32,

        /// The requested size of each LUN, in GB.
        pub size_gb: i32,
    }

    impl LunRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quantity][crate::model::volume_config::LunRange::quantity].
        pub fn set_quantity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.quantity = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::volume_config::LunRange::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for LunRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig.LunRange"
        }
    }

    /// A NFS export entry.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NfsExport {
        /// Network to use to publish the export.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network_id: std::string::String,

        /// Export permissions.
        pub permissions: crate::model::volume_config::nfs_export::Permissions,

        /// Disable root squashing, which is a feature of NFS.
        /// Root squash is a special mapping of the remote superuser (root) identity
        /// when using identity authentication.
        pub no_root_squash: bool,

        /// Allow the setuid flag.
        pub allow_suid: bool,

        /// Allow dev flag in NfsShare AllowedClientsRequest.
        pub allow_dev: bool,

        /// A client object.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub client: std::option::Option<crate::model::volume_config::nfs_export::Client>,
    }

    impl NfsExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_id][crate::model::volume_config::NfsExport::network_id].
        pub fn set_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network_id = v.into();
            self
        }

        /// Sets the value of [permissions][crate::model::volume_config::NfsExport::permissions].
        pub fn set_permissions<
            T: std::convert::Into<crate::model::volume_config::nfs_export::Permissions>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.permissions = v.into();
            self
        }

        /// Sets the value of [no_root_squash][crate::model::volume_config::NfsExport::no_root_squash].
        pub fn set_no_root_squash<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_root_squash = v.into();
            self
        }

        /// Sets the value of [allow_suid][crate::model::volume_config::NfsExport::allow_suid].
        pub fn set_allow_suid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_suid = v.into();
            self
        }

        /// Sets the value of [allow_dev][crate::model::volume_config::NfsExport::allow_dev].
        pub fn set_allow_dev<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_dev = v.into();
            self
        }

        /// Sets the value of `client`.
        pub fn set_client<
            T: std::convert::Into<
                std::option::Option<crate::model::volume_config::nfs_export::Client>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.client = v.into();
            self
        }

        /// The value of [client][crate::model::volume_config::NfsExport::client]
        /// if it holds a `MachineId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_machine_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.client.as_ref().and_then(|v| match v {
                crate::model::volume_config::nfs_export::Client::MachineId(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [client][crate::model::volume_config::NfsExport::client]
        /// if it holds a `Cidr`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_cidr(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.client.as_ref().and_then(|v| match v {
                crate::model::volume_config::nfs_export::Client::Cidr(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client]
        /// to hold a `MachineId`.
        ///
        /// Note that all the setters affecting `client` are
        /// mutually exclusive.
        pub fn set_machine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client = std::option::Option::Some(
                crate::model::volume_config::nfs_export::Client::MachineId(v.into()),
            );
            self
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client]
        /// to hold a `Cidr`.
        ///
        /// Note that all the setters affecting `client` are
        /// mutually exclusive.
        pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client = std::option::Option::Some(
                crate::model::volume_config::nfs_export::Client::Cidr(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for NfsExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport"
        }
    }

    /// Defines additional types related to NfsExport
    pub mod nfs_export {
        #[allow(unused_imports)]
        use super::*;

        /// Permissions that can granted for an export.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct Permissions(i32);

        impl Permissions {
            /// Unspecified value.
            pub const PERMISSIONS_UNSPECIFIED: Permissions = Permissions::new(0);

            /// Read-only permission.
            pub const READ_ONLY: Permissions = Permissions::new(1);

            /// Read-write permission.
            pub const READ_WRITE: Permissions = Permissions::new(2);

            /// Creates a new Permissions instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("PERMISSIONS_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("READ_ONLY"),
                    2 => std::borrow::Cow::Borrowed("READ_WRITE"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "PERMISSIONS_UNSPECIFIED" => {
                        std::option::Option::Some(Self::PERMISSIONS_UNSPECIFIED)
                    }
                    "READ_ONLY" => std::option::Option::Some(Self::READ_ONLY),
                    "READ_WRITE" => std::option::Option::Some(Self::READ_WRITE),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for Permissions {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for Permissions {
            fn default() -> Self {
                Self::new(0)
            }
        }

        /// A client object.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Client {
            /// Either a single machine, identified by an ID, or a comma-separated
            /// list of machine IDs.
            MachineId(std::string::String),
            /// A CIDR range.
            Cidr(std::string::String),
        }
    }

    /// The types of Volumes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// The unspecified type.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// This Volume is on flash.
        pub const FLASH: Type = Type::new(1);

        /// This Volume is on disk.
        pub const DISK: Type = Type::new(2);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FLASH"),
                2 => std::borrow::Cow::Borrowed("DISK"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "FLASH" => std::option::Option::Some(Self::FLASH),
                "DISK" => std::option::Option::Some(Self::DISK),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The protocol used to access the volume.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Protocol(i32);

    impl Protocol {
        /// Unspecified value.
        pub const PROTOCOL_UNSPECIFIED: Protocol = Protocol::new(0);

        /// Fibre channel.
        pub const PROTOCOL_FC: Protocol = Protocol::new(1);

        /// Network file system.
        pub const PROTOCOL_NFS: Protocol = Protocol::new(2);

        /// Creates a new Protocol instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PROTOCOL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PROTOCOL_FC"),
                2 => std::borrow::Cow::Borrowed("PROTOCOL_NFS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PROTOCOL_UNSPECIFIED" => std::option::Option::Some(Self::PROTOCOL_UNSPECIFIED),
                "PROTOCOL_FC" => std::option::Option::Some(Self::PROTOCOL_FC),
                "PROTOCOL_NFS" => std::option::Option::Some(Self::PROTOCOL_NFS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration parameters for a new network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Output only. The name of the network config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A transient unique identifier to identify a volume within an
    /// ProvisioningConfig request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of this network, either Client or Private.
    #[serde(rename = "type")]
    pub r#type: crate::model::network_config::Type,

    /// Interconnect bandwidth. Set only when type is CLIENT.
    pub bandwidth: crate::model::network_config::Bandwidth,

    /// List of VLAN attachments. As of now there are always 2 attachments, but it
    /// is going to change in  the future (multi vlan).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vlan_attachments: std::vec::Vec<crate::model::network_config::IntakeVlanAttachment>,

    /// CIDR range of the network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cidr: std::string::String,

    /// Service CIDR, if any.
    pub service_cidr: crate::model::network_config::ServiceCidr,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_note: std::string::String,

    /// The GCP service of the network. Available gcp_service are in
    /// <https://cloud.google.com/bare-metal/docs/bms-planning>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_service: std::string::String,

    /// Whether the VLAN attachment pair is located in the same project.
    pub vlan_same_project: bool,

    /// The JumboFramesEnabled option for customer to set.
    pub jumbo_frames_enabled: bool,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NetworkConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::NetworkConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::NetworkConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::network_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [bandwidth][crate::model::NetworkConfig::bandwidth].
    pub fn set_bandwidth<T: std::convert::Into<crate::model::network_config::Bandwidth>>(
        mut self,
        v: T,
    ) -> Self {
        self.bandwidth = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::NetworkConfig::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [service_cidr][crate::model::NetworkConfig::service_cidr].
    pub fn set_service_cidr<T: std::convert::Into<crate::model::network_config::ServiceCidr>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_cidr = v.into();
        self
    }

    /// Sets the value of [user_note][crate::model::NetworkConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::NetworkConfig::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [vlan_same_project][crate::model::NetworkConfig::vlan_same_project].
    pub fn set_vlan_same_project<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vlan_same_project = v.into();
        self
    }

    /// Sets the value of [jumbo_frames_enabled][crate::model::NetworkConfig::jumbo_frames_enabled].
    pub fn set_jumbo_frames_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.jumbo_frames_enabled = v.into();
        self
    }

    /// Sets the value of [vlan_attachments][crate::model::NetworkConfig::vlan_attachments].
    pub fn set_vlan_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::network_config::IntakeVlanAttachment>,
    {
        use std::iter::Iterator;
        self.vlan_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkConfig"
    }
}

/// Defines additional types related to NetworkConfig
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// A GCP vlan attachment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IntakeVlanAttachment {
        /// Identifier of the VLAN attachment.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Attachment pairing key.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pairing_key: std::string::String,
    }

    impl IntakeVlanAttachment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::network_config::IntakeVlanAttachment::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [pairing_key][crate::model::network_config::IntakeVlanAttachment::pairing_key].
        pub fn set_pairing_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pairing_key = v.into();
            self
        }
    }

    impl wkt::message::Message for IntakeVlanAttachment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkConfig.IntakeVlanAttachment"
        }
    }

    /// Network type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Unspecified value.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// Client network, that is a network peered to a GCP VPC.
        pub const CLIENT: Type = Type::new(1);

        /// Private network, that is a network local to the BMS POD.
        pub const PRIVATE: Type = Type::new(2);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CLIENT"),
                2 => std::borrow::Cow::Borrowed("PRIVATE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "CLIENT" => std::option::Option::Some(Self::CLIENT),
                "PRIVATE" => std::option::Option::Some(Self::PRIVATE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Interconnect bandwidth.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Bandwidth(i32);

    impl Bandwidth {
        /// Unspecified value.
        pub const BANDWIDTH_UNSPECIFIED: Bandwidth = Bandwidth::new(0);

        /// 1 Gbps.
        pub const BW_1_GBPS: Bandwidth = Bandwidth::new(1);

        /// 2 Gbps.
        pub const BW_2_GBPS: Bandwidth = Bandwidth::new(2);

        /// 5 Gbps.
        pub const BW_5_GBPS: Bandwidth = Bandwidth::new(3);

        /// 10 Gbps.
        pub const BW_10_GBPS: Bandwidth = Bandwidth::new(4);

        /// Creates a new Bandwidth instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BANDWIDTH_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BW_1_GBPS"),
                2 => std::borrow::Cow::Borrowed("BW_2_GBPS"),
                3 => std::borrow::Cow::Borrowed("BW_5_GBPS"),
                4 => std::borrow::Cow::Borrowed("BW_10_GBPS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BANDWIDTH_UNSPECIFIED" => std::option::Option::Some(Self::BANDWIDTH_UNSPECIFIED),
                "BW_1_GBPS" => std::option::Option::Some(Self::BW_1_GBPS),
                "BW_2_GBPS" => std::option::Option::Some(Self::BW_2_GBPS),
                "BW_5_GBPS" => std::option::Option::Some(Self::BW_5_GBPS),
                "BW_10_GBPS" => std::option::Option::Some(Self::BW_10_GBPS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Bandwidth {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Bandwidth {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Service network block.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ServiceCidr(i32);

    impl ServiceCidr {
        /// Unspecified value.
        pub const SERVICE_CIDR_UNSPECIFIED: ServiceCidr = ServiceCidr::new(0);

        /// Services are disabled for the given network.
        pub const DISABLED: ServiceCidr = ServiceCidr::new(1);

        /// Use the highest /26 block of the network to host services.
        pub const HIGH_26: ServiceCidr = ServiceCidr::new(2);

        /// Use the highest /27 block of the network to host services.
        pub const HIGH_27: ServiceCidr = ServiceCidr::new(3);

        /// Use the highest /28 block of the network to host services.
        pub const HIGH_28: ServiceCidr = ServiceCidr::new(4);

        /// Creates a new ServiceCidr instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SERVICE_CIDR_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("HIGH_26"),
                3 => std::borrow::Cow::Borrowed("HIGH_27"),
                4 => std::borrow::Cow::Borrowed("HIGH_28"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SERVICE_CIDR_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SERVICE_CIDR_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "HIGH_26" => std::option::Option::Some(Self::HIGH_26),
                "HIGH_27" => std::option::Option::Some(Self::HIGH_27),
                "HIGH_28" => std::option::Option::Some(Self::HIGH_28),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ServiceCidr {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ServiceCidr {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A resource budget.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceQuota {
    /// Output only. The name of the instance quota.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Instance type.
    /// Deprecated: use gcp_service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_type: std::string::String,

    /// The gcp service of the provisioning quota.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_service: std::string::String,

    /// Location where the quota applies.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Number of machines than can be created for the given location and
    /// instance_type.
    pub available_machine_count: i32,
}

impl InstanceQuota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceQuota::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::InstanceQuota::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::InstanceQuota::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::InstanceQuota::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [available_machine_count][crate::model::InstanceQuota::available_machine_count].
    pub fn set_available_machine_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_machine_count = v.into();
        self
    }
}

impl wkt::message::Message for InstanceQuota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceQuota"
    }
}

/// Request for GetProvisioningConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProvisioningConfigRequest {
    /// Required. Name of the ProvisioningConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProvisioningConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetProvisioningConfigRequest"
    }
}

/// Request for CreateProvisioningConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateProvisioningConfigRequest {
    /// Required. The parent project and location containing the
    /// ProvisioningConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ProvisioningConfig to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,
}

impl CreateProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProvisioningConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [provisioning_config][crate::model::CreateProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<
        T: std::convert::Into<std::option::Option<crate::model::ProvisioningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_config = v.into();
        self
    }

    /// Sets the value of [email][crate::model::CreateProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CreateProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateProvisioningConfigRequest"
    }
}

/// Message for updating a ProvisioningConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateProvisioningConfigRequest {
    /// Required. The ProvisioningConfig to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Required. The list of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,
}

impl UpdateProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_config][crate::model::UpdateProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<
        T: std::convert::Into<std::option::Option<crate::model::ProvisioningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProvisioningConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [email][crate::model::UpdateProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateProvisioningConfigRequest"
    }
}

/// An SSH key, used for authorizing with the interactive serial console feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SSHKey {
    /// Output only. The name of this SSH key.
    /// Currently, the only valid value for the location is "global".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The public SSH key. This must be in OpenSSH .authorized_keys format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,
}

impl SSHKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SSHKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::SSHKey::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }
}

impl wkt::message::Message for SSHKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SSHKey"
    }
}

/// Message for listing the public SSH keys in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSSHKeysRequest {
    /// Required. The parent containing the SSH keys.
    /// Currently, the only valid value for the location is "global".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListSSHKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSSHKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSSHKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSSHKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSSHKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListSSHKeysRequest"
    }
}

/// Message for response of ListSSHKeys.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSSHKeysResponse {
    /// The SSH keys registered in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ssh_keys: std::vec::Vec<crate::model::SSHKey>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSSHKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSSHKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [ssh_keys][crate::model::ListSSHKeysResponse::ssh_keys].
    pub fn set_ssh_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SSHKey>,
    {
        use std::iter::Iterator;
        self.ssh_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSSHKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListSSHKeysResponse"
    }
}

impl gax::paginator::PageableResponse for ListSSHKeysResponse {
    type PageItem = crate::model::SSHKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ssh_keys
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for registering a public SSH key in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSSHKeyRequest {
    /// Required. The parent containing the SSH keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The SSH key to register.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssh_key: std::option::Option<crate::model::SSHKey>,

    /// Required. The ID to use for the key, which will become the final component
    /// of the key's resource name.
    ///
    /// This value must match the regex:
    /// [a-zA-Z0-9@.\-_]{1,64}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssh_key_id: std::string::String,
}

impl CreateSSHKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSSHKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [ssh_key][crate::model::CreateSSHKeyRequest::ssh_key].
    pub fn set_ssh_key<T: std::convert::Into<std::option::Option<crate::model::SSHKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssh_key = v.into();
        self
    }

    /// Sets the value of [ssh_key_id][crate::model::CreateSSHKeyRequest::ssh_key_id].
    pub fn set_ssh_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssh_key_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSSHKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateSSHKeyRequest"
    }
}

/// Message for deleting an SSH key from a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSSHKeyRequest {
    /// Required. The name of the SSH key to delete.
    /// Currently, the only valid value for the location is "global".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteSSHKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSSHKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSSHKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteSSHKeyRequest"
    }
}

/// A storage volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Output only. The resource name of this `Volume`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/volumes/{volume}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An identifier for the `Volume`, generated by the backend.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The storage type for this volume.
    pub storage_type: crate::model::volume::StorageType,

    /// The state of this storage volume.
    pub state: crate::model::volume::State,

    /// The requested size of this storage volume, in GiB.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub requested_size_gib: i64,

    /// Originally requested size, in GiB.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub originally_requested_size_gib: i64,

    /// The current size of this storage volume, in GiB, including space reserved
    /// for snapshots. This size might be different than the requested size if the
    /// storage volume has been configured with auto grow or auto shrink.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub current_size_gib: i64,

    /// Additional emergency size that was requested for this Volume, in GiB.
    /// current_size_gib includes this value.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub emergency_size_gib: i64,

    /// Maximum size volume can be expanded to in case of evergency, in GiB.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_size_gib: i64,

    /// The size, in GiB, that this storage volume has expanded as a result of an
    /// auto grow policy. In the absence of auto-grow, the value is 0.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub auto_grown_size_gib: i64,

    /// The space remaining in the storage volume for new LUNs, in GiB, excluding
    /// space reserved for snapshots.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub remaining_space_gib: i64,

    /// Details about snapshot space reservation and usage on the storage volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_reservation_detail:
        std::option::Option<crate::model::volume::SnapshotReservationDetail>,

    /// The behavior to use when snapshot reserved space is full.
    pub snapshot_auto_delete_behavior: crate::model::volume::SnapshotAutoDeleteBehavior,

    /// Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Whether snapshots are enabled.
    pub snapshot_enabled: bool,

    /// Immutable. Pod name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod: std::string::String,

    /// Output only. Storage protocol for the Volume.
    pub protocol: crate::model::volume::Protocol,

    /// Output only. Whether this volume is a boot volume. A boot volume is one
    /// which contains a boot LUN.
    pub boot_volume: bool,

    /// Immutable. Performance tier of the Volume.
    /// Default is SHARED.
    pub performance_tier: crate::model::VolumePerformanceTier,

    /// Input only. User-specified notes for new Volume.
    /// Used to provision Volumes that require manual intervention.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notes: std::string::String,

    /// The workload profile for the volume.
    pub workload_profile: crate::model::volume::WorkloadProfile,

    /// Output only. Time after which volume will be fully deleted.
    /// It is filled only for volumes in COOLOFF state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instances this Volume is attached to.
    /// This field is set only in Get requests.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<std::string::String>,

    /// Output only. Is the Volume attached at at least one instance.
    /// This field is a lightweight counterpart of `instances` field.
    /// It is filled in List responses as well.
    pub attached: bool,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Volume::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::Volume::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::volume::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Volume::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [requested_size_gib][crate::model::Volume::requested_size_gib].
    pub fn set_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.requested_size_gib = v.into();
        self
    }

    /// Sets the value of [originally_requested_size_gib][crate::model::Volume::originally_requested_size_gib].
    pub fn set_originally_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.originally_requested_size_gib = v.into();
        self
    }

    /// Sets the value of [current_size_gib][crate::model::Volume::current_size_gib].
    pub fn set_current_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.current_size_gib = v.into();
        self
    }

    /// Sets the value of [emergency_size_gib][crate::model::Volume::emergency_size_gib].
    pub fn set_emergency_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.emergency_size_gib = v.into();
        self
    }

    /// Sets the value of [max_size_gib][crate::model::Volume::max_size_gib].
    pub fn set_max_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_size_gib = v.into();
        self
    }

    /// Sets the value of [auto_grown_size_gib][crate::model::Volume::auto_grown_size_gib].
    pub fn set_auto_grown_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.auto_grown_size_gib = v.into();
        self
    }

    /// Sets the value of [remaining_space_gib][crate::model::Volume::remaining_space_gib].
    pub fn set_remaining_space_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.remaining_space_gib = v.into();
        self
    }

    /// Sets the value of [snapshot_reservation_detail][crate::model::Volume::snapshot_reservation_detail].
    pub fn set_snapshot_reservation_detail<
        T: std::convert::Into<std::option::Option<crate::model::volume::SnapshotReservationDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_reservation_detail = v.into();
        self
    }

    /// Sets the value of [snapshot_auto_delete_behavior][crate::model::Volume::snapshot_auto_delete_behavior].
    pub fn set_snapshot_auto_delete_behavior<
        T: std::convert::Into<crate::model::volume::SnapshotAutoDeleteBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_auto_delete_behavior = v.into();
        self
    }

    /// Sets the value of [snapshot_enabled][crate::model::Volume::snapshot_enabled].
    pub fn set_snapshot_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshot_enabled = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Volume::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::Volume::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::volume::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [boot_volume][crate::model::Volume::boot_volume].
    pub fn set_boot_volume<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.boot_volume = v.into();
        self
    }

    /// Sets the value of [performance_tier][crate::model::Volume::performance_tier].
    pub fn set_performance_tier<T: std::convert::Into<crate::model::VolumePerformanceTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.performance_tier = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::Volume::notes].
    pub fn set_notes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.notes = v.into();
        self
    }

    /// Sets the value of [workload_profile][crate::model::Volume::workload_profile].
    pub fn set_workload_profile<T: std::convert::Into<crate::model::volume::WorkloadProfile>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_profile = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Volume::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [attached][crate::model::Volume::attached].
    pub fn set_attached<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.attached = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::Volume::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Volume::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Volume"
    }
}

/// Defines additional types related to Volume
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    /// Details about snapshot space reservation and usage on the storage volume.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SnapshotReservationDetail {
        /// The space on this storage volume reserved for snapshots, shown in GiB.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub reserved_space_gib: i64,

        /// The percent of snapshot space on this storage volume actually being used
        /// by the snapshot copies. This value might be higher than 100% if the
        /// snapshot copies have overflowed into the data portion of the storage
        /// volume.
        pub reserved_space_used_percent: i32,

        /// The amount, in GiB, of available space in this storage volume's reserved
        /// snapshot space.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub reserved_space_remaining_gib: i64,

        /// Percent of the total Volume size reserved for snapshot copies.
        /// Enabling snapshots requires reserving 20% or more of
        /// the storage volume space for snapshots. Maximum reserved space for
        /// snapshots is 40%.
        /// Setting this field will effectively set snapshot_enabled to true.
        pub reserved_space_percent: i32,
    }

    impl SnapshotReservationDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reserved_space_gib][crate::model::volume::SnapshotReservationDetail::reserved_space_gib].
        pub fn set_reserved_space_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.reserved_space_gib = v.into();
            self
        }

        /// Sets the value of [reserved_space_used_percent][crate::model::volume::SnapshotReservationDetail::reserved_space_used_percent].
        pub fn set_reserved_space_used_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.reserved_space_used_percent = v.into();
            self
        }

        /// Sets the value of [reserved_space_remaining_gib][crate::model::volume::SnapshotReservationDetail::reserved_space_remaining_gib].
        pub fn set_reserved_space_remaining_gib<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.reserved_space_remaining_gib = v.into();
            self
        }

        /// Sets the value of [reserved_space_percent][crate::model::volume::SnapshotReservationDetail::reserved_space_percent].
        pub fn set_reserved_space_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.reserved_space_percent = v.into();
            self
        }
    }

    impl wkt::message::Message for SnapshotReservationDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.Volume.SnapshotReservationDetail"
        }
    }

    /// The storage type for a volume.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct StorageType(i32);

    impl StorageType {
        /// The storage type for this volume is unknown.
        pub const STORAGE_TYPE_UNSPECIFIED: StorageType = StorageType::new(0);

        /// The storage type for this volume is SSD.
        pub const SSD: StorageType = StorageType::new(1);

        /// This storage type for this volume is HDD.
        pub const HDD: StorageType = StorageType::new(2);

        /// Creates a new StorageType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STORAGE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SSD"),
                2 => std::borrow::Cow::Borrowed("HDD"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STORAGE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::STORAGE_TYPE_UNSPECIFIED)
                }
                "SSD" => std::option::Option::Some(Self::SSD),
                "HDD" => std::option::Option::Some(Self::HDD),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The possible states for a storage volume.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The storage volume is in an unknown state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The storage volume is being created.
        pub const CREATING: State = State::new(1);

        /// The storage volume is ready for use.
        pub const READY: State = State::new(2);

        /// The storage volume has been requested to be deleted.
        pub const DELETING: State = State::new(3);

        /// The storage volume is being updated.
        pub const UPDATING: State = State::new(4);

        /// The storage volume is in cool off state. It will be deleted after
        /// `expire_time`.
        pub const COOL_OFF: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("DELETING"),
                4 => std::borrow::Cow::Borrowed("UPDATING"),
                5 => std::borrow::Cow::Borrowed("COOL_OFF"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "COOL_OFF" => std::option::Option::Some(Self::COOL_OFF),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The kinds of auto delete behavior to use when snapshot reserved space is
    /// full.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SnapshotAutoDeleteBehavior(i32);

    impl SnapshotAutoDeleteBehavior {
        /// The unspecified behavior.
        pub const SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED: SnapshotAutoDeleteBehavior =
            SnapshotAutoDeleteBehavior::new(0);

        /// Don't delete any snapshots. This disables new snapshot creation, as
        /// long as the snapshot reserved space is full.
        pub const DISABLED: SnapshotAutoDeleteBehavior = SnapshotAutoDeleteBehavior::new(1);

        /// Delete the oldest snapshots first.
        pub const OLDEST_FIRST: SnapshotAutoDeleteBehavior = SnapshotAutoDeleteBehavior::new(2);

        /// Delete the newest snapshots first.
        pub const NEWEST_FIRST: SnapshotAutoDeleteBehavior = SnapshotAutoDeleteBehavior::new(3);

        /// Creates a new SnapshotAutoDeleteBehavior instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("OLDEST_FIRST"),
                3 => std::borrow::Cow::Borrowed("NEWEST_FIRST"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "OLDEST_FIRST" => std::option::Option::Some(Self::OLDEST_FIRST),
                "NEWEST_FIRST" => std::option::Option::Some(Self::NEWEST_FIRST),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SnapshotAutoDeleteBehavior {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SnapshotAutoDeleteBehavior {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Storage protocol.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Protocol(i32);

    impl Protocol {
        /// Value is not specified.
        pub const PROTOCOL_UNSPECIFIED: Protocol = Protocol::new(0);

        /// Fibre Channel protocol.
        pub const FIBRE_CHANNEL: Protocol = Protocol::new(1);

        /// NFS protocol means Volume is a NFS Share volume.
        /// Such volumes cannot be manipulated via Volumes API.
        pub const NFS: Protocol = Protocol::new(2);

        /// Creates a new Protocol instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PROTOCOL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FIBRE_CHANNEL"),
                2 => std::borrow::Cow::Borrowed("NFS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PROTOCOL_UNSPECIFIED" => std::option::Option::Some(Self::PROTOCOL_UNSPECIFIED),
                "FIBRE_CHANNEL" => std::option::Option::Some(Self::FIBRE_CHANNEL),
                "NFS" => std::option::Option::Some(Self::NFS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The possible values for a workload profile.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct WorkloadProfile(i32);

    impl WorkloadProfile {
        /// The workload profile is in an unknown state.
        pub const WORKLOAD_PROFILE_UNSPECIFIED: WorkloadProfile = WorkloadProfile::new(0);

        /// The workload profile is generic.
        pub const GENERIC: WorkloadProfile = WorkloadProfile::new(1);

        /// The workload profile is hana.
        pub const HANA: WorkloadProfile = WorkloadProfile::new(2);

        /// Creates a new WorkloadProfile instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("WORKLOAD_PROFILE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GENERIC"),
                2 => std::borrow::Cow::Borrowed("HANA"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "WORKLOAD_PROFILE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::WORKLOAD_PROFILE_UNSPECIFIED)
                }
                "GENERIC" => std::option::Option::Some(Self::GENERIC),
                "HANA" => std::option::Option::Some(Self::HANA),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for WorkloadProfile {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for WorkloadProfile {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting storage volume information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVolumeRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetVolumeRequest"
    }
}

/// Message for requesting a list of storage volumes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVolumesRequest {
    /// Required. Parent value for ListVolumesRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumesRequest"
    }
}

/// Response message containing the list of storage volumes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVolumesResponse {
    /// The list of storage volumes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListVolumesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [volumes][crate::model::ListVolumesResponse::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumesResponse"
    }
}

impl gax::paginator::PageableResponse for ListVolumesResponse {
    type PageItem = crate::model::Volume;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volumes
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for updating a volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVolumeRequest {
    /// Required. The volume to update.
    ///
    /// The `name` field is used to identify the volume to update.
    /// Format: projects/{project}/locations/{location}/volumes/{volume}
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub volume: std::option::Option<crate::model::Volume>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// 'labels'
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_volume<T: std::convert::Into<std::option::Option<crate::model::Volume>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateVolumeRequest"
    }
}

/// Message requesting rename of a server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenameVolumeRequest {
    /// Required. The `name` field is used to identify the volume.
    /// Format: projects/{project}/locations/{location}/volumes/{volume}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The new `id` of the volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_volume_id: std::string::String,
}

impl RenameVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_volume_id][crate::model::RenameVolumeRequest::new_volume_id].
    pub fn set_new_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_volume_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameVolumeRequest"
    }
}

/// Request for skip volume cooloff and delete it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EvictVolumeRequest {
    /// Required. The name of the Volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl EvictVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EvictVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EvictVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EvictVolumeRequest"
    }
}

/// Request for emergency resize Volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResizeVolumeRequest {
    /// Required. Volume to resize.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume: std::string::String,

    /// New Volume size, in GiB.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_gib: i64,
}

impl ResizeVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume][crate::model::ResizeVolumeRequest::volume].
    pub fn set_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [size_gib][crate::model::ResizeVolumeRequest::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }
}

impl wkt::message::Message for ResizeVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResizeVolumeRequest"
    }
}

/// A snapshot of a volume. Only boot volumes can have snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VolumeSnapshot {
    /// The name of the snapshot.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. An identifier for the snapshot, generated by the backend.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The description of the snapshot.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation time of the snapshot.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the volume which this snapshot belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_volume: std::string::String,

    /// Output only. The type of the snapshot which indicates whether it was
    /// scheduled or manual/ad-hoc.
    #[serde(rename = "type")]
    pub r#type: crate::model::volume_snapshot::SnapshotType,
}

impl VolumeSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeSnapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::VolumeSnapshot::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VolumeSnapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VolumeSnapshot::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [storage_volume][crate::model::VolumeSnapshot::storage_volume].
    pub fn set_storage_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_volume = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VolumeSnapshot::type].
    pub fn set_type<T: std::convert::Into<crate::model::volume_snapshot::SnapshotType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for VolumeSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeSnapshot"
    }
}

/// Defines additional types related to VolumeSnapshot
pub mod volume_snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the type of a snapshot.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SnapshotType(i32);

    impl SnapshotType {
        /// Type is not specified.
        pub const SNAPSHOT_TYPE_UNSPECIFIED: SnapshotType = SnapshotType::new(0);

        /// Snapshot was taken manually by user.
        pub const AD_HOC: SnapshotType = SnapshotType::new(1);

        /// Snapshot was taken automatically as a part of a snapshot schedule.
        pub const SCHEDULED: SnapshotType = SnapshotType::new(2);

        /// Creates a new SnapshotType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SNAPSHOT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AD_HOC"),
                2 => std::borrow::Cow::Borrowed("SCHEDULED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SNAPSHOT_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SNAPSHOT_TYPE_UNSPECIFIED)
                }
                "AD_HOC" => std::option::Option::Some(Self::AD_HOC),
                "SCHEDULED" => std::option::Option::Some(Self::SCHEDULED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SnapshotType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SnapshotType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting volume snapshot information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVolumeSnapshotRequest {
    /// Required. The name of the snapshot.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetVolumeSnapshotRequest"
    }
}

/// Message for requesting a list of volume snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVolumeSnapshotsRequest {
    /// Required. Parent value for ListVolumesRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListVolumeSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumeSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumeSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumeSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumeSnapshotsRequest"
    }
}

/// Response message containing the list of volume snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVolumeSnapshotsResponse {
    /// The list of snapshots.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volume_snapshots: std::vec::Vec<crate::model::VolumeSnapshot>,

    /// A token identifying a page of results from the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListVolumeSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumeSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [volume_snapshots][crate::model::ListVolumeSnapshotsResponse::volume_snapshots].
    pub fn set_volume_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        use std::iter::Iterator;
        self.volume_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumeSnapshotsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumeSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumeSnapshotsResponse"
    }
}

impl gax::paginator::PageableResponse for ListVolumeSnapshotsResponse {
    type PageItem = crate::model::VolumeSnapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volume_snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for deleting named Volume snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVolumeSnapshotRequest {
    /// Required. The name of the snapshot to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVolumeSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteVolumeSnapshotRequest"
    }
}

/// Message for creating a volume snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVolumeSnapshotRequest {
    /// Required. The volume to snapshot.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The snapshot to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub volume_snapshot: std::option::Option<crate::model::VolumeSnapshot>,
}

impl CreateVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVolumeSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [volume_snapshot][crate::model::CreateVolumeSnapshotRequest::volume_snapshot].
    pub fn set_volume_snapshot<
        T: std::convert::Into<std::option::Option<crate::model::VolumeSnapshot>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_snapshot = v.into();
        self
    }
}

impl wkt::message::Message for CreateVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateVolumeSnapshotRequest"
    }
}

/// Message for restoring a volume snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreVolumeSnapshotRequest {
    /// Required. Name of the snapshot which will be used to restore its parent
    /// volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume_snapshot: std::string::String,
}

impl RestoreVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_snapshot][crate::model::RestoreVolumeSnapshotRequest::volume_snapshot].
    pub fn set_volume_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_snapshot = v.into();
        self
    }
}

impl wkt::message::Message for RestoreVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RestoreVolumeSnapshotRequest"
    }
}

/// Performance tier of the Volume.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct VolumePerformanceTier(i32);

impl VolumePerformanceTier {
    /// Value is not specified.
    pub const VOLUME_PERFORMANCE_TIER_UNSPECIFIED: VolumePerformanceTier =
        VolumePerformanceTier::new(0);

    /// Regular volumes, shared aggregates.
    pub const VOLUME_PERFORMANCE_TIER_SHARED: VolumePerformanceTier = VolumePerformanceTier::new(1);

    /// Assigned aggregates.
    pub const VOLUME_PERFORMANCE_TIER_ASSIGNED: VolumePerformanceTier =
        VolumePerformanceTier::new(2);

    /// High throughput aggregates.
    pub const VOLUME_PERFORMANCE_TIER_HT: VolumePerformanceTier = VolumePerformanceTier::new(3);

    /// Creates a new VolumePerformanceTier instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("VOLUME_PERFORMANCE_TIER_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("VOLUME_PERFORMANCE_TIER_SHARED"),
            2 => std::borrow::Cow::Borrowed("VOLUME_PERFORMANCE_TIER_ASSIGNED"),
            3 => std::borrow::Cow::Borrowed("VOLUME_PERFORMANCE_TIER_HT"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "VOLUME_PERFORMANCE_TIER_UNSPECIFIED" => {
                std::option::Option::Some(Self::VOLUME_PERFORMANCE_TIER_UNSPECIFIED)
            }
            "VOLUME_PERFORMANCE_TIER_SHARED" => {
                std::option::Option::Some(Self::VOLUME_PERFORMANCE_TIER_SHARED)
            }
            "VOLUME_PERFORMANCE_TIER_ASSIGNED" => {
                std::option::Option::Some(Self::VOLUME_PERFORMANCE_TIER_ASSIGNED)
            }
            "VOLUME_PERFORMANCE_TIER_HT" => {
                std::option::Option::Some(Self::VOLUME_PERFORMANCE_TIER_HT)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for VolumePerformanceTier {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for VolumePerformanceTier {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The possible values for a workload profile.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct WorkloadProfile(i32);

impl WorkloadProfile {
    /// The workload profile is in an unknown state.
    pub const WORKLOAD_PROFILE_UNSPECIFIED: WorkloadProfile = WorkloadProfile::new(0);

    /// The workload profile is generic.
    pub const WORKLOAD_PROFILE_GENERIC: WorkloadProfile = WorkloadProfile::new(1);

    /// The workload profile is hana.
    pub const WORKLOAD_PROFILE_HANA: WorkloadProfile = WorkloadProfile::new(2);

    /// Creates a new WorkloadProfile instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("WORKLOAD_PROFILE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("WORKLOAD_PROFILE_GENERIC"),
            2 => std::borrow::Cow::Borrowed("WORKLOAD_PROFILE_HANA"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "WORKLOAD_PROFILE_UNSPECIFIED" => {
                std::option::Option::Some(Self::WORKLOAD_PROFILE_UNSPECIFIED)
            }
            "WORKLOAD_PROFILE_GENERIC" => std::option::Option::Some(Self::WORKLOAD_PROFILE_GENERIC),
            "WORKLOAD_PROFILE_HANA" => std::option::Option::Some(Self::WORKLOAD_PROFILE_HANA),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for WorkloadProfile {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for WorkloadProfile {
    fn default() -> Self {
        Self::new(0)
    }
}
