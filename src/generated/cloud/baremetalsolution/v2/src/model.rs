// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the metadata from a long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the action executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user requested the cancellation
    /// of the operation. Operations that have been successfully cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used with the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message from resetting a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetInstanceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResetInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResetInstanceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetInstanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetInstanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetInstanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetInstanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetInstanceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Immutable. The resource name of this `Instance`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}`
    pub name: std::string::String,

    /// Output only. An identifier for the `Instance`, generated by the backend.
    pub id: std::string::String,

    /// Output only. Create a time stamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update a time stamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Immutable. The server type.
    /// [Available server
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub machine_type: std::string::String,

    /// Output only. The state of the server.
    pub state: crate::model::instance::State,

    /// True if you enable hyperthreading for the server, otherwise false.
    /// The default value is false.
    pub hyperthreading_enabled: bool,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. List of LUNs associated with this server.
    pub luns: std::vec::Vec<crate::model::Lun>,

    /// Input only. List of Volumes to attach to this Instance on creation.
    /// This field won't be populated in Get/List responses.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Output only. List of networks associated with this server.
    pub networks: std::vec::Vec<crate::model::Network>,

    /// Output only. True if the interactive serial console feature is enabled for
    /// the instance, false otherwise. The default value is false.
    pub interactive_serial_console_enabled: bool,

    /// The OS image currently installed on the server.
    pub os_image: std::string::String,

    /// Immutable. Pod name.
    /// Pod is an independent part of infrastructure.
    /// Instance can be connected to the assets (networks, volumes) allocated
    /// in the same pod only.
    pub pod: std::string::String,

    /// Instance network template name. For eg, bondaa-bondaa, bondab-nic, etc.
    /// Generally, the template name follows the syntax of
    /// "bond<bond_mode>" or "nic".
    pub network_template: std::string::String,

    /// List of logical interfaces for the instance. The number of logical
    /// interfaces will be the same as number of hardware bond/nic on the chosen
    /// network template. For the non-multivlan configurations (for eg, existing
    /// servers) that use existing default network template (bondaa-bondaa), both
    /// the Instance.networks field and the Instance.logical_interfaces fields will
    /// be filled to ensure backward compatibility. For the others, only
    /// Instance.logical_interfaces will be filled.
    pub logical_interfaces: std::vec::Vec<crate::model::LogicalInterface>,

    /// Output only. Text field about info for logging in.
    pub login_info: std::string::String,

    /// The workload profile for the instance.
    pub workload_profile: crate::model::WorkloadProfile,

    /// Output only. The firmware version for the instance.
    pub firmware_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [hyperthreading_enabled][crate::model::Instance::hyperthreading_enabled].
    pub fn set_hyperthreading_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hyperthreading_enabled = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [luns][crate::model::Instance::luns].
    pub fn set_luns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lun>,
    {
        use std::iter::Iterator;
        self.luns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Instance::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Instance::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [interactive_serial_console_enabled][crate::model::Instance::interactive_serial_console_enabled].
    pub fn set_interactive_serial_console_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.interactive_serial_console_enabled = v.into();
        self
    }

    /// Sets the value of [os_image][crate::model::Instance::os_image].
    pub fn set_os_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_image = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Instance::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [network_template][crate::model::Instance::network_template].
    pub fn set_network_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_template = v.into();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::Instance::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [login_info][crate::model::Instance::login_info].
    pub fn set_login_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.login_info = v.into();
        self
    }

    /// Sets the value of [workload_profile][crate::model::Instance::workload_profile].
    pub fn set_workload_profile<T: std::convert::Into<crate::model::WorkloadProfile>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_profile = v.into();
        self
    }

    /// Sets the value of [firmware_version][crate::model::Instance::firmware_version].
    pub fn set_firmware_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware_version = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __create_time,
            __update_time,
            __machine_type,
            __state,
            __hyperthreading_enabled,
            __labels,
            __luns,
            __volumes,
            __networks,
            __interactive_serial_console_enabled,
            __os_image,
            __pod,
            __network_template,
            __logical_interfaces,
            __login_info,
            __workload_profile,
            __firmware_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "state" => Ok(__FieldTag::__state),
                            "hyperthreadingEnabled" => Ok(__FieldTag::__hyperthreading_enabled),
                            "hyperthreading_enabled" => Ok(__FieldTag::__hyperthreading_enabled),
                            "labels" => Ok(__FieldTag::__labels),
                            "luns" => Ok(__FieldTag::__luns),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "networks" => Ok(__FieldTag::__networks),
                            "interactiveSerialConsoleEnabled" => {
                                Ok(__FieldTag::__interactive_serial_console_enabled)
                            }
                            "interactive_serial_console_enabled" => {
                                Ok(__FieldTag::__interactive_serial_console_enabled)
                            }
                            "osImage" => Ok(__FieldTag::__os_image),
                            "os_image" => Ok(__FieldTag::__os_image),
                            "pod" => Ok(__FieldTag::__pod),
                            "networkTemplate" => Ok(__FieldTag::__network_template),
                            "network_template" => Ok(__FieldTag::__network_template),
                            "logicalInterfaces" => Ok(__FieldTag::__logical_interfaces),
                            "logical_interfaces" => Ok(__FieldTag::__logical_interfaces),
                            "loginInfo" => Ok(__FieldTag::__login_info),
                            "login_info" => Ok(__FieldTag::__login_info),
                            "workloadProfile" => Ok(__FieldTag::__workload_profile),
                            "workload_profile" => Ok(__FieldTag::__workload_profile),
                            "firmwareVersion" => Ok(__FieldTag::__firmware_version),
                            "firmware_version" => Ok(__FieldTag::__firmware_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::instance::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hyperthreading_enabled => {
                            if !fields.insert(__FieldTag::__hyperthreading_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hyperthreading_enabled",
                                ));
                            }
                            result.hyperthreading_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__luns => {
                            if !fields.insert(__FieldTag::__luns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for luns",
                                ));
                            }
                            result.luns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Lun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Network>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__interactive_serial_console_enabled => {
                            if !fields.insert(__FieldTag::__interactive_serial_console_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interactive_serial_console_enabled",
                                ));
                            }
                            result.interactive_serial_console_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_image => {
                            if !fields.insert(__FieldTag::__os_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_image",
                                ));
                            }
                            result.os_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod => {
                            if !fields.insert(__FieldTag::__pod) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod",
                                ));
                            }
                            result.pod = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_template => {
                            if !fields.insert(__FieldTag::__network_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_template",
                                ));
                            }
                            result.network_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logical_interfaces => {
                            if !fields.insert(__FieldTag::__logical_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_interfaces",
                                ));
                            }
                            result.logical_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LogicalInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__login_info => {
                            if !fields.insert(__FieldTag::__login_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for login_info",
                                ));
                            }
                            result.login_info = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_profile => {
                            if !fields.insert(__FieldTag::__workload_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_profile",
                                ));
                            }
                            result.workload_profile = map
                                .next_value::<std::option::Option<crate::model::WorkloadProfile>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__firmware_version => {
                            if !fields.insert(__FieldTag::__firmware_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firmware_version",
                                ));
                            }
                            result.firmware_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.hyperthreading_enabled) {
            state.serialize_entry("hyperthreadingEnabled", &self.hyperthreading_enabled)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.luns.is_empty() {
            state.serialize_entry("luns", &self.luns)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !self.networks.is_empty() {
            state.serialize_entry("networks", &self.networks)?;
        }
        if !wkt::internal::is_default(&self.interactive_serial_console_enabled) {
            state.serialize_entry(
                "interactiveSerialConsoleEnabled",
                &self.interactive_serial_console_enabled,
            )?;
        }
        if !self.os_image.is_empty() {
            state.serialize_entry("osImage", &self.os_image)?;
        }
        if !self.pod.is_empty() {
            state.serialize_entry("pod", &self.pod)?;
        }
        if !self.network_template.is_empty() {
            state.serialize_entry("networkTemplate", &self.network_template)?;
        }
        if !self.logical_interfaces.is_empty() {
            state.serialize_entry("logicalInterfaces", &self.logical_interfaces)?;
        }
        if !self.login_info.is_empty() {
            state.serialize_entry("loginInfo", &self.login_info)?;
        }
        if !wkt::internal::is_default(&self.workload_profile) {
            state.serialize_entry("workloadProfile", &self.workload_profile)?;
        }
        if !self.firmware_version.is_empty() {
            state.serialize_entry("firmwareVersion", &self.firmware_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for this server.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The server is in an unknown state.
        Unspecified,
        /// The server is being provisioned.
        Provisioning,
        /// The server is running.
        Running,
        /// The server has been deleted.
        Deleted,
        /// The server is being updated.
        Updating,
        /// The server is starting.
        Starting,
        /// The server is stopping.
        Stopping,
        /// The server is shutdown.
        Shutdown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Starting => std::option::Option::Some(5),
                Self::Stopping => std::option::Option::Some(6),
                Self::Shutdown => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Shutdown => std::option::Option::Some("SHUTDOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Deleted,
                4 => Self::Updating,
                5 => Self::Starting,
                6 => Self::Stopping,
                7 => Self::Shutdown,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                "STARTING" => Self::Starting,
                "STOPPING" => Self::Stopping,
                "SHUTDOWN" => Self::Shutdown,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Starting => serializer.serialize_i32(5),
                Self::Stopping => serializer.serialize_i32(6),
                Self::Shutdown => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Instance.State",
            ))
        }
    }
}

/// Message for requesting server information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting the list of servers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. Parent value for ListInstancesRequest.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the list of servers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of servers.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting to updating a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. The server to update.
    ///
    /// The `name` field is used to identify the instance to update.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    pub instance: std::option::Option<crate::model::Instance>,

    /// The list of fields to update.
    /// The currently supported fields are:
    /// `labels`
    /// `hyperthreading_enabled`
    /// `os_image`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameInstanceRequest {
    /// Required. The `name` field is used to identify the instance.
    /// Format: projects/{project}/locations/{location}/instances/{instance}
    pub name: std::string::String,

    /// Required. The new `id` of the instance.
    pub new_instance_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_instance_id][crate::model::RenameInstanceRequest::new_instance_id].
    pub fn set_new_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_instance_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenameInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __new_instance_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenameInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "newInstanceId" => Ok(__FieldTag::__new_instance_id),
                            "new_instance_id" => Ok(__FieldTag::__new_instance_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenameInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenameInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_instance_id => {
                            if !fields.insert(__FieldTag::__new_instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_instance_id",
                                ));
                            }
                            result.new_instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenameInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.new_instance_id.is_empty() {
            state.serialize_entry("newInstanceId", &self.new_instance_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting to reset a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting to start a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StartInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message from starting a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartInstanceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StartInstanceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartInstanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartInstanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartInstanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartInstanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartInstanceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting to stop a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopInstanceRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StopInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message from stopping a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopInstanceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopInstanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StopInstanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.StopInstanceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopInstanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopInstanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopInstanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopInstanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopInstanceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for enabling the interactive serial console on an instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableInteractiveSerialConsoleRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableInteractiveSerialConsoleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableInteractiveSerialConsoleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableInteractiveSerialConsoleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EnableInteractiveSerialConsoleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableInteractiveSerialConsoleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for EnableInteractiveSerialConsoleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableInteractiveSerialConsoleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableInteractiveSerialConsoleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableInteractiveSerialConsoleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response of EnableInteractiveSerialConsole.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableInteractiveSerialConsoleResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableInteractiveSerialConsoleResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableInteractiveSerialConsoleResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EnableInteractiveSerialConsoleResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableInteractiveSerialConsoleResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for EnableInteractiveSerialConsoleResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableInteractiveSerialConsoleResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableInteractiveSerialConsoleResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableInteractiveSerialConsoleResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for disabling the interactive serial console on an instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableInteractiveSerialConsoleRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableInteractiveSerialConsoleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableInteractiveSerialConsoleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisableInteractiveSerialConsoleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DisableInteractiveSerialConsoleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableInteractiveSerialConsoleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DisableInteractiveSerialConsoleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableInteractiveSerialConsoleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableInteractiveSerialConsoleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableInteractiveSerialConsoleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response of DisableInteractiveSerialConsole.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableInteractiveSerialConsoleResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableInteractiveSerialConsoleResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisableInteractiveSerialConsoleResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DisableInteractiveSerialConsoleResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableInteractiveSerialConsoleResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DisableInteractiveSerialConsoleResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableInteractiveSerialConsoleResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableInteractiveSerialConsoleResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableInteractiveSerialConsoleResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for detach specific LUN from an Instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachLunRequest {
    /// Required. Name of the instance.
    pub instance: std::string::String,

    /// Required. Name of the Lun to detach.
    pub lun: std::string::String,

    /// If true, performs lun unmapping without instance reboot.
    pub skip_reboot: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::DetachLunRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [lun][crate::model::DetachLunRequest::lun].
    pub fn set_lun<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lun = v.into();
        self
    }

    /// Sets the value of [skip_reboot][crate::model::DetachLunRequest::skip_reboot].
    pub fn set_skip_reboot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_reboot = v.into();
        self
    }
}

impl wkt::message::Message for DetachLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DetachLunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetachLunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __lun,
            __skip_reboot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetachLunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "lun" => Ok(__FieldTag::__lun),
                            "skipReboot" => Ok(__FieldTag::__skip_reboot),
                            "skip_reboot" => Ok(__FieldTag::__skip_reboot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetachLunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetachLunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lun => {
                            if !fields.insert(__FieldTag::__lun) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lun",
                                ));
                            }
                            result.lun = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_reboot => {
                            if !fields.insert(__FieldTag::__skip_reboot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_reboot",
                                ));
                            }
                            result.skip_reboot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetachLunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.lun.is_empty() {
            state.serialize_entry("lun", &self.lun)?;
        }
        if !wkt::internal::is_default(&self.skip_reboot) {
            state.serialize_entry("skipReboot", &self.skip_reboot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Network template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerNetworkTemplate {
    /// Output only. Template's unique name. The full resource name follows the
    /// pattern:
    /// `projects/{project}/locations/{location}/serverNetworkTemplate/{server_network_template}`
    /// Generally, the {server_network_template} follows the syntax of
    /// "bond<interface_type_index><bond_mode>" or "nic<interface_type_index>".
    pub name: std::string::String,

    /// Instance types this template is applicable to.
    pub applicable_instance_types: std::vec::Vec<std::string::String>,

    /// Logical interfaces.
    pub logical_interfaces: std::vec::Vec<crate::model::server_network_template::LogicalInterface>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerNetworkTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServerNetworkTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [applicable_instance_types][crate::model::ServerNetworkTemplate::applicable_instance_types].
    pub fn set_applicable_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::ServerNetworkTemplate::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::server_network_template::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServerNetworkTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ServerNetworkTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServerNetworkTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __applicable_instance_types,
            __logical_interfaces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerNetworkTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "applicableInstanceTypes" => {
                                Ok(__FieldTag::__applicable_instance_types)
                            }
                            "applicable_instance_types" => {
                                Ok(__FieldTag::__applicable_instance_types)
                            }
                            "logicalInterfaces" => Ok(__FieldTag::__logical_interfaces),
                            "logical_interfaces" => Ok(__FieldTag::__logical_interfaces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServerNetworkTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerNetworkTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applicable_instance_types => {
                            if !fields.insert(__FieldTag::__applicable_instance_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applicable_instance_types",
                                ));
                            }
                            result.applicable_instance_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__logical_interfaces => {
                            if !fields.insert(__FieldTag::__logical_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_interfaces",
                                ));
                            }
                            result.logical_interfaces = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::server_network_template::LogicalInterface,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServerNetworkTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.applicable_instance_types.is_empty() {
            state.serialize_entry("applicableInstanceTypes", &self.applicable_instance_types)?;
        }
        if !self.logical_interfaces.is_empty() {
            state.serialize_entry("logicalInterfaces", &self.logical_interfaces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ServerNetworkTemplate].
pub mod server_network_template {
    #[allow(unused_imports)]
    use super::*;

    /// Logical interface.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LogicalInterface {
        /// Interface name.
        /// This is not a globally unique identifier.
        /// Name is unique only inside the ServerNetworkTemplate. This is of syntax
        /// \<bond\><interface_type_index><bond_mode> or \<nic\><interface_type_index>
        /// and forms part of the network template name.
        pub name: std::string::String,

        /// Interface type.
        pub r#type: crate::model::server_network_template::logical_interface::InterfaceType,

        /// If true, interface must have network connected.
        pub required: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LogicalInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::server_network_template::LogicalInterface::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::server_network_template::LogicalInterface::type].
        pub fn set_type<
            T: std::convert::Into<
                    crate::model::server_network_template::logical_interface::InterfaceType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [required][crate::model::server_network_template::LogicalInterface::required].
        pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.required = v.into();
            self
        }
    }

    impl wkt::message::Message for LogicalInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.ServerNetworkTemplate.LogicalInterface"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LogicalInterface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __type,
                __required,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LogicalInterface")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                "required" => Ok(__FieldTag::__required),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LogicalInterface;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LogicalInterface")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map.next_value::<std::option::Option<crate::model::server_network_template::logical_interface::InterfaceType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__required => {
                                if !fields.insert(__FieldTag::__required) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for required",
                                    ));
                                }
                                result.required = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LogicalInterface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.required) {
                state.serialize_entry("required", &self.required)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [LogicalInterface].
    pub mod logical_interface {
        #[allow(unused_imports)]
        use super::*;

        /// Interface type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum InterfaceType {
            /// Unspecified value.
            Unspecified,
            /// Bond interface type.
            Bond,
            /// NIC interface type.
            Nic,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [InterfaceType::value] or
            /// [InterfaceType::name].
            UnknownValue(interface_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod interface_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl InterfaceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Bond => std::option::Option::Some(1),
                    Self::Nic => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("INTERFACE_TYPE_UNSPECIFIED"),
                    Self::Bond => std::option::Option::Some("BOND"),
                    Self::Nic => std::option::Option::Some("NIC"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for InterfaceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for InterfaceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for InterfaceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Bond,
                    2 => Self::Nic,
                    _ => Self::UnknownValue(interface_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for InterfaceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "INTERFACE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "BOND" => Self::Bond,
                    "NIC" => Self::Nic,
                    _ => Self::UnknownValue(interface_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for InterfaceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Bond => serializer.serialize_i32(1),
                    Self::Nic => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for InterfaceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterfaceType>::new(
                    ".google.cloud.baremetalsolution.v2.ServerNetworkTemplate.LogicalInterface.InterfaceType"))
            }
        }
    }
}

/// A storage volume logical unit number (LUN).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Lun {
    /// Output only. The name of the LUN.
    pub name: std::string::String,

    /// An identifier for the LUN, generated by the backend.
    pub id: std::string::String,

    /// The state of this storage volume.
    pub state: crate::model::lun::State,

    /// The size of this LUN, in gigabytes.
    pub size_gb: i64,

    /// The LUN multiprotocol type ensures the characteristics of the LUN are
    /// optimized for each operating system.
    pub multiprotocol_type: crate::model::lun::MultiprotocolType,

    /// Display the storage volume for this LUN.
    pub storage_volume: std::string::String,

    /// Display if this LUN can be shared between multiple physical servers.
    pub shareable: bool,

    /// Display if this LUN is a boot LUN.
    pub boot_lun: bool,

    /// The storage type for this LUN.
    pub storage_type: crate::model::lun::StorageType,

    /// The WWID for this LUN.
    pub wwid: std::string::String,

    /// Output only. Time after which LUN will be fully deleted.
    /// It is filled only for LUNs in COOL_OFF state.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instances this Lun is attached to.
    pub instances: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Lun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Lun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Lun::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Lun::state].
    pub fn set_state<T: std::convert::Into<crate::model::lun::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Lun::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [multiprotocol_type][crate::model::Lun::multiprotocol_type].
    pub fn set_multiprotocol_type<T: std::convert::Into<crate::model::lun::MultiprotocolType>>(
        mut self,
        v: T,
    ) -> Self {
        self.multiprotocol_type = v.into();
        self
    }

    /// Sets the value of [storage_volume][crate::model::Lun::storage_volume].
    pub fn set_storage_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_volume = v.into();
        self
    }

    /// Sets the value of [shareable][crate::model::Lun::shareable].
    pub fn set_shareable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.shareable = v.into();
        self
    }

    /// Sets the value of [boot_lun][crate::model::Lun::boot_lun].
    pub fn set_boot_lun<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.boot_lun = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::Lun::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::lun::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [wwid][crate::model::Lun::wwid].
    pub fn set_wwid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.wwid = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Lun::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Lun::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::Lun::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Lun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Lun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Lun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __state,
            __size_gb,
            __multiprotocol_type,
            __storage_volume,
            __shareable,
            __boot_lun,
            __storage_type,
            __wwid,
            __expire_time,
            __instances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Lun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "state" => Ok(__FieldTag::__state),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            "multiprotocolType" => Ok(__FieldTag::__multiprotocol_type),
                            "multiprotocol_type" => Ok(__FieldTag::__multiprotocol_type),
                            "storageVolume" => Ok(__FieldTag::__storage_volume),
                            "storage_volume" => Ok(__FieldTag::__storage_volume),
                            "shareable" => Ok(__FieldTag::__shareable),
                            "bootLun" => Ok(__FieldTag::__boot_lun),
                            "boot_lun" => Ok(__FieldTag::__boot_lun),
                            "storageType" => Ok(__FieldTag::__storage_type),
                            "storage_type" => Ok(__FieldTag::__storage_type),
                            "wwid" => Ok(__FieldTag::__wwid),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "instances" => Ok(__FieldTag::__instances),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Lun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Lun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::lun::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__multiprotocol_type => {
                            if !fields.insert(__FieldTag::__multiprotocol_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multiprotocol_type",
                                ));
                            }
                            result.multiprotocol_type = map.next_value::<std::option::Option<crate::model::lun::MultiprotocolType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_volume => {
                            if !fields.insert(__FieldTag::__storage_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_volume",
                                ));
                            }
                            result.storage_volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shareable => {
                            if !fields.insert(__FieldTag::__shareable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shareable",
                                ));
                            }
                            result.shareable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_lun => {
                            if !fields.insert(__FieldTag::__boot_lun) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_lun",
                                ));
                            }
                            result.boot_lun = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_type => {
                            if !fields.insert(__FieldTag::__storage_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_type",
                                ));
                            }
                            result.storage_type = map
                                .next_value::<std::option::Option<crate::model::lun::StorageType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wwid => {
                            if !fields.insert(__FieldTag::__wwid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wwid",
                                ));
                            }
                            result.wwid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Lun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !wkt::internal::is_default(&self.multiprotocol_type) {
            state.serialize_entry("multiprotocolType", &self.multiprotocol_type)?;
        }
        if !self.storage_volume.is_empty() {
            state.serialize_entry("storageVolume", &self.storage_volume)?;
        }
        if !wkt::internal::is_default(&self.shareable) {
            state.serialize_entry("shareable", &self.shareable)?;
        }
        if !wkt::internal::is_default(&self.boot_lun) {
            state.serialize_entry("bootLun", &self.boot_lun)?;
        }
        if !wkt::internal::is_default(&self.storage_type) {
            state.serialize_entry("storageType", &self.storage_type)?;
        }
        if !self.wwid.is_empty() {
            state.serialize_entry("wwid", &self.wwid)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Lun].
pub mod lun {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for the LUN.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The LUN is in an unknown state.
        Unspecified,
        /// The LUN is being created.
        Creating,
        /// The LUN is being updated.
        Updating,
        /// The LUN is ready for use.
        Ready,
        /// The LUN has been requested to be deleted.
        Deleting,
        /// The LUN is in cool off state. It will be deleted after `expire_time`.
        CoolOff,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::CoolOff => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::CoolOff => std::option::Option::Some("COOL_OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Updating,
                3 => Self::Ready,
                4 => Self::Deleting,
                5 => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "COOL_OFF" => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::CoolOff => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Lun.State",
            ))
        }
    }

    /// Display the operating systems present for the LUN multiprotocol type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MultiprotocolType {
        /// Server has no OS specified.
        Unspecified,
        /// Server with Linux OS.
        Linux,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MultiprotocolType::value] or
        /// [MultiprotocolType::name].
        UnknownValue(multiprotocol_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod multiprotocol_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MultiprotocolType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Linux => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MULTIPROTOCOL_TYPE_UNSPECIFIED"),
                Self::Linux => std::option::Option::Some("LINUX"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MultiprotocolType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MultiprotocolType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MultiprotocolType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Linux,
                _ => Self::UnknownValue(multiprotocol_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MultiprotocolType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MULTIPROTOCOL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LINUX" => Self::Linux,
                _ => Self::UnknownValue(multiprotocol_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MultiprotocolType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Linux => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MultiprotocolType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MultiprotocolType>::new(
                ".google.cloud.baremetalsolution.v2.Lun.MultiprotocolType",
            ))
        }
    }

    /// The storage types for a LUN.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The storage type for this LUN is unknown.
        Unspecified,
        /// This storage type for this LUN is SSD.
        Ssd,
        /// This storage type for this LUN is HDD.
        Hdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ssd => std::option::Option::Some(1),
                Self::Hdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Ssd => std::option::Option::Some("SSD"),
                Self::Hdd => std::option::Option::Some("HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ssd,
                2 => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SSD" => Self::Ssd,
                "HDD" => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ssd => serializer.serialize_i32(1),
                Self::Hdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.baremetalsolution.v2.Lun.StorageType",
            ))
        }
    }
}

/// Message for requesting storage lun information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLunRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetLunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting a list of storage volume luns.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLunsRequest {
    /// Required. Parent value for ListLunsRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListLunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing the list of storage volume luns.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLunsResponse {
    /// The list of luns.
    pub luns: std::vec::Vec<crate::model::Lun>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [luns][crate::model::ListLunsResponse::luns].
    pub fn set_luns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lun>,
    {
        use std::iter::Iterator;
        self.luns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListLunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListLunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLunsResponse {
    type PageItem = crate::model::Lun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.luns
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __luns,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "luns" => Ok(__FieldTag::__luns),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__luns => {
                            if !fields.insert(__FieldTag::__luns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for luns",
                                ));
                            }
                            result.luns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Lun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.luns.is_empty() {
            state.serialize_entry("luns", &self.luns)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for skip lun cooloff and delete it.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictLunRequest {
    /// Required. The name of the lun.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictLunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EvictLunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EvictLunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EvictLunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvictLunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictLunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvictLunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictLunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvictLunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Network.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Network {
    /// Output only. The resource name of this `Network`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/networks/{network}`
    pub name: std::string::String,

    /// An identifier for the `Network`, generated by the backend.
    pub id: std::string::String,

    /// The type of this network.
    pub r#type: crate::model::network::Type,

    /// IP address configured.
    pub ip_address: std::string::String,

    /// List of physical interfaces.
    pub mac_address: std::vec::Vec<std::string::String>,

    /// The Network state.
    pub state: crate::model::network::State,

    /// The vlan id of the Network.
    pub vlan_id: std::string::String,

    /// The cidr of the Network.
    pub cidr: std::string::String,

    /// The vrf for the Network.
    pub vrf: std::option::Option<crate::model::Vrf>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// IP range for reserved for services (e.g. NFS).
    pub services_cidr: std::string::String,

    /// List of IP address reservations in this network.
    /// When updating this field, an error will be generated if a reservation
    /// conflicts with an IP address already allocated to a physical server.
    pub reservations: std::vec::Vec<crate::model::NetworkAddressReservation>,

    /// Output only. Pod name.
    pub pod: std::string::String,

    /// Input only. List of mount points to attach the network to.
    pub mount_points: std::vec::Vec<crate::model::NetworkMountPoint>,

    /// Whether network uses standard frames or jumbo ones.
    pub jumbo_frames_enabled: bool,

    /// Output only. Gateway ip address.
    pub gateway_ip: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Network::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Network::type].
    pub fn set_type<T: std::convert::Into<crate::model::network::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::Network::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [mac_address][crate::model::Network::mac_address].
    pub fn set_mac_address<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mac_address = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Network::state].
    pub fn set_state<T: std::convert::Into<crate::model::network::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [vlan_id][crate::model::Network::vlan_id].
    pub fn set_vlan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vlan_id = v.into();
        self
    }

    /// Sets the value of [cidr][crate::model::Network::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [vrf][crate::model::Network::vrf].
    pub fn set_vrf<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Vrf>,
    {
        self.vrf = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vrf][crate::model::Network::vrf].
    pub fn set_or_clear_vrf<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Vrf>,
    {
        self.vrf = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Network::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [services_cidr][crate::model::Network::services_cidr].
    pub fn set_services_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.services_cidr = v.into();
        self
    }

    /// Sets the value of [reservations][crate::model::Network::reservations].
    pub fn set_reservations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkAddressReservation>,
    {
        use std::iter::Iterator;
        self.reservations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod][crate::model::Network::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [mount_points][crate::model::Network::mount_points].
    pub fn set_mount_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkMountPoint>,
    {
        use std::iter::Iterator;
        self.mount_points = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jumbo_frames_enabled][crate::model::Network::jumbo_frames_enabled].
    pub fn set_jumbo_frames_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.jumbo_frames_enabled = v.into();
        self
    }

    /// Sets the value of [gateway_ip][crate::model::Network::gateway_ip].
    pub fn set_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gateway_ip = v.into();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Network"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Network {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __type,
            __ip_address,
            __mac_address,
            __state,
            __vlan_id,
            __cidr,
            __vrf,
            __labels,
            __services_cidr,
            __reservations,
            __pod,
            __mount_points,
            __jumbo_frames_enabled,
            __gateway_ip,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Network")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "type" => Ok(__FieldTag::__type),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "macAddress" => Ok(__FieldTag::__mac_address),
                            "mac_address" => Ok(__FieldTag::__mac_address),
                            "state" => Ok(__FieldTag::__state),
                            "vlanId" => Ok(__FieldTag::__vlan_id),
                            "vlan_id" => Ok(__FieldTag::__vlan_id),
                            "cidr" => Ok(__FieldTag::__cidr),
                            "vrf" => Ok(__FieldTag::__vrf),
                            "labels" => Ok(__FieldTag::__labels),
                            "servicesCidr" => Ok(__FieldTag::__services_cidr),
                            "services_cidr" => Ok(__FieldTag::__services_cidr),
                            "reservations" => Ok(__FieldTag::__reservations),
                            "pod" => Ok(__FieldTag::__pod),
                            "mountPoints" => Ok(__FieldTag::__mount_points),
                            "mount_points" => Ok(__FieldTag::__mount_points),
                            "jumboFramesEnabled" => Ok(__FieldTag::__jumbo_frames_enabled),
                            "jumbo_frames_enabled" => Ok(__FieldTag::__jumbo_frames_enabled),
                            "gatewayIp" => Ok(__FieldTag::__gateway_ip),
                            "gateway_ip" => Ok(__FieldTag::__gateway_ip),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Network;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Network")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::network::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mac_address => {
                            if !fields.insert(__FieldTag::__mac_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mac_address",
                                ));
                            }
                            result.mac_address = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::network::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vlan_id => {
                            if !fields.insert(__FieldTag::__vlan_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vlan_id",
                                ));
                            }
                            result.vlan_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr => {
                            if !fields.insert(__FieldTag::__cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr",
                                ));
                            }
                            result.cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vrf => {
                            if !fields.insert(__FieldTag::__vrf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vrf",
                                ));
                            }
                            result.vrf =
                                map.next_value::<std::option::Option<crate::model::Vrf>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_cidr => {
                            if !fields.insert(__FieldTag::__services_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_cidr",
                                ));
                            }
                            result.services_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservations => {
                            if !fields.insert(__FieldTag::__reservations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservations",
                                ));
                            }
                            result.reservations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkAddressReservation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod => {
                            if !fields.insert(__FieldTag::__pod) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod",
                                ));
                            }
                            result.pod = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mount_points => {
                            if !fields.insert(__FieldTag::__mount_points) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mount_points",
                                ));
                            }
                            result.mount_points =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkMountPoint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jumbo_frames_enabled => {
                            if !fields.insert(__FieldTag::__jumbo_frames_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jumbo_frames_enabled",
                                ));
                            }
                            result.jumbo_frames_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gateway_ip => {
                            if !fields.insert(__FieldTag::__gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gateway_ip",
                                ));
                            }
                            result.gateway_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Network {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.mac_address.is_empty() {
            state.serialize_entry("macAddress", &self.mac_address)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.vlan_id.is_empty() {
            state.serialize_entry("vlanId", &self.vlan_id)?;
        }
        if !self.cidr.is_empty() {
            state.serialize_entry("cidr", &self.cidr)?;
        }
        if self.vrf.is_some() {
            state.serialize_entry("vrf", &self.vrf)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.services_cidr.is_empty() {
            state.serialize_entry("servicesCidr", &self.services_cidr)?;
        }
        if !self.reservations.is_empty() {
            state.serialize_entry("reservations", &self.reservations)?;
        }
        if !self.pod.is_empty() {
            state.serialize_entry("pod", &self.pod)?;
        }
        if !self.mount_points.is_empty() {
            state.serialize_entry("mountPoints", &self.mount_points)?;
        }
        if !wkt::internal::is_default(&self.jumbo_frames_enabled) {
            state.serialize_entry("jumboFramesEnabled", &self.jumbo_frames_enabled)?;
        }
        if !self.gateway_ip.is_empty() {
            state.serialize_entry("gatewayIp", &self.gateway_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Network].
pub mod network {
    #[allow(unused_imports)]
    use super::*;

    /// Network type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified value.
        Unspecified,
        /// Client network, a network peered to a Google Cloud VPC.
        Client,
        /// Private network, a network local to the Bare Metal Solution environment.
        Private,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Client => std::option::Option::Some(1),
                Self::Private => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Client => std::option::Option::Some("CLIENT"),
                Self::Private => std::option::Option::Some("PRIVATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Client,
                2 => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLIENT" => Self::Client,
                "PRIVATE" => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Client => serializer.serialize_i32(1),
                Self::Private => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.baremetalsolution.v2.Network.Type",
            ))
        }
    }

    /// The possible states for this Network.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Network is in an unknown state.
        Unspecified,
        /// The Network is provisioning.
        Provisioning,
        /// The Network has been provisioned.
        Provisioned,
        /// The Network is being deprovisioned.
        Deprovisioning,
        /// The Network is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Provisioned => std::option::Option::Some(2),
                Self::Deprovisioning => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::Deprovisioning => std::option::Option::Some("DEPROVISIONING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Provisioned,
                3 => Self::Deprovisioning,
                4 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "PROVISIONED" => Self::Provisioned,
                "DEPROVISIONING" => Self::Deprovisioning,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Provisioned => serializer.serialize_i32(2),
                Self::Deprovisioning => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Network.State",
            ))
        }
    }
}

/// A reservation of one or more addresses in a network.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkAddressReservation {
    /// The first address of this reservation block.
    /// Must be specified as a single IPv4 address, e.g. 10.1.2.2.
    pub start_address: std::string::String,

    /// The last address of this reservation block, inclusive. I.e., for cases when
    /// reservations are only single addresses, end_address and start_address will
    /// be the same.
    /// Must be specified as a single IPv4 address, e.g. 10.1.2.2.
    pub end_address: std::string::String,

    /// A note about this reservation, intended for human consumption.
    pub note: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkAddressReservation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_address][crate::model::NetworkAddressReservation::start_address].
    pub fn set_start_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_address = v.into();
        self
    }

    /// Sets the value of [end_address][crate::model::NetworkAddressReservation::end_address].
    pub fn set_end_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_address = v.into();
        self
    }

    /// Sets the value of [note][crate::model::NetworkAddressReservation::note].
    pub fn set_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note = v.into();
        self
    }
}

impl wkt::message::Message for NetworkAddressReservation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkAddressReservation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkAddressReservation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_address,
            __end_address,
            __note,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkAddressReservation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startAddress" => Ok(__FieldTag::__start_address),
                            "start_address" => Ok(__FieldTag::__start_address),
                            "endAddress" => Ok(__FieldTag::__end_address),
                            "end_address" => Ok(__FieldTag::__end_address),
                            "note" => Ok(__FieldTag::__note),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAddressReservation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkAddressReservation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_address => {
                            if !fields.insert(__FieldTag::__start_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_address",
                                ));
                            }
                            result.start_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_address => {
                            if !fields.insert(__FieldTag::__end_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_address",
                                ));
                            }
                            result.end_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkAddressReservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.start_address.is_empty() {
            state.serialize_entry("startAddress", &self.start_address)?;
        }
        if !self.end_address.is_empty() {
            state.serialize_entry("endAddress", &self.end_address)?;
        }
        if !self.note.is_empty() {
            state.serialize_entry("note", &self.note)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A network VRF.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Vrf {
    /// The name of the VRF.
    pub name: std::string::String,

    /// The possible state of VRF.
    pub state: crate::model::vrf::State,

    /// The QOS policy applied to this VRF.
    /// The value is only meaningful when all the vlan attachments have the same
    /// QoS. This field should not be used for new integrations, use vlan
    /// attachment level qos instead. The field is left for backward-compatibility.
    pub qos_policy: std::option::Option<crate::model::vrf::QosPolicy>,

    /// The list of VLAN attachments for the VRF.
    pub vlan_attachments: std::vec::Vec<crate::model::vrf::VlanAttachment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vrf {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Vrf::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Vrf::state].
    pub fn set_state<T: std::convert::Into<crate::model::vrf::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [qos_policy][crate::model::Vrf::qos_policy].
    pub fn set_qos_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vrf::QosPolicy>,
    {
        self.qos_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qos_policy][crate::model::Vrf::qos_policy].
    pub fn set_or_clear_qos_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vrf::QosPolicy>,
    {
        self.qos_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vlan_attachments][crate::model::Vrf::vlan_attachments].
    pub fn set_vlan_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vrf::VlanAttachment>,
    {
        use std::iter::Iterator;
        self.vlan_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Vrf {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Vrf {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __qos_policy,
            __vlan_attachments,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Vrf")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "qosPolicy" => Ok(__FieldTag::__qos_policy),
                            "qos_policy" => Ok(__FieldTag::__qos_policy),
                            "vlanAttachments" => Ok(__FieldTag::__vlan_attachments),
                            "vlan_attachments" => Ok(__FieldTag::__vlan_attachments),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Vrf;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Vrf")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::vrf::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qos_policy => {
                            if !fields.insert(__FieldTag::__qos_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qos_policy",
                                ));
                            }
                            result.qos_policy = map
                                .next_value::<std::option::Option<crate::model::vrf::QosPolicy>>(
                                )?;
                        }
                        __FieldTag::__vlan_attachments => {
                            if !fields.insert(__FieldTag::__vlan_attachments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vlan_attachments",
                                ));
                            }
                            result.vlan_attachments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vrf::VlanAttachment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Vrf {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.qos_policy.is_some() {
            state.serialize_entry("qosPolicy", &self.qos_policy)?;
        }
        if !self.vlan_attachments.is_empty() {
            state.serialize_entry("vlanAttachments", &self.vlan_attachments)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VRF].
pub mod vrf {
    #[allow(unused_imports)]
    use super::*;

    /// QOS policy parameters.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QosPolicy {
        /// The bandwidth permitted by the QOS policy, in gbps.
        pub bandwidth_gbps: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QosPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bandwidth_gbps][crate::model::vrf::QosPolicy::bandwidth_gbps].
        pub fn set_bandwidth_gbps<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.bandwidth_gbps = v.into();
            self
        }
    }

    impl wkt::message::Message for QosPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF.QosPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QosPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bandwidth_gbps,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QosPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bandwidthGbps" => Ok(__FieldTag::__bandwidth_gbps),
                                "bandwidth_gbps" => Ok(__FieldTag::__bandwidth_gbps),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QosPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QosPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bandwidth_gbps => {
                                if !fields.insert(__FieldTag::__bandwidth_gbps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bandwidth_gbps",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.bandwidth_gbps =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QosPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.bandwidth_gbps) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("bandwidthGbps", &__With(&self.bandwidth_gbps))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// VLAN attachment details.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VlanAttachment {
        /// The peer vlan ID of the attachment.
        pub peer_vlan_id: i64,

        /// The peer IP of the attachment.
        pub peer_ip: std::string::String,

        /// The router IP of the attachment.
        pub router_ip: std::string::String,

        /// Input only. Pairing key.
        pub pairing_key: std::string::String,

        /// The QOS policy applied to this VLAN attachment.
        /// This value should be preferred to using qos at vrf level.
        pub qos_policy: std::option::Option<crate::model::vrf::QosPolicy>,

        /// Immutable. The identifier of the attachment within vrf.
        pub id: std::string::String,

        /// Optional. The name of the vlan attachment within vrf. This is of the form
        /// projects/{project_number}/regions/{region}/interconnectAttachments/{interconnect_attachment}
        pub interconnect_attachment: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VlanAttachment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peer_vlan_id][crate::model::vrf::VlanAttachment::peer_vlan_id].
        pub fn set_peer_vlan_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.peer_vlan_id = v.into();
            self
        }

        /// Sets the value of [peer_ip][crate::model::vrf::VlanAttachment::peer_ip].
        pub fn set_peer_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.peer_ip = v.into();
            self
        }

        /// Sets the value of [router_ip][crate::model::vrf::VlanAttachment::router_ip].
        pub fn set_router_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.router_ip = v.into();
            self
        }

        /// Sets the value of [pairing_key][crate::model::vrf::VlanAttachment::pairing_key].
        pub fn set_pairing_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pairing_key = v.into();
            self
        }

        /// Sets the value of [qos_policy][crate::model::vrf::VlanAttachment::qos_policy].
        pub fn set_qos_policy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::vrf::QosPolicy>,
        {
            self.qos_policy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [qos_policy][crate::model::vrf::VlanAttachment::qos_policy].
        pub fn set_or_clear_qos_policy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::vrf::QosPolicy>,
        {
            self.qos_policy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [id][crate::model::vrf::VlanAttachment::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [interconnect_attachment][crate::model::vrf::VlanAttachment::interconnect_attachment].
        pub fn set_interconnect_attachment<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.interconnect_attachment = v.into();
            self
        }
    }

    impl wkt::message::Message for VlanAttachment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VRF.VlanAttachment"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VlanAttachment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __peer_vlan_id,
                __peer_ip,
                __router_ip,
                __pairing_key,
                __qos_policy,
                __id,
                __interconnect_attachment,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VlanAttachment")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "peerVlanId" => Ok(__FieldTag::__peer_vlan_id),
                                "peer_vlan_id" => Ok(__FieldTag::__peer_vlan_id),
                                "peerIp" => Ok(__FieldTag::__peer_ip),
                                "peer_ip" => Ok(__FieldTag::__peer_ip),
                                "routerIp" => Ok(__FieldTag::__router_ip),
                                "router_ip" => Ok(__FieldTag::__router_ip),
                                "pairingKey" => Ok(__FieldTag::__pairing_key),
                                "pairing_key" => Ok(__FieldTag::__pairing_key),
                                "qosPolicy" => Ok(__FieldTag::__qos_policy),
                                "qos_policy" => Ok(__FieldTag::__qos_policy),
                                "id" => Ok(__FieldTag::__id),
                                "interconnectAttachment" => {
                                    Ok(__FieldTag::__interconnect_attachment)
                                }
                                "interconnect_attachment" => {
                                    Ok(__FieldTag::__interconnect_attachment)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VlanAttachment;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VlanAttachment")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__peer_vlan_id => {
                                if !fields.insert(__FieldTag::__peer_vlan_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for peer_vlan_id",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.peer_vlan_id =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__peer_ip => {
                                if !fields.insert(__FieldTag::__peer_ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for peer_ip",
                                    ));
                                }
                                result.peer_ip = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__router_ip => {
                                if !fields.insert(__FieldTag::__router_ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for router_ip",
                                    ));
                                }
                                result.router_ip = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pairing_key => {
                                if !fields.insert(__FieldTag::__pairing_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pairing_key",
                                    ));
                                }
                                result.pairing_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__qos_policy => {
                                if !fields.insert(__FieldTag::__qos_policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qos_policy",
                                    ));
                                }
                                result.qos_policy = map.next_value::<std::option::Option<crate::model::vrf::QosPolicy>>()?
                                    ;
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__interconnect_attachment => {
                                if !fields.insert(__FieldTag::__interconnect_attachment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for interconnect_attachment",
                                    ));
                                }
                                result.interconnect_attachment = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VlanAttachment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.peer_vlan_id) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("peerVlanId", &__With(&self.peer_vlan_id))?;
            }
            if !self.peer_ip.is_empty() {
                state.serialize_entry("peerIp", &self.peer_ip)?;
            }
            if !self.router_ip.is_empty() {
                state.serialize_entry("routerIp", &self.router_ip)?;
            }
            if !self.pairing_key.is_empty() {
                state.serialize_entry("pairingKey", &self.pairing_key)?;
            }
            if self.qos_policy.is_some() {
                state.serialize_entry("qosPolicy", &self.qos_policy)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.interconnect_attachment.is_empty() {
                state.serialize_entry("interconnectAttachment", &self.interconnect_attachment)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The possible states for this VRF.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The unspecified state.
        Unspecified,
        /// The vrf is provisioning.
        Provisioning,
        /// The vrf is provisioned.
        Provisioned,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Provisioned => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Provisioned,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "PROVISIONED" => Self::Provisioned,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Provisioned => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.VRF.State",
            ))
        }
    }
}

/// Each logical interface represents a logical abstraction of the underlying
/// physical interface (for eg. bond, nic) of the instance. Each logical
/// interface can effectively map to multiple network-IP pairs and still be
/// mapped to one underlying physical interface.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogicalInterface {
    /// List of logical network interfaces within a logical interface.
    pub logical_network_interfaces:
        std::vec::Vec<crate::model::logical_interface::LogicalNetworkInterface>,

    /// Interface name. This is of syntax \<bond\><bond_mode> or \<nic\> and
    /// forms part of the network template name.
    pub name: std::string::String,

    /// The index of the logical interface mapping to the index of the hardware
    /// bond or nic on the chosen network template. This field is deprecated.
    #[deprecated]
    pub interface_index: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogicalInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [logical_network_interfaces][crate::model::LogicalInterface::logical_network_interfaces].
    pub fn set_logical_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logical_interface::LogicalNetworkInterface>,
    {
        use std::iter::Iterator;
        self.logical_network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::LogicalInterface::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [interface_index][crate::model::LogicalInterface::interface_index].
    #[deprecated]
    pub fn set_interface_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.interface_index = v.into();
        self
    }
}

impl wkt::message::Message for LogicalInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.LogicalInterface"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogicalInterface {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __logical_network_interfaces,
            __name,
            __interface_index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogicalInterface")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logicalNetworkInterfaces" => {
                                Ok(__FieldTag::__logical_network_interfaces)
                            }
                            "logical_network_interfaces" => {
                                Ok(__FieldTag::__logical_network_interfaces)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "interfaceIndex" => Ok(__FieldTag::__interface_index),
                            "interface_index" => Ok(__FieldTag::__interface_index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogicalInterface;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogicalInterface")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__logical_network_interfaces => {
                            if !fields.insert(__FieldTag::__logical_network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_network_interfaces",
                                ));
                            }
                            result.logical_network_interfaces = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::logical_interface::LogicalNetworkInterface,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interface_index => {
                            if !fields.insert(__FieldTag::__interface_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interface_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.interface_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogicalInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.logical_network_interfaces.is_empty() {
            state.serialize_entry("logicalNetworkInterfaces", &self.logical_network_interfaces)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.interface_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("interfaceIndex", &__With(&self.interface_index))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LogicalInterface].
pub mod logical_interface {
    #[allow(unused_imports)]
    use super::*;

    /// Each logical network interface is effectively a network and IP pair.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LogicalNetworkInterface {
        /// Name of the network
        pub network: std::string::String,

        /// IP address in the network
        pub ip_address: std::string::String,

        /// Whether this interface is the default gateway for the instance. Only
        /// one interface can be the default gateway for the instance.
        pub default_gateway: bool,

        /// Type of network.
        pub network_type: crate::model::network::Type,

        /// An identifier for the `Network`, generated by the backend.
        pub id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LogicalNetworkInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::logical_interface::LogicalNetworkInterface::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [ip_address][crate::model::logical_interface::LogicalNetworkInterface::ip_address].
        pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip_address = v.into();
            self
        }

        /// Sets the value of [default_gateway][crate::model::logical_interface::LogicalNetworkInterface::default_gateway].
        pub fn set_default_gateway<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.default_gateway = v.into();
            self
        }

        /// Sets the value of [network_type][crate::model::logical_interface::LogicalNetworkInterface::network_type].
        pub fn set_network_type<T: std::convert::Into<crate::model::network::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_type = v.into();
            self
        }

        /// Sets the value of [id][crate::model::logical_interface::LogicalNetworkInterface::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for LogicalNetworkInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.LogicalInterface.LogicalNetworkInterface"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LogicalNetworkInterface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network,
                __ip_address,
                __default_gateway,
                __network_type,
                __id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LogicalNetworkInterface")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "network" => Ok(__FieldTag::__network),
                                "ipAddress" => Ok(__FieldTag::__ip_address),
                                "ip_address" => Ok(__FieldTag::__ip_address),
                                "defaultGateway" => Ok(__FieldTag::__default_gateway),
                                "default_gateway" => Ok(__FieldTag::__default_gateway),
                                "networkType" => Ok(__FieldTag::__network_type),
                                "network_type" => Ok(__FieldTag::__network_type),
                                "id" => Ok(__FieldTag::__id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LogicalNetworkInterface;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LogicalNetworkInterface")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network => {
                                if !fields.insert(__FieldTag::__network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network",
                                    ));
                                }
                                result.network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ip_address => {
                                if !fields.insert(__FieldTag::__ip_address) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ip_address",
                                    ));
                                }
                                result.ip_address = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__default_gateway => {
                                if !fields.insert(__FieldTag::__default_gateway) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_gateway",
                                    ));
                                }
                                result.default_gateway = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__network_type => {
                                if !fields.insert(__FieldTag::__network_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_type",
                                    ));
                                }
                                result.network_type = map
                                    .next_value::<std::option::Option<crate::model::network::Type>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LogicalNetworkInterface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network.is_empty() {
                state.serialize_entry("network", &self.network)?;
            }
            if !self.ip_address.is_empty() {
                state.serialize_entry("ipAddress", &self.ip_address)?;
            }
            if !wkt::internal::is_default(&self.default_gateway) {
                state.serialize_entry("defaultGateway", &self.default_gateway)?;
            }
            if !wkt::internal::is_default(&self.network_type) {
                state.serialize_entry("networkType", &self.network_type)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Message for requesting network information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNetworkRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetNetworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNetworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNetworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNetworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNetworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNetworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting a list of networks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworksRequest {
    /// Required. Parent value for ListNetworksRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNetworksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNetworksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNetworksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNetworksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNetworksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing the list of networks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworksResponse {
    /// The list of networks.
    pub networks: std::vec::Vec<crate::model::Network>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [networks][crate::model::ListNetworksResponse::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNetworksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNetworksResponse {
    type PageItem = crate::model::Network;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.networks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNetworksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __networks,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNetworksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networks" => Ok(__FieldTag::__networks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNetworksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNetworksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Network>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNetworksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.networks.is_empty() {
            state.serialize_entry("networks", &self.networks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting to updating a network.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNetworkRequest {
    /// Required. The network to update.
    ///
    /// The `name` field is used to identify the instance to update.
    /// Format: projects/{project}/locations/{location}/networks/{network}
    pub network: std::option::Option<crate::model::Network>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// `labels`, `reservations`, `vrf.vlan_attachments`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::UpdateNetworkRequest::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::UpdateNetworkRequest::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNetworkRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNetworkRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateNetworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNetworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNetworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNetworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNetworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network =
                                map.next_value::<std::option::Option<crate::model::Network>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNetworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Network with all used IP addresses.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkUsage {
    /// Network.
    pub network: std::option::Option<crate::model::Network>,

    /// All used IP addresses in this network.
    pub used_ips: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkUsage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkUsage::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::NetworkUsage::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Network>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [used_ips][crate::model::NetworkUsage::used_ips].
    pub fn set_used_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.used_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkUsage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkUsage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkUsage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __used_ips,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkUsage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "usedIps" => Ok(__FieldTag::__used_ips),
                            "used_ips" => Ok(__FieldTag::__used_ips),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkUsage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkUsage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network =
                                map.next_value::<std::option::Option<crate::model::Network>>()?;
                        }
                        __FieldTag::__used_ips => {
                            if !fields.insert(__FieldTag::__used_ips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_ips",
                                ));
                            }
                            result.used_ips = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkUsage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.used_ips.is_empty() {
            state.serialize_entry("usedIps", &self.used_ips)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get networks with IPs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworkUsageRequest {
    /// Required. Parent value (project and location).
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkUsageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ListNetworkUsageRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for ListNetworkUsageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworkUsageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNetworkUsageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNetworkUsageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNetworkUsageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNetworkUsageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNetworkUsageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response with Networks with IPs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNetworkUsageResponse {
    /// Networks with IPs.
    pub networks: std::vec::Vec<crate::model::NetworkUsage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNetworkUsageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [networks][crate::model::ListNetworkUsageResponse::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkUsage>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNetworkUsageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNetworkUsageResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNetworkUsageResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __networks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNetworkUsageResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networks" => Ok(__FieldTag::__networks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNetworkUsageResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNetworkUsageResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NetworkUsage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNetworkUsageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.networks.is_empty() {
            state.serialize_entry("networks", &self.networks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Mount point for a network.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkMountPoint {
    /// Instance to attach network to.
    pub instance: std::string::String,

    /// Logical interface to detach from.
    pub logical_interface: std::string::String,

    /// Network should be a default gateway.
    pub default_gateway: bool,

    /// Ip address of the server.
    pub ip_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkMountPoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::NetworkMountPoint::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [logical_interface][crate::model::NetworkMountPoint::logical_interface].
    pub fn set_logical_interface<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.logical_interface = v.into();
        self
    }

    /// Sets the value of [default_gateway][crate::model::NetworkMountPoint::default_gateway].
    pub fn set_default_gateway<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_gateway = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::NetworkMountPoint::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for NetworkMountPoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkMountPoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkMountPoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __logical_interface,
            __default_gateway,
            __ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkMountPoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "logicalInterface" => Ok(__FieldTag::__logical_interface),
                            "logical_interface" => Ok(__FieldTag::__logical_interface),
                            "defaultGateway" => Ok(__FieldTag::__default_gateway),
                            "default_gateway" => Ok(__FieldTag::__default_gateway),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkMountPoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkMountPoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logical_interface => {
                            if !fields.insert(__FieldTag::__logical_interface) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_interface",
                                ));
                            }
                            result.logical_interface = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_gateway => {
                            if !fields.insert(__FieldTag::__default_gateway) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_gateway",
                                ));
                            }
                            result.default_gateway = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkMountPoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.logical_interface.is_empty() {
            state.serialize_entry("logicalInterface", &self.logical_interface)?;
        }
        if !wkt::internal::is_default(&self.default_gateway) {
            state.serialize_entry("defaultGateway", &self.default_gateway)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameNetworkRequest {
    /// Required. The `name` field is used to identify the network.
    /// Format: projects/{project}/locations/{location}/networks/{network}
    pub name: std::string::String,

    /// Required. The new `id` of the network.
    pub new_network_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameNetworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameNetworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_network_id][crate::model::RenameNetworkRequest::new_network_id].
    pub fn set_new_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_network_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameNetworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameNetworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenameNetworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __new_network_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenameNetworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "newNetworkId" => Ok(__FieldTag::__new_network_id),
                            "new_network_id" => Ok(__FieldTag::__new_network_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenameNetworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenameNetworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_network_id => {
                            if !fields.insert(__FieldTag::__new_network_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_network_id",
                                ));
                            }
                            result.new_network_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenameNetworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.new_network_id.is_empty() {
            state.serialize_entry("newNetworkId", &self.new_network_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An NFS share.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NfsShare {
    /// Immutable. The name of the NFS share.
    pub name: std::string::String,

    /// Output only. An identifier for the NFS share, generated by the backend.
    /// This field will be deprecated in the future, use `id` instead.
    pub nfs_share_id: std::string::String,

    /// Output only. An identifier for the NFS share, generated by the backend.
    /// This is the same value as nfs_share_id and will replace it in the future.
    pub id: std::string::String,

    /// Output only. The state of the NFS share.
    pub state: crate::model::nfs_share::State,

    /// Output only. The underlying volume of the share. Created automatically
    /// during provisioning.
    pub volume: std::string::String,

    /// List of allowed access points.
    pub allowed_clients: std::vec::Vec<crate::model::nfs_share::AllowedClient>,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The requested size, in GiB.
    pub requested_size_gib: i64,

    /// Immutable. The storage type of the underlying volume.
    pub storage_type: crate::model::nfs_share::StorageType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NfsShare {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NfsShare::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [nfs_share_id][crate::model::NfsShare::nfs_share_id].
    pub fn set_nfs_share_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nfs_share_id = v.into();
        self
    }

    /// Sets the value of [id][crate::model::NfsShare::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::NfsShare::state].
    pub fn set_state<T: std::convert::Into<crate::model::nfs_share::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [volume][crate::model::NfsShare::volume].
    pub fn set_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [allowed_clients][crate::model::NfsShare::allowed_clients].
    pub fn set_allowed_clients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::nfs_share::AllowedClient>,
    {
        use std::iter::Iterator;
        self.allowed_clients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::NfsShare::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [requested_size_gib][crate::model::NfsShare::requested_size_gib].
    pub fn set_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.requested_size_gib = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::NfsShare::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::nfs_share::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }
}

impl wkt::message::Message for NfsShare {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NfsShare"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NfsShare {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __nfs_share_id,
            __id,
            __state,
            __volume,
            __allowed_clients,
            __labels,
            __requested_size_gib,
            __storage_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NfsShare")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "nfsShareId" => Ok(__FieldTag::__nfs_share_id),
                            "nfs_share_id" => Ok(__FieldTag::__nfs_share_id),
                            "id" => Ok(__FieldTag::__id),
                            "state" => Ok(__FieldTag::__state),
                            "volume" => Ok(__FieldTag::__volume),
                            "allowedClients" => Ok(__FieldTag::__allowed_clients),
                            "allowed_clients" => Ok(__FieldTag::__allowed_clients),
                            "labels" => Ok(__FieldTag::__labels),
                            "requestedSizeGib" => Ok(__FieldTag::__requested_size_gib),
                            "requested_size_gib" => Ok(__FieldTag::__requested_size_gib),
                            "storageType" => Ok(__FieldTag::__storage_type),
                            "storage_type" => Ok(__FieldTag::__storage_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NfsShare;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NfsShare")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nfs_share_id => {
                            if !fields.insert(__FieldTag::__nfs_share_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_share_id",
                                ));
                            }
                            result.nfs_share_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::nfs_share::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume => {
                            if !fields.insert(__FieldTag::__volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume",
                                ));
                            }
                            result.volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed_clients => {
                            if !fields.insert(__FieldTag::__allowed_clients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_clients",
                                ));
                            }
                            result.allowed_clients = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::nfs_share::AllowedClient>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_size_gib => {
                            if !fields.insert(__FieldTag::__requested_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.requested_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_type => {
                            if !fields.insert(__FieldTag::__storage_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_type",
                                ));
                            }
                            result.storage_type = map.next_value::<std::option::Option<crate::model::nfs_share::StorageType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NfsShare {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.nfs_share_id.is_empty() {
            state.serialize_entry("nfsShareId", &self.nfs_share_id)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.volume.is_empty() {
            state.serialize_entry("volume", &self.volume)?;
        }
        if !self.allowed_clients.is_empty() {
            state.serialize_entry("allowedClients", &self.allowed_clients)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.requested_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("requestedSizeGib", &__With(&self.requested_size_gib))?;
        }
        if !wkt::internal::is_default(&self.storage_type) {
            state.serialize_entry("storageType", &self.storage_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NfsShare].
pub mod nfs_share {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an 'access point' for the share.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowedClient {
        /// The network the access point sits on.
        pub network: std::string::String,

        /// Output only. The IP address of the share on this network. Assigned
        /// automatically during provisioning based on the network's services_cidr.
        pub share_ip: std::string::String,

        /// The subnet of IP addresses permitted to access the share.
        pub allowed_clients_cidr: std::string::String,

        /// Mount permissions.
        pub mount_permissions: crate::model::nfs_share::MountPermissions,

        /// Allow dev flag.  Which controls whether to allow creation of devices.
        pub allow_dev: bool,

        /// Allow the setuid flag.
        pub allow_suid: bool,

        /// Disable root squashing, which is a feature of NFS.
        /// Root squash is a special mapping of the remote superuser (root) identity
        /// when using identity authentication.
        pub no_root_squash: bool,

        /// Output only. The path to access NFS, in format shareIP:/InstanceID
        /// InstanceID is the generated ID instead of customer provided name.
        /// example like "10.0.0.0:/g123456789-nfs001"
        pub nfs_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowedClient {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::nfs_share::AllowedClient::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [share_ip][crate::model::nfs_share::AllowedClient::share_ip].
        pub fn set_share_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.share_ip = v.into();
            self
        }

        /// Sets the value of [allowed_clients_cidr][crate::model::nfs_share::AllowedClient::allowed_clients_cidr].
        pub fn set_allowed_clients_cidr<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allowed_clients_cidr = v.into();
            self
        }

        /// Sets the value of [mount_permissions][crate::model::nfs_share::AllowedClient::mount_permissions].
        pub fn set_mount_permissions<
            T: std::convert::Into<crate::model::nfs_share::MountPermissions>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mount_permissions = v.into();
            self
        }

        /// Sets the value of [allow_dev][crate::model::nfs_share::AllowedClient::allow_dev].
        pub fn set_allow_dev<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_dev = v.into();
            self
        }

        /// Sets the value of [allow_suid][crate::model::nfs_share::AllowedClient::allow_suid].
        pub fn set_allow_suid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_suid = v.into();
            self
        }

        /// Sets the value of [no_root_squash][crate::model::nfs_share::AllowedClient::no_root_squash].
        pub fn set_no_root_squash<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_root_squash = v.into();
            self
        }

        /// Sets the value of [nfs_path][crate::model::nfs_share::AllowedClient::nfs_path].
        pub fn set_nfs_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.nfs_path = v.into();
            self
        }
    }

    impl wkt::message::Message for AllowedClient {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.NfsShare.AllowedClient"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AllowedClient {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network,
                __share_ip,
                __allowed_clients_cidr,
                __mount_permissions,
                __allow_dev,
                __allow_suid,
                __no_root_squash,
                __nfs_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AllowedClient")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "network" => Ok(__FieldTag::__network),
                                "shareIp" => Ok(__FieldTag::__share_ip),
                                "share_ip" => Ok(__FieldTag::__share_ip),
                                "allowedClientsCidr" => Ok(__FieldTag::__allowed_clients_cidr),
                                "allowed_clients_cidr" => Ok(__FieldTag::__allowed_clients_cidr),
                                "mountPermissions" => Ok(__FieldTag::__mount_permissions),
                                "mount_permissions" => Ok(__FieldTag::__mount_permissions),
                                "allowDev" => Ok(__FieldTag::__allow_dev),
                                "allow_dev" => Ok(__FieldTag::__allow_dev),
                                "allowSuid" => Ok(__FieldTag::__allow_suid),
                                "allow_suid" => Ok(__FieldTag::__allow_suid),
                                "noRootSquash" => Ok(__FieldTag::__no_root_squash),
                                "no_root_squash" => Ok(__FieldTag::__no_root_squash),
                                "nfsPath" => Ok(__FieldTag::__nfs_path),
                                "nfs_path" => Ok(__FieldTag::__nfs_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AllowedClient;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AllowedClient")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network => {
                                if !fields.insert(__FieldTag::__network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network",
                                    ));
                                }
                                result.network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__share_ip => {
                                if !fields.insert(__FieldTag::__share_ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for share_ip",
                                    ));
                                }
                                result.share_ip = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allowed_clients_cidr => {
                                if !fields.insert(__FieldTag::__allowed_clients_cidr) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_clients_cidr",
                                    ));
                                }
                                result.allowed_clients_cidr = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mount_permissions => {
                                if !fields.insert(__FieldTag::__mount_permissions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mount_permissions",
                                    ));
                                }
                                result.mount_permissions =
                                    map.next_value::<std::option::Option<
                                        crate::model::nfs_share::MountPermissions,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_dev => {
                                if !fields.insert(__FieldTag::__allow_dev) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_dev",
                                    ));
                                }
                                result.allow_dev = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_suid => {
                                if !fields.insert(__FieldTag::__allow_suid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_suid",
                                    ));
                                }
                                result.allow_suid = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__no_root_squash => {
                                if !fields.insert(__FieldTag::__no_root_squash) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_root_squash",
                                    ));
                                }
                                result.no_root_squash = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__nfs_path => {
                                if !fields.insert(__FieldTag::__nfs_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for nfs_path",
                                    ));
                                }
                                result.nfs_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AllowedClient {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network.is_empty() {
                state.serialize_entry("network", &self.network)?;
            }
            if !self.share_ip.is_empty() {
                state.serialize_entry("shareIp", &self.share_ip)?;
            }
            if !self.allowed_clients_cidr.is_empty() {
                state.serialize_entry("allowedClientsCidr", &self.allowed_clients_cidr)?;
            }
            if !wkt::internal::is_default(&self.mount_permissions) {
                state.serialize_entry("mountPermissions", &self.mount_permissions)?;
            }
            if !wkt::internal::is_default(&self.allow_dev) {
                state.serialize_entry("allowDev", &self.allow_dev)?;
            }
            if !wkt::internal::is_default(&self.allow_suid) {
                state.serialize_entry("allowSuid", &self.allow_suid)?;
            }
            if !wkt::internal::is_default(&self.no_root_squash) {
                state.serialize_entry("noRootSquash", &self.no_root_squash)?;
            }
            if !self.nfs_path.is_empty() {
                state.serialize_entry("nfsPath", &self.nfs_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The possible states for this NFS share.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The share is in an unknown state.
        Unspecified,
        /// The share has been provisioned.
        Provisioned,
        /// The NFS Share is being created.
        Creating,
        /// The NFS Share is being updated.
        Updating,
        /// The NFS Share has been requested to be deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioned => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioned,
                2 => Self::Creating,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONED" => Self::Provisioned,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioned => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.NfsShare.State",
            ))
        }
    }

    /// The possible mount permissions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MountPermissions {
        /// Permissions were not specified.
        Unspecified,
        /// NFS share can be mount with read-only permissions.
        Read,
        /// NFS share can be mount with read-write permissions.
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MountPermissions::value] or
        /// [MountPermissions::name].
        UnknownValue(mount_permissions::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mount_permissions {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MountPermissions {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Read => std::option::Option::Some(1),
                Self::ReadWrite => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MOUNT_PERMISSIONS_UNSPECIFIED"),
                Self::Read => std::option::Option::Some("READ"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MountPermissions {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MountPermissions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MountPermissions {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Read,
                2 => Self::ReadWrite,
                _ => Self::UnknownValue(mount_permissions::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MountPermissions {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MOUNT_PERMISSIONS_UNSPECIFIED" => Self::Unspecified,
                "READ" => Self::Read,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(mount_permissions::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MountPermissions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Read => serializer.serialize_i32(1),
                Self::ReadWrite => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MountPermissions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MountPermissions>::new(
                ".google.cloud.baremetalsolution.v2.NfsShare.MountPermissions",
            ))
        }
    }

    /// The storage type for a volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The storage type for this volume is unknown.
        Unspecified,
        /// The storage type for this volume is SSD.
        Ssd,
        /// This storage type for this volume is HDD.
        Hdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ssd => std::option::Option::Some(1),
                Self::Hdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Ssd => std::option::Option::Some("SSD"),
                Self::Hdd => std::option::Option::Some("HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ssd,
                2 => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SSD" => Self::Ssd,
                "HDD" => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ssd => serializer.serialize_i32(1),
                Self::Hdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.baremetalsolution.v2.NfsShare.StorageType",
            ))
        }
    }
}

/// Message for requesting NFS share information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNfsShareRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetNfsShareRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNfsShareRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNfsShareRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNfsShareRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNfsShareRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNfsShareRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting a list of NFS shares.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNfsSharesRequest {
    /// Required. Parent value for ListNfsSharesRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNfsSharesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNfsSharesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNfsSharesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNfsSharesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNfsSharesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListNfsSharesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNfsSharesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNfsSharesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNfsSharesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNfsSharesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNfsSharesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNfsSharesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing the list of NFS shares.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNfsSharesResponse {
    /// The list of NFS shares.
    pub nfs_shares: std::vec::Vec<crate::model::NfsShare>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNfsSharesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nfs_shares][crate::model::ListNfsSharesResponse::nfs_shares].
    pub fn set_nfs_shares<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NfsShare>,
    {
        use std::iter::Iterator;
        self.nfs_shares = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNfsSharesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNfsSharesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNfsSharesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListNfsSharesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNfsSharesResponse {
    type PageItem = crate::model::NfsShare;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.nfs_shares
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNfsSharesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __nfs_shares,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNfsSharesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nfsShares" => Ok(__FieldTag::__nfs_shares),
                            "nfs_shares" => Ok(__FieldTag::__nfs_shares),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNfsSharesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNfsSharesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__nfs_shares => {
                            if !fields.insert(__FieldTag::__nfs_shares) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_shares",
                                ));
                            }
                            result.nfs_shares = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NfsShare>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNfsSharesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nfs_shares.is_empty() {
            state.serialize_entry("nfsShares", &self.nfs_shares)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting to updating an NFS share.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNfsShareRequest {
    /// Required. The NFS share to update.
    ///
    /// The `name` field is used to identify the NFS share to update.
    /// Format: projects/{project}/locations/{location}/nfsShares/{nfs_share}
    pub nfs_share: std::option::Option<crate::model::NfsShare>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// `labels`
    /// `allowed_clients`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nfs_share][crate::model::UpdateNfsShareRequest::nfs_share].
    pub fn set_nfs_share<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfs_share][crate::model::UpdateNfsShareRequest::nfs_share].
    pub fn set_or_clear_nfs_share<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNfsShareRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNfsShareRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateNfsShareRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNfsShareRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __nfs_share,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNfsShareRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nfsShare" => Ok(__FieldTag::__nfs_share),
                            "nfs_share" => Ok(__FieldTag::__nfs_share),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNfsShareRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNfsShareRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__nfs_share => {
                            if !fields.insert(__FieldTag::__nfs_share) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_share",
                                ));
                            }
                            result.nfs_share =
                                map.next_value::<std::option::Option<crate::model::NfsShare>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNfsShareRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.nfs_share.is_some() {
            state.serialize_entry("nfsShare", &self.nfs_share)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameNfsShareRequest {
    /// Required. The `name` field is used to identify the nfsshare.
    /// Format: projects/{project}/locations/{location}/nfsshares/{nfsshare}
    pub name: std::string::String,

    /// Required. The new `id` of the nfsshare.
    pub new_nfsshare_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_nfsshare_id][crate::model::RenameNfsShareRequest::new_nfsshare_id].
    pub fn set_new_nfsshare_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_nfsshare_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameNfsShareRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenameNfsShareRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __new_nfsshare_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenameNfsShareRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "newNfsshareId" => Ok(__FieldTag::__new_nfsshare_id),
                            "new_nfsshare_id" => Ok(__FieldTag::__new_nfsshare_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenameNfsShareRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenameNfsShareRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_nfsshare_id => {
                            if !fields.insert(__FieldTag::__new_nfsshare_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_nfsshare_id",
                                ));
                            }
                            result.new_nfsshare_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenameNfsShareRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.new_nfsshare_id.is_empty() {
            state.serialize_entry("newNfsshareId", &self.new_nfsshare_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating an NFS share.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNfsShareRequest {
    /// Required. The parent project and location.
    pub parent: std::string::String,

    /// Required. The NfsShare to create.
    pub nfs_share: std::option::Option<crate::model::NfsShare>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNfsShareRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [nfs_share][crate::model::CreateNfsShareRequest::nfs_share].
    pub fn set_nfs_share<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfs_share][crate::model::CreateNfsShareRequest::nfs_share].
    pub fn set_or_clear_nfs_share<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NfsShare>,
    {
        self.nfs_share = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateNfsShareRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNfsShareRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __nfs_share,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNfsShareRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "nfsShare" => Ok(__FieldTag::__nfs_share),
                            "nfs_share" => Ok(__FieldTag::__nfs_share),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNfsShareRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNfsShareRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nfs_share => {
                            if !fields.insert(__FieldTag::__nfs_share) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_share",
                                ));
                            }
                            result.nfs_share =
                                map.next_value::<std::option::Option<crate::model::NfsShare>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNfsShareRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.nfs_share.is_some() {
            state.serialize_entry("nfsShare", &self.nfs_share)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting an NFS share.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNfsShareRequest {
    /// Required. The name of the NFS share to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNfsShareRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNfsShareRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNfsShareRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteNfsShareRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteNfsShareRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNfsShareRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteNfsShareRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNfsShareRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteNfsShareRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Operation System image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OSImage {
    /// Output only. OS Image's unique name.
    pub name: std::string::String,

    /// OS Image code.
    pub code: std::string::String,

    /// OS Image description.
    pub description: std::string::String,

    /// Instance types this image is applicable to.
    /// [Available
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub applicable_instance_types: std::vec::Vec<std::string::String>,

    /// Network templates that can be used with this OS Image.
    pub supported_network_templates: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::OSImage::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSImage::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [applicable_instance_types][crate::model::OSImage::applicable_instance_types].
    pub fn set_applicable_instance_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_instance_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_network_templates][crate::model::OSImage::supported_network_templates].
    pub fn set_supported_network_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_network_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OSImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.OSImage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OSImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __code,
            __description,
            __applicable_instance_types,
            __supported_network_templates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "code" => Ok(__FieldTag::__code),
                            "description" => Ok(__FieldTag::__description),
                            "applicableInstanceTypes" => {
                                Ok(__FieldTag::__applicable_instance_types)
                            }
                            "applicable_instance_types" => {
                                Ok(__FieldTag::__applicable_instance_types)
                            }
                            "supportedNetworkTemplates" => {
                                Ok(__FieldTag::__supported_network_templates)
                            }
                            "supported_network_templates" => {
                                Ok(__FieldTag::__supported_network_templates)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OSImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applicable_instance_types => {
                            if !fields.insert(__FieldTag::__applicable_instance_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applicable_instance_types",
                                ));
                            }
                            result.applicable_instance_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__supported_network_templates => {
                            if !fields.insert(__FieldTag::__supported_network_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_network_templates",
                                ));
                            }
                            result.supported_network_templates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OSImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.applicable_instance_types.is_empty() {
            state.serialize_entry("applicableInstanceTypes", &self.applicable_instance_types)?;
        }
        if !self.supported_network_templates.is_empty() {
            state.serialize_entry(
                "supportedNetworkTemplates",
                &self.supported_network_templates,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for getting all available OS images.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSImagesRequest {
    /// Required. Parent value for ListProvisioningQuotasRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    /// Notice that page_size field is not supported and won't be respected in
    /// the API request for now, will be updated when pagination is supported.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSImagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSImagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListOSImagesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSImagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSImagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSImagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSImagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSImagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for getting all available OS images.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSImagesResponse {
    /// The OS images available.
    pub os_images: std::vec::Vec<crate::model::OSImage>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_images][crate::model::ListOSImagesResponse::os_images].
    pub fn set_os_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSImage>,
    {
        use std::iter::Iterator;
        self.os_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSImagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListOSImagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSImagesResponse {
    type PageItem = crate::model::OSImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_images
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSImagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_images,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSImagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osImages" => Ok(__FieldTag::__os_images),
                            "os_images" => Ok(__FieldTag::__os_images),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSImagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSImagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_images => {
                            if !fields.insert(__FieldTag::__os_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_images",
                                ));
                            }
                            result.os_images = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OSImage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSImagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_images.is_empty() {
            state.serialize_entry("osImages", &self.os_images)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A provisioning configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProvisioningConfig {
    /// Output only. The system-generated name of the provisioning config. This
    /// follows the UUID format.
    pub name: std::string::String,

    /// Instances to be created.
    pub instances: std::vec::Vec<crate::model::InstanceConfig>,

    /// Networks to be created.
    pub networks: std::vec::Vec<crate::model::NetworkConfig>,

    /// Volumes to be created.
    pub volumes: std::vec::Vec<crate::model::VolumeConfig>,

    /// A generated ticket id to track provisioning request.
    pub ticket_id: std::string::String,

    /// A service account to enable customers to access instance credentials upon
    /// handover.
    pub handover_service_account: std::string::String,

    /// Email provided to send a confirmation with provisioning config to.
    /// Deprecated in favour of email field in request messages.
    #[deprecated]
    pub email: std::string::String,

    /// Output only. State of ProvisioningConfig.
    pub state: crate::model::provisioning_config::State,

    /// Optional. Location name of this ProvisioningConfig.
    /// It is optional only for Intake UI transition period.
    pub location: std::string::String,

    /// Output only. Last update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. URI to Cloud Console UI view of this provisioning config.
    pub cloud_console_uri: std::string::String,

    /// If true, VPC SC is enabled for the cluster.
    pub vpc_sc_enabled: bool,

    /// Optional status messages associated with the FAILED state.
    pub status_message: std::string::String,

    /// Optional. The user-defined identifier of the provisioning config.
    pub custom_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisioningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisioningConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ProvisioningConfig::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceConfig>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::ProvisioningConfig::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::ProvisioningConfig::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeConfig>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ticket_id][crate::model::ProvisioningConfig::ticket_id].
    pub fn set_ticket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ticket_id = v.into();
        self
    }

    /// Sets the value of [handover_service_account][crate::model::ProvisioningConfig::handover_service_account].
    pub fn set_handover_service_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.handover_service_account = v.into();
        self
    }

    /// Sets the value of [email][crate::model::ProvisioningConfig::email].
    #[deprecated]
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ProvisioningConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::provisioning_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ProvisioningConfig::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ProvisioningConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ProvisioningConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_console_uri][crate::model::ProvisioningConfig::cloud_console_uri].
    pub fn set_cloud_console_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_console_uri = v.into();
        self
    }

    /// Sets the value of [vpc_sc_enabled][crate::model::ProvisioningConfig::vpc_sc_enabled].
    pub fn set_vpc_sc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vpc_sc_enabled = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::ProvisioningConfig::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [custom_id][crate::model::ProvisioningConfig::custom_id].
    pub fn set_custom_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_id = v.into();
        self
    }
}

impl wkt::message::Message for ProvisioningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ProvisioningConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProvisioningConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instances,
            __networks,
            __volumes,
            __ticket_id,
            __handover_service_account,
            __email,
            __state,
            __location,
            __update_time,
            __cloud_console_uri,
            __vpc_sc_enabled,
            __status_message,
            __custom_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProvisioningConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instances" => Ok(__FieldTag::__instances),
                            "networks" => Ok(__FieldTag::__networks),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "ticketId" => Ok(__FieldTag::__ticket_id),
                            "ticket_id" => Ok(__FieldTag::__ticket_id),
                            "handoverServiceAccount" => Ok(__FieldTag::__handover_service_account),
                            "handover_service_account" => {
                                Ok(__FieldTag::__handover_service_account)
                            }
                            "email" => Ok(__FieldTag::__email),
                            "state" => Ok(__FieldTag::__state),
                            "location" => Ok(__FieldTag::__location),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "cloudConsoleUri" => Ok(__FieldTag::__cloud_console_uri),
                            "cloud_console_uri" => Ok(__FieldTag::__cloud_console_uri),
                            "vpcScEnabled" => Ok(__FieldTag::__vpc_sc_enabled),
                            "vpc_sc_enabled" => Ok(__FieldTag::__vpc_sc_enabled),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "customId" => Ok(__FieldTag::__custom_id),
                            "custom_id" => Ok(__FieldTag::__custom_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProvisioningConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProvisioningConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InstanceConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NetworkConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VolumeConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ticket_id => {
                            if !fields.insert(__FieldTag::__ticket_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ticket_id",
                                ));
                            }
                            result.ticket_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__handover_service_account => {
                            if !fields.insert(__FieldTag::__handover_service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for handover_service_account",
                                ));
                            }
                            result.handover_service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::provisioning_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cloud_console_uri => {
                            if !fields.insert(__FieldTag::__cloud_console_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_console_uri",
                                ));
                            }
                            result.cloud_console_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_sc_enabled => {
                            if !fields.insert(__FieldTag::__vpc_sc_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_sc_enabled",
                                ));
                            }
                            result.vpc_sc_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_id => {
                            if !fields.insert(__FieldTag::__custom_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_id",
                                ));
                            }
                            result.custom_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProvisioningConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.networks.is_empty() {
            state.serialize_entry("networks", &self.networks)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !self.ticket_id.is_empty() {
            state.serialize_entry("ticketId", &self.ticket_id)?;
        }
        if !self.handover_service_account.is_empty() {
            state.serialize_entry("handoverServiceAccount", &self.handover_service_account)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.cloud_console_uri.is_empty() {
            state.serialize_entry("cloudConsoleUri", &self.cloud_console_uri)?;
        }
        if !wkt::internal::is_default(&self.vpc_sc_enabled) {
            state.serialize_entry("vpcScEnabled", &self.vpc_sc_enabled)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self.custom_id.is_empty() {
            state.serialize_entry("customId", &self.custom_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ProvisioningConfig].
pub mod provisioning_config {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states for this ProvisioningConfig.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State wasn't specified.
        Unspecified,
        /// ProvisioningConfig is a draft and can be freely modified.
        Draft,
        /// ProvisioningConfig was already submitted and cannot be modified.
        Submitted,
        /// ProvisioningConfig was in the provisioning state.  Initially this state
        /// comes from the work order table in big query when SNOW is used.  Later
        /// this field can be set by the work order API.
        Provisioning,
        /// ProvisioningConfig was provisioned, meaning the resources exist.
        Provisioned,
        /// ProvisioningConfig was validated.  A validation tool will be run to
        /// set this state.
        Validated,
        /// ProvisioningConfig was canceled.
        Cancelled,
        /// The request is submitted for provisioning, with error return.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Submitted => std::option::Option::Some(2),
                Self::Provisioning => std::option::Option::Some(3),
                Self::Provisioned => std::option::Option::Some(4),
                Self::Validated => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Submitted => std::option::Option::Some("SUBMITTED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Provisioned => std::option::Option::Some("PROVISIONED"),
                Self::Validated => std::option::Option::Some("VALIDATED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Submitted,
                3 => Self::Provisioning,
                4 => Self::Provisioned,
                5 => Self::Validated,
                6 => Self::Cancelled,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "SUBMITTED" => Self::Submitted,
                "PROVISIONING" => Self::Provisioning,
                "PROVISIONED" => Self::Provisioned,
                "VALIDATED" => Self::Validated,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Submitted => serializer.serialize_i32(2),
                Self::Provisioning => serializer.serialize_i32(3),
                Self::Provisioned => serializer.serialize_i32(4),
                Self::Validated => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.ProvisioningConfig.State",
            ))
        }
    }
}

/// Request for SubmitProvisioningConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitProvisioningConfigRequest {
    /// Required. The parent project and location containing the
    /// ProvisioningConfig.
    pub parent: std::string::String,

    /// Required. The ProvisioningConfig to create.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitProvisioningConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [provisioning_config][crate::model::SubmitProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::SubmitProvisioningConfigRequest::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [email][crate::model::SubmitProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for SubmitProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SubmitProvisioningConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitProvisioningConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __provisioning_config,
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitProvisioningConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "provisioningConfig" => Ok(__FieldTag::__provisioning_config),
                            "provisioning_config" => Ok(__FieldTag::__provisioning_config),
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitProvisioningConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitProvisioningConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__provisioning_config => {
                            if !fields.insert(__FieldTag::__provisioning_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_config",
                                ));
                            }
                            result.provisioning_config = map.next_value::<std::option::Option<crate::model::ProvisioningConfig>>()?
                                ;
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitProvisioningConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.provisioning_config.is_some() {
            state.serialize_entry("provisioningConfig", &self.provisioning_config)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for SubmitProvisioningConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitProvisioningConfigResponse {
    /// The submitted provisioning config.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitProvisioningConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_config][crate::model::SubmitProvisioningConfigResponse::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::SubmitProvisioningConfigResponse::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitProvisioningConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SubmitProvisioningConfigResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitProvisioningConfigResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provisioning_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitProvisioningConfigResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provisioningConfig" => Ok(__FieldTag::__provisioning_config),
                            "provisioning_config" => Ok(__FieldTag::__provisioning_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitProvisioningConfigResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitProvisioningConfigResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provisioning_config => {
                            if !fields.insert(__FieldTag::__provisioning_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_config",
                                ));
                            }
                            result.provisioning_config = map.next_value::<std::option::Option<crate::model::ProvisioningConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitProvisioningConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.provisioning_config.is_some() {
            state.serialize_entry("provisioningConfig", &self.provisioning_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A provisioning quota for a given project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProvisioningQuota {
    /// Output only. The name of the provisioning quota.
    pub name: std::string::String,

    /// The asset type of this provisioning quota.
    pub asset_type: crate::model::provisioning_quota::AssetType,

    /// The gcp service of the provisioning quota.
    pub gcp_service: std::string::String,

    /// The specific location of the provisioining quota.
    pub location: std::string::String,

    /// The available count of the provisioning quota.
    pub available_count: i32,

    /// The quota of one asset type.
    pub quota: std::option::Option<crate::model::provisioning_quota::Quota>,

    /// Available quantity based on asset type.
    pub availability: std::option::Option<crate::model::provisioning_quota::Availability>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisioningQuota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisioningQuota::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::ProvisioningQuota::asset_type].
    pub fn set_asset_type<T: std::convert::Into<crate::model::provisioning_quota::AssetType>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset_type = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::ProvisioningQuota::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ProvisioningQuota::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [available_count][crate::model::ProvisioningQuota::available_count].
    pub fn set_available_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_count = v.into();
        self
    }

    /// Sets the value of [quota][crate::model::ProvisioningQuota::quota].
    ///
    /// Note that all the setters affecting `quota` are mutually
    /// exclusive.
    pub fn set_quota<
        T: std::convert::Into<std::option::Option<crate::model::provisioning_quota::Quota>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quota = v.into();
        self
    }

    /// The value of [quota][crate::model::ProvisioningQuota::quota]
    /// if it holds a `InstanceQuota`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instance_quota(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstanceQuota>> {
        #[allow(unreachable_patterns)]
        self.quota.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Quota::InstanceQuota(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [quota][crate::model::ProvisioningQuota::quota]
    /// to hold a `InstanceQuota`.
    ///
    /// Note that all the setters affecting `quota` are
    /// mutually exclusive.
    pub fn set_instance_quota<
        T: std::convert::Into<std::boxed::Box<crate::model::InstanceQuota>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quota = std::option::Option::Some(
            crate::model::provisioning_quota::Quota::InstanceQuota(v.into()),
        );
        self
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability].
    ///
    /// Note that all the setters affecting `availability` are mutually
    /// exclusive.
    pub fn set_availability<
        T: std::convert::Into<std::option::Option<crate::model::provisioning_quota::Availability>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `ServerCount`, `None` if the field is not set or
    /// holds a different branch.
    pub fn server_count(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::ServerCount(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `ServerCount`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_server_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::ServerCount(v.into()),
        );
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `NetworkBandwidth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn network_bandwidth(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::NetworkBandwidth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `NetworkBandwidth`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_network_bandwidth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::NetworkBandwidth(v.into()),
        );
        self
    }

    /// The value of [availability][crate::model::ProvisioningQuota::availability]
    /// if it holds a `StorageGib`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_gib(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.availability.as_ref().and_then(|v| match v {
            crate::model::provisioning_quota::Availability::StorageGib(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [availability][crate::model::ProvisioningQuota::availability]
    /// to hold a `StorageGib`.
    ///
    /// Note that all the setters affecting `availability` are
    /// mutually exclusive.
    pub fn set_storage_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.availability = std::option::Option::Some(
            crate::model::provisioning_quota::Availability::StorageGib(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ProvisioningQuota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ProvisioningQuota"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProvisioningQuota {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __asset_type,
            __gcp_service,
            __location,
            __available_count,
            __instance_quota,
            __server_count,
            __network_bandwidth,
            __storage_gib,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProvisioningQuota")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "assetType" => Ok(__FieldTag::__asset_type),
                            "asset_type" => Ok(__FieldTag::__asset_type),
                            "gcpService" => Ok(__FieldTag::__gcp_service),
                            "gcp_service" => Ok(__FieldTag::__gcp_service),
                            "location" => Ok(__FieldTag::__location),
                            "availableCount" => Ok(__FieldTag::__available_count),
                            "available_count" => Ok(__FieldTag::__available_count),
                            "instanceQuota" => Ok(__FieldTag::__instance_quota),
                            "instance_quota" => Ok(__FieldTag::__instance_quota),
                            "serverCount" => Ok(__FieldTag::__server_count),
                            "server_count" => Ok(__FieldTag::__server_count),
                            "networkBandwidth" => Ok(__FieldTag::__network_bandwidth),
                            "network_bandwidth" => Ok(__FieldTag::__network_bandwidth),
                            "storageGib" => Ok(__FieldTag::__storage_gib),
                            "storage_gib" => Ok(__FieldTag::__storage_gib),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProvisioningQuota;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProvisioningQuota")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_type => {
                            if !fields.insert(__FieldTag::__asset_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_type",
                                ));
                            }
                            result.asset_type =
                                map.next_value::<std::option::Option<
                                    crate::model::provisioning_quota::AssetType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_service => {
                            if !fields.insert(__FieldTag::__gcp_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_service",
                                ));
                            }
                            result.gcp_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_count => {
                            if !fields.insert(__FieldTag::__available_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance_quota => {
                            if !fields.insert(__FieldTag::__instance_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_quota",
                                ));
                            }
                            if result.quota.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `quota`, a oneof with full ID .google.cloud.baremetalsolution.v2.ProvisioningQuota.instance_quota, latest field was instanceQuota",
                                ));
                            }
                            result.quota = std::option::Option::Some(
                                crate::model::provisioning_quota::Quota::InstanceQuota(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstanceQuota>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__server_count => {
                            if !fields.insert(__FieldTag::__server_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.availability.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `availability`, a oneof with full ID .google.cloud.baremetalsolution.v2.ProvisioningQuota.server_count, latest field was serverCount",
                                ));
                            }
                            result.availability = std::option::Option::Some(
                                crate::model::provisioning_quota::Availability::ServerCount(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__network_bandwidth => {
                            if !fields.insert(__FieldTag::__network_bandwidth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_bandwidth",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.availability.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `availability`, a oneof with full ID .google.cloud.baremetalsolution.v2.ProvisioningQuota.network_bandwidth, latest field was networkBandwidth",
                                ));
                            }
                            result.availability = std::option::Option::Some(
                                crate::model::provisioning_quota::Availability::NetworkBandwidth(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__storage_gib => {
                            if !fields.insert(__FieldTag::__storage_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.availability.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `availability`, a oneof with full ID .google.cloud.baremetalsolution.v2.ProvisioningQuota.storage_gib, latest field was storageGib",
                                ));
                            }
                            result.availability = std::option::Option::Some(
                                crate::model::provisioning_quota::Availability::StorageGib(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProvisioningQuota {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.asset_type) {
            state.serialize_entry("assetType", &self.asset_type)?;
        }
        if !self.gcp_service.is_empty() {
            state.serialize_entry("gcpService", &self.gcp_service)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.available_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("availableCount", &__With(&self.available_count))?;
        }
        if let Some(value) = self.instance_quota() {
            state.serialize_entry("instanceQuota", value)?;
        }
        if let Some(value) = self.server_count() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("serverCount", &__With(value))?;
        }
        if let Some(value) = self.network_bandwidth() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("networkBandwidth", &__With(value))?;
        }
        if let Some(value) = self.storage_gib() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("storageGib", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ProvisioningQuota].
pub mod provisioning_quota {
    #[allow(unused_imports)]
    use super::*;

    /// The available asset types for intake.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AssetType {
        /// The unspecified type.
        Unspecified,
        /// The server asset type.
        Server,
        /// The storage asset type.
        Storage,
        /// The network asset type.
        Network,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AssetType::value] or
        /// [AssetType::name].
        UnknownValue(asset_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod asset_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AssetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Server => std::option::Option::Some(1),
                Self::Storage => std::option::Option::Some(2),
                Self::Network => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ASSET_TYPE_UNSPECIFIED"),
                Self::Server => std::option::Option::Some("ASSET_TYPE_SERVER"),
                Self::Storage => std::option::Option::Some("ASSET_TYPE_STORAGE"),
                Self::Network => std::option::Option::Some("ASSET_TYPE_NETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AssetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AssetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AssetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Server,
                2 => Self::Storage,
                3 => Self::Network,
                _ => Self::UnknownValue(asset_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AssetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ASSET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ASSET_TYPE_SERVER" => Self::Server,
                "ASSET_TYPE_STORAGE" => Self::Storage,
                "ASSET_TYPE_NETWORK" => Self::Network,
                _ => Self::UnknownValue(asset_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AssetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Server => serializer.serialize_i32(1),
                Self::Storage => serializer.serialize_i32(2),
                Self::Network => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AssetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AssetType>::new(
                ".google.cloud.baremetalsolution.v2.ProvisioningQuota.AssetType",
            ))
        }
    }

    /// The quota of one asset type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Quota {
        /// Instance quota.
        InstanceQuota(std::boxed::Box<crate::model::InstanceQuota>),
    }

    /// Available quantity based on asset type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Availability {
        /// Server count.
        ServerCount(i64),
        /// Network bandwidth, Gbps
        NetworkBandwidth(i64),
        /// Storage size (GB).
        StorageGib(i64),
    }
}

/// Message for requesting the list of provisioning quotas.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvisioningQuotasRequest {
    /// Required. Parent value for ListProvisioningQuotasRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    /// Notice that page_size field is not supported and won't be respected in
    /// the API request for now, will be updated when pagination is supported.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvisioningQuotasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProvisioningQuotasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProvisioningQuotasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProvisioningQuotasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvisioningQuotasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListProvisioningQuotasRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProvisioningQuotasRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProvisioningQuotasRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProvisioningQuotasRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProvisioningQuotasRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProvisioningQuotasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the list of provisioning quotas.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProvisioningQuotasResponse {
    /// The provisioning quotas registered in this project.
    pub provisioning_quotas: std::vec::Vec<crate::model::ProvisioningQuota>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProvisioningQuotasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_quotas][crate::model::ListProvisioningQuotasResponse::provisioning_quotas].
    pub fn set_provisioning_quotas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProvisioningQuota>,
    {
        use std::iter::Iterator;
        self.provisioning_quotas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProvisioningQuotasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProvisioningQuotasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListProvisioningQuotasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProvisioningQuotasResponse {
    type PageItem = crate::model::ProvisioningQuota;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.provisioning_quotas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProvisioningQuotasResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provisioning_quotas,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProvisioningQuotasResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provisioningQuotas" => Ok(__FieldTag::__provisioning_quotas),
                            "provisioning_quotas" => Ok(__FieldTag::__provisioning_quotas),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProvisioningQuotasResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProvisioningQuotasResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provisioning_quotas => {
                            if !fields.insert(__FieldTag::__provisioning_quotas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_quotas",
                                ));
                            }
                            result.provisioning_quotas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ProvisioningQuota>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProvisioningQuotasResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.provisioning_quotas.is_empty() {
            state.serialize_entry("provisioningQuotas", &self.provisioning_quotas)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration parameters for a new instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceConfig {
    /// Output only. The name of the instance config.
    pub name: std::string::String,

    /// A transient unique identifier to idenfity an instance within an
    /// ProvisioningConfig request.
    pub id: std::string::String,

    /// Instance type.
    /// [Available
    /// types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub instance_type: std::string::String,

    /// Whether the instance should be provisioned with Hyperthreading enabled.
    pub hyperthreading: bool,

    /// OS image to initialize the instance.
    /// [Available
    /// images](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
    pub os_image: std::string::String,

    /// Client network address. Filled if InstanceConfig.multivlan_config is false.
    #[deprecated]
    pub client_network: std::option::Option<crate::model::instance_config::NetworkAddress>,

    /// Private network address, if any. Filled if InstanceConfig.multivlan_config
    /// is false.
    #[deprecated]
    pub private_network: std::option::Option<crate::model::instance_config::NetworkAddress>,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    pub user_note: std::string::String,

    /// If true networks can be from different projects of the same vendor account.
    pub account_networks_enabled: bool,

    /// The type of network configuration on the instance.
    pub network_config: crate::model::instance_config::NetworkConfig,

    /// Server network template name. Filled if InstanceConfig.multivlan_config is
    /// true.
    pub network_template: std::string::String,

    /// List of logical interfaces for the instance. The number of logical
    /// interfaces will be the same as number of hardware bond/nic on the chosen
    /// network template. Filled if InstanceConfig.multivlan_config is true.
    pub logical_interfaces: std::vec::Vec<crate::model::LogicalInterface>,

    /// List of names of ssh keys used to provision the instance.
    pub ssh_key_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::InstanceConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::InstanceConfig::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [hyperthreading][crate::model::InstanceConfig::hyperthreading].
    pub fn set_hyperthreading<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hyperthreading = v.into();
        self
    }

    /// Sets the value of [os_image][crate::model::InstanceConfig::os_image].
    pub fn set_os_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_image = v.into();
        self
    }

    /// Sets the value of [client_network][crate::model::InstanceConfig::client_network].
    #[deprecated]
    pub fn set_client_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.client_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_network][crate::model::InstanceConfig::client_network].
    #[deprecated]
    pub fn set_or_clear_client_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.client_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_network][crate::model::InstanceConfig::private_network].
    #[deprecated]
    pub fn set_private_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.private_network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_network][crate::model::InstanceConfig::private_network].
    #[deprecated]
    pub fn set_or_clear_private_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_config::NetworkAddress>,
    {
        self.private_network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_note][crate::model::InstanceConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [account_networks_enabled][crate::model::InstanceConfig::account_networks_enabled].
    pub fn set_account_networks_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.account_networks_enabled = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::InstanceConfig::network_config].
    pub fn set_network_config<
        T: std::convert::Into<crate::model::instance_config::NetworkConfig>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [network_template][crate::model::InstanceConfig::network_template].
    pub fn set_network_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_template = v.into();
        self
    }

    /// Sets the value of [logical_interfaces][crate::model::InstanceConfig::logical_interfaces].
    pub fn set_logical_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalInterface>,
    {
        use std::iter::Iterator;
        self.logical_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ssh_key_names][crate::model::InstanceConfig::ssh_key_names].
    pub fn set_ssh_key_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ssh_key_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __instance_type,
            __hyperthreading,
            __os_image,
            __client_network,
            __private_network,
            __user_note,
            __account_networks_enabled,
            __network_config,
            __network_template,
            __logical_interfaces,
            __ssh_key_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "hyperthreading" => Ok(__FieldTag::__hyperthreading),
                            "osImage" => Ok(__FieldTag::__os_image),
                            "os_image" => Ok(__FieldTag::__os_image),
                            "clientNetwork" => Ok(__FieldTag::__client_network),
                            "client_network" => Ok(__FieldTag::__client_network),
                            "privateNetwork" => Ok(__FieldTag::__private_network),
                            "private_network" => Ok(__FieldTag::__private_network),
                            "userNote" => Ok(__FieldTag::__user_note),
                            "user_note" => Ok(__FieldTag::__user_note),
                            "accountNetworksEnabled" => Ok(__FieldTag::__account_networks_enabled),
                            "account_networks_enabled" => {
                                Ok(__FieldTag::__account_networks_enabled)
                            }
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "networkTemplate" => Ok(__FieldTag::__network_template),
                            "network_template" => Ok(__FieldTag::__network_template),
                            "logicalInterfaces" => Ok(__FieldTag::__logical_interfaces),
                            "logical_interfaces" => Ok(__FieldTag::__logical_interfaces),
                            "sshKeyNames" => Ok(__FieldTag::__ssh_key_names),
                            "ssh_key_names" => Ok(__FieldTag::__ssh_key_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hyperthreading => {
                            if !fields.insert(__FieldTag::__hyperthreading) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hyperthreading",
                                ));
                            }
                            result.hyperthreading = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_image => {
                            if !fields.insert(__FieldTag::__os_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_image",
                                ));
                            }
                            result.os_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_network => {
                            if !fields.insert(__FieldTag::__client_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_network",
                                ));
                            }
                            result.client_network = map.next_value::<std::option::Option<
                                crate::model::instance_config::NetworkAddress,
                            >>()?;
                        }
                        __FieldTag::__private_network => {
                            if !fields.insert(__FieldTag::__private_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_network",
                                ));
                            }
                            result.private_network = map.next_value::<std::option::Option<
                                crate::model::instance_config::NetworkAddress,
                            >>()?;
                        }
                        __FieldTag::__user_note => {
                            if !fields.insert(__FieldTag::__user_note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_note",
                                ));
                            }
                            result.user_note = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_networks_enabled => {
                            if !fields.insert(__FieldTag::__account_networks_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_networks_enabled",
                                ));
                            }
                            result.account_networks_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config =
                                map.next_value::<std::option::Option<
                                    crate::model::instance_config::NetworkConfig,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_template => {
                            if !fields.insert(__FieldTag::__network_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_template",
                                ));
                            }
                            result.network_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logical_interfaces => {
                            if !fields.insert(__FieldTag::__logical_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_interfaces",
                                ));
                            }
                            result.logical_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LogicalInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_key_names => {
                            if !fields.insert(__FieldTag::__ssh_key_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_key_names",
                                ));
                            }
                            result.ssh_key_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !wkt::internal::is_default(&self.hyperthreading) {
            state.serialize_entry("hyperthreading", &self.hyperthreading)?;
        }
        if !self.os_image.is_empty() {
            state.serialize_entry("osImage", &self.os_image)?;
        }
        if self.client_network.is_some() {
            state.serialize_entry("clientNetwork", &self.client_network)?;
        }
        if self.private_network.is_some() {
            state.serialize_entry("privateNetwork", &self.private_network)?;
        }
        if !self.user_note.is_empty() {
            state.serialize_entry("userNote", &self.user_note)?;
        }
        if !wkt::internal::is_default(&self.account_networks_enabled) {
            state.serialize_entry("accountNetworksEnabled", &self.account_networks_enabled)?;
        }
        if !wkt::internal::is_default(&self.network_config) {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self.network_template.is_empty() {
            state.serialize_entry("networkTemplate", &self.network_template)?;
        }
        if !self.logical_interfaces.is_empty() {
            state.serialize_entry("logicalInterfaces", &self.logical_interfaces)?;
        }
        if !self.ssh_key_names.is_empty() {
            state.serialize_entry("sshKeyNames", &self.ssh_key_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InstanceConfig].
pub mod instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// A network.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkAddress {
        /// Id of the network to use, within the same ProvisioningConfig request.
        pub network_id: std::string::String,

        /// IPv4 address to be assigned to the server.
        pub address: std::string::String,

        /// Name of the existing network to use.
        pub existing_network_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkAddress {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_id][crate::model::instance_config::NetworkAddress::network_id].
        pub fn set_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network_id = v.into();
            self
        }

        /// Sets the value of [address][crate::model::instance_config::NetworkAddress::address].
        pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.address = v.into();
            self
        }

        /// Sets the value of [existing_network_id][crate::model::instance_config::NetworkAddress::existing_network_id].
        pub fn set_existing_network_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.existing_network_id = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkAddress {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceConfig.NetworkAddress"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NetworkAddress {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_id,
                __address,
                __existing_network_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NetworkAddress")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkId" => Ok(__FieldTag::__network_id),
                                "network_id" => Ok(__FieldTag::__network_id),
                                "address" => Ok(__FieldTag::__address),
                                "existingNetworkId" => Ok(__FieldTag::__existing_network_id),
                                "existing_network_id" => Ok(__FieldTag::__existing_network_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NetworkAddress;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NetworkAddress")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_id => {
                                if !fields.insert(__FieldTag::__network_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_id",
                                    ));
                                }
                                result.network_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__address => {
                                if !fields.insert(__FieldTag::__address) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for address",
                                    ));
                                }
                                result.address = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__existing_network_id => {
                                if !fields.insert(__FieldTag::__existing_network_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for existing_network_id",
                                    ));
                                }
                                result.existing_network_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NetworkAddress {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network_id.is_empty() {
                state.serialize_entry("networkId", &self.network_id)?;
            }
            if !self.address.is_empty() {
                state.serialize_entry("address", &self.address)?;
            }
            if !self.existing_network_id.is_empty() {
                state.serialize_entry("existingNetworkId", &self.existing_network_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The network configuration of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkConfig {
        /// The unspecified network configuration.
        NetworkconfigUnspecified,
        /// Instance part of single client network and single private network.
        SingleVlan,
        /// Instance part of multiple (or single) client networks and private
        /// networks.
        MultiVlan,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkConfig::value] or
        /// [NetworkConfig::name].
        UnknownValue(network_config::UnknownValue),
    }

    #[doc(hidden)]
    pub mod network_config {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NetworkConfig {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NetworkconfigUnspecified => std::option::Option::Some(0),
                Self::SingleVlan => std::option::Option::Some(1),
                Self::MultiVlan => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NetworkconfigUnspecified => {
                    std::option::Option::Some("NETWORKCONFIG_UNSPECIFIED")
                }
                Self::SingleVlan => std::option::Option::Some("SINGLE_VLAN"),
                Self::MultiVlan => std::option::Option::Some("MULTI_VLAN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NetworkConfig {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NetworkConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NetworkConfig {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NetworkconfigUnspecified,
                1 => Self::SingleVlan,
                2 => Self::MultiVlan,
                _ => Self::UnknownValue(network_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NetworkConfig {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NETWORKCONFIG_UNSPECIFIED" => Self::NetworkconfigUnspecified,
                "SINGLE_VLAN" => Self::SingleVlan,
                "MULTI_VLAN" => Self::MultiVlan,
                _ => Self::UnknownValue(network_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NetworkConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NetworkconfigUnspecified => serializer.serialize_i32(0),
                Self::SingleVlan => serializer.serialize_i32(1),
                Self::MultiVlan => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkConfig>::new(
                ".google.cloud.baremetalsolution.v2.InstanceConfig.NetworkConfig",
            ))
        }
    }
}

/// Configuration parameters for a new volume.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeConfig {
    /// Output only. The name of the volume config.
    pub name: std::string::String,

    /// A transient unique identifier to identify a volume within an
    /// ProvisioningConfig request.
    pub id: std::string::String,

    /// Whether snapshots should be enabled.
    pub snapshots_enabled: bool,

    /// The type of this Volume.
    pub r#type: crate::model::volume_config::Type,

    /// Volume protocol.
    pub protocol: crate::model::volume_config::Protocol,

    /// The requested size of this volume, in GB.
    pub size_gb: i32,

    /// LUN ranges to be configured. Set only when protocol is PROTOCOL_FC.
    pub lun_ranges: std::vec::Vec<crate::model::volume_config::LunRange>,

    /// Machine ids connected to this volume. Set only when protocol is
    /// PROTOCOL_FC.
    pub machine_ids: std::vec::Vec<std::string::String>,

    /// NFS exports. Set only when protocol is PROTOCOL_NFS.
    pub nfs_exports: std::vec::Vec<crate::model::volume_config::NfsExport>,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    pub user_note: std::string::String,

    /// The GCP service of the storage volume. Available gcp_service are in
    /// <https://cloud.google.com/bare-metal/docs/bms-planning>.
    pub gcp_service: std::string::String,

    /// Performance tier of the Volume.
    /// Default is SHARED.
    pub performance_tier: crate::model::VolumePerformanceTier,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::VolumeConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [snapshots_enabled][crate::model::VolumeConfig::snapshots_enabled].
    pub fn set_snapshots_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshots_enabled = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VolumeConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::volume_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::VolumeConfig::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::volume_config::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::VolumeConfig::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [lun_ranges][crate::model::VolumeConfig::lun_ranges].
    pub fn set_lun_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::volume_config::LunRange>,
    {
        use std::iter::Iterator;
        self.lun_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [machine_ids][crate::model::VolumeConfig::machine_ids].
    pub fn set_machine_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.machine_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nfs_exports][crate::model::VolumeConfig::nfs_exports].
    pub fn set_nfs_exports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::volume_config::NfsExport>,
    {
        use std::iter::Iterator;
        self.nfs_exports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_note][crate::model::VolumeConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::VolumeConfig::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [performance_tier][crate::model::VolumeConfig::performance_tier].
    pub fn set_performance_tier<T: std::convert::Into<crate::model::VolumePerformanceTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.performance_tier = v.into();
        self
    }
}

impl wkt::message::Message for VolumeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __snapshots_enabled,
            __type,
            __protocol,
            __size_gb,
            __lun_ranges,
            __machine_ids,
            __nfs_exports,
            __user_note,
            __gcp_service,
            __performance_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "snapshotsEnabled" => Ok(__FieldTag::__snapshots_enabled),
                            "snapshots_enabled" => Ok(__FieldTag::__snapshots_enabled),
                            "type" => Ok(__FieldTag::__type),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            "lunRanges" => Ok(__FieldTag::__lun_ranges),
                            "lun_ranges" => Ok(__FieldTag::__lun_ranges),
                            "machineIds" => Ok(__FieldTag::__machine_ids),
                            "machine_ids" => Ok(__FieldTag::__machine_ids),
                            "nfsExports" => Ok(__FieldTag::__nfs_exports),
                            "nfs_exports" => Ok(__FieldTag::__nfs_exports),
                            "userNote" => Ok(__FieldTag::__user_note),
                            "user_note" => Ok(__FieldTag::__user_note),
                            "gcpService" => Ok(__FieldTag::__gcp_service),
                            "gcp_service" => Ok(__FieldTag::__gcp_service),
                            "performanceTier" => Ok(__FieldTag::__performance_tier),
                            "performance_tier" => Ok(__FieldTag::__performance_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshots_enabled => {
                            if !fields.insert(__FieldTag::__snapshots_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots_enabled",
                                ));
                            }
                            result.snapshots_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::volume_config::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map.next_value::<std::option::Option<crate::model::volume_config::Protocol>>()?.unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__lun_ranges => {
                            if !fields.insert(__FieldTag::__lun_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lun_ranges",
                                ));
                            }
                            result.lun_ranges = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::volume_config::LunRange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_ids => {
                            if !fields.insert(__FieldTag::__machine_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_ids",
                                ));
                            }
                            result.machine_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__nfs_exports => {
                            if !fields.insert(__FieldTag::__nfs_exports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_exports",
                                ));
                            }
                            result.nfs_exports = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::volume_config::NfsExport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_note => {
                            if !fields.insert(__FieldTag::__user_note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_note",
                                ));
                            }
                            result.user_note = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_service => {
                            if !fields.insert(__FieldTag::__gcp_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_service",
                                ));
                            }
                            result.gcp_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__performance_tier => {
                            if !fields.insert(__FieldTag::__performance_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_tier",
                                ));
                            }
                            result.performance_tier = map.next_value::<std::option::Option<crate::model::VolumePerformanceTier>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.snapshots_enabled) {
            state.serialize_entry("snapshotsEnabled", &self.snapshots_enabled)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.protocol) {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !wkt::internal::is_default(&self.size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !self.lun_ranges.is_empty() {
            state.serialize_entry("lunRanges", &self.lun_ranges)?;
        }
        if !self.machine_ids.is_empty() {
            state.serialize_entry("machineIds", &self.machine_ids)?;
        }
        if !self.nfs_exports.is_empty() {
            state.serialize_entry("nfsExports", &self.nfs_exports)?;
        }
        if !self.user_note.is_empty() {
            state.serialize_entry("userNote", &self.user_note)?;
        }
        if !self.gcp_service.is_empty() {
            state.serialize_entry("gcpService", &self.gcp_service)?;
        }
        if !wkt::internal::is_default(&self.performance_tier) {
            state.serialize_entry("performanceTier", &self.performance_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VolumeConfig].
pub mod volume_config {
    #[allow(unused_imports)]
    use super::*;

    /// A LUN(Logical Unit Number) range.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LunRange {
        /// Number of LUNs to create.
        pub quantity: i32,

        /// The requested size of each LUN, in GB.
        pub size_gb: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LunRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [quantity][crate::model::volume_config::LunRange::quantity].
        pub fn set_quantity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.quantity = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::volume_config::LunRange::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for LunRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig.LunRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LunRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __quantity,
                __size_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LunRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "quantity" => Ok(__FieldTag::__quantity),
                                "sizeGb" => Ok(__FieldTag::__size_gb),
                                "size_gb" => Ok(__FieldTag::__size_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LunRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LunRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__quantity => {
                                if !fields.insert(__FieldTag::__quantity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quantity",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.quantity = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__size_gb => {
                                if !fields.insert(__FieldTag::__size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LunRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.quantity) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("quantity", &__With(&self.quantity))?;
            }
            if !wkt::internal::is_default(&self.size_gb) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A NFS export entry.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NfsExport {
        /// Network to use to publish the export.
        pub network_id: std::string::String,

        /// Export permissions.
        pub permissions: crate::model::volume_config::nfs_export::Permissions,

        /// Disable root squashing, which is a feature of NFS.
        /// Root squash is a special mapping of the remote superuser (root) identity
        /// when using identity authentication.
        pub no_root_squash: bool,

        /// Allow the setuid flag.
        pub allow_suid: bool,

        /// Allow dev flag in NfsShare AllowedClientsRequest.
        pub allow_dev: bool,

        /// A client object.
        pub client: std::option::Option<crate::model::volume_config::nfs_export::Client>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NfsExport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_id][crate::model::volume_config::NfsExport::network_id].
        pub fn set_network_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network_id = v.into();
            self
        }

        /// Sets the value of [permissions][crate::model::volume_config::NfsExport::permissions].
        pub fn set_permissions<
            T: std::convert::Into<crate::model::volume_config::nfs_export::Permissions>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.permissions = v.into();
            self
        }

        /// Sets the value of [no_root_squash][crate::model::volume_config::NfsExport::no_root_squash].
        pub fn set_no_root_squash<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_root_squash = v.into();
            self
        }

        /// Sets the value of [allow_suid][crate::model::volume_config::NfsExport::allow_suid].
        pub fn set_allow_suid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_suid = v.into();
            self
        }

        /// Sets the value of [allow_dev][crate::model::volume_config::NfsExport::allow_dev].
        pub fn set_allow_dev<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_dev = v.into();
            self
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client].
        ///
        /// Note that all the setters affecting `client` are mutually
        /// exclusive.
        pub fn set_client<
            T: std::convert::Into<
                    std::option::Option<crate::model::volume_config::nfs_export::Client>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.client = v.into();
            self
        }

        /// The value of [client][crate::model::volume_config::NfsExport::client]
        /// if it holds a `MachineId`, `None` if the field is not set or
        /// holds a different branch.
        pub fn machine_id(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.client.as_ref().and_then(|v| match v {
                crate::model::volume_config::nfs_export::Client::MachineId(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client]
        /// to hold a `MachineId`.
        ///
        /// Note that all the setters affecting `client` are
        /// mutually exclusive.
        pub fn set_machine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client = std::option::Option::Some(
                crate::model::volume_config::nfs_export::Client::MachineId(v.into()),
            );
            self
        }

        /// The value of [client][crate::model::volume_config::NfsExport::client]
        /// if it holds a `Cidr`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cidr(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.client.as_ref().and_then(|v| match v {
                crate::model::volume_config::nfs_export::Client::Cidr(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [client][crate::model::volume_config::NfsExport::client]
        /// to hold a `Cidr`.
        ///
        /// Note that all the setters affecting `client` are
        /// mutually exclusive.
        pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client = std::option::Option::Some(
                crate::model::volume_config::nfs_export::Client::Cidr(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for NfsExport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NfsExport {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_id,
                __machine_id,
                __cidr,
                __permissions,
                __no_root_squash,
                __allow_suid,
                __allow_dev,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NfsExport")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkId" => Ok(__FieldTag::__network_id),
                                "network_id" => Ok(__FieldTag::__network_id),
                                "machineId" => Ok(__FieldTag::__machine_id),
                                "machine_id" => Ok(__FieldTag::__machine_id),
                                "cidr" => Ok(__FieldTag::__cidr),
                                "permissions" => Ok(__FieldTag::__permissions),
                                "noRootSquash" => Ok(__FieldTag::__no_root_squash),
                                "no_root_squash" => Ok(__FieldTag::__no_root_squash),
                                "allowSuid" => Ok(__FieldTag::__allow_suid),
                                "allow_suid" => Ok(__FieldTag::__allow_suid),
                                "allowDev" => Ok(__FieldTag::__allow_dev),
                                "allow_dev" => Ok(__FieldTag::__allow_dev),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NfsExport;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NfsExport")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_id => {
                                if !fields.insert(__FieldTag::__network_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_id",
                                    ));
                                }
                                result.network_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__machine_id => {
                                if !fields.insert(__FieldTag::__machine_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_id",
                                    ));
                                }
                                if result.client.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `client`, a oneof with full ID .google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport.machine_id, latest field was machineId",
                                    ));
                                }
                                result.client = std::option::Option::Some(
                                    crate::model::volume_config::nfs_export::Client::MachineId(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__cidr => {
                                if !fields.insert(__FieldTag::__cidr) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cidr",
                                    ));
                                }
                                if result.client.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `client`, a oneof with full ID .google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport.cidr, latest field was cidr",
                                    ));
                                }
                                result.client = std::option::Option::Some(
                                    crate::model::volume_config::nfs_export::Client::Cidr(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__permissions => {
                                if !fields.insert(__FieldTag::__permissions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permissions",
                                    ));
                                }
                                result.permissions = map
                                    .next_value::<std::option::Option<
                                        crate::model::volume_config::nfs_export::Permissions,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__no_root_squash => {
                                if !fields.insert(__FieldTag::__no_root_squash) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_root_squash",
                                    ));
                                }
                                result.no_root_squash = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_suid => {
                                if !fields.insert(__FieldTag::__allow_suid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_suid",
                                    ));
                                }
                                result.allow_suid = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_dev => {
                                if !fields.insert(__FieldTag::__allow_dev) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_dev",
                                    ));
                                }
                                result.allow_dev = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NfsExport {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network_id.is_empty() {
                state.serialize_entry("networkId", &self.network_id)?;
            }
            if let Some(value) = self.machine_id() {
                state.serialize_entry("machineId", value)?;
            }
            if let Some(value) = self.cidr() {
                state.serialize_entry("cidr", value)?;
            }
            if !wkt::internal::is_default(&self.permissions) {
                state.serialize_entry("permissions", &self.permissions)?;
            }
            if !wkt::internal::is_default(&self.no_root_squash) {
                state.serialize_entry("noRootSquash", &self.no_root_squash)?;
            }
            if !wkt::internal::is_default(&self.allow_suid) {
                state.serialize_entry("allowSuid", &self.allow_suid)?;
            }
            if !wkt::internal::is_default(&self.allow_dev) {
                state.serialize_entry("allowDev", &self.allow_dev)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [NfsExport].
    pub mod nfs_export {
        #[allow(unused_imports)]
        use super::*;

        /// Permissions that can granted for an export.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Permissions {
            /// Unspecified value.
            Unspecified,
            /// Read-only permission.
            ReadOnly,
            /// Read-write permission.
            ReadWrite,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Permissions::value] or
            /// [Permissions::name].
            UnknownValue(permissions::UnknownValue),
        }

        #[doc(hidden)]
        pub mod permissions {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Permissions {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ReadOnly => std::option::Option::Some(1),
                    Self::ReadWrite => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PERMISSIONS_UNSPECIFIED"),
                    Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                    Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Permissions {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Permissions {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Permissions {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ReadOnly,
                    2 => Self::ReadWrite,
                    _ => Self::UnknownValue(permissions::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Permissions {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PERMISSIONS_UNSPECIFIED" => Self::Unspecified,
                    "READ_ONLY" => Self::ReadOnly,
                    "READ_WRITE" => Self::ReadWrite,
                    _ => Self::UnknownValue(permissions::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Permissions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ReadOnly => serializer.serialize_i32(1),
                    Self::ReadWrite => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Permissions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Permissions>::new(
                    ".google.cloud.baremetalsolution.v2.VolumeConfig.NfsExport.Permissions",
                ))
            }
        }

        /// A client object.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Client {
            /// Either a single machine, identified by an ID, or a comma-separated
            /// list of machine IDs.
            MachineId(std::string::String),
            /// A CIDR range.
            Cidr(std::string::String),
        }
    }

    /// The types of Volumes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The unspecified type.
        Unspecified,
        /// This Volume is on flash.
        Flash,
        /// This Volume is on disk.
        Disk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Flash => std::option::Option::Some(1),
                Self::Disk => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Flash => std::option::Option::Some("FLASH"),
                Self::Disk => std::option::Option::Some("DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Flash,
                2 => Self::Disk,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "FLASH" => Self::Flash,
                "DISK" => Self::Disk,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Flash => serializer.serialize_i32(1),
                Self::Disk => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.baremetalsolution.v2.VolumeConfig.Type",
            ))
        }
    }

    /// The protocol used to access the volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Unspecified value.
        Unspecified,
        /// Fibre channel.
        Fc,
        /// Network file system.
        Nfs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fc => std::option::Option::Some(1),
                Self::Nfs => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Fc => std::option::Option::Some("PROTOCOL_FC"),
                Self::Nfs => std::option::Option::Some("PROTOCOL_NFS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fc,
                2 => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "PROTOCOL_FC" => Self::Fc,
                "PROTOCOL_NFS" => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fc => serializer.serialize_i32(1),
                Self::Nfs => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.baremetalsolution.v2.VolumeConfig.Protocol",
            ))
        }
    }
}

/// Configuration parameters for a new network.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Output only. The name of the network config.
    pub name: std::string::String,

    /// A transient unique identifier to identify a volume within an
    /// ProvisioningConfig request.
    pub id: std::string::String,

    /// The type of this network, either Client or Private.
    pub r#type: crate::model::network_config::Type,

    /// Interconnect bandwidth. Set only when type is CLIENT.
    pub bandwidth: crate::model::network_config::Bandwidth,

    /// List of VLAN attachments. As of now there are always 2 attachments, but it
    /// is going to change in  the future (multi vlan).
    pub vlan_attachments: std::vec::Vec<crate::model::network_config::IntakeVlanAttachment>,

    /// CIDR range of the network.
    pub cidr: std::string::String,

    /// Service CIDR, if any.
    pub service_cidr: crate::model::network_config::ServiceCidr,

    /// User note field, it can be used by customers to add additional information
    /// for the BMS Ops team .
    pub user_note: std::string::String,

    /// The GCP service of the network. Available gcp_service are in
    /// <https://cloud.google.com/bare-metal/docs/bms-planning>.
    pub gcp_service: std::string::String,

    /// Whether the VLAN attachment pair is located in the same project.
    pub vlan_same_project: bool,

    /// The JumboFramesEnabled option for customer to set.
    pub jumbo_frames_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NetworkConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::NetworkConfig::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::NetworkConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::network_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [bandwidth][crate::model::NetworkConfig::bandwidth].
    pub fn set_bandwidth<T: std::convert::Into<crate::model::network_config::Bandwidth>>(
        mut self,
        v: T,
    ) -> Self {
        self.bandwidth = v.into();
        self
    }

    /// Sets the value of [vlan_attachments][crate::model::NetworkConfig::vlan_attachments].
    pub fn set_vlan_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::network_config::IntakeVlanAttachment>,
    {
        use std::iter::Iterator;
        self.vlan_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cidr][crate::model::NetworkConfig::cidr].
    pub fn set_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cidr = v.into();
        self
    }

    /// Sets the value of [service_cidr][crate::model::NetworkConfig::service_cidr].
    pub fn set_service_cidr<T: std::convert::Into<crate::model::network_config::ServiceCidr>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_cidr = v.into();
        self
    }

    /// Sets the value of [user_note][crate::model::NetworkConfig::user_note].
    pub fn set_user_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_note = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::NetworkConfig::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [vlan_same_project][crate::model::NetworkConfig::vlan_same_project].
    pub fn set_vlan_same_project<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.vlan_same_project = v.into();
        self
    }

    /// Sets the value of [jumbo_frames_enabled][crate::model::NetworkConfig::jumbo_frames_enabled].
    pub fn set_jumbo_frames_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.jumbo_frames_enabled = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __type,
            __bandwidth,
            __vlan_attachments,
            __cidr,
            __service_cidr,
            __user_note,
            __gcp_service,
            __vlan_same_project,
            __jumbo_frames_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "type" => Ok(__FieldTag::__type),
                            "bandwidth" => Ok(__FieldTag::__bandwidth),
                            "vlanAttachments" => Ok(__FieldTag::__vlan_attachments),
                            "vlan_attachments" => Ok(__FieldTag::__vlan_attachments),
                            "cidr" => Ok(__FieldTag::__cidr),
                            "serviceCidr" => Ok(__FieldTag::__service_cidr),
                            "service_cidr" => Ok(__FieldTag::__service_cidr),
                            "userNote" => Ok(__FieldTag::__user_note),
                            "user_note" => Ok(__FieldTag::__user_note),
                            "gcpService" => Ok(__FieldTag::__gcp_service),
                            "gcp_service" => Ok(__FieldTag::__gcp_service),
                            "vlanSameProject" => Ok(__FieldTag::__vlan_same_project),
                            "vlan_same_project" => Ok(__FieldTag::__vlan_same_project),
                            "jumboFramesEnabled" => Ok(__FieldTag::__jumbo_frames_enabled),
                            "jumbo_frames_enabled" => Ok(__FieldTag::__jumbo_frames_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::network_config::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__bandwidth => {
                            if !fields.insert(__FieldTag::__bandwidth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bandwidth",
                                ));
                            }
                            result.bandwidth = map.next_value::<std::option::Option<crate::model::network_config::Bandwidth>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vlan_attachments => {
                            if !fields.insert(__FieldTag::__vlan_attachments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vlan_attachments",
                                ));
                            }
                            result.vlan_attachments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::network_config::IntakeVlanAttachment,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr => {
                            if !fields.insert(__FieldTag::__cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr",
                                ));
                            }
                            result.cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_cidr => {
                            if !fields.insert(__FieldTag::__service_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_cidr",
                                ));
                            }
                            result.service_cidr = map.next_value::<std::option::Option<crate::model::network_config::ServiceCidr>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_note => {
                            if !fields.insert(__FieldTag::__user_note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_note",
                                ));
                            }
                            result.user_note = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_service => {
                            if !fields.insert(__FieldTag::__gcp_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_service",
                                ));
                            }
                            result.gcp_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vlan_same_project => {
                            if !fields.insert(__FieldTag::__vlan_same_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vlan_same_project",
                                ));
                            }
                            result.vlan_same_project = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jumbo_frames_enabled => {
                            if !fields.insert(__FieldTag::__jumbo_frames_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jumbo_frames_enabled",
                                ));
                            }
                            result.jumbo_frames_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.bandwidth) {
            state.serialize_entry("bandwidth", &self.bandwidth)?;
        }
        if !self.vlan_attachments.is_empty() {
            state.serialize_entry("vlanAttachments", &self.vlan_attachments)?;
        }
        if !self.cidr.is_empty() {
            state.serialize_entry("cidr", &self.cidr)?;
        }
        if !wkt::internal::is_default(&self.service_cidr) {
            state.serialize_entry("serviceCidr", &self.service_cidr)?;
        }
        if !self.user_note.is_empty() {
            state.serialize_entry("userNote", &self.user_note)?;
        }
        if !self.gcp_service.is_empty() {
            state.serialize_entry("gcpService", &self.gcp_service)?;
        }
        if !wkt::internal::is_default(&self.vlan_same_project) {
            state.serialize_entry("vlanSameProject", &self.vlan_same_project)?;
        }
        if !wkt::internal::is_default(&self.jumbo_frames_enabled) {
            state.serialize_entry("jumboFramesEnabled", &self.jumbo_frames_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NetworkConfig].
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// A GCP vlan attachment.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntakeVlanAttachment {
        /// Identifier of the VLAN attachment.
        pub id: std::string::String,

        /// Attachment pairing key.
        pub pairing_key: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntakeVlanAttachment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::network_config::IntakeVlanAttachment::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [pairing_key][crate::model::network_config::IntakeVlanAttachment::pairing_key].
        pub fn set_pairing_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.pairing_key = v.into();
            self
        }
    }

    impl wkt::message::Message for IntakeVlanAttachment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.NetworkConfig.IntakeVlanAttachment"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IntakeVlanAttachment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __pairing_key,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IntakeVlanAttachment")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "pairingKey" => Ok(__FieldTag::__pairing_key),
                                "pairing_key" => Ok(__FieldTag::__pairing_key),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IntakeVlanAttachment;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IntakeVlanAttachment")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pairing_key => {
                                if !fields.insert(__FieldTag::__pairing_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pairing_key",
                                    ));
                                }
                                result.pairing_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IntakeVlanAttachment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.pairing_key.is_empty() {
                state.serialize_entry("pairingKey", &self.pairing_key)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Network type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified value.
        Unspecified,
        /// Client network, that is a network peered to a GCP VPC.
        Client,
        /// Private network, that is a network local to the BMS POD.
        Private,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Client => std::option::Option::Some(1),
                Self::Private => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Client => std::option::Option::Some("CLIENT"),
                Self::Private => std::option::Option::Some("PRIVATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Client,
                2 => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLIENT" => Self::Client,
                "PRIVATE" => Self::Private,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Client => serializer.serialize_i32(1),
                Self::Private => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.baremetalsolution.v2.NetworkConfig.Type",
            ))
        }
    }

    /// Interconnect bandwidth.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Bandwidth {
        /// Unspecified value.
        Unspecified,
        /// 1 Gbps.
        Bw1Gbps,
        /// 2 Gbps.
        Bw2Gbps,
        /// 5 Gbps.
        Bw5Gbps,
        /// 10 Gbps.
        Bw10Gbps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Bandwidth::value] or
        /// [Bandwidth::name].
        UnknownValue(bandwidth::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bandwidth {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Bandwidth {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Bw1Gbps => std::option::Option::Some(1),
                Self::Bw2Gbps => std::option::Option::Some(2),
                Self::Bw5Gbps => std::option::Option::Some(3),
                Self::Bw10Gbps => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BANDWIDTH_UNSPECIFIED"),
                Self::Bw1Gbps => std::option::Option::Some("BW_1_GBPS"),
                Self::Bw2Gbps => std::option::Option::Some("BW_2_GBPS"),
                Self::Bw5Gbps => std::option::Option::Some("BW_5_GBPS"),
                Self::Bw10Gbps => std::option::Option::Some("BW_10_GBPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Bandwidth {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Bandwidth {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Bandwidth {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Bw1Gbps,
                2 => Self::Bw2Gbps,
                3 => Self::Bw5Gbps,
                4 => Self::Bw10Gbps,
                _ => Self::UnknownValue(bandwidth::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Bandwidth {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BANDWIDTH_UNSPECIFIED" => Self::Unspecified,
                "BW_1_GBPS" => Self::Bw1Gbps,
                "BW_2_GBPS" => Self::Bw2Gbps,
                "BW_5_GBPS" => Self::Bw5Gbps,
                "BW_10_GBPS" => Self::Bw10Gbps,
                _ => Self::UnknownValue(bandwidth::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Bandwidth {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Bw1Gbps => serializer.serialize_i32(1),
                Self::Bw2Gbps => serializer.serialize_i32(2),
                Self::Bw5Gbps => serializer.serialize_i32(3),
                Self::Bw10Gbps => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Bandwidth {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Bandwidth>::new(
                ".google.cloud.baremetalsolution.v2.NetworkConfig.Bandwidth",
            ))
        }
    }

    /// Service network block.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServiceCidr {
        /// Unspecified value.
        Unspecified,
        /// Services are disabled for the given network.
        Disabled,
        /// Use the highest /26 block of the network to host services.
        High26,
        /// Use the highest /27 block of the network to host services.
        High27,
        /// Use the highest /28 block of the network to host services.
        High28,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ServiceCidr::value] or
        /// [ServiceCidr::name].
        UnknownValue(service_cidr::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service_cidr {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ServiceCidr {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::High26 => std::option::Option::Some(2),
                Self::High27 => std::option::Option::Some(3),
                Self::High28 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_CIDR_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::High26 => std::option::Option::Some("HIGH_26"),
                Self::High27 => std::option::Option::Some("HIGH_27"),
                Self::High28 => std::option::Option::Some("HIGH_28"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ServiceCidr {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ServiceCidr {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ServiceCidr {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::High26,
                3 => Self::High27,
                4 => Self::High28,
                _ => Self::UnknownValue(service_cidr::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ServiceCidr {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_CIDR_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "HIGH_26" => Self::High26,
                "HIGH_27" => Self::High27,
                "HIGH_28" => Self::High28,
                _ => Self::UnknownValue(service_cidr::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ServiceCidr {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::High26 => serializer.serialize_i32(2),
                Self::High27 => serializer.serialize_i32(3),
                Self::High28 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ServiceCidr {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceCidr>::new(
                ".google.cloud.baremetalsolution.v2.NetworkConfig.ServiceCidr",
            ))
        }
    }
}

/// A resource budget.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceQuota {
    /// Output only. The name of the instance quota.
    pub name: std::string::String,

    /// Instance type.
    /// Deprecated: use gcp_service.
    #[deprecated]
    pub instance_type: std::string::String,

    /// The gcp service of the provisioning quota.
    pub gcp_service: std::string::String,

    /// Location where the quota applies.
    pub location: std::string::String,

    /// Number of machines than can be created for the given location and
    /// instance_type.
    pub available_machine_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceQuota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceQuota::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::InstanceQuota::instance_type].
    #[deprecated]
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [gcp_service][crate::model::InstanceQuota::gcp_service].
    pub fn set_gcp_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcp_service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::InstanceQuota::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [available_machine_count][crate::model::InstanceQuota::available_machine_count].
    pub fn set_available_machine_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_machine_count = v.into();
        self
    }
}

impl wkt::message::Message for InstanceQuota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.InstanceQuota"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceQuota {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance_type,
            __gcp_service,
            __location,
            __available_machine_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceQuota")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "gcpService" => Ok(__FieldTag::__gcp_service),
                            "gcp_service" => Ok(__FieldTag::__gcp_service),
                            "location" => Ok(__FieldTag::__location),
                            "availableMachineCount" => Ok(__FieldTag::__available_machine_count),
                            "available_machine_count" => Ok(__FieldTag::__available_machine_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceQuota;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceQuota")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_service => {
                            if !fields.insert(__FieldTag::__gcp_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_service",
                                ));
                            }
                            result.gcp_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_machine_count => {
                            if !fields.insert(__FieldTag::__available_machine_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_machine_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_machine_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceQuota {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !self.gcp_service.is_empty() {
            state.serialize_entry("gcpService", &self.gcp_service)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.available_machine_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableMachineCount",
                &__With(&self.available_machine_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for GetProvisioningConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProvisioningConfigRequest {
    /// Required. Name of the ProvisioningConfig.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProvisioningConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetProvisioningConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProvisioningConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProvisioningConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProvisioningConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProvisioningConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProvisioningConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for CreateProvisioningConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateProvisioningConfigRequest {
    /// Required. The parent project and location containing the
    /// ProvisioningConfig.
    pub parent: std::string::String,

    /// Required. The ProvisioningConfig to create.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProvisioningConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [provisioning_config][crate::model::CreateProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::CreateProvisioningConfigRequest::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [email][crate::model::CreateProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for CreateProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateProvisioningConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateProvisioningConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __provisioning_config,
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateProvisioningConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "provisioningConfig" => Ok(__FieldTag::__provisioning_config),
                            "provisioning_config" => Ok(__FieldTag::__provisioning_config),
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateProvisioningConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateProvisioningConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__provisioning_config => {
                            if !fields.insert(__FieldTag::__provisioning_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_config",
                                ));
                            }
                            result.provisioning_config = map.next_value::<std::option::Option<crate::model::ProvisioningConfig>>()?
                                ;
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateProvisioningConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.provisioning_config.is_some() {
            state.serialize_entry("provisioningConfig", &self.provisioning_config)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a ProvisioningConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProvisioningConfigRequest {
    /// Required. The ProvisioningConfig to update.
    pub provisioning_config: std::option::Option<crate::model::ProvisioningConfig>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Email provided to send a confirmation with provisioning config
    /// to.
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProvisioningConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_config][crate::model::UpdateProvisioningConfigRequest::provisioning_config].
    pub fn set_provisioning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_config][crate::model::UpdateProvisioningConfigRequest::provisioning_config].
    pub fn set_or_clear_provisioning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProvisioningConfig>,
    {
        self.provisioning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProvisioningConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateProvisioningConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [email][crate::model::UpdateProvisioningConfigRequest::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProvisioningConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateProvisioningConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateProvisioningConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provisioning_config,
            __update_mask,
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateProvisioningConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provisioningConfig" => Ok(__FieldTag::__provisioning_config),
                            "provisioning_config" => Ok(__FieldTag::__provisioning_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateProvisioningConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateProvisioningConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provisioning_config => {
                            if !fields.insert(__FieldTag::__provisioning_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_config",
                                ));
                            }
                            result.provisioning_config = map.next_value::<std::option::Option<crate::model::ProvisioningConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateProvisioningConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.provisioning_config.is_some() {
            state.serialize_entry("provisioningConfig", &self.provisioning_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An SSH key, used for authorizing with the interactive serial console feature.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SSHKey {
    /// Output only. The name of this SSH key.
    /// Currently, the only valid value for the location is "global".
    pub name: std::string::String,

    /// The public SSH key. This must be in OpenSSH .authorized_keys format.
    pub public_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SSHKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SSHKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::SSHKey::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }
}

impl wkt::message::Message for SSHKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.SSHKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SSHKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __public_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SSHKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SSHKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SSHKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SSHKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.public_key.is_empty() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for listing the public SSH keys in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSSHKeysRequest {
    /// Required. The parent containing the SSH keys.
    /// Currently, the only valid value for the location is "global".
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSSHKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSSHKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSSHKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSSHKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSSHKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListSSHKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSSHKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSSHKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSSHKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSSHKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSSHKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response of ListSSHKeys.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSSHKeysResponse {
    /// The SSH keys registered in the project.
    pub ssh_keys: std::vec::Vec<crate::model::SSHKey>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSSHKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssh_keys][crate::model::ListSSHKeysResponse::ssh_keys].
    pub fn set_ssh_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SSHKey>,
    {
        use std::iter::Iterator;
        self.ssh_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSSHKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSSHKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListSSHKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSSHKeysResponse {
    type PageItem = crate::model::SSHKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ssh_keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSSHKeysResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ssh_keys,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSSHKeysResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sshKeys" => Ok(__FieldTag::__ssh_keys),
                            "ssh_keys" => Ok(__FieldTag::__ssh_keys),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSSHKeysResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSSHKeysResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ssh_keys => {
                            if !fields.insert(__FieldTag::__ssh_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_keys",
                                ));
                            }
                            result.ssh_keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SSHKey>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSSHKeysResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssh_keys.is_empty() {
            state.serialize_entry("sshKeys", &self.ssh_keys)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for registering a public SSH key in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSSHKeyRequest {
    /// Required. The parent containing the SSH keys.
    pub parent: std::string::String,

    /// Required. The SSH key to register.
    pub ssh_key: std::option::Option<crate::model::SSHKey>,

    /// Required. The ID to use for the key, which will become the final component
    /// of the key's resource name.
    ///
    /// This value must match the regex:
    /// [a-zA-Z0-9@.\-_]{1,64}
    pub ssh_key_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSSHKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSSHKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [ssh_key][crate::model::CreateSSHKeyRequest::ssh_key].
    pub fn set_ssh_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SSHKey>,
    {
        self.ssh_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssh_key][crate::model::CreateSSHKeyRequest::ssh_key].
    pub fn set_or_clear_ssh_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SSHKey>,
    {
        self.ssh_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssh_key_id][crate::model::CreateSSHKeyRequest::ssh_key_id].
    pub fn set_ssh_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssh_key_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSSHKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateSSHKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSSHKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __ssh_key,
            __ssh_key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSSHKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sshKey" => Ok(__FieldTag::__ssh_key),
                            "ssh_key" => Ok(__FieldTag::__ssh_key),
                            "sshKeyId" => Ok(__FieldTag::__ssh_key_id),
                            "ssh_key_id" => Ok(__FieldTag::__ssh_key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSSHKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSSHKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssh_key => {
                            if !fields.insert(__FieldTag::__ssh_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_key",
                                ));
                            }
                            result.ssh_key =
                                map.next_value::<std::option::Option<crate::model::SSHKey>>()?;
                        }
                        __FieldTag::__ssh_key_id => {
                            if !fields.insert(__FieldTag::__ssh_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssh_key_id",
                                ));
                            }
                            result.ssh_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSSHKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.ssh_key.is_some() {
            state.serialize_entry("sshKey", &self.ssh_key)?;
        }
        if !self.ssh_key_id.is_empty() {
            state.serialize_entry("sshKeyId", &self.ssh_key_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting an SSH key from a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSSHKeyRequest {
    /// Required. The name of the SSH key to delete.
    /// Currently, the only valid value for the location is "global".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSSHKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSSHKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSSHKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteSSHKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSSHKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSSHKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSSHKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSSHKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSSHKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A storage volume.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Volume {
    /// Output only. The resource name of this `Volume`.
    /// Resource names are schemeless URIs that follow the conventions in
    /// <https://cloud.google.com/apis/design/resource_names>.
    /// Format:
    /// `projects/{project}/locations/{location}/volumes/{volume}`
    pub name: std::string::String,

    /// An identifier for the `Volume`, generated by the backend.
    pub id: std::string::String,

    /// The storage type for this volume.
    pub storage_type: crate::model::volume::StorageType,

    /// The state of this storage volume.
    pub state: crate::model::volume::State,

    /// The requested size of this storage volume, in GiB.
    pub requested_size_gib: i64,

    /// Originally requested size, in GiB.
    pub originally_requested_size_gib: i64,

    /// The current size of this storage volume, in GiB, including space reserved
    /// for snapshots. This size might be different than the requested size if the
    /// storage volume has been configured with auto grow or auto shrink.
    pub current_size_gib: i64,

    /// Additional emergency size that was requested for this Volume, in GiB.
    /// current_size_gib includes this value.
    pub emergency_size_gib: i64,

    /// Maximum size volume can be expanded to in case of evergency, in GiB.
    pub max_size_gib: i64,

    /// The size, in GiB, that this storage volume has expanded as a result of an
    /// auto grow policy. In the absence of auto-grow, the value is 0.
    pub auto_grown_size_gib: i64,

    /// The space remaining in the storage volume for new LUNs, in GiB, excluding
    /// space reserved for snapshots.
    pub remaining_space_gib: i64,

    /// Details about snapshot space reservation and usage on the storage volume.
    pub snapshot_reservation_detail:
        std::option::Option<crate::model::volume::SnapshotReservationDetail>,

    /// The behavior to use when snapshot reserved space is full.
    pub snapshot_auto_delete_behavior: crate::model::volume::SnapshotAutoDeleteBehavior,

    /// Labels as key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Whether snapshots are enabled.
    pub snapshot_enabled: bool,

    /// Immutable. Pod name.
    pub pod: std::string::String,

    /// Output only. Storage protocol for the Volume.
    pub protocol: crate::model::volume::Protocol,

    /// Output only. Whether this volume is a boot volume. A boot volume is one
    /// which contains a boot LUN.
    pub boot_volume: bool,

    /// Immutable. Performance tier of the Volume.
    /// Default is SHARED.
    pub performance_tier: crate::model::VolumePerformanceTier,

    /// Input only. User-specified notes for new Volume.
    /// Used to provision Volumes that require manual intervention.
    pub notes: std::string::String,

    /// The workload profile for the volume.
    pub workload_profile: crate::model::volume::WorkloadProfile,

    /// Output only. Time after which volume will be fully deleted.
    /// It is filled only for volumes in COOLOFF state.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instances this Volume is attached to.
    /// This field is set only in Get requests.
    pub instances: std::vec::Vec<std::string::String>,

    /// Output only. Is the Volume attached at at least one instance.
    /// This field is a lightweight counterpart of `instances` field.
    /// It is filled in List responses as well.
    pub attached: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Volume::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [storage_type][crate::model::Volume::storage_type].
    pub fn set_storage_type<T: std::convert::Into<crate::model::volume::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Volume::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [requested_size_gib][crate::model::Volume::requested_size_gib].
    pub fn set_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.requested_size_gib = v.into();
        self
    }

    /// Sets the value of [originally_requested_size_gib][crate::model::Volume::originally_requested_size_gib].
    pub fn set_originally_requested_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.originally_requested_size_gib = v.into();
        self
    }

    /// Sets the value of [current_size_gib][crate::model::Volume::current_size_gib].
    pub fn set_current_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.current_size_gib = v.into();
        self
    }

    /// Sets the value of [emergency_size_gib][crate::model::Volume::emergency_size_gib].
    pub fn set_emergency_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.emergency_size_gib = v.into();
        self
    }

    /// Sets the value of [max_size_gib][crate::model::Volume::max_size_gib].
    pub fn set_max_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_size_gib = v.into();
        self
    }

    /// Sets the value of [auto_grown_size_gib][crate::model::Volume::auto_grown_size_gib].
    pub fn set_auto_grown_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.auto_grown_size_gib = v.into();
        self
    }

    /// Sets the value of [remaining_space_gib][crate::model::Volume::remaining_space_gib].
    pub fn set_remaining_space_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.remaining_space_gib = v.into();
        self
    }

    /// Sets the value of [snapshot_reservation_detail][crate::model::Volume::snapshot_reservation_detail].
    pub fn set_snapshot_reservation_detail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::volume::SnapshotReservationDetail>,
    {
        self.snapshot_reservation_detail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_reservation_detail][crate::model::Volume::snapshot_reservation_detail].
    pub fn set_or_clear_snapshot_reservation_detail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::volume::SnapshotReservationDetail>,
    {
        self.snapshot_reservation_detail = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snapshot_auto_delete_behavior][crate::model::Volume::snapshot_auto_delete_behavior].
    pub fn set_snapshot_auto_delete_behavior<
        T: std::convert::Into<crate::model::volume::SnapshotAutoDeleteBehavior>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_auto_delete_behavior = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Volume::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [snapshot_enabled][crate::model::Volume::snapshot_enabled].
    pub fn set_snapshot_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshot_enabled = v.into();
        self
    }

    /// Sets the value of [pod][crate::model::Volume::pod].
    pub fn set_pod<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::Volume::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::volume::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [boot_volume][crate::model::Volume::boot_volume].
    pub fn set_boot_volume<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.boot_volume = v.into();
        self
    }

    /// Sets the value of [performance_tier][crate::model::Volume::performance_tier].
    pub fn set_performance_tier<T: std::convert::Into<crate::model::VolumePerformanceTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.performance_tier = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::Volume::notes].
    pub fn set_notes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.notes = v.into();
        self
    }

    /// Sets the value of [workload_profile][crate::model::Volume::workload_profile].
    pub fn set_workload_profile<T: std::convert::Into<crate::model::volume::WorkloadProfile>>(
        mut self,
        v: T,
    ) -> Self {
        self.workload_profile = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Volume::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Volume::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::Volume::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attached][crate::model::Volume::attached].
    pub fn set_attached<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.attached = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.Volume"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Volume {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __storage_type,
            __state,
            __requested_size_gib,
            __originally_requested_size_gib,
            __current_size_gib,
            __emergency_size_gib,
            __max_size_gib,
            __auto_grown_size_gib,
            __remaining_space_gib,
            __snapshot_reservation_detail,
            __snapshot_auto_delete_behavior,
            __labels,
            __snapshot_enabled,
            __pod,
            __protocol,
            __boot_volume,
            __performance_tier,
            __notes,
            __workload_profile,
            __expire_time,
            __instances,
            __attached,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Volume")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "storageType" => Ok(__FieldTag::__storage_type),
                            "storage_type" => Ok(__FieldTag::__storage_type),
                            "state" => Ok(__FieldTag::__state),
                            "requestedSizeGib" => Ok(__FieldTag::__requested_size_gib),
                            "requested_size_gib" => Ok(__FieldTag::__requested_size_gib),
                            "originallyRequestedSizeGib" => {
                                Ok(__FieldTag::__originally_requested_size_gib)
                            }
                            "originally_requested_size_gib" => {
                                Ok(__FieldTag::__originally_requested_size_gib)
                            }
                            "currentSizeGib" => Ok(__FieldTag::__current_size_gib),
                            "current_size_gib" => Ok(__FieldTag::__current_size_gib),
                            "emergencySizeGib" => Ok(__FieldTag::__emergency_size_gib),
                            "emergency_size_gib" => Ok(__FieldTag::__emergency_size_gib),
                            "maxSizeGib" => Ok(__FieldTag::__max_size_gib),
                            "max_size_gib" => Ok(__FieldTag::__max_size_gib),
                            "autoGrownSizeGib" => Ok(__FieldTag::__auto_grown_size_gib),
                            "auto_grown_size_gib" => Ok(__FieldTag::__auto_grown_size_gib),
                            "remainingSpaceGib" => Ok(__FieldTag::__remaining_space_gib),
                            "remaining_space_gib" => Ok(__FieldTag::__remaining_space_gib),
                            "snapshotReservationDetail" => {
                                Ok(__FieldTag::__snapshot_reservation_detail)
                            }
                            "snapshot_reservation_detail" => {
                                Ok(__FieldTag::__snapshot_reservation_detail)
                            }
                            "snapshotAutoDeleteBehavior" => {
                                Ok(__FieldTag::__snapshot_auto_delete_behavior)
                            }
                            "snapshot_auto_delete_behavior" => {
                                Ok(__FieldTag::__snapshot_auto_delete_behavior)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "snapshotEnabled" => Ok(__FieldTag::__snapshot_enabled),
                            "snapshot_enabled" => Ok(__FieldTag::__snapshot_enabled),
                            "pod" => Ok(__FieldTag::__pod),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "bootVolume" => Ok(__FieldTag::__boot_volume),
                            "boot_volume" => Ok(__FieldTag::__boot_volume),
                            "performanceTier" => Ok(__FieldTag::__performance_tier),
                            "performance_tier" => Ok(__FieldTag::__performance_tier),
                            "notes" => Ok(__FieldTag::__notes),
                            "workloadProfile" => Ok(__FieldTag::__workload_profile),
                            "workload_profile" => Ok(__FieldTag::__workload_profile),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "instances" => Ok(__FieldTag::__instances),
                            "attached" => Ok(__FieldTag::__attached),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Volume;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Volume")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_type => {
                            if !fields.insert(__FieldTag::__storage_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_type",
                                ));
                            }
                            result.storage_type = map.next_value::<std::option::Option<crate::model::volume::StorageType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::volume::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_size_gib => {
                            if !fields.insert(__FieldTag::__requested_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.requested_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__originally_requested_size_gib => {
                            if !fields.insert(__FieldTag::__originally_requested_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for originally_requested_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.originally_requested_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__current_size_gib => {
                            if !fields.insert(__FieldTag::__current_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.current_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__emergency_size_gib => {
                            if !fields.insert(__FieldTag::__emergency_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for emergency_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.emergency_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_size_gib => {
                            if !fields.insert(__FieldTag::__max_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_size_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__auto_grown_size_gib => {
                            if !fields.insert(__FieldTag::__auto_grown_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_grown_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.auto_grown_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remaining_space_gib => {
                            if !fields.insert(__FieldTag::__remaining_space_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remaining_space_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.remaining_space_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__snapshot_reservation_detail => {
                            if !fields.insert(__FieldTag::__snapshot_reservation_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_reservation_detail",
                                ));
                            }
                            result.snapshot_reservation_detail = map
                                .next_value::<std::option::Option<
                                    crate::model::volume::SnapshotReservationDetail,
                                >>()?;
                        }
                        __FieldTag::__snapshot_auto_delete_behavior => {
                            if !fields.insert(__FieldTag::__snapshot_auto_delete_behavior) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_auto_delete_behavior",
                                ));
                            }
                            result.snapshot_auto_delete_behavior = map
                                .next_value::<std::option::Option<
                                    crate::model::volume::SnapshotAutoDeleteBehavior,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_enabled => {
                            if !fields.insert(__FieldTag::__snapshot_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_enabled",
                                ));
                            }
                            result.snapshot_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod => {
                            if !fields.insert(__FieldTag::__pod) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod",
                                ));
                            }
                            result.pod = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<crate::model::volume::Protocol>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_volume => {
                            if !fields.insert(__FieldTag::__boot_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_volume",
                                ));
                            }
                            result.boot_volume = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__performance_tier => {
                            if !fields.insert(__FieldTag::__performance_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_tier",
                                ));
                            }
                            result.performance_tier = map.next_value::<std::option::Option<crate::model::VolumePerformanceTier>>()?.unwrap_or_default();
                        }
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_profile => {
                            if !fields.insert(__FieldTag::__workload_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_profile",
                                ));
                            }
                            result.workload_profile = map.next_value::<std::option::Option<crate::model::volume::WorkloadProfile>>()?.unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attached => {
                            if !fields.insert(__FieldTag::__attached) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attached",
                                ));
                            }
                            result.attached = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Volume {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.storage_type) {
            state.serialize_entry("storageType", &self.storage_type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.requested_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("requestedSizeGib", &__With(&self.requested_size_gib))?;
        }
        if !wkt::internal::is_default(&self.originally_requested_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "originallyRequestedSizeGib",
                &__With(&self.originally_requested_size_gib),
            )?;
        }
        if !wkt::internal::is_default(&self.current_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("currentSizeGib", &__With(&self.current_size_gib))?;
        }
        if !wkt::internal::is_default(&self.emergency_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("emergencySizeGib", &__With(&self.emergency_size_gib))?;
        }
        if !wkt::internal::is_default(&self.max_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSizeGib", &__With(&self.max_size_gib))?;
        }
        if !wkt::internal::is_default(&self.auto_grown_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("autoGrownSizeGib", &__With(&self.auto_grown_size_gib))?;
        }
        if !wkt::internal::is_default(&self.remaining_space_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("remainingSpaceGib", &__With(&self.remaining_space_gib))?;
        }
        if self.snapshot_reservation_detail.is_some() {
            state.serialize_entry(
                "snapshotReservationDetail",
                &self.snapshot_reservation_detail,
            )?;
        }
        if !wkt::internal::is_default(&self.snapshot_auto_delete_behavior) {
            state.serialize_entry(
                "snapshotAutoDeleteBehavior",
                &self.snapshot_auto_delete_behavior,
            )?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.snapshot_enabled) {
            state.serialize_entry("snapshotEnabled", &self.snapshot_enabled)?;
        }
        if !self.pod.is_empty() {
            state.serialize_entry("pod", &self.pod)?;
        }
        if !wkt::internal::is_default(&self.protocol) {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !wkt::internal::is_default(&self.boot_volume) {
            state.serialize_entry("bootVolume", &self.boot_volume)?;
        }
        if !wkt::internal::is_default(&self.performance_tier) {
            state.serialize_entry("performanceTier", &self.performance_tier)?;
        }
        if !self.notes.is_empty() {
            state.serialize_entry("notes", &self.notes)?;
        }
        if !wkt::internal::is_default(&self.workload_profile) {
            state.serialize_entry("workloadProfile", &self.workload_profile)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !wkt::internal::is_default(&self.attached) {
            state.serialize_entry("attached", &self.attached)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Volume].
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    /// Details about snapshot space reservation and usage on the storage volume.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SnapshotReservationDetail {
        /// The space on this storage volume reserved for snapshots, shown in GiB.
        pub reserved_space_gib: i64,

        /// The percent of snapshot space on this storage volume actually being used
        /// by the snapshot copies. This value might be higher than 100% if the
        /// snapshot copies have overflowed into the data portion of the storage
        /// volume.
        pub reserved_space_used_percent: i32,

        /// The amount, in GiB, of available space in this storage volume's reserved
        /// snapshot space.
        pub reserved_space_remaining_gib: i64,

        /// Percent of the total Volume size reserved for snapshot copies.
        /// Enabling snapshots requires reserving 20% or more of
        /// the storage volume space for snapshots. Maximum reserved space for
        /// snapshots is 40%.
        /// Setting this field will effectively set snapshot_enabled to true.
        pub reserved_space_percent: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SnapshotReservationDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reserved_space_gib][crate::model::volume::SnapshotReservationDetail::reserved_space_gib].
        pub fn set_reserved_space_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.reserved_space_gib = v.into();
            self
        }

        /// Sets the value of [reserved_space_used_percent][crate::model::volume::SnapshotReservationDetail::reserved_space_used_percent].
        pub fn set_reserved_space_used_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.reserved_space_used_percent = v.into();
            self
        }

        /// Sets the value of [reserved_space_remaining_gib][crate::model::volume::SnapshotReservationDetail::reserved_space_remaining_gib].
        pub fn set_reserved_space_remaining_gib<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.reserved_space_remaining_gib = v.into();
            self
        }

        /// Sets the value of [reserved_space_percent][crate::model::volume::SnapshotReservationDetail::reserved_space_percent].
        pub fn set_reserved_space_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.reserved_space_percent = v.into();
            self
        }
    }

    impl wkt::message::Message for SnapshotReservationDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.baremetalsolution.v2.Volume.SnapshotReservationDetail"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SnapshotReservationDetail {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __reserved_space_gib,
                __reserved_space_used_percent,
                __reserved_space_remaining_gib,
                __reserved_space_percent,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SnapshotReservationDetail")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "reservedSpaceGib" => Ok(__FieldTag::__reserved_space_gib),
                                "reserved_space_gib" => Ok(__FieldTag::__reserved_space_gib),
                                "reservedSpaceUsedPercent" => {
                                    Ok(__FieldTag::__reserved_space_used_percent)
                                }
                                "reserved_space_used_percent" => {
                                    Ok(__FieldTag::__reserved_space_used_percent)
                                }
                                "reservedSpaceRemainingGib" => {
                                    Ok(__FieldTag::__reserved_space_remaining_gib)
                                }
                                "reserved_space_remaining_gib" => {
                                    Ok(__FieldTag::__reserved_space_remaining_gib)
                                }
                                "reservedSpacePercent" => Ok(__FieldTag::__reserved_space_percent),
                                "reserved_space_percent" => {
                                    Ok(__FieldTag::__reserved_space_percent)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SnapshotReservationDetail;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SnapshotReservationDetail")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__reserved_space_gib => {
                                if !fields.insert(__FieldTag::__reserved_space_gib) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reserved_space_gib",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.reserved_space_gib =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__reserved_space_used_percent => {
                                if !fields.insert(__FieldTag::__reserved_space_used_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reserved_space_used_percent",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.reserved_space_used_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__reserved_space_remaining_gib => {
                                if !fields.insert(__FieldTag::__reserved_space_remaining_gib) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reserved_space_remaining_gib",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.reserved_space_remaining_gib =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__reserved_space_percent => {
                                if !fields.insert(__FieldTag::__reserved_space_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reserved_space_percent",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.reserved_space_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SnapshotReservationDetail {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.reserved_space_gib) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("reservedSpaceGib", &__With(&self.reserved_space_gib))?;
            }
            if !wkt::internal::is_default(&self.reserved_space_used_percent) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "reservedSpaceUsedPercent",
                    &__With(&self.reserved_space_used_percent),
                )?;
            }
            if !wkt::internal::is_default(&self.reserved_space_remaining_gib) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "reservedSpaceRemainingGib",
                    &__With(&self.reserved_space_remaining_gib),
                )?;
            }
            if !wkt::internal::is_default(&self.reserved_space_percent) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "reservedSpacePercent",
                    &__With(&self.reserved_space_percent),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The storage type for a volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The storage type for this volume is unknown.
        Unspecified,
        /// The storage type for this volume is SSD.
        Ssd,
        /// This storage type for this volume is HDD.
        Hdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ssd => std::option::Option::Some(1),
                Self::Hdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Ssd => std::option::Option::Some("SSD"),
                Self::Hdd => std::option::Option::Some("HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ssd,
                2 => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SSD" => Self::Ssd,
                "HDD" => Self::Hdd,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ssd => serializer.serialize_i32(1),
                Self::Hdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.baremetalsolution.v2.Volume.StorageType",
            ))
        }
    }

    /// The possible states for a storage volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The storage volume is in an unknown state.
        Unspecified,
        /// The storage volume is being created.
        Creating,
        /// The storage volume is ready for use.
        Ready,
        /// The storage volume has been requested to be deleted.
        Deleting,
        /// The storage volume is being updated.
        Updating,
        /// The storage volume is in cool off state. It will be deleted after
        /// `expire_time`.
        CoolOff,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::CoolOff => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::CoolOff => std::option::Option::Some("COOL_OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "COOL_OFF" => Self::CoolOff,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::CoolOff => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.baremetalsolution.v2.Volume.State",
            ))
        }
    }

    /// The kinds of auto delete behavior to use when snapshot reserved space is
    /// full.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SnapshotAutoDeleteBehavior {
        /// The unspecified behavior.
        Unspecified,
        /// Don't delete any snapshots. This disables new snapshot creation, as
        /// long as the snapshot reserved space is full.
        Disabled,
        /// Delete the oldest snapshots first.
        OldestFirst,
        /// Delete the newest snapshots first.
        NewestFirst,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SnapshotAutoDeleteBehavior::value] or
        /// [SnapshotAutoDeleteBehavior::name].
        UnknownValue(snapshot_auto_delete_behavior::UnknownValue),
    }

    #[doc(hidden)]
    pub mod snapshot_auto_delete_behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SnapshotAutoDeleteBehavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::OldestFirst => std::option::Option::Some(2),
                Self::NewestFirst => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED")
                }
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::OldestFirst => std::option::Option::Some("OLDEST_FIRST"),
                Self::NewestFirst => std::option::Option::Some("NEWEST_FIRST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SnapshotAutoDeleteBehavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SnapshotAutoDeleteBehavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SnapshotAutoDeleteBehavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::OldestFirst,
                3 => Self::NewestFirst,
                _ => Self::UnknownValue(snapshot_auto_delete_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SnapshotAutoDeleteBehavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "OLDEST_FIRST" => Self::OldestFirst,
                "NEWEST_FIRST" => Self::NewestFirst,
                _ => Self::UnknownValue(snapshot_auto_delete_behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SnapshotAutoDeleteBehavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::OldestFirst => serializer.serialize_i32(2),
                Self::NewestFirst => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SnapshotAutoDeleteBehavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<SnapshotAutoDeleteBehavior>::new(
                    ".google.cloud.baremetalsolution.v2.Volume.SnapshotAutoDeleteBehavior",
                ),
            )
        }
    }

    /// Storage protocol.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Value is not specified.
        Unspecified,
        /// Fibre Channel protocol.
        FibreChannel,
        /// NFS protocol means Volume is a NFS Share volume.
        /// Such volumes cannot be manipulated via Volumes API.
        Nfs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FibreChannel => std::option::Option::Some(1),
                Self::Nfs => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::FibreChannel => std::option::Option::Some("FIBRE_CHANNEL"),
                Self::Nfs => std::option::Option::Some("NFS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FibreChannel,
                2 => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "FIBRE_CHANNEL" => Self::FibreChannel,
                "NFS" => Self::Nfs,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FibreChannel => serializer.serialize_i32(1),
                Self::Nfs => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.baremetalsolution.v2.Volume.Protocol",
            ))
        }
    }

    /// The possible values for a workload profile.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WorkloadProfile {
        /// The workload profile is in an unknown state.
        Unspecified,
        /// The workload profile is generic.
        Generic,
        /// The workload profile is hana.
        Hana,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WorkloadProfile::value] or
        /// [WorkloadProfile::name].
        UnknownValue(workload_profile::UnknownValue),
    }

    #[doc(hidden)]
    pub mod workload_profile {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WorkloadProfile {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Generic => std::option::Option::Some(1),
                Self::Hana => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WORKLOAD_PROFILE_UNSPECIFIED"),
                Self::Generic => std::option::Option::Some("GENERIC"),
                Self::Hana => std::option::Option::Some("HANA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WorkloadProfile {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WorkloadProfile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WorkloadProfile {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Generic,
                2 => Self::Hana,
                _ => Self::UnknownValue(workload_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WorkloadProfile {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WORKLOAD_PROFILE_UNSPECIFIED" => Self::Unspecified,
                "GENERIC" => Self::Generic,
                "HANA" => Self::Hana,
                _ => Self::UnknownValue(workload_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WorkloadProfile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Generic => serializer.serialize_i32(1),
                Self::Hana => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WorkloadProfile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WorkloadProfile>::new(
                ".google.cloud.baremetalsolution.v2.Volume.WorkloadProfile",
            ))
        }
    }
}

/// Message for requesting storage volume information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting a list of storage volumes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumesRequest {
    /// Required. Parent value for ListVolumesRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing the list of storage volumes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumesResponse {
    /// The list of storage volumes.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volumes][crate::model::ListVolumesResponse::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumesResponse {
    type PageItem = crate::model::Volume;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volumes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volumes,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumes" => Ok(__FieldTag::__volumes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a volume.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVolumeRequest {
    /// Required. The volume to update.
    ///
    /// The `name` field is used to identify the volume to update.
    /// Format: projects/{project}/locations/{location}/volumes/{volume}
    pub volume: std::option::Option<crate::model::Volume>,

    /// The list of fields to update.
    /// The only currently supported fields are:
    /// 'labels'
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_or_clear_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.UpdateVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volume" => Ok(__FieldTag::__volume),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume => {
                            if !fields.insert(__FieldTag::__volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume",
                                ));
                            }
                            result.volume =
                                map.next_value::<std::option::Option<crate::model::Volume>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.volume.is_some() {
            state.serialize_entry("volume", &self.volume)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message requesting rename of a server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenameVolumeRequest {
    /// Required. The `name` field is used to identify the volume.
    /// Format: projects/{project}/locations/{location}/volumes/{volume}
    pub name: std::string::String,

    /// Required. The new `id` of the volume.
    pub new_volume_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenameVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RenameVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [new_volume_id][crate::model::RenameVolumeRequest::new_volume_id].
    pub fn set_new_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_volume_id = v.into();
        self
    }
}

impl wkt::message::Message for RenameVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RenameVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenameVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __new_volume_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenameVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "newVolumeId" => Ok(__FieldTag::__new_volume_id),
                            "new_volume_id" => Ok(__FieldTag::__new_volume_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenameVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenameVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_volume_id => {
                            if !fields.insert(__FieldTag::__new_volume_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_volume_id",
                                ));
                            }
                            result.new_volume_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenameVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.new_volume_id.is_empty() {
            state.serialize_entry("newVolumeId", &self.new_volume_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for skip volume cooloff and delete it.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictVolumeRequest {
    /// Required. The name of the Volume.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EvictVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EvictVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.EvictVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvictVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvictVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvictVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for emergency resize Volume.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResizeVolumeRequest {
    /// Required. Volume to resize.
    pub volume: std::string::String,

    /// New Volume size, in GiB.
    pub size_gib: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResizeVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume][crate::model::ResizeVolumeRequest::volume].
    pub fn set_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume = v.into();
        self
    }

    /// Sets the value of [size_gib][crate::model::ResizeVolumeRequest::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }
}

impl wkt::message::Message for ResizeVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ResizeVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResizeVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume,
            __size_gib,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResizeVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volume" => Ok(__FieldTag::__volume),
                            "sizeGib" => Ok(__FieldTag::__size_gib),
                            "size_gib" => Ok(__FieldTag::__size_gib),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResizeVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResizeVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume => {
                            if !fields.insert(__FieldTag::__volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume",
                                ));
                            }
                            result.volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_gib => {
                            if !fields.insert(__FieldTag::__size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResizeVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volume.is_empty() {
            state.serialize_entry("volume", &self.volume)?;
        }
        if !wkt::internal::is_default(&self.size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGib", &__With(&self.size_gib))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A snapshot of a volume. Only boot volumes can have snapshots.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeSnapshot {
    /// The name of the snapshot.
    pub name: std::string::String,

    /// Output only. An identifier for the snapshot, generated by the backend.
    pub id: std::string::String,

    /// The description of the snapshot.
    pub description: std::string::String,

    /// Output only. The creation time of the snapshot.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the volume which this snapshot belongs to.
    pub storage_volume: std::string::String,

    /// Output only. The type of the snapshot which indicates whether it was
    /// scheduled or manual/ad-hoc.
    pub r#type: crate::model::volume_snapshot::SnapshotType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeSnapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::VolumeSnapshot::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::VolumeSnapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VolumeSnapshot::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VolumeSnapshot::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_volume][crate::model::VolumeSnapshot::storage_volume].
    pub fn set_storage_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_volume = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::VolumeSnapshot::type].
    pub fn set_type<T: std::convert::Into<crate::model::volume_snapshot::SnapshotType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for VolumeSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.VolumeSnapshot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeSnapshot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __description,
            __create_time,
            __storage_volume,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeSnapshot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "storageVolume" => Ok(__FieldTag::__storage_volume),
                            "storage_volume" => Ok(__FieldTag::__storage_volume),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeSnapshot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeSnapshot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__storage_volume => {
                            if !fields.insert(__FieldTag::__storage_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_volume",
                                ));
                            }
                            result.storage_volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::volume_snapshot::SnapshotType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeSnapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.storage_volume.is_empty() {
            state.serialize_entry("storageVolume", &self.storage_volume)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VolumeSnapshot].
pub mod volume_snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the type of a snapshot.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SnapshotType {
        /// Type is not specified.
        Unspecified,
        /// Snapshot was taken manually by user.
        AdHoc,
        /// Snapshot was taken automatically as a part of a snapshot schedule.
        Scheduled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SnapshotType::value] or
        /// [SnapshotType::name].
        UnknownValue(snapshot_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod snapshot_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SnapshotType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AdHoc => std::option::Option::Some(1),
                Self::Scheduled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SNAPSHOT_TYPE_UNSPECIFIED"),
                Self::AdHoc => std::option::Option::Some("AD_HOC"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SnapshotType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SnapshotType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SnapshotType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AdHoc,
                2 => Self::Scheduled,
                _ => Self::UnknownValue(snapshot_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SnapshotType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SNAPSHOT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AD_HOC" => Self::AdHoc,
                "SCHEDULED" => Self::Scheduled,
                _ => Self::UnknownValue(snapshot_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SnapshotType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AdHoc => serializer.serialize_i32(1),
                Self::Scheduled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SnapshotType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SnapshotType>::new(
                ".google.cloud.baremetalsolution.v2.VolumeSnapshot.SnapshotType",
            ))
        }
    }
}

/// Message for requesting volume snapshot information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeSnapshotRequest {
    /// Required. The name of the snapshot.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.GetVolumeSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVolumeSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVolumeSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVolumeSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVolumeSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVolumeSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting a list of volume snapshots.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeSnapshotsRequest {
    /// Required. Parent value for ListVolumesRequest.
    pub parent: std::string::String,

    /// Requested page size. The server might return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results from the server.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumeSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumeSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumeSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumeSnapshotsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumeSnapshotsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumeSnapshotsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumeSnapshotsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumeSnapshotsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumeSnapshotsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing the list of volume snapshots.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeSnapshotsResponse {
    /// The list of snapshots.
    pub volume_snapshots: std::vec::Vec<crate::model::VolumeSnapshot>,

    /// A token identifying a page of results from the server.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_snapshots][crate::model::ListVolumeSnapshotsResponse::volume_snapshots].
    pub fn set_volume_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        use std::iter::Iterator;
        self.volume_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumeSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumeSnapshotsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumeSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.ListVolumeSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumeSnapshotsResponse {
    type PageItem = crate::model::VolumeSnapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volume_snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumeSnapshotsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_snapshots,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumeSnapshotsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumeSnapshots" => Ok(__FieldTag::__volume_snapshots),
                            "volume_snapshots" => Ok(__FieldTag::__volume_snapshots),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumeSnapshotsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumeSnapshotsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_snapshots => {
                            if !fields.insert(__FieldTag::__volume_snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_snapshots",
                                ));
                            }
                            result.volume_snapshots =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VolumeSnapshot>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumeSnapshotsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volume_snapshots.is_empty() {
            state.serialize_entry("volumeSnapshots", &self.volume_snapshots)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting named Volume snapshot.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVolumeSnapshotRequest {
    /// Required. The name of the snapshot to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVolumeSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.DeleteVolumeSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVolumeSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVolumeSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVolumeSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVolumeSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVolumeSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a volume snapshot.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVolumeSnapshotRequest {
    /// Required. The volume to snapshot.
    pub parent: std::string::String,

    /// Required. The snapshot to create.
    pub volume_snapshot: std::option::Option<crate::model::VolumeSnapshot>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVolumeSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [volume_snapshot][crate::model::CreateVolumeSnapshotRequest::volume_snapshot].
    pub fn set_volume_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        self.volume_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [volume_snapshot][crate::model::CreateVolumeSnapshotRequest::volume_snapshot].
    pub fn set_or_clear_volume_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VolumeSnapshot>,
    {
        self.volume_snapshot = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.CreateVolumeSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVolumeSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __volume_snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVolumeSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "volumeSnapshot" => Ok(__FieldTag::__volume_snapshot),
                            "volume_snapshot" => Ok(__FieldTag::__volume_snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVolumeSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVolumeSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_snapshot => {
                            if !fields.insert(__FieldTag::__volume_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_snapshot",
                                ));
                            }
                            result.volume_snapshot = map
                                .next_value::<std::option::Option<crate::model::VolumeSnapshot>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVolumeSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.volume_snapshot.is_some() {
            state.serialize_entry("volumeSnapshot", &self.volume_snapshot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for restoring a volume snapshot.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreVolumeSnapshotRequest {
    /// Required. Name of the snapshot which will be used to restore its parent
    /// volume.
    pub volume_snapshot: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreVolumeSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_snapshot][crate::model::RestoreVolumeSnapshotRequest::volume_snapshot].
    pub fn set_volume_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_snapshot = v.into();
        self
    }
}

impl wkt::message::Message for RestoreVolumeSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.baremetalsolution.v2.RestoreVolumeSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreVolumeSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreVolumeSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumeSnapshot" => Ok(__FieldTag::__volume_snapshot),
                            "volume_snapshot" => Ok(__FieldTag::__volume_snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreVolumeSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreVolumeSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_snapshot => {
                            if !fields.insert(__FieldTag::__volume_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_snapshot",
                                ));
                            }
                            result.volume_snapshot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreVolumeSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volume_snapshot.is_empty() {
            state.serialize_entry("volumeSnapshot", &self.volume_snapshot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Performance tier of the Volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum VolumePerformanceTier {
    /// Value is not specified.
    Unspecified,
    /// Regular volumes, shared aggregates.
    Shared,
    /// Assigned aggregates.
    Assigned,
    /// High throughput aggregates.
    Ht,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [VolumePerformanceTier::value] or
    /// [VolumePerformanceTier::name].
    UnknownValue(volume_performance_tier::UnknownValue),
}

#[doc(hidden)]
pub mod volume_performance_tier {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl VolumePerformanceTier {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Shared => std::option::Option::Some(1),
            Self::Assigned => std::option::Option::Some(2),
            Self::Ht => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_UNSPECIFIED"),
            Self::Shared => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_SHARED"),
            Self::Assigned => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_ASSIGNED"),
            Self::Ht => std::option::Option::Some("VOLUME_PERFORMANCE_TIER_HT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for VolumePerformanceTier {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for VolumePerformanceTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for VolumePerformanceTier {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Shared,
            2 => Self::Assigned,
            3 => Self::Ht,
            _ => Self::UnknownValue(volume_performance_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for VolumePerformanceTier {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VOLUME_PERFORMANCE_TIER_UNSPECIFIED" => Self::Unspecified,
            "VOLUME_PERFORMANCE_TIER_SHARED" => Self::Shared,
            "VOLUME_PERFORMANCE_TIER_ASSIGNED" => Self::Assigned,
            "VOLUME_PERFORMANCE_TIER_HT" => Self::Ht,
            _ => Self::UnknownValue(volume_performance_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for VolumePerformanceTier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Shared => serializer.serialize_i32(1),
            Self::Assigned => serializer.serialize_i32(2),
            Self::Ht => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for VolumePerformanceTier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumePerformanceTier>::new(
            ".google.cloud.baremetalsolution.v2.VolumePerformanceTier",
        ))
    }
}

/// The possible values for a workload profile.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum WorkloadProfile {
    /// The workload profile is in an unknown state.
    Unspecified,
    /// The workload profile is generic.
    Generic,
    /// The workload profile is hana.
    Hana,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [WorkloadProfile::value] or
    /// [WorkloadProfile::name].
    UnknownValue(workload_profile::UnknownValue),
}

#[doc(hidden)]
pub mod workload_profile {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl WorkloadProfile {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Generic => std::option::Option::Some(1),
            Self::Hana => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("WORKLOAD_PROFILE_UNSPECIFIED"),
            Self::Generic => std::option::Option::Some("WORKLOAD_PROFILE_GENERIC"),
            Self::Hana => std::option::Option::Some("WORKLOAD_PROFILE_HANA"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for WorkloadProfile {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for WorkloadProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for WorkloadProfile {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Generic,
            2 => Self::Hana,
            _ => Self::UnknownValue(workload_profile::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for WorkloadProfile {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "WORKLOAD_PROFILE_UNSPECIFIED" => Self::Unspecified,
            "WORKLOAD_PROFILE_GENERIC" => Self::Generic,
            "WORKLOAD_PROFILE_HANA" => Self::Hana,
            _ => Self::UnknownValue(workload_profile::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for WorkloadProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Generic => serializer.serialize_i32(1),
            Self::Hana => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for WorkloadProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<WorkloadProfile>::new(
            ".google.cloud.baremetalsolution.v2.WorkloadProfile",
        ))
    }
}
