// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents service health events that may affect Google Cloud products.
/// Event resource is a read-only view and does not allow any modifications. All
/// fields are output only.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Output only. Identifier. Name of the event. Unique name of the event in
    /// this scope including project and location using the form
    /// `projects/{project_id}/locations/{location}/events/{event_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Brief description for the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Output only. Free-form, human-readable description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The category of the event.
    pub category: crate::model::event::EventCategory,

    /// Output only. The detailed category of the event.
    pub detailed_category: crate::model::event::DetailedCategory,

    /// Output only. The current state of the event.
    pub state: crate::model::event::State,

    /// Output only. The current detailed state of the incident.
    pub detailed_state: crate::model::event::DetailedState,

    /// Google Cloud products and locations impacted by the event.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub event_impacts: std::vec::Vec<crate::model::EventImpact>,

    /// Output only. Communicates why a given event is deemed relevant in the
    /// context of a given project.
    pub relevance: crate::model::event::Relevance,

    /// Output only. Event updates are correspondence from Google.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub updates: std::vec::Vec<crate::model::EventUpdate>,

    /// Output only. When `detailed_state`=`MERGED`, `parent_event` contains the
    /// name of the parent event. All further updates will be published to the
    /// parent event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_event: std::string::String,

    /// Output only. The time when the event was last modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The start time of the event, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of the event, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the next update can be expected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Event::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Event::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Event::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [category][crate::model::Event::category].
    pub fn set_category<T: std::convert::Into<crate::model::event::EventCategory>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [detailed_category][crate::model::Event::detailed_category].
    pub fn set_detailed_category<T: std::convert::Into<crate::model::event::DetailedCategory>>(
        mut self,
        v: T,
    ) -> Self {
        self.detailed_category = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Event::state].
    pub fn set_state<T: std::convert::Into<crate::model::event::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [detailed_state][crate::model::Event::detailed_state].
    pub fn set_detailed_state<T: std::convert::Into<crate::model::event::DetailedState>>(
        mut self,
        v: T,
    ) -> Self {
        self.detailed_state = v.into();
        self
    }

    /// Sets the value of [event_impacts][crate::model::Event::event_impacts].
    pub fn set_event_impacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventImpact>,
    {
        use std::iter::Iterator;
        self.event_impacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [relevance][crate::model::Event::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::event::Relevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [updates][crate::model::Event::updates].
    pub fn set_updates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventUpdate>,
    {
        use std::iter::Iterator;
        self.updates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent_event][crate::model::Event::parent_event].
    pub fn set_parent_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_event = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Event::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Event::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Event::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [next_update_time][crate::model::Event::next_update_time].
    pub fn set_next_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_update_time = v.into();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.Event"
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// The category of the event. This enum lists all possible categories of
    /// event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventCategory {
        /// Unspecified category.
        Unspecified,
        /// Event category for service outage or degradation.
        Incident,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventCategory::value] or
        /// [EventCategory::name].
        UnknownValue(event_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incident => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_CATEGORY_UNSPECIFIED"),
                Self::Incident => std::option::Option::Some("INCIDENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Incident,
                _ => Self::UnknownValue(event_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "INCIDENT" => Self::Incident,
                _ => Self::UnknownValue(event_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incident => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventCategory>::new(
                ".google.cloud.servicehealth.v1.Event.EventCategory",
            ))
        }
    }

    /// The detailed category of an event. Contains all possible states for all
    /// event categories.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailedCategory {
        /// Unspecified detailed category.
        Unspecified,
        /// Indicates an event with category INCIDENT has a confirmed impact to at
        /// least one Google Cloud product.
        ConfirmedIncident,
        /// Indicates an event with category INCIDENT is under investigation to
        /// determine if it has a confirmed impact on any Google Cloud products.
        EmergingIncident,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DetailedCategory::value] or
        /// [DetailedCategory::name].
        UnknownValue(detailed_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod detailed_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DetailedCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConfirmedIncident => std::option::Option::Some(1),
                Self::EmergingIncident => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DETAILED_CATEGORY_UNSPECIFIED"),
                Self::ConfirmedIncident => std::option::Option::Some("CONFIRMED_INCIDENT"),
                Self::EmergingIncident => std::option::Option::Some("EMERGING_INCIDENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DetailedCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DetailedCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DetailedCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConfirmedIncident,
                2 => Self::EmergingIncident,
                _ => Self::UnknownValue(detailed_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DetailedCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DETAILED_CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "CONFIRMED_INCIDENT" => Self::ConfirmedIncident,
                "EMERGING_INCIDENT" => Self::EmergingIncident,
                _ => Self::UnknownValue(detailed_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DetailedCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConfirmedIncident => serializer.serialize_i32(1),
                Self::EmergingIncident => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DetailedCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailedCategory>::new(
                ".google.cloud.servicehealth.v1.Event.DetailedCategory",
            ))
        }
    }

    /// The state of the event. This enum lists all possible states of event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Event is actively affecting a Google Cloud product and will continue to
        /// receive updates.
        Active,
        /// Event is no longer affecting the Google Cloud product or has been merged
        /// with another event.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Closed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Closed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.servicehealth.v1.Event.State",
            ))
        }
    }

    /// The detailed state of the incident. This enum lists all possible detailed
    /// states of an incident.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailedState {
        /// Unspecified detail state.
        Unspecified,
        /// Google engineers are actively investigating the event to determine the
        /// impact.
        Emerging,
        /// The incident is confirmed and impacting at least one Google Cloud
        /// product. Ongoing status updates will be provided until it is resolved.
        Confirmed,
        /// The incident is no longer affecting any Google Cloud product, and there
        /// will be no further updates.
        Resolved,
        /// The incident was merged into a parent incident. All further updates will
        /// be published to the parent only. The `parent_event` field contains the
        /// name of the parent.
        Merged,
        /// The incident was automatically closed because of the following reasons:
        ///
        /// * The impact of the incident could not be confirmed.
        /// * The incident was intermittent or resolved itself.
        ///
        /// The incident does not have a resolution because no action or
        /// investigation happened. If it is intermittent, the incident may reopen.
        AutoClosed,
        /// Upon investigation, Google engineers concluded that the incident is not
        /// affecting a Google Cloud product. This state can change if the incident
        /// is reviewed again.
        FalsePositive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DetailedState::value] or
        /// [DetailedState::name].
        UnknownValue(detailed_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod detailed_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DetailedState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Emerging => std::option::Option::Some(1),
                Self::Confirmed => std::option::Option::Some(2),
                Self::Resolved => std::option::Option::Some(3),
                Self::Merged => std::option::Option::Some(4),
                Self::AutoClosed => std::option::Option::Some(9),
                Self::FalsePositive => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DETAILED_STATE_UNSPECIFIED"),
                Self::Emerging => std::option::Option::Some("EMERGING"),
                Self::Confirmed => std::option::Option::Some("CONFIRMED"),
                Self::Resolved => std::option::Option::Some("RESOLVED"),
                Self::Merged => std::option::Option::Some("MERGED"),
                Self::AutoClosed => std::option::Option::Some("AUTO_CLOSED"),
                Self::FalsePositive => std::option::Option::Some("FALSE_POSITIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DetailedState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DetailedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DetailedState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Emerging,
                2 => Self::Confirmed,
                3 => Self::Resolved,
                4 => Self::Merged,
                9 => Self::AutoClosed,
                10 => Self::FalsePositive,
                _ => Self::UnknownValue(detailed_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DetailedState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DETAILED_STATE_UNSPECIFIED" => Self::Unspecified,
                "EMERGING" => Self::Emerging,
                "CONFIRMED" => Self::Confirmed,
                "RESOLVED" => Self::Resolved,
                "MERGED" => Self::Merged,
                "AUTO_CLOSED" => Self::AutoClosed,
                "FALSE_POSITIVE" => Self::FalsePositive,
                _ => Self::UnknownValue(detailed_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DetailedState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Emerging => serializer.serialize_i32(1),
                Self::Confirmed => serializer.serialize_i32(2),
                Self::Resolved => serializer.serialize_i32(3),
                Self::Merged => serializer.serialize_i32(4),
                Self::AutoClosed => serializer.serialize_i32(9),
                Self::FalsePositive => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DetailedState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailedState>::new(
                ".google.cloud.servicehealth.v1.Event.DetailedState",
            ))
        }
    }

    /// Communicates why a given incident is deemed relevant in the context of a
    /// given project. This enum lists all possible detailed states of relevance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Relevance {
        /// Unspecified relevance.
        Unspecified,
        /// The relevance of the incident to the project is unknown.
        Unknown,
        /// The incident does not impact the project.
        NotImpacted,
        /// The incident is associated with a Google Cloud product your project uses,
        /// but the incident may not be impacting your project. For example, the
        /// incident may be impacting a Google Cloud product that your project uses,
        /// but in a location that your project does not use.
        PartiallyRelated,
        /// The incident has a direct connection with your project and impacts a
        /// Google Cloud product in a location your project uses.
        Related,
        /// The incident is verified to be impacting your project.
        Impacted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Relevance::value] or
        /// [Relevance::name].
        UnknownValue(relevance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod relevance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Relevance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(2),
                Self::NotImpacted => std::option::Option::Some(6),
                Self::PartiallyRelated => std::option::Option::Some(7),
                Self::Related => std::option::Option::Some(8),
                Self::Impacted => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELEVANCE_UNSPECIFIED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::NotImpacted => std::option::Option::Some("NOT_IMPACTED"),
                Self::PartiallyRelated => std::option::Option::Some("PARTIALLY_RELATED"),
                Self::Related => std::option::Option::Some("RELATED"),
                Self::Impacted => std::option::Option::Some("IMPACTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Relevance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Relevance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Relevance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Unknown,
                6 => Self::NotImpacted,
                7 => Self::PartiallyRelated,
                8 => Self::Related,
                9 => Self::Impacted,
                _ => Self::UnknownValue(relevance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Relevance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELEVANCE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN" => Self::Unknown,
                "NOT_IMPACTED" => Self::NotImpacted,
                "PARTIALLY_RELATED" => Self::PartiallyRelated,
                "RELATED" => Self::Related,
                "IMPACTED" => Self::Impacted,
                _ => Self::UnknownValue(relevance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Relevance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(2),
                Self::NotImpacted => serializer.serialize_i32(6),
                Self::PartiallyRelated => serializer.serialize_i32(7),
                Self::Related => serializer.serialize_i32(8),
                Self::Impacted => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Relevance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Relevance>::new(
                ".google.cloud.servicehealth.v1.Event.Relevance",
            ))
        }
    }
}

/// Represents service health events that may affect Google Cloud products used
/// across the organization. It is a read-only view and does not allow any
/// modifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OrganizationEvent {
    /// Output only. Identifier. Name of the event. Unique name of the event in
    /// this scope including organization ID and location using the form
    /// `organizations/{organization_id}/locations/{location}/organizationEvents/{event_id}`.
    ///
    /// `organization_id` - see [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).\<br\>
    /// `location` - The location to get the service health events from.\<br\>
    /// `event_id` - Organization event ID to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Brief description for the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Output only. Free-form, human-readable description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The category of the event.
    pub category: crate::model::organization_event::EventCategory,

    /// Output only. The detailed category of the event.
    pub detailed_category: crate::model::organization_event::DetailedCategory,

    /// Output only. The current state of the event.
    pub state: crate::model::organization_event::State,

    /// Output only. The current detailed state of the incident.
    pub detailed_state: crate::model::organization_event::DetailedState,

    /// Output only. Represents the Google Cloud products and locations impacted by
    /// the event.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub event_impacts: std::vec::Vec<crate::model::EventImpact>,

    /// Output only. Incident-only field. Event updates are correspondence from
    /// Google.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub updates: std::vec::Vec<crate::model::EventUpdate>,

    /// Output only. When `detailed_state`=`MERGED`, `parent_event` contains the
    /// name of the parent event. All further updates will be published to the
    /// parent event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_event: std::string::String,

    /// Output only. The time the update was posted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The start time of the event, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of the event, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Incident-only field. The time when the next update can be
    /// expected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrganizationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OrganizationEvent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [title][crate::model::OrganizationEvent::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OrganizationEvent::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [category][crate::model::OrganizationEvent::category].
    pub fn set_category<T: std::convert::Into<crate::model::organization_event::EventCategory>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [detailed_category][crate::model::OrganizationEvent::detailed_category].
    pub fn set_detailed_category<
        T: std::convert::Into<crate::model::organization_event::DetailedCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detailed_category = v.into();
        self
    }

    /// Sets the value of [state][crate::model::OrganizationEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::organization_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [detailed_state][crate::model::OrganizationEvent::detailed_state].
    pub fn set_detailed_state<
        T: std::convert::Into<crate::model::organization_event::DetailedState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detailed_state = v.into();
        self
    }

    /// Sets the value of [event_impacts][crate::model::OrganizationEvent::event_impacts].
    pub fn set_event_impacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventImpact>,
    {
        use std::iter::Iterator;
        self.event_impacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [updates][crate::model::OrganizationEvent::updates].
    pub fn set_updates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventUpdate>,
    {
        use std::iter::Iterator;
        self.updates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent_event][crate::model::OrganizationEvent::parent_event].
    pub fn set_parent_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_event = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::OrganizationEvent::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OrganizationEvent::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OrganizationEvent::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [next_update_time][crate::model::OrganizationEvent::next_update_time].
    pub fn set_next_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_update_time = v.into();
        self
    }
}

impl wkt::message::Message for OrganizationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.OrganizationEvent"
    }
}

/// Defines additional types related to [OrganizationEvent].
pub mod organization_event {
    #[allow(unused_imports)]
    use super::*;

    /// The category of the event. This enum lists all possible categories of
    /// event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventCategory {
        /// Unspecified category.
        Unspecified,
        /// Event category for service outage or degradation.
        Incident,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventCategory::value] or
        /// [EventCategory::name].
        UnknownValue(event_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incident => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_CATEGORY_UNSPECIFIED"),
                Self::Incident => std::option::Option::Some("INCIDENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Incident,
                _ => Self::UnknownValue(event_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "INCIDENT" => Self::Incident,
                _ => Self::UnknownValue(event_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incident => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventCategory>::new(
                ".google.cloud.servicehealth.v1.OrganizationEvent.EventCategory",
            ))
        }
    }

    /// The detailed category of an event. Contains all possible states for all
    /// event categories.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailedCategory {
        /// Unspecified detailed category.
        Unspecified,
        /// Indicates an event with category INCIDENT has a confirmed impact to at
        /// least one Google Cloud product.
        ConfirmedIncident,
        /// Indicates an event with category INCIDENT is under investigation to
        /// determine if it has a confirmed impact on any Google Cloud products.
        EmergingIncident,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DetailedCategory::value] or
        /// [DetailedCategory::name].
        UnknownValue(detailed_category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod detailed_category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DetailedCategory {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConfirmedIncident => std::option::Option::Some(1),
                Self::EmergingIncident => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DETAILED_CATEGORY_UNSPECIFIED"),
                Self::ConfirmedIncident => std::option::Option::Some("CONFIRMED_INCIDENT"),
                Self::EmergingIncident => std::option::Option::Some("EMERGING_INCIDENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DetailedCategory {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DetailedCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DetailedCategory {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConfirmedIncident,
                2 => Self::EmergingIncident,
                _ => Self::UnknownValue(detailed_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DetailedCategory {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DETAILED_CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "CONFIRMED_INCIDENT" => Self::ConfirmedIncident,
                "EMERGING_INCIDENT" => Self::EmergingIncident,
                _ => Self::UnknownValue(detailed_category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DetailedCategory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConfirmedIncident => serializer.serialize_i32(1),
                Self::EmergingIncident => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DetailedCategory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailedCategory>::new(
                ".google.cloud.servicehealth.v1.OrganizationEvent.DetailedCategory",
            ))
        }
    }

    /// The state of the organization event. This enum lists all possible states of
    /// event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Event is actively affecting a Google Cloud product and will continue to
        /// receive updates.
        Active,
        /// Event is no longer affecting the Google Cloud product or has been merged
        /// with another event.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Closed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Closed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.servicehealth.v1.OrganizationEvent.State",
            ))
        }
    }

    /// The detailed state of the incident. This enum lists all possible detailed
    /// states of an incident.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailedState {
        /// Unspecified detail state.
        Unspecified,
        /// Google engineers are actively investigating the incident to determine the
        /// impact.
        Emerging,
        /// The incident is confirmed and impacting at least one Google Cloud
        /// product. Ongoing status updates will be provided until it is resolved.
        Confirmed,
        /// The incident is no longer affecting any Google Cloud product, and there
        /// will be no further updates.
        Resolved,
        /// The incident was merged into a parent event. All further updates will be
        /// published to the parent only. The `parent_event` contains the name of the
        /// parent.
        Merged,
        /// The incident was automatically closed because of the following reasons:
        ///
        /// * The impact of the incident could not be confirmed.
        /// * The incident was intermittent or resolved itself.
        ///
        /// The incident does not have a resolution because no action or
        /// investigation happened. If it is intermittent, the incident may reopen.
        AutoClosed,
        /// Upon investigation, Google engineers concluded that the incident is not
        /// affecting a Google Cloud product. This state can change if the incident
        /// is reviewed again.
        FalsePositive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DetailedState::value] or
        /// [DetailedState::name].
        UnknownValue(detailed_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod detailed_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DetailedState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Emerging => std::option::Option::Some(1),
                Self::Confirmed => std::option::Option::Some(2),
                Self::Resolved => std::option::Option::Some(3),
                Self::Merged => std::option::Option::Some(4),
                Self::AutoClosed => std::option::Option::Some(9),
                Self::FalsePositive => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DETAILED_STATE_UNSPECIFIED"),
                Self::Emerging => std::option::Option::Some("EMERGING"),
                Self::Confirmed => std::option::Option::Some("CONFIRMED"),
                Self::Resolved => std::option::Option::Some("RESOLVED"),
                Self::Merged => std::option::Option::Some("MERGED"),
                Self::AutoClosed => std::option::Option::Some("AUTO_CLOSED"),
                Self::FalsePositive => std::option::Option::Some("FALSE_POSITIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DetailedState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DetailedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DetailedState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Emerging,
                2 => Self::Confirmed,
                3 => Self::Resolved,
                4 => Self::Merged,
                9 => Self::AutoClosed,
                10 => Self::FalsePositive,
                _ => Self::UnknownValue(detailed_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DetailedState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DETAILED_STATE_UNSPECIFIED" => Self::Unspecified,
                "EMERGING" => Self::Emerging,
                "CONFIRMED" => Self::Confirmed,
                "RESOLVED" => Self::Resolved,
                "MERGED" => Self::Merged,
                "AUTO_CLOSED" => Self::AutoClosed,
                "FALSE_POSITIVE" => Self::FalsePositive,
                _ => Self::UnknownValue(detailed_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DetailedState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Emerging => serializer.serialize_i32(1),
                Self::Confirmed => serializer.serialize_i32(2),
                Self::Resolved => serializer.serialize_i32(3),
                Self::Merged => serializer.serialize_i32(4),
                Self::AutoClosed => serializer.serialize_i32(9),
                Self::FalsePositive => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DetailedState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailedState>::new(
                ".google.cloud.servicehealth.v1.OrganizationEvent.DetailedState",
            ))
        }
    }
}

/// Records an update made to the event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventUpdate {
    /// Output only. The time the update was posted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Brief title for the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Output only. Free-form, human-readable description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Symptoms of the event, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub symptom: std::string::String,

    /// Output only. Workaround steps to remediate the event impact, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workaround: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::EventUpdate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [title][crate::model::EventUpdate::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EventUpdate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [symptom][crate::model::EventUpdate::symptom].
    pub fn set_symptom<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.symptom = v.into();
        self
    }

    /// Sets the value of [workaround][crate::model::EventUpdate::workaround].
    pub fn set_workaround<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workaround = v.into();
        self
    }
}

impl wkt::message::Message for EventUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.EventUpdate"
    }
}

/// Represents the locations impacted by the event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Location {
    /// Location impacted by the event. Example: `"us-central1"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location_name][crate::model::Location::location_name].
    pub fn set_location_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_name = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.Location"
    }
}

/// Represents the Google Cloud product impacted by the event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Product {
    /// Google Cloud product impacted by the event. Example: `"Google Cloud SQL"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product_name: std::string::String,

    /// Unique identifier for the product.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Product {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product_name][crate::model::Product::product_name].
    pub fn set_product_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Product::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for Product {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.Product"
    }
}

/// Represents the Google Cloud products and locations impacted by the event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EventImpact {
    /// Google Cloud product impacted by the event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product: std::option::Option<crate::model::Product>,

    /// Location impacted by the event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::Location>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EventImpact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::EventImpact::product].
    pub fn set_product<T: std::convert::Into<std::option::Option<crate::model::Product>>>(
        mut self,
        v: T,
    ) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [location][crate::model::EventImpact::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<crate::model::Location>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for EventImpact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.EventImpact"
    }
}

/// Represents impact to assets at organizational level. It is a read-only view
/// and does not allow any modifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OrganizationImpact {
    /// Output only. Identifier. Unique name of the organization impact in this
    /// scope including organization and location using the form
    /// `organizations/{organization_id}/locations/{location}/organizationImpacts/{organization_impact_id}`.
    ///
    /// `organization_id` - ID (number) of the organization that contains the
    /// event. To get your `organization_id`, see
    /// [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).\<br\>
    /// `organization_impact_id` - ID of the [OrganizationImpact
    /// resource](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. A list of event names impacting the asset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<std::string::String>,

    /// Output only. Google Cloud asset possibly impacted by the specified events.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub asset: std::option::Option<crate::model::Asset>,

    /// Output only. The time when the affected project was last modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrganizationImpact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OrganizationImpact::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [events][crate::model::OrganizationImpact::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [asset][crate::model::OrganizationImpact::asset].
    pub fn set_asset<T: std::convert::Into<std::option::Option<crate::model::Asset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::OrganizationImpact::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for OrganizationImpact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.OrganizationImpact"
    }
}

/// Represents the asset impacted by the events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Asset {
    /// Output only. Full name of the resource as defined in
    /// [Resource
    /// Names](https://cloud.google.com/apis/design/resource_names#full_resource_name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_name: std::string::String,

    /// Output only. Type of the asset. Example:
    /// `"cloudresourcemanager.googleapis.com/Project"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset_name][crate::model::Asset::asset_name].
    pub fn set_asset_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_name = v.into();
        self
    }

    /// Sets the value of [asset_type][crate::model::Asset::asset_type].
    pub fn set_asset_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_type = v.into();
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.Asset"
    }
}

/// Requests list of events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEventsRequest {
    /// Required. Parent value using the form
    /// `projects/{project_id}/locations/{location}/events`.
    ///
    /// `project_id` - ID of the project for which to list service health
    /// events.
    /// `location` - The location to get the service health events from.
    /// To retrieve service health events of category = INCIDENT, use `location` =
    /// `global`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of events that should be returned.  Acceptable
    /// values are 1 to 100, inclusive. (The default value is 10.) If more results
    /// are available, the service returns a next_page_token that you can use to
    /// get the next page of results in subsequent list requests. The service may
    /// return fewer events than the requested page_size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Provide Page token returned by a previous `ListEvents` call to retrieve the
    /// next page of results. When paginating, all other parameters provided to
    /// `ListEvents` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter expression that filters resources listed in the
    /// response. The expression takes the following forms: \<br\>
    ///
    /// * field=value for `category` and `state`\<br\>
    /// * field &lt;, >, &lt;=, or >= value for `update_time` \<br\>
    ///   Examples: `category=INCIDENT`, `update_time>="2000-01-01T11:30:00-04:00"`,
    ///   `event_impacts.product.product_name:"Eventarc"`
    ///   \<br\>
    ///
    /// Multiple filter queries are separated by spaces. Example:
    /// `category=INCIDENT state=ACTIVE`.
    ///
    /// By default, each expression is an AND expression. However, you can include
    /// AND and OR expressions explicitly.
    ///
    /// Filter is supported for the following fields: `category`, `state`,
    /// `update_time`, `event_impacts.product.product_name`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Event fields to include in response.
    pub view: crate::model::EventView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEventsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEventsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEventsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListEventsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::EventView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.ListEventsRequest"
    }
}

/// Response to request for listing events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEventsResponse {
    /// Output only. List of events.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,

    /// Output only. The continuation token, used to page through large result
    /// sets. Provide this value in a subsequent request as page_token to retrieve
    /// the next page.
    ///
    /// If this field is not present, there are no subsequent results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [events][crate::model::ListEventsResponse::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEventsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEventsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.ListEventsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEventsResponse {
    type PageItem = crate::model::Event;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.events
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets information about a specific event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEventRequest {
    /// Required. Unique name of the event in this scope including project
    /// and location using the form
    /// `projects/{project_id}/locations/{location}/events/{event_id}`.
    ///
    /// `project_id` - Project ID of the project that contains the event. \<br\>
    /// `location` - The location to get the service health events from. \<br\>
    /// `event_id` - Event ID to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEventRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.GetEventRequest"
    }
}

/// Requests list of events that affect an organization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrganizationEventsRequest {
    /// Required. Parent value using the form
    /// `organizations/{organization_id}/locations/{location}/organizationEvents`.
    ///
    /// `organization_id` - ID (number) of the project that contains the event. To
    /// get your `organization_id`, see
    /// [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).\<br\>
    /// `location` - The location to get the service health events from. To
    /// retrieve service health events of category = INCIDENT, use `location` =
    /// `global`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of events that should be returned.  Acceptable
    /// values are `1` to `100`, inclusive. (The default value is `10`.) If more
    /// results are available, the service returns a `next_page_token` that you can
    /// use to get the next page of results in subsequent list requests. The
    /// service may return fewer events than the requested `page_size`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    ///
    /// Provide Page token returned by a previous `ListOrganizationEvents` call to
    /// retrieve the next page of results.
    ///
    /// When paginating, all other parameters provided to
    /// `ListOrganizationEvents` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter expression that filters resources listed in the
    /// response. The expression takes the following forms:
    ///
    /// * field=value for `category` and `state`
    /// * field &lt;, >, &lt;=, or >= value for `update_time`
    ///
    /// Examples: `category=INCIDENT`, `update_time>="2000-01-01T11:30:00-04:00"`
    ///
    /// Multiple filter queries are space-separated. Example:
    /// `category=INCIDENT state=ACTIVE`.
    ///
    /// By default, each expression is an AND expression. However, you can include
    /// AND and OR expressions explicitly.
    ///
    /// Filter is supported for the following fields: `category`, `state`,
    /// `update_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. OrganizationEvent fields to include in response.
    pub view: crate::model::OrganizationEventView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrganizationEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOrganizationEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOrganizationEventsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOrganizationEventsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOrganizationEventsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListOrganizationEventsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::OrganizationEventView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListOrganizationEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.ListOrganizationEventsRequest"
    }
}

/// Response to request for listing organization events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrganizationEventsResponse {
    /// Output only. List of organization events affecting an organization.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub organization_events: std::vec::Vec<crate::model::OrganizationEvent>,

    /// Output only. The continuation token, used to page through large result
    /// sets. Provide this value in a subsequent request as `page_token` to
    /// retrieve the next page.
    ///
    /// If this field is not present, there are no subsequent results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrganizationEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [organization_events][crate::model::ListOrganizationEventsResponse::organization_events].
    pub fn set_organization_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrganizationEvent>,
    {
        use std::iter::Iterator;
        self.organization_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOrganizationEventsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListOrganizationEventsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOrganizationEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.ListOrganizationEventsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOrganizationEventsResponse {
    type PageItem = crate::model::OrganizationEvent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.organization_events
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets information about a specific event affecting an organization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOrganizationEventRequest {
    /// Required. Unique name of the event in this scope including organization and
    /// event ID using the form
    /// `organizations/{organization_id}/locations/locations/global/organizationEvents/{event_id}`.
    ///
    /// `organization_id` - ID (number) of the project that contains the event. To
    /// get your `organization_id`, see
    /// [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).\<br\>
    /// `event_id` - Organization event ID to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOrganizationEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOrganizationEventRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOrganizationEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.GetOrganizationEventRequest"
    }
}

/// Requests list of projects under an organization affected by an event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrganizationImpactsRequest {
    /// Required. Parent value using the form
    /// `organizations/{organization_id}/locations/{location}/organizationImpacts`.
    ///
    /// `organization_id` - ID (number) of the project that contains the event. To
    /// get your `organization_id`, see
    /// [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of events that should be returned. Acceptable
    /// values are `1` to `100`, inclusive. The default value is `10`.
    ///
    /// If more results are available, the service returns a
    /// `next_page_token` that can be used to get the next page of results in
    /// subsequent list requests. The service may return fewer
    /// [impacts](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact)
    /// than the requested `page_size`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    ///
    /// Provide `page_token` returned by a previous `ListOrganizationImpacts` call
    /// to retrieve the next page of results.
    ///
    /// When paginating, all other parameters provided to `ListOrganizationImpacts`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter expression that filters resources listed in the
    /// response. The expression is in the form of `field:value` for checking if a
    /// repeated field contains a value.
    ///
    /// Example:
    /// `events:organizations%2F{organization_id}%2Flocations%2Fglobal%2ForganizationEvents%2Fevent-id`
    ///
    /// To get your `{organization_id}`, see
    /// [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
    ///
    /// Multiple filter queries are separated by spaces.
    ///
    /// By default, each expression is an AND expression. However, you can include
    /// AND and OR expressions explicitly.
    /// Filter is supported for the following fields: `events`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrganizationImpactsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOrganizationImpactsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOrganizationImpactsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOrganizationImpactsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOrganizationImpactsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListOrganizationImpactsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.ListOrganizationImpactsRequest"
    }
}

/// Response to request for listing projects under an organization affected by an
/// event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrganizationImpactsResponse {
    /// Output only. List of
    /// [impacts](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact)
    /// for an organization affected by service health events.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub organization_impacts: std::vec::Vec<crate::model::OrganizationImpact>,

    /// Output only. The continuation token, used to page through large result
    /// sets. Provide this value in a subsequent request as `page_token` to
    /// retrieve the next page.
    ///
    /// If this field is not present, there are no subsequent results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrganizationImpactsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [organization_impacts][crate::model::ListOrganizationImpactsResponse::organization_impacts].
    pub fn set_organization_impacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrganizationImpact>,
    {
        use std::iter::Iterator;
        self.organization_impacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOrganizationImpactsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListOrganizationImpactsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOrganizationImpactsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.ListOrganizationImpactsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOrganizationImpactsResponse {
    type PageItem = crate::model::OrganizationImpact;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.organization_impacts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets information about an event that affects a project under an organization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOrganizationImpactRequest {
    /// Required. Name of the resource using the form
    /// `organizations/{organization_id}/locations/global/organizationImpacts/{organization_impact_id}`.
    ///
    /// `organization_id` - ID (number) of the organization that contains the
    /// event. To get your `organization_id`, see
    /// [Getting your organization resource
    /// ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).\<br\>
    /// `organization_impact_id` - ID of the [OrganizationImpact
    /// resource](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOrganizationImpactRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOrganizationImpactRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOrganizationImpactRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.servicehealth.v1.GetOrganizationImpactRequest"
    }
}

/// The event fields to include in ListEvents API response. This enum lists all
/// possible event views.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EventView {
    /// Unspecified event view. Default to `EVENT_VIEW_BASIC`.
    Unspecified,
    /// Includes all fields except `updates`. This view is the default for
    /// ListEvents API.
    Basic,
    /// Includes all event fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EventView::value] or
    /// [EventView::name].
    UnknownValue(event_view::UnknownValue),
}

#[doc(hidden)]
pub mod event_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EventView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("EVENT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("EVENT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("EVENT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EventView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EventView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EventView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(event_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EventView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EVENT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "EVENT_VIEW_BASIC" => Self::Basic,
            "EVENT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(event_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EventView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EventView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventView>::new(
            ".google.cloud.servicehealth.v1.EventView",
        ))
    }
}

/// The organization event fields to include in ListOrganizationEvents API
/// response. This enum lists all possible organization event views.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OrganizationEventView {
    /// Unspecified event view. Default to `ORGANIZATION_EVENT_VIEW_BASIC`.
    Unspecified,
    /// Includes all organization event fields except `updates`. This view is the
    /// default for ListOrganizationEvents API.
    Basic,
    /// Includes all organization event fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OrganizationEventView::value] or
    /// [OrganizationEventView::name].
    UnknownValue(organization_event_view::UnknownValue),
}

#[doc(hidden)]
pub mod organization_event_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OrganizationEventView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ORGANIZATION_EVENT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("ORGANIZATION_EVENT_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("ORGANIZATION_EVENT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OrganizationEventView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OrganizationEventView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OrganizationEventView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(organization_event_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OrganizationEventView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ORGANIZATION_EVENT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "ORGANIZATION_EVENT_VIEW_BASIC" => Self::Basic,
            "ORGANIZATION_EVENT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(organization_event_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OrganizationEventView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OrganizationEventView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OrganizationEventView>::new(
            ".google.cloud.servicehealth.v1.OrganizationEventView",
        ))
    }
}
