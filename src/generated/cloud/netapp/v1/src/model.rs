// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// ListActiveDirectoriesRequest for requesting multiple active directories.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListActiveDirectoriesRequest {
    /// Required. Parent value for ListActiveDirectoriesRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListActiveDirectoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListActiveDirectoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListActiveDirectoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListActiveDirectoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListActiveDirectoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListActiveDirectoriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListActiveDirectoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListActiveDirectoriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListActiveDirectoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListActiveDirectoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListActiveDirectoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListActiveDirectoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListActiveDirectoriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListActiveDirectoriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListActiveDirectoriesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListActiveDirectoriesResponse contains all the active directories requested.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListActiveDirectoriesResponse {
    /// The list of active directories.
    pub active_directories: std::vec::Vec<crate::model::ActiveDirectory>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListActiveDirectoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [active_directories][crate::model::ListActiveDirectoriesResponse::active_directories].
    pub fn set_active_directories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ActiveDirectory>,
    {
        use std::iter::Iterator;
        self.active_directories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListActiveDirectoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListActiveDirectoriesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListActiveDirectoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListActiveDirectoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListActiveDirectoriesResponse {
    type PageItem = crate::model::ActiveDirectory;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.active_directories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListActiveDirectoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __active_directories,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListActiveDirectoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "activeDirectories" => Ok(__FieldTag::__active_directories),
                            "active_directories" => Ok(__FieldTag::__active_directories),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListActiveDirectoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListActiveDirectoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__active_directories => {
                            if !fields.insert(__FieldTag::__active_directories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directories",
                                ));
                            }
                            result.active_directories =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ActiveDirectory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListActiveDirectoriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.active_directories.is_empty() {
            state.serialize_entry("activeDirectories", &self.active_directories)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListActiveDirectoriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListActiveDirectoriesResponse");
        debug_struct.field("active_directories", &self.active_directories);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetActiveDirectory for getting a single active directory.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetActiveDirectoryRequest {
    /// Required. Name of the active directory.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetActiveDirectoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetActiveDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetActiveDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetActiveDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetActiveDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetActiveDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetActiveDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetActiveDirectoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetActiveDirectoryRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateActiveDirectoryRequest for creating an active directory.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateActiveDirectoryRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. Fields of the to be created active directory.
    pub active_directory: std::option::Option<crate::model::ActiveDirectory>,

    /// Required. ID of the active directory to create. Must be unique within the
    /// parent resource. Must contain only letters, numbers and hyphen, with the
    /// first character a letter , the last a letter or a number, and a 63
    /// character maximum.
    pub active_directory_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateActiveDirectoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::CreateActiveDirectoryRequest::active_directory].
    pub fn set_active_directory<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ActiveDirectory>,
    {
        self.active_directory = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [active_directory][crate::model::CreateActiveDirectoryRequest::active_directory].
    pub fn set_or_clear_active_directory<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ActiveDirectory>,
    {
        self.active_directory = v.map(|x| x.into());
        self
    }

    /// Sets the value of [active_directory_id][crate::model::CreateActiveDirectoryRequest::active_directory_id].
    pub fn set_active_directory_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateActiveDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateActiveDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __active_directory,
            __active_directory_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateActiveDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "activeDirectory" => Ok(__FieldTag::__active_directory),
                            "active_directory" => Ok(__FieldTag::__active_directory),
                            "activeDirectoryId" => Ok(__FieldTag::__active_directory_id),
                            "active_directory_id" => Ok(__FieldTag::__active_directory_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateActiveDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateActiveDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_directory => {
                            if !fields.insert(__FieldTag::__active_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directory",
                                ));
                            }
                            result.active_directory = map
                                .next_value::<std::option::Option<crate::model::ActiveDirectory>>(
                                )?;
                        }
                        __FieldTag::__active_directory_id => {
                            if !fields.insert(__FieldTag::__active_directory_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directory_id",
                                ));
                            }
                            result.active_directory_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateActiveDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.active_directory.is_some() {
            state.serialize_entry("activeDirectory", &self.active_directory)?;
        }
        if !self.active_directory_id.is_empty() {
            state.serialize_entry("activeDirectoryId", &self.active_directory_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateActiveDirectoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateActiveDirectoryRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("active_directory", &self.active_directory);
        debug_struct.field("active_directory_id", &self.active_directory_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateActiveDirectoryRequest for updating an active directory.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateActiveDirectoryRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Active Directory resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The volume being updated
    pub active_directory: std::option::Option<crate::model::ActiveDirectory>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateActiveDirectoryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateActiveDirectoryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [active_directory][crate::model::UpdateActiveDirectoryRequest::active_directory].
    pub fn set_active_directory<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ActiveDirectory>,
    {
        self.active_directory = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [active_directory][crate::model::UpdateActiveDirectoryRequest::active_directory].
    pub fn set_or_clear_active_directory<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ActiveDirectory>,
    {
        self.active_directory = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateActiveDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateActiveDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __active_directory,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateActiveDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "activeDirectory" => Ok(__FieldTag::__active_directory),
                            "active_directory" => Ok(__FieldTag::__active_directory),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateActiveDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateActiveDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__active_directory => {
                            if !fields.insert(__FieldTag::__active_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directory",
                                ));
                            }
                            result.active_directory = map
                                .next_value::<std::option::Option<crate::model::ActiveDirectory>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateActiveDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.active_directory.is_some() {
            state.serialize_entry("activeDirectory", &self.active_directory)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateActiveDirectoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateActiveDirectoryRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("active_directory", &self.active_directory);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteActiveDirectoryRequest for deleting a single active directory.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteActiveDirectoryRequest {
    /// Required. Name of the active directory.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteActiveDirectoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteActiveDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteActiveDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteActiveDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteActiveDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteActiveDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteActiveDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteActiveDirectoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteActiveDirectoryRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ActiveDirectory is the public representation of the active directory config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ActiveDirectory {
    /// Identifier. The resource name of the active directory.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/activeDirectories/{active_directory_id}`.
    pub name: std::string::String,

    /// Output only. Create time of the active directory.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the AD.
    pub state: crate::model::active_directory::State,

    /// Required. Name of the Active Directory domain
    pub domain: std::string::String,

    /// The Active Directory site the service will limit Domain Controller
    /// discovery too.
    pub site: std::string::String,

    /// Required. Comma separated list of DNS server IP addresses for the Active
    /// Directory domain.
    pub dns: std::string::String,

    /// Required. NetBIOSPrefix is used as a prefix for SMB server name.
    pub net_bios_prefix: std::string::String,

    /// The Organizational Unit (OU) within the Windows Active Directory the user
    /// belongs to.
    pub organizational_unit: std::string::String,

    /// If enabled, AES encryption will be enabled for SMB communication.
    pub aes_encryption: bool,

    /// Required. Username of the Active Directory domain administrator.
    pub username: std::string::String,

    /// Required. Password of the Active Directory domain administrator.
    pub password: std::string::String,

    /// Optional. Users to be added to the Built-in Backup Operator active
    /// directory group.
    pub backup_operators: std::vec::Vec<std::string::String>,

    /// Optional. Users to be added to the Built-in Admininstrators group.
    pub administrators: std::vec::Vec<std::string::String>,

    /// Optional. Domain users to be given the SeSecurityPrivilege.
    pub security_operators: std::vec::Vec<std::string::String>,

    /// Name of the active directory machine. This optional parameter is used only
    /// while creating kerberos volume
    pub kdc_hostname: std::string::String,

    /// KDC server IP address for the active directory machine.
    pub kdc_ip: std::string::String,

    /// If enabled, will allow access to local users and LDAP users. If access is
    /// needed for only LDAP users, it has to be disabled.
    pub nfs_users_with_ldap: bool,

    /// Description of the active directory.
    pub description: std::string::String,

    /// Specifies whether or not the LDAP traffic needs to be signed.
    pub ldap_signing: bool,

    /// If enabled, traffic between the SMB server to Domain Controller (DC) will
    /// be encrypted.
    pub encrypt_dc_connections: bool,

    /// Labels for the active directory.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The state details of the Active Directory.
    pub state_details: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActiveDirectory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ActiveDirectory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ActiveDirectory::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ActiveDirectory::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ActiveDirectory::state].
    pub fn set_state<T: std::convert::Into<crate::model::active_directory::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::ActiveDirectory::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [site][crate::model::ActiveDirectory::site].
    pub fn set_site<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site = v.into();
        self
    }

    /// Sets the value of [dns][crate::model::ActiveDirectory::dns].
    pub fn set_dns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns = v.into();
        self
    }

    /// Sets the value of [net_bios_prefix][crate::model::ActiveDirectory::net_bios_prefix].
    pub fn set_net_bios_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.net_bios_prefix = v.into();
        self
    }

    /// Sets the value of [organizational_unit][crate::model::ActiveDirectory::organizational_unit].
    pub fn set_organizational_unit<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.organizational_unit = v.into();
        self
    }

    /// Sets the value of [aes_encryption][crate::model::ActiveDirectory::aes_encryption].
    pub fn set_aes_encryption<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.aes_encryption = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ActiveDirectory::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::ActiveDirectory::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [backup_operators][crate::model::ActiveDirectory::backup_operators].
    pub fn set_backup_operators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.backup_operators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [administrators][crate::model::ActiveDirectory::administrators].
    pub fn set_administrators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.administrators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_operators][crate::model::ActiveDirectory::security_operators].
    pub fn set_security_operators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.security_operators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kdc_hostname][crate::model::ActiveDirectory::kdc_hostname].
    pub fn set_kdc_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kdc_hostname = v.into();
        self
    }

    /// Sets the value of [kdc_ip][crate::model::ActiveDirectory::kdc_ip].
    pub fn set_kdc_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kdc_ip = v.into();
        self
    }

    /// Sets the value of [nfs_users_with_ldap][crate::model::ActiveDirectory::nfs_users_with_ldap].
    pub fn set_nfs_users_with_ldap<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nfs_users_with_ldap = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ActiveDirectory::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [ldap_signing][crate::model::ActiveDirectory::ldap_signing].
    pub fn set_ldap_signing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ldap_signing = v.into();
        self
    }

    /// Sets the value of [encrypt_dc_connections][crate::model::ActiveDirectory::encrypt_dc_connections].
    pub fn set_encrypt_dc_connections<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.encrypt_dc_connections = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ActiveDirectory::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state_details][crate::model::ActiveDirectory::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }
}

impl wkt::message::Message for ActiveDirectory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ActiveDirectory"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ActiveDirectory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __state,
            __domain,
            __site,
            __dns,
            __net_bios_prefix,
            __organizational_unit,
            __aes_encryption,
            __username,
            __password,
            __backup_operators,
            __administrators,
            __security_operators,
            __kdc_hostname,
            __kdc_ip,
            __nfs_users_with_ldap,
            __description,
            __ldap_signing,
            __encrypt_dc_connections,
            __labels,
            __state_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ActiveDirectory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "state" => Ok(__FieldTag::__state),
                            "domain" => Ok(__FieldTag::__domain),
                            "site" => Ok(__FieldTag::__site),
                            "dns" => Ok(__FieldTag::__dns),
                            "netBiosPrefix" => Ok(__FieldTag::__net_bios_prefix),
                            "net_bios_prefix" => Ok(__FieldTag::__net_bios_prefix),
                            "organizationalUnit" => Ok(__FieldTag::__organizational_unit),
                            "organizational_unit" => Ok(__FieldTag::__organizational_unit),
                            "aesEncryption" => Ok(__FieldTag::__aes_encryption),
                            "aes_encryption" => Ok(__FieldTag::__aes_encryption),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "backupOperators" => Ok(__FieldTag::__backup_operators),
                            "backup_operators" => Ok(__FieldTag::__backup_operators),
                            "administrators" => Ok(__FieldTag::__administrators),
                            "securityOperators" => Ok(__FieldTag::__security_operators),
                            "security_operators" => Ok(__FieldTag::__security_operators),
                            "kdcHostname" => Ok(__FieldTag::__kdc_hostname),
                            "kdc_hostname" => Ok(__FieldTag::__kdc_hostname),
                            "kdcIp" => Ok(__FieldTag::__kdc_ip),
                            "kdc_ip" => Ok(__FieldTag::__kdc_ip),
                            "nfsUsersWithLdap" => Ok(__FieldTag::__nfs_users_with_ldap),
                            "nfs_users_with_ldap" => Ok(__FieldTag::__nfs_users_with_ldap),
                            "description" => Ok(__FieldTag::__description),
                            "ldapSigning" => Ok(__FieldTag::__ldap_signing),
                            "ldap_signing" => Ok(__FieldTag::__ldap_signing),
                            "encryptDcConnections" => Ok(__FieldTag::__encrypt_dc_connections),
                            "encrypt_dc_connections" => Ok(__FieldTag::__encrypt_dc_connections),
                            "labels" => Ok(__FieldTag::__labels),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ActiveDirectory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ActiveDirectory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::active_directory::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__site => {
                            if !fields.insert(__FieldTag::__site) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for site",
                                ));
                            }
                            result.site = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns => {
                            if !fields.insert(__FieldTag::__dns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns",
                                ));
                            }
                            result.dns = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__net_bios_prefix => {
                            if !fields.insert(__FieldTag::__net_bios_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for net_bios_prefix",
                                ));
                            }
                            result.net_bios_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organizational_unit => {
                            if !fields.insert(__FieldTag::__organizational_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organizational_unit",
                                ));
                            }
                            result.organizational_unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aes_encryption => {
                            if !fields.insert(__FieldTag::__aes_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aes_encryption",
                                ));
                            }
                            result.aes_encryption = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_operators => {
                            if !fields.insert(__FieldTag::__backup_operators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_operators",
                                ));
                            }
                            result.backup_operators = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__administrators => {
                            if !fields.insert(__FieldTag::__administrators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for administrators",
                                ));
                            }
                            result.administrators = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__security_operators => {
                            if !fields.insert(__FieldTag::__security_operators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_operators",
                                ));
                            }
                            result.security_operators = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kdc_hostname => {
                            if !fields.insert(__FieldTag::__kdc_hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kdc_hostname",
                                ));
                            }
                            result.kdc_hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kdc_ip => {
                            if !fields.insert(__FieldTag::__kdc_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kdc_ip",
                                ));
                            }
                            result.kdc_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nfs_users_with_ldap => {
                            if !fields.insert(__FieldTag::__nfs_users_with_ldap) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs_users_with_ldap",
                                ));
                            }
                            result.nfs_users_with_ldap = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ldap_signing => {
                            if !fields.insert(__FieldTag::__ldap_signing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ldap_signing",
                                ));
                            }
                            result.ldap_signing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encrypt_dc_connections => {
                            if !fields.insert(__FieldTag::__encrypt_dc_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encrypt_dc_connections",
                                ));
                            }
                            result.encrypt_dc_connections = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ActiveDirectory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.site.is_empty() {
            state.serialize_entry("site", &self.site)?;
        }
        if !self.dns.is_empty() {
            state.serialize_entry("dns", &self.dns)?;
        }
        if !self.net_bios_prefix.is_empty() {
            state.serialize_entry("netBiosPrefix", &self.net_bios_prefix)?;
        }
        if !self.organizational_unit.is_empty() {
            state.serialize_entry("organizationalUnit", &self.organizational_unit)?;
        }
        if !wkt::internal::is_default(&self.aes_encryption) {
            state.serialize_entry("aesEncryption", &self.aes_encryption)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.backup_operators.is_empty() {
            state.serialize_entry("backupOperators", &self.backup_operators)?;
        }
        if !self.administrators.is_empty() {
            state.serialize_entry("administrators", &self.administrators)?;
        }
        if !self.security_operators.is_empty() {
            state.serialize_entry("securityOperators", &self.security_operators)?;
        }
        if !self.kdc_hostname.is_empty() {
            state.serialize_entry("kdcHostname", &self.kdc_hostname)?;
        }
        if !self.kdc_ip.is_empty() {
            state.serialize_entry("kdcIp", &self.kdc_ip)?;
        }
        if !wkt::internal::is_default(&self.nfs_users_with_ldap) {
            state.serialize_entry("nfsUsersWithLdap", &self.nfs_users_with_ldap)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.ldap_signing) {
            state.serialize_entry("ldapSigning", &self.ldap_signing)?;
        }
        if !wkt::internal::is_default(&self.encrypt_dc_connections) {
            state.serialize_entry("encryptDcConnections", &self.encrypt_dc_connections)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ActiveDirectory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ActiveDirectory");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("domain", &self.domain);
        debug_struct.field("site", &self.site);
        debug_struct.field("dns", &self.dns);
        debug_struct.field("net_bios_prefix", &self.net_bios_prefix);
        debug_struct.field("organizational_unit", &self.organizational_unit);
        debug_struct.field("aes_encryption", &self.aes_encryption);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("backup_operators", &self.backup_operators);
        debug_struct.field("administrators", &self.administrators);
        debug_struct.field("security_operators", &self.security_operators);
        debug_struct.field("kdc_hostname", &self.kdc_hostname);
        debug_struct.field("kdc_ip", &self.kdc_ip);
        debug_struct.field("nfs_users_with_ldap", &self.nfs_users_with_ldap);
        debug_struct.field("description", &self.description);
        debug_struct.field("ldap_signing", &self.ldap_signing);
        debug_struct.field("encrypt_dc_connections", &self.encrypt_dc_connections);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("state_details", &self.state_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ActiveDirectory].
pub mod active_directory {
    #[allow(unused_imports)]
    use super::*;

    /// The Active Directory States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Active Directory State
        Unspecified,
        /// Active Directory State is Creating
        Creating,
        /// Active Directory State is Ready
        Ready,
        /// Active Directory State is Updating
        Updating,
        /// Active Directory State is In use
        InUse,
        /// Active Directory State is Deleting
        Deleting,
        /// Active Directory State is Error
        Error,
        /// Active Directory State is Diagnosing.
        Diagnosing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::InUse => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::Diagnosing => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::InUse => std::option::Option::Some("IN_USE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Diagnosing => std::option::Option::Some("DIAGNOSING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                4 => Self::InUse,
                5 => Self::Deleting,
                6 => Self::Error,
                7 => Self::Diagnosing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "IN_USE" => Self::InUse,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "DIAGNOSING" => Self::Diagnosing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::InUse => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::Diagnosing => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.ActiveDirectory.State",
            ))
        }
    }
}

/// A NetApp Backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Identifier. The resource name of the backup.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`.
    pub name: std::string::String,

    /// Output only. The backup state.
    pub state: crate::model::backup::State,

    /// A description of the backup with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    pub description: std::string::String,

    /// Output only. Size of the file system when the backup was created. When
    /// creating a new volume from the backup, the volume capacity will have to be
    /// at least as big.
    pub volume_usage_bytes: i64,

    /// Output only. Type of backup, manually created or created by a backup
    /// policy.
    pub backup_type: crate::model::backup::Type,

    /// Volume full name of this backup belongs to.
    /// Format:
    /// `projects/{projects_id}/locations/{location}/volumes/{volume_id}`
    pub source_volume: std::string::String,

    /// If specified, backup will be created from the given snapshot.
    /// If not specified, there will be a new snapshot taken to initiate the backup
    /// creation. Format:
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`
    pub source_snapshot: std::option::Option<std::string::String>,

    /// Output only. The time when the backup was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Total size of all backups in a chain in bytes = baseline
    /// backup size + sum(incremental backup size)
    pub chain_storage_bytes: i64,

    /// Output only. Reserved for future use
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use
    pub satisfies_pzi: bool,

    /// Output only. Region of the volume from which the backup was created.
    /// Format: `projects/{project_id}/locations/{location}`
    pub volume_region: std::string::String,

    /// Output only. Region in which backup is stored.
    /// Format: `projects/{project_id}/locations/{location}`
    pub backup_region: std::string::String,

    /// Output only. The time until which the backup is not deletable.
    pub enforced_retention_end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [volume_usage_bytes][crate::model::Backup::volume_usage_bytes].
    pub fn set_volume_usage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.volume_usage_bytes = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [source_volume][crate::model::Backup::source_volume].
    pub fn set_source_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_volume = v.into();
        self
    }

    /// Sets the value of [source_snapshot][crate::model::Backup::source_snapshot].
    pub fn set_source_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot][crate::model::Backup::source_snapshot].
    pub fn set_or_clear_source_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [chain_storage_bytes][crate::model::Backup::chain_storage_bytes].
    pub fn set_chain_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.chain_storage_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Backup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [volume_region][crate::model::Backup::volume_region].
    pub fn set_volume_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_region = v.into();
        self
    }

    /// Sets the value of [backup_region][crate::model::Backup::backup_region].
    pub fn set_backup_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_region = v.into();
        self
    }

    /// Sets the value of [enforced_retention_end_time][crate::model::Backup::enforced_retention_end_time].
    pub fn set_enforced_retention_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enforced_retention_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enforced_retention_end_time][crate::model::Backup::enforced_retention_end_time].
    pub fn set_or_clear_enforced_retention_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enforced_retention_end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __description,
            __volume_usage_bytes,
            __backup_type,
            __source_volume,
            __source_snapshot,
            __create_time,
            __labels,
            __chain_storage_bytes,
            __satisfies_pzs,
            __satisfies_pzi,
            __volume_region,
            __backup_region,
            __enforced_retention_end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "description" => Ok(__FieldTag::__description),
                            "volumeUsageBytes" => Ok(__FieldTag::__volume_usage_bytes),
                            "volume_usage_bytes" => Ok(__FieldTag::__volume_usage_bytes),
                            "backupType" => Ok(__FieldTag::__backup_type),
                            "backup_type" => Ok(__FieldTag::__backup_type),
                            "sourceVolume" => Ok(__FieldTag::__source_volume),
                            "source_volume" => Ok(__FieldTag::__source_volume),
                            "sourceSnapshot" => Ok(__FieldTag::__source_snapshot),
                            "source_snapshot" => Ok(__FieldTag::__source_snapshot),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "chainStorageBytes" => Ok(__FieldTag::__chain_storage_bytes),
                            "chain_storage_bytes" => Ok(__FieldTag::__chain_storage_bytes),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "volumeRegion" => Ok(__FieldTag::__volume_region),
                            "volume_region" => Ok(__FieldTag::__volume_region),
                            "backupRegion" => Ok(__FieldTag::__backup_region),
                            "backup_region" => Ok(__FieldTag::__backup_region),
                            "enforcedRetentionEndTime" => {
                                Ok(__FieldTag::__enforced_retention_end_time)
                            }
                            "enforced_retention_end_time" => {
                                Ok(__FieldTag::__enforced_retention_end_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_usage_bytes => {
                            if !fields.insert(__FieldTag::__volume_usage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_usage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_usage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__backup_type => {
                            if !fields.insert(__FieldTag::__backup_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_type",
                                ));
                            }
                            result.backup_type = map
                                .next_value::<std::option::Option<crate::model::backup::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_volume => {
                            if !fields.insert(__FieldTag::__source_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_volume",
                                ));
                            }
                            result.source_volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_snapshot => {
                            if !fields.insert(__FieldTag::__source_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_snapshot",
                                ));
                            }
                            result.source_snapshot =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__chain_storage_bytes => {
                            if !fields.insert(__FieldTag::__chain_storage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chain_storage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.chain_storage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_region => {
                            if !fields.insert(__FieldTag::__volume_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_region",
                                ));
                            }
                            result.volume_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_region => {
                            if !fields.insert(__FieldTag::__backup_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_region",
                                ));
                            }
                            result.backup_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enforced_retention_end_time => {
                            if !fields.insert(__FieldTag::__enforced_retention_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enforced_retention_end_time",
                                ));
                            }
                            result.enforced_retention_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.volume_usage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeUsageBytes", &__With(&self.volume_usage_bytes))?;
        }
        if !wkt::internal::is_default(&self.backup_type) {
            state.serialize_entry("backupType", &self.backup_type)?;
        }
        if !self.source_volume.is_empty() {
            state.serialize_entry("sourceVolume", &self.source_volume)?;
        }
        if self.source_snapshot.is_some() {
            state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.chain_storage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("chainStorageBytes", &__With(&self.chain_storage_bytes))?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self.volume_region.is_empty() {
            state.serialize_entry("volumeRegion", &self.volume_region)?;
        }
        if !self.backup_region.is_empty() {
            state.serialize_entry("backupRegion", &self.backup_region)?;
        }
        if self.enforced_retention_end_time.is_some() {
            state.serialize_entry(
                "enforcedRetentionEndTime",
                &self.enforced_retention_end_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Backup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Backup");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("description", &self.description);
        debug_struct.field("volume_usage_bytes", &self.volume_usage_bytes);
        debug_struct.field("backup_type", &self.backup_type);
        debug_struct.field("source_volume", &self.source_volume);
        debug_struct.field("source_snapshot", &self.source_snapshot);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("chain_storage_bytes", &self.chain_storage_bytes);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("volume_region", &self.volume_region);
        debug_struct.field("backup_region", &self.backup_region);
        debug_struct.field(
            "enforced_retention_end_time",
            &self.enforced_retention_end_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// The Backup States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// Backup is being created. While in this state, the snapshot for the backup
        /// point-in-time may not have been created yet, and so the point-in-time may
        /// not have been fixed.
        Creating,
        /// Backup is being uploaded. While in this state, none of the writes to the
        /// volume will be included in the backup.
        Uploading,
        /// Backup is available for use.
        Ready,
        /// Backup is being deleted.
        Deleting,
        /// Backup is not valid and cannot be used for creating new volumes or
        /// restoring existing volumes.
        Error,
        /// Backup is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Uploading => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Updating => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Uploading => std::option::Option::Some("UPLOADING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Uploading,
                3 => Self::Ready,
                4 => Self::Deleting,
                5 => Self::Error,
                6 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPLOADING" => Self::Uploading,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Uploading => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Updating => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Backup.State",
            ))
        }
    }

    /// Backup types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified backup type.
        Unspecified,
        /// Manual backup type.
        Manual,
        /// Scheduled backup type.
        Scheduled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Manual => std::option::Option::Some(1),
                Self::Scheduled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Manual,
                2 => Self::Scheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "MANUAL" => Self::Manual,
                "SCHEDULED" => Self::Scheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Manual => serializer.serialize_i32(1),
                Self::Scheduled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.netapp.v1.Backup.Type",
            ))
        }
    }
}

/// ListBackupsRequest lists backups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The backupVault for which to retrieve backup information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    /// To retrieve backup information for all locations, use "-" for the
    /// `{location}` value.
    /// To retrieve backup information for all backupVaults, use "-" for the
    /// `{backup_vault_id}` value.
    /// To retrieve backup information for a volume, use "-" for the
    /// `{backup_vault_id}` value and specify volume full name with the filter.
    pub parent: std::string::String,

    /// The maximum number of items to return. The service may return fewer
    /// than this value. The maximum value
    /// is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    /// The standard list filter.
    /// If specified, backups will be returned based on the attribute name that
    /// matches the filter expression. If empty, then no backups are filtered out.
    /// See <https://google.aip.dev/160>
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListBackupsResponse is the result of ListBackupsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project.
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupsResponse");
        debug_struct.field("backups", &self.backups);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetBackupRequest gets the state of a backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateBackupRequest creates a backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. The NetApp backupVault to create the backups of, in the format
    /// `projects/*/locations/*/backupVaults/{backup_vault_id}`
    pub parent: std::string::String,

    /// Required. The ID to use for the backup.
    /// The ID must be unique within the specified backupVault.
    /// Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    pub backup_id: std::string::String,

    /// Required. A backup resource
    pub backup: std::option::Option<crate::model::Backup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_id,
            __backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            "backup" => Ok(__FieldTag::__backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            result.backup_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            state.serialize_entry("backupId", &self.backup_id)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBackupRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("backup_id", &self.backup_id);
        debug_struct.field("backup", &self.backup);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteBackupRequest deletes a backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateBackupRequest updates description and/or labels for a backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource to be updated.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The backup being updated
    pub backup: std::option::Option<crate::model::Backup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "backup" => Ok(__FieldTag::__backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("backup", &self.backup);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Backup Policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupPolicy {
    /// Identifier. The resource name of the backup policy.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`.
    pub name: std::string::String,

    /// Number of daily backups to keep. Note that the minimum daily backup limit
    /// is 2.
    pub daily_backup_limit: std::option::Option<i32>,

    /// Number of weekly backups to keep. Note that the sum of daily, weekly and
    /// monthly backups should be greater than 1.
    pub weekly_backup_limit: std::option::Option<i32>,

    /// Number of monthly backups to keep. Note that the sum of daily, weekly and
    /// monthly backups should be greater than 1.
    pub monthly_backup_limit: std::option::Option<i32>,

    /// Description of the backup policy.
    pub description: std::option::Option<std::string::String>,

    /// If enabled, make backups automatically according to the schedules.
    /// This will be applied to all volumes that have this policy attached and
    /// enforced on volume level. If not specified, default is true.
    pub enabled: std::option::Option<bool>,

    /// Output only. The total number of volumes assigned by this backup policy.
    pub assigned_volume_count: std::option::Option<i32>,

    /// Output only. The time when the backup policy was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The backup policy state.
    pub state: crate::model::backup_policy::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [daily_backup_limit][crate::model::BackupPolicy::daily_backup_limit].
    pub fn set_daily_backup_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.daily_backup_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [daily_backup_limit][crate::model::BackupPolicy::daily_backup_limit].
    pub fn set_or_clear_daily_backup_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.daily_backup_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [weekly_backup_limit][crate::model::BackupPolicy::weekly_backup_limit].
    pub fn set_weekly_backup_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.weekly_backup_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [weekly_backup_limit][crate::model::BackupPolicy::weekly_backup_limit].
    pub fn set_or_clear_weekly_backup_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.weekly_backup_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [monthly_backup_limit][crate::model::BackupPolicy::monthly_backup_limit].
    pub fn set_monthly_backup_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.monthly_backup_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monthly_backup_limit][crate::model::BackupPolicy::monthly_backup_limit].
    pub fn set_or_clear_monthly_backup_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.monthly_backup_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::BackupPolicy::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::BackupPolicy::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enabled][crate::model::BackupPolicy::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::BackupPolicy::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assigned_volume_count][crate::model::BackupPolicy::assigned_volume_count].
    pub fn set_assigned_volume_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.assigned_volume_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assigned_volume_count][crate::model::BackupPolicy::assigned_volume_count].
    pub fn set_or_clear_assigned_volume_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.assigned_volume_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPolicy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupPolicy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::BackupPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::BackupPolicy::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_policy::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for BackupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.BackupPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __daily_backup_limit,
            __weekly_backup_limit,
            __monthly_backup_limit,
            __description,
            __enabled,
            __assigned_volume_count,
            __create_time,
            __labels,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dailyBackupLimit" => Ok(__FieldTag::__daily_backup_limit),
                            "daily_backup_limit" => Ok(__FieldTag::__daily_backup_limit),
                            "weeklyBackupLimit" => Ok(__FieldTag::__weekly_backup_limit),
                            "weekly_backup_limit" => Ok(__FieldTag::__weekly_backup_limit),
                            "monthlyBackupLimit" => Ok(__FieldTag::__monthly_backup_limit),
                            "monthly_backup_limit" => Ok(__FieldTag::__monthly_backup_limit),
                            "description" => Ok(__FieldTag::__description),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "assignedVolumeCount" => Ok(__FieldTag::__assigned_volume_count),
                            "assigned_volume_count" => Ok(__FieldTag::__assigned_volume_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__daily_backup_limit => {
                            if !fields.insert(__FieldTag::__daily_backup_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily_backup_limit",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.daily_backup_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__weekly_backup_limit => {
                            if !fields.insert(__FieldTag::__weekly_backup_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly_backup_limit",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.weekly_backup_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__monthly_backup_limit => {
                            if !fields.insert(__FieldTag::__monthly_backup_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly_backup_limit",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.monthly_backup_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__assigned_volume_count => {
                            if !fields.insert(__FieldTag::__assigned_volume_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assigned_volume_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.assigned_volume_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::backup_policy::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.daily_backup_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dailyBackupLimit", &__With(&self.daily_backup_limit))?;
        }
        if self.weekly_backup_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("weeklyBackupLimit", &__With(&self.weekly_backup_limit))?;
        }
        if self.monthly_backup_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("monthlyBackupLimit", &__With(&self.monthly_backup_limit))?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.assigned_volume_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("assignedVolumeCount", &__With(&self.assigned_volume_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupPolicy");
        debug_struct.field("name", &self.name);
        debug_struct.field("daily_backup_limit", &self.daily_backup_limit);
        debug_struct.field("weekly_backup_limit", &self.weekly_backup_limit);
        debug_struct.field("monthly_backup_limit", &self.monthly_backup_limit);
        debug_struct.field("description", &self.description);
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("assigned_volume_count", &self.assigned_volume_count);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BackupPolicy].
pub mod backup_policy {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// BackupPolicy is being created.
        Creating,
        /// BackupPolicy is available for use.
        Ready,
        /// BackupPolicy is being deleted.
        Deleting,
        /// BackupPolicy is not valid and cannot be used.
        Error,
        /// BackupPolicy is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Error,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.BackupPolicy.State",
            ))
        }
    }
}

/// CreateBackupPolicyRequest creates a backupPolicy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupPolicyRequest {
    /// Required. The location to create the backup policies of, in the format
    /// `projects/{project_id}/locations/{location}`
    pub parent: std::string::String,

    /// Required. A backupPolicy resource
    pub backup_policy: std::option::Option<crate::model::BackupPolicy>,

    /// Required. The ID to use for the backup policy.
    /// The ID must be unique within the specified location.
    /// Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    pub backup_policy_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_policy][crate::model::CreateBackupPolicyRequest::backup_policy].
    pub fn set_backup_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupPolicy>,
    {
        self.backup_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_policy][crate::model::CreateBackupPolicyRequest::backup_policy].
    pub fn set_or_clear_backup_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupPolicy>,
    {
        self.backup_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_policy_id][crate::model::CreateBackupPolicyRequest::backup_policy_id].
    pub fn set_backup_policy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_policy_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateBackupPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_policy,
            __backup_policy_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupPolicy" => Ok(__FieldTag::__backup_policy),
                            "backup_policy" => Ok(__FieldTag::__backup_policy),
                            "backupPolicyId" => Ok(__FieldTag::__backup_policy_id),
                            "backup_policy_id" => Ok(__FieldTag::__backup_policy_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_policy => {
                            if !fields.insert(__FieldTag::__backup_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_policy",
                                ));
                            }
                            result.backup_policy = map
                                .next_value::<std::option::Option<crate::model::BackupPolicy>>()?;
                        }
                        __FieldTag::__backup_policy_id => {
                            if !fields.insert(__FieldTag::__backup_policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_policy_id",
                                ));
                            }
                            result.backup_policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.backup_policy.is_some() {
            state.serialize_entry("backupPolicy", &self.backup_policy)?;
        }
        if !self.backup_policy_id.is_empty() {
            state.serialize_entry("backupPolicyId", &self.backup_policy_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateBackupPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBackupPolicyRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("backup_policy", &self.backup_policy);
        debug_struct.field("backup_policy_id", &self.backup_policy_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetBackupPolicyRequest gets the state of a backupPolicy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupPolicyRequest {
    /// Required. The backupPolicy resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetBackupPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBackupPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupPolicyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListBackupPoliciesRequest for requesting multiple backup policies.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPoliciesRequest {
    /// Required. Parent value for ListBackupPoliciesRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPoliciesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListBackupPoliciesResponse contains all the backup policies requested.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPoliciesResponse {
    /// The list of backup policies.
    pub backup_policies: std::vec::Vec<crate::model::BackupPolicy>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_policies][crate::model::ListBackupPoliciesResponse::backup_policies].
    pub fn set_backup_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPolicy>,
    {
        use std::iter::Iterator;
        self.backup_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPoliciesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPoliciesResponse {
    type PageItem = crate::model::BackupPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_policies,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPolicies" => Ok(__FieldTag::__backup_policies),
                            "backup_policies" => Ok(__FieldTag::__backup_policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_policies => {
                            if !fields.insert(__FieldTag::__backup_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_policies",
                                ));
                            }
                            result.backup_policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_policies.is_empty() {
            state.serialize_entry("backupPolicies", &self.backup_policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupPoliciesResponse");
        debug_struct.field("backup_policies", &self.backup_policies);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateBackupPolicyRequest for updating a backup policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupPolicyRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup Policy resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The backup policy being updated
    pub backup_policy: std::option::Option<crate::model::BackupPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupPolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupPolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_policy][crate::model::UpdateBackupPolicyRequest::backup_policy].
    pub fn set_backup_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupPolicy>,
    {
        self.backup_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_policy][crate::model::UpdateBackupPolicyRequest::backup_policy].
    pub fn set_or_clear_backup_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupPolicy>,
    {
        self.backup_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateBackupPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __backup_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "backupPolicy" => Ok(__FieldTag::__backup_policy),
                            "backup_policy" => Ok(__FieldTag::__backup_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__backup_policy => {
                            if !fields.insert(__FieldTag::__backup_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_policy",
                                ));
                            }
                            result.backup_policy = map
                                .next_value::<std::option::Option<crate::model::BackupPolicy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.backup_policy.is_some() {
            state.serialize_entry("backupPolicy", &self.backup_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateBackupPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupPolicyRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("backup_policy", &self.backup_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteBackupPolicyRequest deletes a backup policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupPolicyRequest {
    /// Required. The backup policy resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteBackupPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteBackupPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupPolicyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A NetApp BackupVault.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupVault {
    /// Identifier. The resource name of the backup vault.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    pub name: std::string::String,

    /// Output only. The backup vault state.
    pub state: crate::model::backup_vault::State,

    /// Output only. Create time of the backup vault.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Description of the backup vault.
    pub description: std::string::String,

    /// Resource labels to represent user provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Type of backup vault to be created.
    /// Default is IN_REGION.
    pub backup_vault_type: crate::model::backup_vault::BackupVaultType,

    /// Output only. Region in which the backup vault is created.
    /// Format: `projects/{project_id}/locations/{location}`
    pub source_region: std::string::String,

    /// Optional. Region where the backups are stored.
    /// Format: `projects/{project_id}/locations/{location}`
    pub backup_region: std::string::String,

    /// Output only. Name of the Backup vault created in source region.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
    pub source_backup_vault: std::string::String,

    /// Output only. Name of the Backup vault created in backup region.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
    pub destination_backup_vault: std::string::String,

    /// Optional. Backup retention policy defining the retenton of backups.
    pub backup_retention_policy:
        std::option::Option<crate::model::backup_vault::BackupRetentionPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupVault {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupVault::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BackupVault::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_vault::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupVault::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupVault::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::BackupVault::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BackupVault::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [backup_vault_type][crate::model::BackupVault::backup_vault_type].
    pub fn set_backup_vault_type<
        T: std::convert::Into<crate::model::backup_vault::BackupVaultType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault_type = v.into();
        self
    }

    /// Sets the value of [source_region][crate::model::BackupVault::source_region].
    pub fn set_source_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_region = v.into();
        self
    }

    /// Sets the value of [backup_region][crate::model::BackupVault::backup_region].
    pub fn set_backup_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_region = v.into();
        self
    }

    /// Sets the value of [source_backup_vault][crate::model::BackupVault::source_backup_vault].
    pub fn set_source_backup_vault<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_backup_vault = v.into();
        self
    }

    /// Sets the value of [destination_backup_vault][crate::model::BackupVault::destination_backup_vault].
    pub fn set_destination_backup_vault<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_backup_vault = v.into();
        self
    }

    /// Sets the value of [backup_retention_policy][crate::model::BackupVault::backup_retention_policy].
    pub fn set_backup_retention_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_vault::BackupRetentionPolicy>,
    {
        self.backup_retention_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_retention_policy][crate::model::BackupVault::backup_retention_policy].
    pub fn set_or_clear_backup_retention_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup_vault::BackupRetentionPolicy>,
    {
        self.backup_retention_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupVault {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.BackupVault"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupVault {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __create_time,
            __description,
            __labels,
            __backup_vault_type,
            __source_region,
            __backup_region,
            __source_backup_vault,
            __destination_backup_vault,
            __backup_retention_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupVault")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "backupVaultType" => Ok(__FieldTag::__backup_vault_type),
                            "backup_vault_type" => Ok(__FieldTag::__backup_vault_type),
                            "sourceRegion" => Ok(__FieldTag::__source_region),
                            "source_region" => Ok(__FieldTag::__source_region),
                            "backupRegion" => Ok(__FieldTag::__backup_region),
                            "backup_region" => Ok(__FieldTag::__backup_region),
                            "sourceBackupVault" => Ok(__FieldTag::__source_backup_vault),
                            "source_backup_vault" => Ok(__FieldTag::__source_backup_vault),
                            "destinationBackupVault" => Ok(__FieldTag::__destination_backup_vault),
                            "destination_backup_vault" => {
                                Ok(__FieldTag::__destination_backup_vault)
                            }
                            "backupRetentionPolicy" => Ok(__FieldTag::__backup_retention_policy),
                            "backup_retention_policy" => Ok(__FieldTag::__backup_retention_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupVault;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupVault")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::backup_vault::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault_type => {
                            if !fields.insert(__FieldTag::__backup_vault_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault_type",
                                ));
                            }
                            result.backup_vault_type =
                                map.next_value::<std::option::Option<
                                    crate::model::backup_vault::BackupVaultType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_region => {
                            if !fields.insert(__FieldTag::__source_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_region",
                                ));
                            }
                            result.source_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_region => {
                            if !fields.insert(__FieldTag::__backup_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_region",
                                ));
                            }
                            result.backup_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_backup_vault => {
                            if !fields.insert(__FieldTag::__source_backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_backup_vault",
                                ));
                            }
                            result.source_backup_vault = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_backup_vault => {
                            if !fields.insert(__FieldTag::__destination_backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_backup_vault",
                                ));
                            }
                            result.destination_backup_vault = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_retention_policy => {
                            if !fields.insert(__FieldTag::__backup_retention_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_retention_policy",
                                ));
                            }
                            result.backup_retention_policy = map.next_value::<std::option::Option<
                                crate::model::backup_vault::BackupRetentionPolicy,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupVault {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.backup_vault_type) {
            state.serialize_entry("backupVaultType", &self.backup_vault_type)?;
        }
        if !self.source_region.is_empty() {
            state.serialize_entry("sourceRegion", &self.source_region)?;
        }
        if !self.backup_region.is_empty() {
            state.serialize_entry("backupRegion", &self.backup_region)?;
        }
        if !self.source_backup_vault.is_empty() {
            state.serialize_entry("sourceBackupVault", &self.source_backup_vault)?;
        }
        if !self.destination_backup_vault.is_empty() {
            state.serialize_entry("destinationBackupVault", &self.destination_backup_vault)?;
        }
        if self.backup_retention_policy.is_some() {
            state.serialize_entry("backupRetentionPolicy", &self.backup_retention_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupVault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupVault");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("backup_vault_type", &self.backup_vault_type);
        debug_struct.field("source_region", &self.source_region);
        debug_struct.field("backup_region", &self.backup_region);
        debug_struct.field("source_backup_vault", &self.source_backup_vault);
        debug_struct.field("destination_backup_vault", &self.destination_backup_vault);
        debug_struct.field("backup_retention_policy", &self.backup_retention_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BackupVault].
pub mod backup_vault {
    #[allow(unused_imports)]
    use super::*;

    /// Retention policy for backups in the backup vault
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BackupRetentionPolicy {
        /// Required. Minimum retention duration in days for backups in the backup
        /// vault.
        pub backup_minimum_enforced_retention_days: i32,

        /// Optional. Indicates if the daily backups are immutable.
        /// At least one of daily_backup_immutable, weekly_backup_immutable,
        /// monthly_backup_immutable and manual_backup_immutable must be true.
        pub daily_backup_immutable: bool,

        /// Optional. Indicates if the weekly backups are immutable.
        /// At least one of daily_backup_immutable, weekly_backup_immutable,
        /// monthly_backup_immutable and manual_backup_immutable must be true.
        pub weekly_backup_immutable: bool,

        /// Optional. Indicates if the monthly backups are immutable.
        /// At least one of daily_backup_immutable, weekly_backup_immutable,
        /// monthly_backup_immutable and manual_backup_immutable must be true.
        pub monthly_backup_immutable: bool,

        /// Optional. Indicates if the manual backups are immutable.
        /// At least one of daily_backup_immutable, weekly_backup_immutable,
        /// monthly_backup_immutable and manual_backup_immutable must be true.
        pub manual_backup_immutable: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackupRetentionPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup_minimum_enforced_retention_days][crate::model::backup_vault::BackupRetentionPolicy::backup_minimum_enforced_retention_days].
        pub fn set_backup_minimum_enforced_retention_days<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.backup_minimum_enforced_retention_days = v.into();
            self
        }

        /// Sets the value of [daily_backup_immutable][crate::model::backup_vault::BackupRetentionPolicy::daily_backup_immutable].
        pub fn set_daily_backup_immutable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.daily_backup_immutable = v.into();
            self
        }

        /// Sets the value of [weekly_backup_immutable][crate::model::backup_vault::BackupRetentionPolicy::weekly_backup_immutable].
        pub fn set_weekly_backup_immutable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.weekly_backup_immutable = v.into();
            self
        }

        /// Sets the value of [monthly_backup_immutable][crate::model::backup_vault::BackupRetentionPolicy::monthly_backup_immutable].
        pub fn set_monthly_backup_immutable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.monthly_backup_immutable = v.into();
            self
        }

        /// Sets the value of [manual_backup_immutable][crate::model::backup_vault::BackupRetentionPolicy::manual_backup_immutable].
        pub fn set_manual_backup_immutable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.manual_backup_immutable = v.into();
            self
        }
    }

    impl wkt::message::Message for BackupRetentionPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.netapp.v1.BackupVault.BackupRetentionPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BackupRetentionPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __backup_minimum_enforced_retention_days,
                __daily_backup_immutable,
                __weekly_backup_immutable,
                __monthly_backup_immutable,
                __manual_backup_immutable,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BackupRetentionPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "backupMinimumEnforcedRetentionDays" => {
                                    Ok(__FieldTag::__backup_minimum_enforced_retention_days)
                                }
                                "backup_minimum_enforced_retention_days" => {
                                    Ok(__FieldTag::__backup_minimum_enforced_retention_days)
                                }
                                "dailyBackupImmutable" => Ok(__FieldTag::__daily_backup_immutable),
                                "daily_backup_immutable" => {
                                    Ok(__FieldTag::__daily_backup_immutable)
                                }
                                "weeklyBackupImmutable" => {
                                    Ok(__FieldTag::__weekly_backup_immutable)
                                }
                                "weekly_backup_immutable" => {
                                    Ok(__FieldTag::__weekly_backup_immutable)
                                }
                                "monthlyBackupImmutable" => {
                                    Ok(__FieldTag::__monthly_backup_immutable)
                                }
                                "monthly_backup_immutable" => {
                                    Ok(__FieldTag::__monthly_backup_immutable)
                                }
                                "manualBackupImmutable" => {
                                    Ok(__FieldTag::__manual_backup_immutable)
                                }
                                "manual_backup_immutable" => {
                                    Ok(__FieldTag::__manual_backup_immutable)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BackupRetentionPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BackupRetentionPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__backup_minimum_enforced_retention_days => {
                                if !fields
                                    .insert(__FieldTag::__backup_minimum_enforced_retention_days)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_minimum_enforced_retention_days",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.backup_minimum_enforced_retention_days =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__daily_backup_immutable => {
                                if !fields.insert(__FieldTag::__daily_backup_immutable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for daily_backup_immutable",
                                    ));
                                }
                                result.daily_backup_immutable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__weekly_backup_immutable => {
                                if !fields.insert(__FieldTag::__weekly_backup_immutable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for weekly_backup_immutable",
                                    ));
                                }
                                result.weekly_backup_immutable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__monthly_backup_immutable => {
                                if !fields.insert(__FieldTag::__monthly_backup_immutable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for monthly_backup_immutable",
                                    ));
                                }
                                result.monthly_backup_immutable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__manual_backup_immutable => {
                                if !fields.insert(__FieldTag::__manual_backup_immutable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for manual_backup_immutable",
                                    ));
                                }
                                result.manual_backup_immutable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BackupRetentionPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.backup_minimum_enforced_retention_days) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "backupMinimumEnforcedRetentionDays",
                    &__With(&self.backup_minimum_enforced_retention_days),
                )?;
            }
            if !wkt::internal::is_default(&self.daily_backup_immutable) {
                state.serialize_entry("dailyBackupImmutable", &self.daily_backup_immutable)?;
            }
            if !wkt::internal::is_default(&self.weekly_backup_immutable) {
                state.serialize_entry("weeklyBackupImmutable", &self.weekly_backup_immutable)?;
            }
            if !wkt::internal::is_default(&self.monthly_backup_immutable) {
                state.serialize_entry("monthlyBackupImmutable", &self.monthly_backup_immutable)?;
            }
            if !wkt::internal::is_default(&self.manual_backup_immutable) {
                state.serialize_entry("manualBackupImmutable", &self.manual_backup_immutable)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BackupRetentionPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BackupRetentionPolicy");
            debug_struct.field(
                "backup_minimum_enforced_retention_days",
                &self.backup_minimum_enforced_retention_days,
            );
            debug_struct.field("daily_backup_immutable", &self.daily_backup_immutable);
            debug_struct.field("weekly_backup_immutable", &self.weekly_backup_immutable);
            debug_struct.field("monthly_backup_immutable", &self.monthly_backup_immutable);
            debug_struct.field("manual_backup_immutable", &self.manual_backup_immutable);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The Backup Vault States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// BackupVault is being created.
        Creating,
        /// BackupVault is available for use.
        Ready,
        /// BackupVault is being deleted.
        Deleting,
        /// BackupVault is not valid and cannot be used.
        Error,
        /// BackupVault is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Error,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.BackupVault.State",
            ))
        }
    }

    /// Backup Vault Type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupVaultType {
        /// BackupVault type not set.
        Unspecified,
        /// BackupVault type is IN_REGION.
        InRegion,
        /// BackupVault type is CROSS_REGION.
        CrossRegion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupVaultType::value] or
        /// [BackupVaultType::name].
        UnknownValue(backup_vault_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_vault_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupVaultType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InRegion => std::option::Option::Some(1),
                Self::CrossRegion => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_VAULT_TYPE_UNSPECIFIED"),
                Self::InRegion => std::option::Option::Some("IN_REGION"),
                Self::CrossRegion => std::option::Option::Some("CROSS_REGION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupVaultType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupVaultType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupVaultType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InRegion,
                2 => Self::CrossRegion,
                _ => Self::UnknownValue(backup_vault_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupVaultType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_VAULT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IN_REGION" => Self::InRegion,
                "CROSS_REGION" => Self::CrossRegion,
                _ => Self::UnknownValue(backup_vault_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupVaultType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InRegion => serializer.serialize_i32(1),
                Self::CrossRegion => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupVaultType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupVaultType>::new(
                ".google.cloud.netapp.v1.BackupVault.BackupVaultType",
            ))
        }
    }
}

/// GetBackupVaultRequest gets the state of a backupVault.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupVaultRequest {
    /// Required. The backupVault resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupVaultRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListBackupVaultsRequest lists backupVaults.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupVaultsRequest {
    /// Required. The location for which to retrieve backupVault information,
    /// in the format
    /// `projects/{project_id}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupVaultsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupVaultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupVaultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupVaultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupVaultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupVaultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupVaultsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupVaultsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListBackupVaultsResponse is the result of ListBackupVaultsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupVaultsResponse {
    /// A list of backupVaults in the project for the specified location.
    pub backup_vaults: std::vec::Vec<crate::model::BackupVault>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vaults][crate::model::ListBackupVaultsResponse::backup_vaults].
    pub fn set_backup_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupVault>,
    {
        use std::iter::Iterator;
        self.backup_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupVaultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupVaultsResponse {
    type PageItem = crate::model::BackupVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupVaultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_vaults,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupVaultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupVaults" => Ok(__FieldTag::__backup_vaults),
                            "backup_vaults" => Ok(__FieldTag::__backup_vaults),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupVaultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupVaultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_vaults => {
                            if !fields.insert(__FieldTag::__backup_vaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vaults",
                                ));
                            }
                            result.backup_vaults = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupVault>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupVaultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_vaults.is_empty() {
            state.serialize_entry("backupVaults", &self.backup_vaults)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupVaultsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupVaultsResponse");
        debug_struct.field("backup_vaults", &self.backup_vaults);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateBackupVaultRequest creates a backup vault.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupVaultRequest {
    /// Required. The location to create the backup vaults, in the format
    /// `projects/{project_id}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The ID to use for the backupVault.
    /// The ID must be unique within the specified location.
    /// Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    pub backup_vault_id: std::string::String,

    /// Required. A backupVault resource
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupVaultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_vault_id][crate::model::CreateBackupVaultRequest::backup_vault_id].
    pub fn set_backup_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault_id = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::CreateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_vault][crate::model::CreateBackupVaultRequest::backup_vault].
    pub fn set_or_clear_backup_vault<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_vault_id,
            __backup_vault,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupVaultId" => Ok(__FieldTag::__backup_vault_id),
                            "backup_vault_id" => Ok(__FieldTag::__backup_vault_id),
                            "backupVault" => Ok(__FieldTag::__backup_vault),
                            "backup_vault" => Ok(__FieldTag::__backup_vault),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault_id => {
                            if !fields.insert(__FieldTag::__backup_vault_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault_id",
                                ));
                            }
                            result.backup_vault_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_vault => {
                            if !fields.insert(__FieldTag::__backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault",
                                ));
                            }
                            result.backup_vault =
                                map.next_value::<std::option::Option<crate::model::BackupVault>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_vault_id.is_empty() {
            state.serialize_entry("backupVaultId", &self.backup_vault_id)?;
        }
        if self.backup_vault.is_some() {
            state.serialize_entry("backupVault", &self.backup_vault)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBackupVaultRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("backup_vault_id", &self.backup_vault_id);
        debug_struct.field("backup_vault", &self.backup_vault);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteBackupVaultRequest deletes a backupVault.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupVaultRequest {
    /// Required. The backupVault resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupVaultRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateBackupVaultRequest updates description and/or labels for a backupVault.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupVaultRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource to be updated.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The backupVault being updated
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupVaultRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupVaultRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_vault][crate::model::UpdateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_vault][crate::model::UpdateBackupVaultRequest::backup_vault].
    pub fn set_or_clear_backup_vault<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupVault>,
    {
        self.backup_vault = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateBackupVaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupVaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __backup_vault,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupVaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "backupVault" => Ok(__FieldTag::__backup_vault),
                            "backup_vault" => Ok(__FieldTag::__backup_vault),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupVaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupVaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__backup_vault => {
                            if !fields.insert(__FieldTag::__backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault",
                                ));
                            }
                            result.backup_vault =
                                map.next_value::<std::option::Option<crate::model::BackupVault>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupVaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.backup_vault.is_some() {
            state.serialize_entry("backupVault", &self.backup_vault)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateBackupVaultRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBackupVaultRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("backup_vault", &self.backup_vault);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been canceled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for a given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Supported service levels in a location.
    pub supported_service_levels: std::vec::Vec<crate::model::ServiceLevel>,

    /// Output only. Supported flex performance in a location.
    pub supported_flex_performance: std::vec::Vec<crate::model::FlexPerformance>,

    /// Output only. Indicates if the location has VCP support.
    pub has_vcp: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [supported_service_levels][crate::model::LocationMetadata::supported_service_levels].
    pub fn set_supported_service_levels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceLevel>,
    {
        use std::iter::Iterator;
        self.supported_service_levels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_flex_performance][crate::model::LocationMetadata::supported_flex_performance].
    pub fn set_supported_flex_performance<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FlexPerformance>,
    {
        use std::iter::Iterator;
        self.supported_flex_performance = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [has_vcp][crate::model::LocationMetadata::has_vcp].
    pub fn set_has_vcp<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_vcp = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __supported_service_levels,
            __supported_flex_performance,
            __has_vcp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "supportedServiceLevels" => Ok(__FieldTag::__supported_service_levels),
                            "supported_service_levels" => {
                                Ok(__FieldTag::__supported_service_levels)
                            }
                            "supportedFlexPerformance" => {
                                Ok(__FieldTag::__supported_flex_performance)
                            }
                            "supported_flex_performance" => {
                                Ok(__FieldTag::__supported_flex_performance)
                            }
                            "hasVcp" => Ok(__FieldTag::__has_vcp),
                            "has_vcp" => Ok(__FieldTag::__has_vcp),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__supported_service_levels => {
                            if !fields.insert(__FieldTag::__supported_service_levels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_service_levels",
                                ));
                            }
                            result.supported_service_levels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ServiceLevel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__supported_flex_performance => {
                            if !fields.insert(__FieldTag::__supported_flex_performance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_flex_performance",
                                ));
                            }
                            result.supported_flex_performance =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FlexPerformance>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__has_vcp => {
                            if !fields.insert(__FieldTag::__has_vcp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_vcp",
                                ));
                            }
                            result.has_vcp = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.supported_service_levels.is_empty() {
            state.serialize_entry("supportedServiceLevels", &self.supported_service_levels)?;
        }
        if !self.supported_flex_performance.is_empty() {
            state.serialize_entry("supportedFlexPerformance", &self.supported_flex_performance)?;
        }
        if !wkt::internal::is_default(&self.has_vcp) {
            state.serialize_entry("hasVcp", &self.has_vcp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field("supported_service_levels", &self.supported_service_levels);
        debug_struct.field(
            "supported_flex_performance",
            &self.supported_flex_performance,
        );
        debug_struct.field("has_vcp", &self.has_vcp);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UserCommands contains the commands to be executed by the customer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserCommands {
    /// Output only. List of commands to be executed by the customer.
    pub commands: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserCommands {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [commands][crate::model::UserCommands::commands].
    pub fn set_commands<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.commands = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserCommands {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UserCommands"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserCommands {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __commands,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserCommands")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commands" => Ok(__FieldTag::__commands),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserCommands;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserCommands")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__commands => {
                            if !fields.insert(__FieldTag::__commands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commands",
                                ));
                            }
                            result.commands = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserCommands {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.commands.is_empty() {
            state.serialize_entry("commands", &self.commands)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserCommands {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserCommands");
        debug_struct.field("commands", &self.commands);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetKmsConfigRequest gets a KMS Config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetKmsConfigRequest {
    /// Required. Name of the KmsConfig
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKmsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetKmsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetKmsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetKmsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetKmsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetKmsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetKmsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetKmsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetKmsConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListKmsConfigsRequest lists KMS Configs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKmsConfigsRequest {
    /// Required. Parent value
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKmsConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKmsConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKmsConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKmsConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListKmsConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKmsConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListKmsConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListKmsConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKmsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKmsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKmsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKmsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKmsConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListKmsConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListKmsConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListKmsConfigsResponse is the response to a ListKmsConfigsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKmsConfigsResponse {
    /// The list of KmsConfigs
    pub kms_configs: std::vec::Vec<crate::model::KmsConfig>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKmsConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_configs][crate::model::ListKmsConfigsResponse::kms_configs].
    pub fn set_kms_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KmsConfig>,
    {
        use std::iter::Iterator;
        self.kms_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKmsConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListKmsConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListKmsConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListKmsConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKmsConfigsResponse {
    type PageItem = crate::model::KmsConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.kms_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKmsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKmsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsConfigs" => Ok(__FieldTag::__kms_configs),
                            "kms_configs" => Ok(__FieldTag::__kms_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKmsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKmsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_configs => {
                            if !fields.insert(__FieldTag::__kms_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_configs",
                                ));
                            }
                            result.kms_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::KmsConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKmsConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_configs.is_empty() {
            state.serialize_entry("kmsConfigs", &self.kms_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListKmsConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListKmsConfigsResponse");
        debug_struct.field("kms_configs", &self.kms_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateKmsConfigRequest creates a KMS Config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKmsConfigRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. Id of the requesting KmsConfig. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    pub kms_config_id: std::string::String,

    /// Required. The required parameters to create a new KmsConfig.
    pub kms_config: std::option::Option<crate::model::KmsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKmsConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [kms_config_id][crate::model::CreateKmsConfigRequest::kms_config_id].
    pub fn set_kms_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_config_id = v.into();
        self
    }

    /// Sets the value of [kms_config][crate::model::CreateKmsConfigRequest::kms_config].
    pub fn set_kms_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KmsConfig>,
    {
        self.kms_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_config][crate::model::CreateKmsConfigRequest::kms_config].
    pub fn set_or_clear_kms_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KmsConfig>,
    {
        self.kms_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateKmsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateKmsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __kms_config_id,
            __kms_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKmsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "kmsConfigId" => Ok(__FieldTag::__kms_config_id),
                            "kms_config_id" => Ok(__FieldTag::__kms_config_id),
                            "kmsConfig" => Ok(__FieldTag::__kms_config),
                            "kms_config" => Ok(__FieldTag::__kms_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateKmsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKmsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_config_id => {
                            if !fields.insert(__FieldTag::__kms_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_config_id",
                                ));
                            }
                            result.kms_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_config => {
                            if !fields.insert(__FieldTag::__kms_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_config",
                                ));
                            }
                            result.kms_config =
                                map.next_value::<std::option::Option<crate::model::KmsConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateKmsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.kms_config_id.is_empty() {
            state.serialize_entry("kmsConfigId", &self.kms_config_id)?;
        }
        if self.kms_config.is_some() {
            state.serialize_entry("kmsConfig", &self.kms_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateKmsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateKmsConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("kms_config_id", &self.kms_config_id);
        debug_struct.field("kms_config", &self.kms_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateKmsConfigRequest updates a KMS Config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateKmsConfigRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// KmsConfig resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The KmsConfig being updated
    pub kms_config: std::option::Option<crate::model::KmsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateKmsConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateKmsConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_config][crate::model::UpdateKmsConfigRequest::kms_config].
    pub fn set_kms_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KmsConfig>,
    {
        self.kms_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_config][crate::model::UpdateKmsConfigRequest::kms_config].
    pub fn set_or_clear_kms_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KmsConfig>,
    {
        self.kms_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateKmsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateKmsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __kms_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateKmsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "kmsConfig" => Ok(__FieldTag::__kms_config),
                            "kms_config" => Ok(__FieldTag::__kms_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateKmsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateKmsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__kms_config => {
                            if !fields.insert(__FieldTag::__kms_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_config",
                                ));
                            }
                            result.kms_config =
                                map.next_value::<std::option::Option<crate::model::KmsConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateKmsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.kms_config.is_some() {
            state.serialize_entry("kmsConfig", &self.kms_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateKmsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateKmsConfigRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("kms_config", &self.kms_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteKmsConfigRequest deletes a KMS Config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteKmsConfigRequest {
    /// Required. Name of the KmsConfig.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteKmsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteKmsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteKmsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteKmsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteKmsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteKmsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteKmsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteKmsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteKmsConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// EncryptVolumesRequest specifies the KMS config to encrypt existing volumes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptVolumesRequest {
    /// Required. Name of the KmsConfig.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptVolumesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.EncryptVolumesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptVolumesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptVolumesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptVolumesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptVolumesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptVolumesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EncryptVolumesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptVolumesRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VerifyKmsConfigRequest specifies the KMS config to be validated.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyKmsConfigRequest {
    /// Required. Name of the KMS Config to be verified.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyKmsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for VerifyKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.VerifyKmsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyKmsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyKmsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyKmsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyKmsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyKmsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VerifyKmsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyKmsConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VerifyKmsConfigResponse contains the information if the config is correctly
/// and error message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyKmsConfigResponse {
    /// Output only. If the customer key configured correctly to the encrypt
    /// volume.
    pub healthy: bool,

    /// Output only. Error message if config is not healthy.
    pub health_error: std::string::String,

    /// Output only. Instructions for the customers to provide the access to the
    /// encryption key.
    pub instructions: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyKmsConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [healthy][crate::model::VerifyKmsConfigResponse::healthy].
    pub fn set_healthy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.healthy = v.into();
        self
    }

    /// Sets the value of [health_error][crate::model::VerifyKmsConfigResponse::health_error].
    pub fn set_health_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.health_error = v.into();
        self
    }

    /// Sets the value of [instructions][crate::model::VerifyKmsConfigResponse::instructions].
    pub fn set_instructions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instructions = v.into();
        self
    }
}

impl wkt::message::Message for VerifyKmsConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.VerifyKmsConfigResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyKmsConfigResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __healthy,
            __health_error,
            __instructions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyKmsConfigResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "healthy" => Ok(__FieldTag::__healthy),
                            "healthError" => Ok(__FieldTag::__health_error),
                            "health_error" => Ok(__FieldTag::__health_error),
                            "instructions" => Ok(__FieldTag::__instructions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyKmsConfigResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyKmsConfigResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__healthy => {
                            if !fields.insert(__FieldTag::__healthy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for healthy",
                                ));
                            }
                            result.healthy = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_error => {
                            if !fields.insert(__FieldTag::__health_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_error",
                                ));
                            }
                            result.health_error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instructions => {
                            if !fields.insert(__FieldTag::__instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instructions",
                                ));
                            }
                            result.instructions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyKmsConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.healthy) {
            state.serialize_entry("healthy", &self.healthy)?;
        }
        if !self.health_error.is_empty() {
            state.serialize_entry("healthError", &self.health_error)?;
        }
        if !self.instructions.is_empty() {
            state.serialize_entry("instructions", &self.instructions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VerifyKmsConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyKmsConfigResponse");
        debug_struct.field("healthy", &self.healthy);
        debug_struct.field("health_error", &self.health_error);
        debug_struct.field("instructions", &self.instructions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// KmsConfig is the customer managed encryption key(CMEK) configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct KmsConfig {
    /// Identifier. Name of the KmsConfig.
    pub name: std::string::String,

    /// Required. Customer managed crypto key resource full name. Format:
    /// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{key}.
    pub crypto_key_name: std::string::String,

    /// Output only. State of the KmsConfig.
    pub state: crate::model::kms_config::State,

    /// Output only. State details of the KmsConfig.
    pub state_details: std::string::String,

    /// Output only. Create time of the KmsConfig.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Description of the KmsConfig.
    pub description: std::string::String,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Instructions to provide the access to the customer provided
    /// encryption key.
    pub instructions: std::string::String,

    /// Output only. The Service account which will have access to the customer
    /// provided encryption key.
    pub service_account: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KmsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KmsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::KmsConfig::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::KmsConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::kms_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::KmsConfig::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::KmsConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::KmsConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::KmsConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::KmsConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [instructions][crate::model::KmsConfig::instructions].
    pub fn set_instructions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instructions = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::KmsConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for KmsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.KmsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KmsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __crypto_key_name,
            __state,
            __state_details,
            __create_time,
            __description,
            __labels,
            __instructions,
            __service_account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KmsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cryptoKeyName" => Ok(__FieldTag::__crypto_key_name),
                            "crypto_key_name" => Ok(__FieldTag::__crypto_key_name),
                            "state" => Ok(__FieldTag::__state),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "instructions" => Ok(__FieldTag::__instructions),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KmsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KmsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_name => {
                            if !fields.insert(__FieldTag::__crypto_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_name",
                                ));
                            }
                            result.crypto_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::kms_config::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instructions => {
                            if !fields.insert(__FieldTag::__instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instructions",
                                ));
                            }
                            result.instructions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KmsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.crypto_key_name.is_empty() {
            state.serialize_entry("cryptoKeyName", &self.crypto_key_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.instructions.is_empty() {
            state.serialize_entry("instructions", &self.instructions)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for KmsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KmsConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("crypto_key_name", &self.crypto_key_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_details", &self.state_details);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("instructions", &self.instructions);
        debug_struct.field("service_account", &self.service_account);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [KmsConfig].
pub mod kms_config {
    #[allow(unused_imports)]
    use super::*;

    /// The KmsConfig States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified KmsConfig State
        Unspecified,
        /// KmsConfig State is Ready
        Ready,
        /// KmsConfig State is Creating
        Creating,
        /// KmsConfig State is Deleting
        Deleting,
        /// KmsConfig State is Updating
        Updating,
        /// KmsConfig State is In Use.
        InUse,
        /// KmsConfig State is Error
        Error,
        /// KmsConfig State is Pending to verify crypto key access.
        KeyCheckPending,
        /// KmsConfig State is Not accessbile by the SDE service account to the
        /// crypto key.
        KeyNotReachable,
        /// KmsConfig State is Disabling.
        Disabling,
        /// KmsConfig State is Disabled.
        Disabled,
        /// KmsConfig State is Migrating.
        /// The existing volumes are migrating from SMEK to CMEK.
        Migrating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::InUse => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::KeyCheckPending => std::option::Option::Some(7),
                Self::KeyNotReachable => std::option::Option::Some(8),
                Self::Disabling => std::option::Option::Some(9),
                Self::Disabled => std::option::Option::Some(10),
                Self::Migrating => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::InUse => std::option::Option::Some("IN_USE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::KeyCheckPending => std::option::Option::Some("KEY_CHECK_PENDING"),
                Self::KeyNotReachable => std::option::Option::Some("KEY_NOT_REACHABLE"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Migrating => std::option::Option::Some("MIGRATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::InUse,
                6 => Self::Error,
                7 => Self::KeyCheckPending,
                8 => Self::KeyNotReachable,
                9 => Self::Disabling,
                10 => Self::Disabled,
                11 => Self::Migrating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "IN_USE" => Self::InUse,
                "ERROR" => Self::Error,
                "KEY_CHECK_PENDING" => Self::KeyCheckPending,
                "KEY_NOT_REACHABLE" => Self::KeyNotReachable,
                "DISABLING" => Self::Disabling,
                "DISABLED" => Self::Disabled,
                "MIGRATING" => Self::Migrating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::InUse => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::KeyCheckPending => serializer.serialize_i32(7),
                Self::KeyNotReachable => serializer.serialize_i32(8),
                Self::Disabling => serializer.serialize_i32(9),
                Self::Disabled => serializer.serialize_i32(10),
                Self::Migrating => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.KmsConfig.State",
            ))
        }
    }
}

/// ListQuotaRulesRequest for listing quota rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQuotaRulesRequest {
    /// Required. Parent value for ListQuotaRulesRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQuotaRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQuotaRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQuotaRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQuotaRulesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListQuotaRulesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListQuotaRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQuotaRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQuotaRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQuotaRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQuotaRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQuotaRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQuotaRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQuotaRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListQuotaRulesResponse is the response to a ListQuotaRulesRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQuotaRulesResponse {
    /// List of quota rules
    pub quota_rules: std::vec::Vec<crate::model::QuotaRule>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota_rules][crate::model::ListQuotaRulesResponse::quota_rules].
    pub fn set_quota_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaRule>,
    {
        use std::iter::Iterator;
        self.quota_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQuotaRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListQuotaRulesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListQuotaRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListQuotaRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQuotaRulesResponse {
    type PageItem = crate::model::QuotaRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.quota_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQuotaRulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __quota_rules,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQuotaRulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "quotaRules" => Ok(__FieldTag::__quota_rules),
                            "quota_rules" => Ok(__FieldTag::__quota_rules),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQuotaRulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQuotaRulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__quota_rules => {
                            if !fields.insert(__FieldTag::__quota_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_rules",
                                ));
                            }
                            result.quota_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QuotaRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQuotaRulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.quota_rules.is_empty() {
            state.serialize_entry("quotaRules", &self.quota_rules)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQuotaRulesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQuotaRulesResponse");
        debug_struct.field("quota_rules", &self.quota_rules);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetQuotaRuleRequest for getting a quota rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQuotaRuleRequest {
    /// Required. Name of the quota rule
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQuotaRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetQuotaRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQuotaRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQuotaRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQuotaRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQuotaRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQuotaRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetQuotaRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQuotaRuleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateQuotaRuleRequest for creating a quota rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateQuotaRuleRequest {
    /// Required. Parent value for CreateQuotaRuleRequest
    pub parent: std::string::String,

    /// Required. Fields of the to be created quota rule.
    pub quota_rule: std::option::Option<crate::model::QuotaRule>,

    /// Required. ID of the quota rule to create. Must be unique within the parent
    /// resource. Must contain only letters, numbers, underscore and hyphen, with
    /// the first character a letter or underscore, the last a letter or underscore
    /// or a number, and a 63 character maximum.
    pub quota_rule_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQuotaRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [quota_rule][crate::model::CreateQuotaRuleRequest::quota_rule].
    pub fn set_quota_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaRule>,
    {
        self.quota_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_rule][crate::model::CreateQuotaRuleRequest::quota_rule].
    pub fn set_or_clear_quota_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaRule>,
    {
        self.quota_rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quota_rule_id][crate::model::CreateQuotaRuleRequest::quota_rule_id].
    pub fn set_quota_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quota_rule_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateQuotaRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateQuotaRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __quota_rule,
            __quota_rule_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateQuotaRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "quotaRule" => Ok(__FieldTag::__quota_rule),
                            "quota_rule" => Ok(__FieldTag::__quota_rule),
                            "quotaRuleId" => Ok(__FieldTag::__quota_rule_id),
                            "quota_rule_id" => Ok(__FieldTag::__quota_rule_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateQuotaRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateQuotaRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_rule => {
                            if !fields.insert(__FieldTag::__quota_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_rule",
                                ));
                            }
                            result.quota_rule =
                                map.next_value::<std::option::Option<crate::model::QuotaRule>>()?;
                        }
                        __FieldTag::__quota_rule_id => {
                            if !fields.insert(__FieldTag::__quota_rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_rule_id",
                                ));
                            }
                            result.quota_rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateQuotaRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.quota_rule.is_some() {
            state.serialize_entry("quotaRule", &self.quota_rule)?;
        }
        if !self.quota_rule_id.is_empty() {
            state.serialize_entry("quotaRuleId", &self.quota_rule_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateQuotaRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateQuotaRuleRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("quota_rule", &self.quota_rule);
        debug_struct.field("quota_rule_id", &self.quota_rule_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateQuotaRuleRequest for updating a quota rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateQuotaRuleRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Quota Rule resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The quota rule being updated
    pub quota_rule: std::option::Option<crate::model::QuotaRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateQuotaRuleRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateQuotaRuleRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quota_rule][crate::model::UpdateQuotaRuleRequest::quota_rule].
    pub fn set_quota_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaRule>,
    {
        self.quota_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_rule][crate::model::UpdateQuotaRuleRequest::quota_rule].
    pub fn set_or_clear_quota_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaRule>,
    {
        self.quota_rule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateQuotaRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateQuotaRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __quota_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateQuotaRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "quotaRule" => Ok(__FieldTag::__quota_rule),
                            "quota_rule" => Ok(__FieldTag::__quota_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateQuotaRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateQuotaRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__quota_rule => {
                            if !fields.insert(__FieldTag::__quota_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_rule",
                                ));
                            }
                            result.quota_rule =
                                map.next_value::<std::option::Option<crate::model::QuotaRule>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateQuotaRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.quota_rule.is_some() {
            state.serialize_entry("quotaRule", &self.quota_rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateQuotaRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateQuotaRuleRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("quota_rule", &self.quota_rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteQuotaRuleRequest for deleting a single quota rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteQuotaRuleRequest {
    /// Required. Name of the quota rule.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQuotaRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteQuotaRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteQuotaRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteQuotaRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteQuotaRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteQuotaRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteQuotaRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteQuotaRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteQuotaRuleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// QuotaRule specifies the maximum disk space a user or group can use within a
/// volume. They can be used for creating default and individual quota rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaRule {
    /// Identifier. The resource name of the quota rule.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/volumes/volumes/{volume_id}/quotaRules/{quota_rule_id}`.
    pub name: std::string::String,

    /// Optional. The quota rule applies to the specified user or group, identified
    /// by a Unix UID/GID, Windows SID, or null for default.
    pub target: std::string::String,

    /// Required. The type of quota rule.
    pub r#type: crate::model::quota_rule::Type,

    /// Required. The maximum allowed disk space in MiB.
    pub disk_limit_mib: i32,

    /// Output only. State of the quota rule
    pub state: crate::model::quota_rule::State,

    /// Output only. State details of the quota rule
    pub state_details: std::string::String,

    /// Output only. Create time of the quota rule
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the quota rule
    pub description: std::string::String,

    /// Optional. Labels of the quota rule
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QuotaRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::QuotaRule::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::QuotaRule::type].
    pub fn set_type<T: std::convert::Into<crate::model::quota_rule::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [disk_limit_mib][crate::model::QuotaRule::disk_limit_mib].
    pub fn set_disk_limit_mib<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_limit_mib = v.into();
        self
    }

    /// Sets the value of [state][crate::model::QuotaRule::state].
    pub fn set_state<T: std::convert::Into<crate::model::quota_rule::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::QuotaRule::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QuotaRule::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QuotaRule::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::QuotaRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::QuotaRule::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for QuotaRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.QuotaRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target,
            __type,
            __disk_limit_mib,
            __state,
            __state_details,
            __create_time,
            __description,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "target" => Ok(__FieldTag::__target),
                            "type" => Ok(__FieldTag::__type),
                            "diskLimitMib" => Ok(__FieldTag::__disk_limit_mib),
                            "disk_limit_mib" => Ok(__FieldTag::__disk_limit_mib),
                            "state" => Ok(__FieldTag::__state),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::quota_rule::Type>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_limit_mib => {
                            if !fields.insert(__FieldTag::__disk_limit_mib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_limit_mib",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_limit_mib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::quota_rule::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.disk_limit_mib) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskLimitMib", &__With(&self.disk_limit_mib))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QuotaRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QuotaRule");
        debug_struct.field("name", &self.name);
        debug_struct.field("target", &self.target);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("disk_limit_mib", &self.disk_limit_mib);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_details", &self.state_details);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QuotaRule].
pub mod quota_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Types of Quota Rule
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified type for quota rule
        Unspecified,
        /// Individual user quota rule
        IndividualUserQuota,
        /// Individual group quota rule
        IndividualGroupQuota,
        /// Default user quota rule
        DefaultUserQuota,
        /// Default group quota rule
        DefaultGroupQuota,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::IndividualUserQuota => std::option::Option::Some(1),
                Self::IndividualGroupQuota => std::option::Option::Some(2),
                Self::DefaultUserQuota => std::option::Option::Some(3),
                Self::DefaultGroupQuota => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::IndividualUserQuota => std::option::Option::Some("INDIVIDUAL_USER_QUOTA"),
                Self::IndividualGroupQuota => std::option::Option::Some("INDIVIDUAL_GROUP_QUOTA"),
                Self::DefaultUserQuota => std::option::Option::Some("DEFAULT_USER_QUOTA"),
                Self::DefaultGroupQuota => std::option::Option::Some("DEFAULT_GROUP_QUOTA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::IndividualUserQuota,
                2 => Self::IndividualGroupQuota,
                3 => Self::DefaultUserQuota,
                4 => Self::DefaultGroupQuota,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INDIVIDUAL_USER_QUOTA" => Self::IndividualUserQuota,
                "INDIVIDUAL_GROUP_QUOTA" => Self::IndividualGroupQuota,
                "DEFAULT_USER_QUOTA" => Self::DefaultUserQuota,
                "DEFAULT_GROUP_QUOTA" => Self::DefaultGroupQuota,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::IndividualUserQuota => serializer.serialize_i32(1),
                Self::IndividualGroupQuota => serializer.serialize_i32(2),
                Self::DefaultUserQuota => serializer.serialize_i32(3),
                Self::DefaultGroupQuota => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.netapp.v1.QuotaRule.Type",
            ))
        }
    }

    /// Quota Rule states
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state for quota rule
        Unspecified,
        /// Quota rule is creating
        Creating,
        /// Quota rule is updating
        Updating,
        /// Quota rule is deleting
        Deleting,
        /// Quota rule is ready
        Ready,
        /// Quota rule is in error state.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Ready => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Updating,
                3 => Self::Deleting,
                4 => Self::Ready,
                5 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "READY" => Self::Ready,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Ready => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.QuotaRule.State",
            ))
        }
    }
}

/// TransferStats reports all statistics related to replication transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransferStats {
    /// Cumulative bytes transferred so far for the replication relationship.
    pub transfer_bytes: std::option::Option<i64>,

    /// Cumulative time taken across all transfers for the replication
    /// relationship.
    pub total_transfer_duration: std::option::Option<wkt::Duration>,

    /// Last transfer size in bytes.
    pub last_transfer_bytes: std::option::Option<i64>,

    /// Time taken during last transfer.
    pub last_transfer_duration: std::option::Option<wkt::Duration>,

    /// Lag duration indicates the duration by which Destination region volume
    /// content lags behind the primary region volume content.
    pub lag_duration: std::option::Option<wkt::Duration>,

    /// Time when progress was updated last.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Time when last transfer completed.
    pub last_transfer_end_time: std::option::Option<wkt::Timestamp>,

    /// A message describing the cause of the last transfer failure.
    pub last_transfer_error: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_bytes][crate::model::TransferStats::transfer_bytes].
    pub fn set_transfer_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.transfer_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_bytes][crate::model::TransferStats::transfer_bytes].
    pub fn set_or_clear_transfer_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.transfer_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_transfer_duration][crate::model::TransferStats::total_transfer_duration].
    pub fn set_total_transfer_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_transfer_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_transfer_duration][crate::model::TransferStats::total_transfer_duration].
    pub fn set_or_clear_total_transfer_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_transfer_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_transfer_bytes][crate::model::TransferStats::last_transfer_bytes].
    pub fn set_last_transfer_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.last_transfer_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_transfer_bytes][crate::model::TransferStats::last_transfer_bytes].
    pub fn set_or_clear_last_transfer_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.last_transfer_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_transfer_duration][crate::model::TransferStats::last_transfer_duration].
    pub fn set_last_transfer_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.last_transfer_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_transfer_duration][crate::model::TransferStats::last_transfer_duration].
    pub fn set_or_clear_last_transfer_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.last_transfer_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lag_duration][crate::model::TransferStats::lag_duration].
    pub fn set_lag_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lag_duration][crate::model::TransferStats::lag_duration].
    pub fn set_or_clear_lag_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lag_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::TransferStats::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TransferStats::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_transfer_end_time][crate::model::TransferStats::last_transfer_end_time].
    pub fn set_last_transfer_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_transfer_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_transfer_end_time][crate::model::TransferStats::last_transfer_end_time].
    pub fn set_or_clear_last_transfer_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_transfer_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_transfer_error][crate::model::TransferStats::last_transfer_error].
    pub fn set_last_transfer_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_transfer_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_transfer_error][crate::model::TransferStats::last_transfer_error].
    pub fn set_or_clear_last_transfer_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_transfer_error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransferStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.TransferStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransferStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transfer_bytes,
            __total_transfer_duration,
            __last_transfer_bytes,
            __last_transfer_duration,
            __lag_duration,
            __update_time,
            __last_transfer_end_time,
            __last_transfer_error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransferStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transferBytes" => Ok(__FieldTag::__transfer_bytes),
                            "transfer_bytes" => Ok(__FieldTag::__transfer_bytes),
                            "totalTransferDuration" => Ok(__FieldTag::__total_transfer_duration),
                            "total_transfer_duration" => Ok(__FieldTag::__total_transfer_duration),
                            "lastTransferBytes" => Ok(__FieldTag::__last_transfer_bytes),
                            "last_transfer_bytes" => Ok(__FieldTag::__last_transfer_bytes),
                            "lastTransferDuration" => Ok(__FieldTag::__last_transfer_duration),
                            "last_transfer_duration" => Ok(__FieldTag::__last_transfer_duration),
                            "lagDuration" => Ok(__FieldTag::__lag_duration),
                            "lag_duration" => Ok(__FieldTag::__lag_duration),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastTransferEndTime" => Ok(__FieldTag::__last_transfer_end_time),
                            "last_transfer_end_time" => Ok(__FieldTag::__last_transfer_end_time),
                            "lastTransferError" => Ok(__FieldTag::__last_transfer_error),
                            "last_transfer_error" => Ok(__FieldTag::__last_transfer_error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransferStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransferStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transfer_bytes => {
                            if !fields.insert(__FieldTag::__transfer_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transfer_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_transfer_duration => {
                            if !fields.insert(__FieldTag::__total_transfer_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_transfer_duration",
                                ));
                            }
                            result.total_transfer_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__last_transfer_bytes => {
                            if !fields.insert(__FieldTag::__last_transfer_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_transfer_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_transfer_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__last_transfer_duration => {
                            if !fields.insert(__FieldTag::__last_transfer_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_transfer_duration",
                                ));
                            }
                            result.last_transfer_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__lag_duration => {
                            if !fields.insert(__FieldTag::__lag_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lag_duration",
                                ));
                            }
                            result.lag_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_transfer_end_time => {
                            if !fields.insert(__FieldTag::__last_transfer_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_transfer_end_time",
                                ));
                            }
                            result.last_transfer_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_transfer_error => {
                            if !fields.insert(__FieldTag::__last_transfer_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_transfer_error",
                                ));
                            }
                            result.last_transfer_error =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransferStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transfer_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("transferBytes", &__With(&self.transfer_bytes))?;
        }
        if self.total_transfer_duration.is_some() {
            state.serialize_entry("totalTransferDuration", &self.total_transfer_duration)?;
        }
        if self.last_transfer_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("lastTransferBytes", &__With(&self.last_transfer_bytes))?;
        }
        if self.last_transfer_duration.is_some() {
            state.serialize_entry("lastTransferDuration", &self.last_transfer_duration)?;
        }
        if self.lag_duration.is_some() {
            state.serialize_entry("lagDuration", &self.lag_duration)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_transfer_end_time.is_some() {
            state.serialize_entry("lastTransferEndTime", &self.last_transfer_end_time)?;
        }
        if self.last_transfer_error.is_some() {
            state.serialize_entry("lastTransferError", &self.last_transfer_error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TransferStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransferStats");
        debug_struct.field("transfer_bytes", &self.transfer_bytes);
        debug_struct.field("total_transfer_duration", &self.total_transfer_duration);
        debug_struct.field("last_transfer_bytes", &self.last_transfer_bytes);
        debug_struct.field("last_transfer_duration", &self.last_transfer_duration);
        debug_struct.field("lag_duration", &self.lag_duration);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("last_transfer_end_time", &self.last_transfer_end_time);
        debug_struct.field("last_transfer_error", &self.last_transfer_error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Replication is a nested resource under Volume, that describes a
/// cross-region replication relationship between 2 volumes in different
/// regions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Replication {
    /// Identifier. The resource name of the Replication.
    /// Format:
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}`.
    pub name: std::string::String,

    /// Output only. State of the replication.
    pub state: crate::model::replication::State,

    /// Output only. State details of the replication.
    pub state_details: std::string::String,

    /// Output only. Indicates whether this points to source or destination.
    pub role: crate::model::replication::ReplicationRole,

    /// Required. Indicates the schedule for replication.
    pub replication_schedule: crate::model::replication::ReplicationSchedule,

    /// Output only. Indicates the state of mirroring.
    pub mirror_state: crate::model::replication::MirrorState,

    /// Output only. Condition of the relationship. Can be one of the following:
    ///
    /// - true: The replication relationship is healthy. It has not missed the most
    ///   recent scheduled transfer.
    /// - false: The replication relationship is not healthy. It has missed the
    ///   most recent scheduled transfer.
    pub healthy: std::option::Option<bool>,

    /// Output only. Replication create time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Full name of destination volume resource.
    /// Example : "projects/{project}/locations/{location}/volumes/{volume_id}"
    pub destination_volume: std::string::String,

    /// Output only. Replication transfer statistics.
    pub transfer_stats: std::option::Option<crate::model::TransferStats>,

    /// Resource labels to represent user provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A description about this replication relationship.
    pub description: std::option::Option<std::string::String>,

    /// Required. Input only. Destination volume parameters
    pub destination_volume_parameters:
        std::option::Option<crate::model::DestinationVolumeParameters>,

    /// Output only. Full name of source volume resource.
    /// Example : "projects/{project}/locations/{location}/volumes/{volume_id}"
    pub source_volume: std::string::String,

    /// Output only. Hybrid peering details.
    pub hybrid_peering_details: std::option::Option<crate::model::HybridPeeringDetails>,

    /// Optional. Location of the user cluster.
    pub cluster_location: std::string::String,

    /// Output only. Type of the hybrid replication.
    pub hybrid_replication_type: crate::model::replication::HybridReplicationType,

    /// Output only. Copy pastable snapmirror commands to be executed on onprem
    /// cluster by the customer.
    pub hybrid_replication_user_commands: std::option::Option<crate::model::UserCommands>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Replication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Replication::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Replication::state].
    pub fn set_state<T: std::convert::Into<crate::model::replication::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::Replication::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [role][crate::model::Replication::role].
    pub fn set_role<T: std::convert::Into<crate::model::replication::ReplicationRole>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [replication_schedule][crate::model::Replication::replication_schedule].
    pub fn set_replication_schedule<
        T: std::convert::Into<crate::model::replication::ReplicationSchedule>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_schedule = v.into();
        self
    }

    /// Sets the value of [mirror_state][crate::model::Replication::mirror_state].
    pub fn set_mirror_state<T: std::convert::Into<crate::model::replication::MirrorState>>(
        mut self,
        v: T,
    ) -> Self {
        self.mirror_state = v.into();
        self
    }

    /// Sets the value of [healthy][crate::model::Replication::healthy].
    pub fn set_healthy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.healthy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [healthy][crate::model::Replication::healthy].
    pub fn set_or_clear_healthy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.healthy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Replication::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Replication::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_volume][crate::model::Replication::destination_volume].
    pub fn set_destination_volume<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_volume = v.into();
        self
    }

    /// Sets the value of [transfer_stats][crate::model::Replication::transfer_stats].
    pub fn set_transfer_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransferStats>,
    {
        self.transfer_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transfer_stats][crate::model::Replication::transfer_stats].
    pub fn set_or_clear_transfer_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransferStats>,
    {
        self.transfer_stats = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Replication::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Replication::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Replication::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_volume_parameters][crate::model::Replication::destination_volume_parameters].
    pub fn set_destination_volume_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DestinationVolumeParameters>,
    {
        self.destination_volume_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination_volume_parameters][crate::model::Replication::destination_volume_parameters].
    pub fn set_or_clear_destination_volume_parameters<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DestinationVolumeParameters>,
    {
        self.destination_volume_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_volume][crate::model::Replication::source_volume].
    pub fn set_source_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_volume = v.into();
        self
    }

    /// Sets the value of [hybrid_peering_details][crate::model::Replication::hybrid_peering_details].
    pub fn set_hybrid_peering_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HybridPeeringDetails>,
    {
        self.hybrid_peering_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hybrid_peering_details][crate::model::Replication::hybrid_peering_details].
    pub fn set_or_clear_hybrid_peering_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HybridPeeringDetails>,
    {
        self.hybrid_peering_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster_location][crate::model::Replication::cluster_location].
    pub fn set_cluster_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_location = v.into();
        self
    }

    /// Sets the value of [hybrid_replication_type][crate::model::Replication::hybrid_replication_type].
    pub fn set_hybrid_replication_type<
        T: std::convert::Into<crate::model::replication::HybridReplicationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_replication_type = v.into();
        self
    }

    /// Sets the value of [hybrid_replication_user_commands][crate::model::Replication::hybrid_replication_user_commands].
    pub fn set_hybrid_replication_user_commands<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCommands>,
    {
        self.hybrid_replication_user_commands = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hybrid_replication_user_commands][crate::model::Replication::hybrid_replication_user_commands].
    pub fn set_or_clear_hybrid_replication_user_commands<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::UserCommands>,
    {
        self.hybrid_replication_user_commands = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Replication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Replication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Replication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __state_details,
            __role,
            __replication_schedule,
            __mirror_state,
            __healthy,
            __create_time,
            __destination_volume,
            __transfer_stats,
            __labels,
            __description,
            __destination_volume_parameters,
            __source_volume,
            __hybrid_peering_details,
            __cluster_location,
            __hybrid_replication_type,
            __hybrid_replication_user_commands,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Replication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            "role" => Ok(__FieldTag::__role),
                            "replicationSchedule" => Ok(__FieldTag::__replication_schedule),
                            "replication_schedule" => Ok(__FieldTag::__replication_schedule),
                            "mirrorState" => Ok(__FieldTag::__mirror_state),
                            "mirror_state" => Ok(__FieldTag::__mirror_state),
                            "healthy" => Ok(__FieldTag::__healthy),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "destinationVolume" => Ok(__FieldTag::__destination_volume),
                            "destination_volume" => Ok(__FieldTag::__destination_volume),
                            "transferStats" => Ok(__FieldTag::__transfer_stats),
                            "transfer_stats" => Ok(__FieldTag::__transfer_stats),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "destinationVolumeParameters" => {
                                Ok(__FieldTag::__destination_volume_parameters)
                            }
                            "destination_volume_parameters" => {
                                Ok(__FieldTag::__destination_volume_parameters)
                            }
                            "sourceVolume" => Ok(__FieldTag::__source_volume),
                            "source_volume" => Ok(__FieldTag::__source_volume),
                            "hybridPeeringDetails" => Ok(__FieldTag::__hybrid_peering_details),
                            "hybrid_peering_details" => Ok(__FieldTag::__hybrid_peering_details),
                            "clusterLocation" => Ok(__FieldTag::__cluster_location),
                            "cluster_location" => Ok(__FieldTag::__cluster_location),
                            "hybridReplicationType" => Ok(__FieldTag::__hybrid_replication_type),
                            "hybrid_replication_type" => Ok(__FieldTag::__hybrid_replication_type),
                            "hybridReplicationUserCommands" => {
                                Ok(__FieldTag::__hybrid_replication_user_commands)
                            }
                            "hybrid_replication_user_commands" => {
                                Ok(__FieldTag::__hybrid_replication_user_commands)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Replication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Replication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::replication::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map.next_value::<std::option::Option<crate::model::replication::ReplicationRole>>()?.unwrap_or_default();
                        }
                        __FieldTag::__replication_schedule => {
                            if !fields.insert(__FieldTag::__replication_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_schedule",
                                ));
                            }
                            result.replication_schedule =
                                map.next_value::<std::option::Option<
                                    crate::model::replication::ReplicationSchedule,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mirror_state => {
                            if !fields.insert(__FieldTag::__mirror_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mirror_state",
                                ));
                            }
                            result.mirror_state = map.next_value::<std::option::Option<crate::model::replication::MirrorState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__healthy => {
                            if !fields.insert(__FieldTag::__healthy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for healthy",
                                ));
                            }
                            result.healthy = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__destination_volume => {
                            if !fields.insert(__FieldTag::__destination_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_volume",
                                ));
                            }
                            result.destination_volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transfer_stats => {
                            if !fields.insert(__FieldTag::__transfer_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transfer_stats",
                                ));
                            }
                            result.transfer_stats = map
                                .next_value::<std::option::Option<crate::model::TransferStats>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__destination_volume_parameters => {
                            if !fields.insert(__FieldTag::__destination_volume_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_volume_parameters",
                                ));
                            }
                            result.destination_volume_parameters = map.next_value::<std::option::Option<crate::model::DestinationVolumeParameters>>()?
                                ;
                        }
                        __FieldTag::__source_volume => {
                            if !fields.insert(__FieldTag::__source_volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_volume",
                                ));
                            }
                            result.source_volume = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hybrid_peering_details => {
                            if !fields.insert(__FieldTag::__hybrid_peering_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_peering_details",
                                ));
                            }
                            result.hybrid_peering_details = map.next_value::<std::option::Option<crate::model::HybridPeeringDetails>>()?
                                ;
                        }
                        __FieldTag::__cluster_location => {
                            if !fields.insert(__FieldTag::__cluster_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_location",
                                ));
                            }
                            result.cluster_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hybrid_replication_type => {
                            if !fields.insert(__FieldTag::__hybrid_replication_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_replication_type",
                                ));
                            }
                            result.hybrid_replication_type = map
                                .next_value::<std::option::Option<
                                    crate::model::replication::HybridReplicationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hybrid_replication_user_commands => {
                            if !fields.insert(__FieldTag::__hybrid_replication_user_commands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_replication_user_commands",
                                ));
                            }
                            result.hybrid_replication_user_commands = map
                                .next_value::<std::option::Option<crate::model::UserCommands>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Replication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !wkt::internal::is_default(&self.replication_schedule) {
            state.serialize_entry("replicationSchedule", &self.replication_schedule)?;
        }
        if !wkt::internal::is_default(&self.mirror_state) {
            state.serialize_entry("mirrorState", &self.mirror_state)?;
        }
        if self.healthy.is_some() {
            state.serialize_entry("healthy", &self.healthy)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.destination_volume.is_empty() {
            state.serialize_entry("destinationVolume", &self.destination_volume)?;
        }
        if self.transfer_stats.is_some() {
            state.serialize_entry("transferStats", &self.transfer_stats)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.destination_volume_parameters.is_some() {
            state.serialize_entry(
                "destinationVolumeParameters",
                &self.destination_volume_parameters,
            )?;
        }
        if !self.source_volume.is_empty() {
            state.serialize_entry("sourceVolume", &self.source_volume)?;
        }
        if self.hybrid_peering_details.is_some() {
            state.serialize_entry("hybridPeeringDetails", &self.hybrid_peering_details)?;
        }
        if !self.cluster_location.is_empty() {
            state.serialize_entry("clusterLocation", &self.cluster_location)?;
        }
        if !wkt::internal::is_default(&self.hybrid_replication_type) {
            state.serialize_entry("hybridReplicationType", &self.hybrid_replication_type)?;
        }
        if self.hybrid_replication_user_commands.is_some() {
            state.serialize_entry(
                "hybridReplicationUserCommands",
                &self.hybrid_replication_user_commands,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Replication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Replication");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_details", &self.state_details);
        debug_struct.field("role", &self.role);
        debug_struct.field("replication_schedule", &self.replication_schedule);
        debug_struct.field("mirror_state", &self.mirror_state);
        debug_struct.field("healthy", &self.healthy);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("destination_volume", &self.destination_volume);
        debug_struct.field("transfer_stats", &self.transfer_stats);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field(
            "destination_volume_parameters",
            &self.destination_volume_parameters,
        );
        debug_struct.field("source_volume", &self.source_volume);
        debug_struct.field("hybrid_peering_details", &self.hybrid_peering_details);
        debug_struct.field("cluster_location", &self.cluster_location);
        debug_struct.field("hybrid_replication_type", &self.hybrid_replication_type);
        debug_struct.field(
            "hybrid_replication_user_commands",
            &self.hybrid_replication_user_commands,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Replication].
pub mod replication {
    #[allow(unused_imports)]
    use super::*;

    /// The replication states
    /// New enum values may be added in future to indicate possible new states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified replication State
        Unspecified,
        /// Replication is creating.
        Creating,
        /// Replication is ready.
        Ready,
        /// Replication is updating.
        Updating,
        /// Replication is deleting.
        Deleting,
        /// Replication is in error state.
        Error,
        /// Replication is waiting for cluster peering to be established.
        PendingClusterPeering,
        /// Replication is waiting for SVM peering to be established.
        PendingSvmPeering,
        /// Replication is waiting for Commands to be executed on Onprem ONTAP.
        PendingRemoteResync,
        /// Onprem ONTAP is destination and Replication can only be managed from
        /// Onprem.
        ExternallyManagedReplication,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::PendingClusterPeering => std::option::Option::Some(8),
                Self::PendingSvmPeering => std::option::Option::Some(9),
                Self::PendingRemoteResync => std::option::Option::Some(10),
                Self::ExternallyManagedReplication => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::PendingClusterPeering => std::option::Option::Some("PENDING_CLUSTER_PEERING"),
                Self::PendingSvmPeering => std::option::Option::Some("PENDING_SVM_PEERING"),
                Self::PendingRemoteResync => std::option::Option::Some("PENDING_REMOTE_RESYNC"),
                Self::ExternallyManagedReplication => {
                    std::option::Option::Some("EXTERNALLY_MANAGED_REPLICATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                5 => Self::Deleting,
                6 => Self::Error,
                8 => Self::PendingClusterPeering,
                9 => Self::PendingSvmPeering,
                10 => Self::PendingRemoteResync,
                11 => Self::ExternallyManagedReplication,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "PENDING_CLUSTER_PEERING" => Self::PendingClusterPeering,
                "PENDING_SVM_PEERING" => Self::PendingSvmPeering,
                "PENDING_REMOTE_RESYNC" => Self::PendingRemoteResync,
                "EXTERNALLY_MANAGED_REPLICATION" => Self::ExternallyManagedReplication,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::PendingClusterPeering => serializer.serialize_i32(8),
                Self::PendingSvmPeering => serializer.serialize_i32(9),
                Self::PendingRemoteResync => serializer.serialize_i32(10),
                Self::ExternallyManagedReplication => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Replication.State",
            ))
        }
    }

    /// New enum values may be added in future to support different replication
    /// topology.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicationRole {
        /// Unspecified replication role
        Unspecified,
        /// Indicates Source volume.
        Source,
        /// Indicates Destination volume.
        Destination,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicationRole::value] or
        /// [ReplicationRole::name].
        UnknownValue(replication_role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replication_role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicationRole {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Source => std::option::Option::Some(1),
                Self::Destination => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPLICATION_ROLE_UNSPECIFIED"),
                Self::Source => std::option::Option::Some("SOURCE"),
                Self::Destination => std::option::Option::Some("DESTINATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicationRole {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicationRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicationRole {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Source,
                2 => Self::Destination,
                _ => Self::UnknownValue(replication_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicationRole {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPLICATION_ROLE_UNSPECIFIED" => Self::Unspecified,
                "SOURCE" => Self::Source,
                "DESTINATION" => Self::Destination,
                _ => Self::UnknownValue(replication_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicationRole {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Source => serializer.serialize_i32(1),
                Self::Destination => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicationRole {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicationRole>::new(
                ".google.cloud.netapp.v1.Replication.ReplicationRole",
            ))
        }
    }

    /// Schedule for Replication.
    /// New enum values may be added in future to support different frequency of
    /// replication.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicationSchedule {
        /// Unspecified ReplicationSchedule
        Unspecified,
        /// Replication happens once every 10 minutes.
        Every10Minutes,
        /// Replication happens once every hour.
        Hourly,
        /// Replication happens once every day.
        Daily,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicationSchedule::value] or
        /// [ReplicationSchedule::name].
        UnknownValue(replication_schedule::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replication_schedule {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicationSchedule {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Every10Minutes => std::option::Option::Some(1),
                Self::Hourly => std::option::Option::Some(2),
                Self::Daily => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPLICATION_SCHEDULE_UNSPECIFIED"),
                Self::Every10Minutes => std::option::Option::Some("EVERY_10_MINUTES"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicationSchedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicationSchedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicationSchedule {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Every10Minutes,
                2 => Self::Hourly,
                3 => Self::Daily,
                _ => Self::UnknownValue(replication_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicationSchedule {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPLICATION_SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                "EVERY_10_MINUTES" => Self::Every10Minutes,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                _ => Self::UnknownValue(replication_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicationSchedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Every10Minutes => serializer.serialize_i32(1),
                Self::Hourly => serializer.serialize_i32(2),
                Self::Daily => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicationSchedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicationSchedule>::new(
                ".google.cloud.netapp.v1.Replication.ReplicationSchedule",
            ))
        }
    }

    /// Mirroring states.
    /// No new value is expected to be added in future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MirrorState {
        /// Unspecified MirrorState
        Unspecified,
        /// Destination volume is being prepared.
        Preparing,
        /// Destination volume has been initialized and is ready to receive
        /// replication transfers.
        Mirrored,
        /// Destination volume is not receiving replication transfers.
        Stopped,
        /// Incremental replication is in progress.
        Transferring,
        /// Baseline replication is in progress.
        BaselineTransferring,
        /// Replication is aborted.
        Aborted,
        /// Replication is being managed from Onprem ONTAP.
        ExternallyManaged,
        /// Peering is yet to be established.
        PendingPeering,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MirrorState::value] or
        /// [MirrorState::name].
        UnknownValue(mirror_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mirror_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MirrorState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Preparing => std::option::Option::Some(1),
                Self::Mirrored => std::option::Option::Some(2),
                Self::Stopped => std::option::Option::Some(3),
                Self::Transferring => std::option::Option::Some(4),
                Self::BaselineTransferring => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::ExternallyManaged => std::option::Option::Some(7),
                Self::PendingPeering => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIRROR_STATE_UNSPECIFIED"),
                Self::Preparing => std::option::Option::Some("PREPARING"),
                Self::Mirrored => std::option::Option::Some("MIRRORED"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Transferring => std::option::Option::Some("TRANSFERRING"),
                Self::BaselineTransferring => std::option::Option::Some("BASELINE_TRANSFERRING"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::ExternallyManaged => std::option::Option::Some("EXTERNALLY_MANAGED"),
                Self::PendingPeering => std::option::Option::Some("PENDING_PEERING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MirrorState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MirrorState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MirrorState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Preparing,
                2 => Self::Mirrored,
                3 => Self::Stopped,
                4 => Self::Transferring,
                5 => Self::BaselineTransferring,
                6 => Self::Aborted,
                7 => Self::ExternallyManaged,
                8 => Self::PendingPeering,
                _ => Self::UnknownValue(mirror_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MirrorState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIRROR_STATE_UNSPECIFIED" => Self::Unspecified,
                "PREPARING" => Self::Preparing,
                "MIRRORED" => Self::Mirrored,
                "STOPPED" => Self::Stopped,
                "TRANSFERRING" => Self::Transferring,
                "BASELINE_TRANSFERRING" => Self::BaselineTransferring,
                "ABORTED" => Self::Aborted,
                "EXTERNALLY_MANAGED" => Self::ExternallyManaged,
                "PENDING_PEERING" => Self::PendingPeering,
                _ => Self::UnknownValue(mirror_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MirrorState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Preparing => serializer.serialize_i32(1),
                Self::Mirrored => serializer.serialize_i32(2),
                Self::Stopped => serializer.serialize_i32(3),
                Self::Transferring => serializer.serialize_i32(4),
                Self::BaselineTransferring => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::ExternallyManaged => serializer.serialize_i32(7),
                Self::PendingPeering => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MirrorState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MirrorState>::new(
                ".google.cloud.netapp.v1.Replication.MirrorState",
            ))
        }
    }

    /// Hybrid replication type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HybridReplicationType {
        /// Unspecified hybrid replication type.
        Unspecified,
        /// Hybrid replication type for migration.
        Migration,
        /// Hybrid replication type for continuous replication.
        ContinuousReplication,
        /// New field for reversible OnPrem replication, to be used for data
        /// protection.
        OnpremReplication,
        /// Hybrid replication type for incremental Transfer in the reverse direction
        /// (GCNV is source and Onprem is destination)
        ReverseOnpremReplication,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HybridReplicationType::value] or
        /// [HybridReplicationType::name].
        UnknownValue(hybrid_replication_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod hybrid_replication_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HybridReplicationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Migration => std::option::Option::Some(1),
                Self::ContinuousReplication => std::option::Option::Some(2),
                Self::OnpremReplication => std::option::Option::Some(3),
                Self::ReverseOnpremReplication => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("HYBRID_REPLICATION_TYPE_UNSPECIFIED")
                }
                Self::Migration => std::option::Option::Some("MIGRATION"),
                Self::ContinuousReplication => std::option::Option::Some("CONTINUOUS_REPLICATION"),
                Self::OnpremReplication => std::option::Option::Some("ONPREM_REPLICATION"),
                Self::ReverseOnpremReplication => {
                    std::option::Option::Some("REVERSE_ONPREM_REPLICATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HybridReplicationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HybridReplicationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HybridReplicationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Migration,
                2 => Self::ContinuousReplication,
                3 => Self::OnpremReplication,
                4 => Self::ReverseOnpremReplication,
                _ => Self::UnknownValue(hybrid_replication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HybridReplicationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HYBRID_REPLICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MIGRATION" => Self::Migration,
                "CONTINUOUS_REPLICATION" => Self::ContinuousReplication,
                "ONPREM_REPLICATION" => Self::OnpremReplication,
                "REVERSE_ONPREM_REPLICATION" => Self::ReverseOnpremReplication,
                _ => Self::UnknownValue(hybrid_replication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HybridReplicationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Migration => serializer.serialize_i32(1),
                Self::ContinuousReplication => serializer.serialize_i32(2),
                Self::OnpremReplication => serializer.serialize_i32(3),
                Self::ReverseOnpremReplication => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HybridReplicationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HybridReplicationType>::new(
                ".google.cloud.netapp.v1.Replication.HybridReplicationType",
            ))
        }
    }
}

/// HybridPeeringDetails contains details about the hybrid peering.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridPeeringDetails {
    /// Output only. IP address of the subnet.
    pub subnet_ip: std::string::String,

    /// Output only. Copy-paste-able commands to be used on user's ONTAP to accept
    /// peering requests.
    pub command: std::string::String,

    /// Output only. Expiration time for the peering command to be executed on
    /// user's ONTAP.
    pub command_expiry_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Temporary passphrase generated to accept cluster peering
    /// command.
    pub passphrase: std::string::String,

    /// Output only. Name of the user's local source volume to be peered with the
    /// destination volume.
    pub peer_volume_name: std::string::String,

    /// Output only. Name of the user's local source cluster to be peered with the
    /// destination cluster.
    pub peer_cluster_name: std::string::String,

    /// Output only. Name of the user's local source vserver svm to be peered with
    /// the destination vserver svm.
    pub peer_svm_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridPeeringDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnet_ip][crate::model::HybridPeeringDetails::subnet_ip].
    pub fn set_subnet_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_ip = v.into();
        self
    }

    /// Sets the value of [command][crate::model::HybridPeeringDetails::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [command_expiry_time][crate::model::HybridPeeringDetails::command_expiry_time].
    pub fn set_command_expiry_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.command_expiry_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [command_expiry_time][crate::model::HybridPeeringDetails::command_expiry_time].
    pub fn set_or_clear_command_expiry_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.command_expiry_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [passphrase][crate::model::HybridPeeringDetails::passphrase].
    pub fn set_passphrase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.passphrase = v.into();
        self
    }

    /// Sets the value of [peer_volume_name][crate::model::HybridPeeringDetails::peer_volume_name].
    pub fn set_peer_volume_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_volume_name = v.into();
        self
    }

    /// Sets the value of [peer_cluster_name][crate::model::HybridPeeringDetails::peer_cluster_name].
    pub fn set_peer_cluster_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_cluster_name = v.into();
        self
    }

    /// Sets the value of [peer_svm_name][crate::model::HybridPeeringDetails::peer_svm_name].
    pub fn set_peer_svm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_svm_name = v.into();
        self
    }
}

impl wkt::message::Message for HybridPeeringDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.HybridPeeringDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridPeeringDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnet_ip,
            __command,
            __command_expiry_time,
            __passphrase,
            __peer_volume_name,
            __peer_cluster_name,
            __peer_svm_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridPeeringDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetIp" => Ok(__FieldTag::__subnet_ip),
                            "subnet_ip" => Ok(__FieldTag::__subnet_ip),
                            "command" => Ok(__FieldTag::__command),
                            "commandExpiryTime" => Ok(__FieldTag::__command_expiry_time),
                            "command_expiry_time" => Ok(__FieldTag::__command_expiry_time),
                            "passphrase" => Ok(__FieldTag::__passphrase),
                            "peerVolumeName" => Ok(__FieldTag::__peer_volume_name),
                            "peer_volume_name" => Ok(__FieldTag::__peer_volume_name),
                            "peerClusterName" => Ok(__FieldTag::__peer_cluster_name),
                            "peer_cluster_name" => Ok(__FieldTag::__peer_cluster_name),
                            "peerSvmName" => Ok(__FieldTag::__peer_svm_name),
                            "peer_svm_name" => Ok(__FieldTag::__peer_svm_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridPeeringDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridPeeringDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnet_ip => {
                            if !fields.insert(__FieldTag::__subnet_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_ip",
                                ));
                            }
                            result.subnet_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__command => {
                            if !fields.insert(__FieldTag::__command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command",
                                ));
                            }
                            result.command = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__command_expiry_time => {
                            if !fields.insert(__FieldTag::__command_expiry_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command_expiry_time",
                                ));
                            }
                            result.command_expiry_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__passphrase => {
                            if !fields.insert(__FieldTag::__passphrase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passphrase",
                                ));
                            }
                            result.passphrase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_volume_name => {
                            if !fields.insert(__FieldTag::__peer_volume_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_volume_name",
                                ));
                            }
                            result.peer_volume_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_cluster_name => {
                            if !fields.insert(__FieldTag::__peer_cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_cluster_name",
                                ));
                            }
                            result.peer_cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_svm_name => {
                            if !fields.insert(__FieldTag::__peer_svm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_svm_name",
                                ));
                            }
                            result.peer_svm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridPeeringDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnet_ip.is_empty() {
            state.serialize_entry("subnetIp", &self.subnet_ip)?;
        }
        if !self.command.is_empty() {
            state.serialize_entry("command", &self.command)?;
        }
        if self.command_expiry_time.is_some() {
            state.serialize_entry("commandExpiryTime", &self.command_expiry_time)?;
        }
        if !self.passphrase.is_empty() {
            state.serialize_entry("passphrase", &self.passphrase)?;
        }
        if !self.peer_volume_name.is_empty() {
            state.serialize_entry("peerVolumeName", &self.peer_volume_name)?;
        }
        if !self.peer_cluster_name.is_empty() {
            state.serialize_entry("peerClusterName", &self.peer_cluster_name)?;
        }
        if !self.peer_svm_name.is_empty() {
            state.serialize_entry("peerSvmName", &self.peer_svm_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HybridPeeringDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HybridPeeringDetails");
        debug_struct.field("subnet_ip", &self.subnet_ip);
        debug_struct.field("command", &self.command);
        debug_struct.field("command_expiry_time", &self.command_expiry_time);
        debug_struct.field("passphrase", &self.passphrase);
        debug_struct.field("peer_volume_name", &self.peer_volume_name);
        debug_struct.field("peer_cluster_name", &self.peer_cluster_name);
        debug_struct.field("peer_svm_name", &self.peer_svm_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListReplications lists replications.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReplicationsRequest {
    /// Required. The volume for which to retrieve replication information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReplicationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReplicationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReplicationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReplicationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReplicationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListReplicationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListReplicationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReplicationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReplicationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReplicationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReplicationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReplicationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReplicationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReplicationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListReplicationsResponse is the result of ListReplicationsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReplicationsResponse {
    /// A list of replications in the project for the specified volume.
    pub replications: std::vec::Vec<crate::model::Replication>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replications][crate::model::ListReplicationsResponse::replications].
    pub fn set_replications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Replication>,
    {
        use std::iter::Iterator;
        self.replications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReplicationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReplicationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReplicationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListReplicationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReplicationsResponse {
    type PageItem = crate::model::Replication;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.replications
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReplicationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __replications,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReplicationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replications" => Ok(__FieldTag::__replications),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReplicationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReplicationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__replications => {
                            if !fields.insert(__FieldTag::__replications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replications",
                                ));
                            }
                            result.replications = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Replication>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReplicationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.replications.is_empty() {
            state.serialize_entry("replications", &self.replications)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReplicationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReplicationsResponse");
        debug_struct.field("replications", &self.replications);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetReplicationRequest gets the state of a replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReplicationRequest {
    /// Required. The replication resource name, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReplicationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DestinationVolumeParameters specify input parameters used for creating
/// destination volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DestinationVolumeParameters {
    /// Required. Existing destination StoragePool name.
    pub storage_pool: std::string::String,

    /// Desired destination volume resource id. If not specified, source volume's
    /// resource id will be used.
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    pub volume_id: std::string::String,

    /// Destination volume's share name. If not specified, source volume's share
    /// name will be used.
    pub share_name: std::string::String,

    /// Description for the destination volume.
    pub description: std::option::Option<std::string::String>,

    /// Optional. Tiering policy for the volume.
    pub tiering_policy: std::option::Option<crate::model::TieringPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestinationVolumeParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_pool][crate::model::DestinationVolumeParameters::storage_pool].
    pub fn set_storage_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool = v.into();
        self
    }

    /// Sets the value of [volume_id][crate::model::DestinationVolumeParameters::volume_id].
    pub fn set_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_id = v.into();
        self
    }

    /// Sets the value of [share_name][crate::model::DestinationVolumeParameters::share_name].
    pub fn set_share_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.share_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DestinationVolumeParameters::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::DestinationVolumeParameters::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tiering_policy][crate::model::DestinationVolumeParameters::tiering_policy].
    pub fn set_tiering_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TieringPolicy>,
    {
        self.tiering_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tiering_policy][crate::model::DestinationVolumeParameters::tiering_policy].
    pub fn set_or_clear_tiering_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TieringPolicy>,
    {
        self.tiering_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DestinationVolumeParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DestinationVolumeParameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DestinationVolumeParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_pool,
            __volume_id,
            __share_name,
            __description,
            __tiering_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DestinationVolumeParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storagePool" => Ok(__FieldTag::__storage_pool),
                            "storage_pool" => Ok(__FieldTag::__storage_pool),
                            "volumeId" => Ok(__FieldTag::__volume_id),
                            "volume_id" => Ok(__FieldTag::__volume_id),
                            "shareName" => Ok(__FieldTag::__share_name),
                            "share_name" => Ok(__FieldTag::__share_name),
                            "description" => Ok(__FieldTag::__description),
                            "tieringPolicy" => Ok(__FieldTag::__tiering_policy),
                            "tiering_policy" => Ok(__FieldTag::__tiering_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DestinationVolumeParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DestinationVolumeParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_pool => {
                            if !fields.insert(__FieldTag::__storage_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pool",
                                ));
                            }
                            result.storage_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_id => {
                            if !fields.insert(__FieldTag::__volume_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_id",
                                ));
                            }
                            result.volume_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__share_name => {
                            if !fields.insert(__FieldTag::__share_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for share_name",
                                ));
                            }
                            result.share_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__tiering_policy => {
                            if !fields.insert(__FieldTag::__tiering_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tiering_policy",
                                ));
                            }
                            result.tiering_policy = map
                                .next_value::<std::option::Option<crate::model::TieringPolicy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DestinationVolumeParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.storage_pool.is_empty() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if !self.volume_id.is_empty() {
            state.serialize_entry("volumeId", &self.volume_id)?;
        }
        if !self.share_name.is_empty() {
            state.serialize_entry("shareName", &self.share_name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.tiering_policy.is_some() {
            state.serialize_entry("tieringPolicy", &self.tiering_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DestinationVolumeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DestinationVolumeParameters");
        debug_struct.field("storage_pool", &self.storage_pool);
        debug_struct.field("volume_id", &self.volume_id);
        debug_struct.field("share_name", &self.share_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("tiering_policy", &self.tiering_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateReplicationRequest creates a replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReplicationRequest {
    /// Required. The NetApp volume to create the replications of, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`
    pub parent: std::string::String,

    /// Required. A replication resource
    pub replication: std::option::Option<crate::model::Replication>,

    /// Required. ID of the replication to create. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    pub replication_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReplicationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [replication][crate::model::CreateReplicationRequest::replication].
    pub fn set_replication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Replication>,
    {
        self.replication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication][crate::model::CreateReplicationRequest::replication].
    pub fn set_or_clear_replication<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Replication>,
    {
        self.replication = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_id][crate::model::CreateReplicationRequest::replication_id].
    pub fn set_replication_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replication_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __replication,
            __replication_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "replication" => Ok(__FieldTag::__replication),
                            "replicationId" => Ok(__FieldTag::__replication_id),
                            "replication_id" => Ok(__FieldTag::__replication_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replication => {
                            if !fields.insert(__FieldTag::__replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication",
                                ));
                            }
                            result.replication =
                                map.next_value::<std::option::Option<crate::model::Replication>>()?;
                        }
                        __FieldTag::__replication_id => {
                            if !fields.insert(__FieldTag::__replication_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_id",
                                ));
                            }
                            result.replication_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.replication.is_some() {
            state.serialize_entry("replication", &self.replication)?;
        }
        if !self.replication_id.is_empty() {
            state.serialize_entry("replicationId", &self.replication_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReplicationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("replication", &self.replication);
        debug_struct.field("replication_id", &self.replication_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteReplicationRequest deletes a replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReplicationRequest {
    /// Required. The replication resource name, in the format
    /// `projects/*/locations/*/volumes/*/replications/{replication_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteReplicationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateReplicationRequest updates description and/or labels for a replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateReplicationRequest {
    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A replication resource
    pub replication: std::option::Option<crate::model::Replication>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateReplicationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateReplicationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication][crate::model::UpdateReplicationRequest::replication].
    pub fn set_replication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Replication>,
    {
        self.replication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication][crate::model::UpdateReplicationRequest::replication].
    pub fn set_or_clear_replication<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Replication>,
    {
        self.replication = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __replication,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "replication" => Ok(__FieldTag::__replication),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__replication => {
                            if !fields.insert(__FieldTag::__replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication",
                                ));
                            }
                            result.replication =
                                map.next_value::<std::option::Option<crate::model::Replication>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.replication.is_some() {
            state.serialize_entry("replication", &self.replication)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateReplicationRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("replication", &self.replication);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// StopReplicationRequest stops a replication until resumed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopReplicationRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    pub name: std::string::String,

    /// Indicates whether to stop replication forcefully while data transfer is in
    /// progress.
    /// Warning! if force is true, this will abort any current transfers
    /// and can lead to data loss due to partial transfer.
    /// If force is false, stop replication will fail while data transfer is in
    /// progress and you will need to retry later.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::StopReplicationRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for StopReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.StopReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopReplicationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ResumeReplicationRequest resumes a stopped replication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeReplicationRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ResumeReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeReplicationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReverseReplicationDirectionRequest reverses direction of replication. Source
/// becomes destination and destination becomes source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReverseReplicationDirectionRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReverseReplicationDirectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReverseReplicationDirectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ReverseReplicationDirectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ReverseReplicationDirectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReverseReplicationDirectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReverseReplicationDirectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReverseReplicationDirectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReverseReplicationDirectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReverseReplicationDirectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReverseReplicationDirectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReverseReplicationDirectionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// EstablishPeeringRequest establishes cluster and svm peerings between the
/// source and the destination replications.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EstablishPeeringRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    pub name: std::string::String,

    /// Required. Name of the user's local source cluster to be peered with the
    /// destination cluster.
    pub peer_cluster_name: std::string::String,

    /// Required. Name of the user's local source vserver svm to be peered with the
    /// destination vserver svm.
    pub peer_svm_name: std::string::String,

    /// Optional. List of IPv4 ip addresses to be used for peering.
    pub peer_ip_addresses: std::vec::Vec<std::string::String>,

    /// Required. Name of the user's local source volume to be peered with the
    /// destination volume.
    pub peer_volume_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EstablishPeeringRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EstablishPeeringRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [peer_cluster_name][crate::model::EstablishPeeringRequest::peer_cluster_name].
    pub fn set_peer_cluster_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_cluster_name = v.into();
        self
    }

    /// Sets the value of [peer_svm_name][crate::model::EstablishPeeringRequest::peer_svm_name].
    pub fn set_peer_svm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_svm_name = v.into();
        self
    }

    /// Sets the value of [peer_ip_addresses][crate::model::EstablishPeeringRequest::peer_ip_addresses].
    pub fn set_peer_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [peer_volume_name][crate::model::EstablishPeeringRequest::peer_volume_name].
    pub fn set_peer_volume_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_volume_name = v.into();
        self
    }
}

impl wkt::message::Message for EstablishPeeringRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.EstablishPeeringRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EstablishPeeringRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __peer_cluster_name,
            __peer_svm_name,
            __peer_ip_addresses,
            __peer_volume_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EstablishPeeringRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "peerClusterName" => Ok(__FieldTag::__peer_cluster_name),
                            "peer_cluster_name" => Ok(__FieldTag::__peer_cluster_name),
                            "peerSvmName" => Ok(__FieldTag::__peer_svm_name),
                            "peer_svm_name" => Ok(__FieldTag::__peer_svm_name),
                            "peerIpAddresses" => Ok(__FieldTag::__peer_ip_addresses),
                            "peer_ip_addresses" => Ok(__FieldTag::__peer_ip_addresses),
                            "peerVolumeName" => Ok(__FieldTag::__peer_volume_name),
                            "peer_volume_name" => Ok(__FieldTag::__peer_volume_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EstablishPeeringRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EstablishPeeringRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_cluster_name => {
                            if !fields.insert(__FieldTag::__peer_cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_cluster_name",
                                ));
                            }
                            result.peer_cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_svm_name => {
                            if !fields.insert(__FieldTag::__peer_svm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_svm_name",
                                ));
                            }
                            result.peer_svm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_ip_addresses => {
                            if !fields.insert(__FieldTag::__peer_ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_ip_addresses",
                                ));
                            }
                            result.peer_ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__peer_volume_name => {
                            if !fields.insert(__FieldTag::__peer_volume_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_volume_name",
                                ));
                            }
                            result.peer_volume_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EstablishPeeringRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.peer_cluster_name.is_empty() {
            state.serialize_entry("peerClusterName", &self.peer_cluster_name)?;
        }
        if !self.peer_svm_name.is_empty() {
            state.serialize_entry("peerSvmName", &self.peer_svm_name)?;
        }
        if !self.peer_ip_addresses.is_empty() {
            state.serialize_entry("peerIpAddresses", &self.peer_ip_addresses)?;
        }
        if !self.peer_volume_name.is_empty() {
            state.serialize_entry("peerVolumeName", &self.peer_volume_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EstablishPeeringRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EstablishPeeringRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("peer_cluster_name", &self.peer_cluster_name);
        debug_struct.field("peer_svm_name", &self.peer_svm_name);
        debug_struct.field("peer_ip_addresses", &self.peer_ip_addresses);
        debug_struct.field("peer_volume_name", &self.peer_volume_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SyncReplicationRequest syncs the replication from source to destination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SyncReplicationRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyncReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SyncReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SyncReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SyncReplicationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SyncReplicationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SyncReplicationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SyncReplicationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SyncReplicationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SyncReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SyncReplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SyncReplicationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListSnapshotsRequest lists snapshots.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The volume for which to retrieve snapshot information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    /// List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSnapshotsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnapshotsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListSnapshotsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnapshotsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnapshotsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnapshotsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnapshotsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnapshotsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSnapshotsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSnapshotsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListSnapshotsResponse is the result of ListSnapshotsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// A list of snapshots in the project for the specified volume.
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSnapshotsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnapshotsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnapshotsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshots" => Ok(__FieldTag::__snapshots),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnapshotsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnapshotsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots => {
                            if !fields.insert(__FieldTag::__snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots",
                                ));
                            }
                            result.snapshots = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Snapshot>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnapshotsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshots.is_empty() {
            state.serialize_entry("snapshots", &self.snapshots)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSnapshotsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSnapshotsResponse");
        debug_struct.field("snapshots", &self.snapshots);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetSnapshotRequest gets the state of a snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSnapshotRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateSnapshotRequest creates a snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. The NetApp volume to create the snapshots of, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`
    pub parent: std::string::String,

    /// Required. A snapshot resource
    pub snapshot: std::option::Option<crate::model::Snapshot>,

    /// Required. ID of the snapshot to create. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    pub snapshot_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::CreateSnapshotRequest::snapshot].
    pub fn set_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot][crate::model::CreateSnapshotRequest::snapshot].
    pub fn set_or_clear_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snapshot_id][crate::model::CreateSnapshotRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __snapshot,
            __snapshot_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            "snapshotId" => Ok(__FieldTag::__snapshot_id),
                            "snapshot_id" => Ok(__FieldTag::__snapshot_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot =
                                map.next_value::<std::option::Option<crate::model::Snapshot>>()?;
                        }
                        __FieldTag::__snapshot_id => {
                            if !fields.insert(__FieldTag::__snapshot_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_id",
                                ));
                            }
                            result.snapshot_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.snapshot.is_some() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if !self.snapshot_id.is_empty() {
            state.serialize_entry("snapshotId", &self.snapshot_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSnapshotRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("snapshot", &self.snapshot);
        debug_struct.field("snapshot_id", &self.snapshot_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteSnapshotRequest deletes a snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/*/locations/*/volumes/*/snapshots/{snapshot_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSnapshotRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateSnapshotRequest updates description and/or labels for a snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A snapshot resource
    pub snapshot: std::option::Option<crate::model::Snapshot>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_or_clear_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot =
                                map.next_value::<std::option::Option<crate::model::Snapshot>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.snapshot.is_some() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSnapshotRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("snapshot", &self.snapshot);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Snapshot is a point-in-time version of a Volume's content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Snapshot {
    /// Identifier. The resource name of the snapshot.
    /// Format:
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`.
    pub name: std::string::String,

    /// Output only. The snapshot state.
    pub state: crate::model::snapshot::State,

    /// Output only. State details of the storage pool
    pub state_details: std::string::String,

    /// A description of the snapshot with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    pub description: std::string::String,

    /// Output only. Current storage usage for the snapshot in bytes.
    pub used_bytes: f64,

    /// Output only. The time when the snapshot was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::Snapshot::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [used_bytes][crate::model::Snapshot::used_bytes].
    pub fn set_used_bytes<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.used_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Snapshot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Snapshot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __state_details,
            __description,
            __used_bytes,
            __create_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Snapshot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            "description" => Ok(__FieldTag::__description),
                            "usedBytes" => Ok(__FieldTag::__used_bytes),
                            "used_bytes" => Ok(__FieldTag::__used_bytes),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Snapshot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Snapshot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::snapshot::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__used_bytes => {
                            if !fields.insert(__FieldTag::__used_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_bytes",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.used_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Snapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.used_bytes) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("usedBytes", &__With(&self.used_bytes))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Snapshot");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_details", &self.state_details);
        debug_struct.field("description", &self.description);
        debug_struct.field("used_bytes", &self.used_bytes);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Snapshot].
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// The Snapshot States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Snapshot State
        Unspecified,
        /// Snapshot State is Ready
        Ready,
        /// Snapshot State is Creating
        Creating,
        /// Snapshot State is Deleting
        Deleting,
        /// Snapshot State is Updating
        Updating,
        /// Snapshot State is Disabled
        Disabled,
        /// Snapshot State is Error
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Disabled => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::Disabled,
                6 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "DISABLED" => Self::Disabled,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Disabled => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Snapshot.State",
            ))
        }
    }
}

/// GetStoragePoolRequest gets a Storage Pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStoragePoolRequest {
    /// Required. Name of the storage pool
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStoragePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetStoragePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStoragePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStoragePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStoragePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStoragePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStoragePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetStoragePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetStoragePoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListStoragePoolsRequest lists Storage Pools.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStoragePoolsRequest {
    /// Required. Parent value
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    pub page_size: i32,

    /// Optional. The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    pub page_token: std::string::String,

    /// Optional. Sort results. Supported values are "name", "name desc" or ""
    /// (unsorted).
    pub order_by: std::string::String,

    /// Optional. List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoragePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStoragePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStoragePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStoragePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStoragePoolsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListStoragePoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListStoragePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListStoragePoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStoragePoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStoragePoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStoragePoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStoragePoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStoragePoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListStoragePoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListStoragePoolsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListStoragePoolsResponse is the response to a ListStoragePoolsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListStoragePoolsResponse {
    /// The list of StoragePools
    pub storage_pools: std::vec::Vec<crate::model::StoragePool>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoragePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_pools][crate::model::ListStoragePoolsResponse::storage_pools].
    pub fn set_storage_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoragePool>,
    {
        use std::iter::Iterator;
        self.storage_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStoragePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListStoragePoolsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListStoragePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListStoragePoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStoragePoolsResponse {
    type PageItem = crate::model::StoragePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.storage_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListStoragePoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __storage_pools,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListStoragePoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "storagePools" => Ok(__FieldTag::__storage_pools),
                            "storage_pools" => Ok(__FieldTag::__storage_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListStoragePoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListStoragePoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__storage_pools => {
                            if !fields.insert(__FieldTag::__storage_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pools",
                                ));
                            }
                            result.storage_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::StoragePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListStoragePoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.storage_pools.is_empty() {
            state.serialize_entry("storagePools", &self.storage_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListStoragePoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListStoragePoolsResponse");
        debug_struct.field("storage_pools", &self.storage_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateStoragePoolRequest creates a Storage Pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateStoragePoolRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. Id of the requesting storage pool. Must be unique within the
    /// parent resource. Must contain only letters, numbers and hyphen, with the
    /// first character a letter, the last a letter or a number, and a 63 character
    /// maximum.
    pub storage_pool_id: std::string::String,

    /// Required. The required parameters to create a new storage pool.
    pub storage_pool: std::option::Option<crate::model::StoragePool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStoragePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [storage_pool_id][crate::model::CreateStoragePoolRequest::storage_pool_id].
    pub fn set_storage_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool_id = v.into();
        self
    }

    /// Sets the value of [storage_pool][crate::model::CreateStoragePoolRequest::storage_pool].
    pub fn set_storage_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoragePool>,
    {
        self.storage_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_pool][crate::model::CreateStoragePoolRequest::storage_pool].
    pub fn set_or_clear_storage_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoragePool>,
    {
        self.storage_pool = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateStoragePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateStoragePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __storage_pool_id,
            __storage_pool,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateStoragePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "storagePoolId" => Ok(__FieldTag::__storage_pool_id),
                            "storage_pool_id" => Ok(__FieldTag::__storage_pool_id),
                            "storagePool" => Ok(__FieldTag::__storage_pool),
                            "storage_pool" => Ok(__FieldTag::__storage_pool),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateStoragePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateStoragePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_pool_id => {
                            if !fields.insert(__FieldTag::__storage_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pool_id",
                                ));
                            }
                            result.storage_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_pool => {
                            if !fields.insert(__FieldTag::__storage_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pool",
                                ));
                            }
                            result.storage_pool =
                                map.next_value::<std::option::Option<crate::model::StoragePool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateStoragePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.storage_pool_id.is_empty() {
            state.serialize_entry("storagePoolId", &self.storage_pool_id)?;
        }
        if self.storage_pool.is_some() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateStoragePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateStoragePoolRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("storage_pool_id", &self.storage_pool_id);
        debug_struct.field("storage_pool", &self.storage_pool);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateStoragePoolRequest updates a Storage Pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateStoragePoolRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// StoragePool resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The pool being updated
    pub storage_pool: std::option::Option<crate::model::StoragePool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateStoragePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateStoragePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_pool][crate::model::UpdateStoragePoolRequest::storage_pool].
    pub fn set_storage_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StoragePool>,
    {
        self.storage_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_pool][crate::model::UpdateStoragePoolRequest::storage_pool].
    pub fn set_or_clear_storage_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StoragePool>,
    {
        self.storage_pool = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateStoragePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateStoragePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __storage_pool,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateStoragePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "storagePool" => Ok(__FieldTag::__storage_pool),
                            "storage_pool" => Ok(__FieldTag::__storage_pool),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateStoragePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateStoragePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__storage_pool => {
                            if !fields.insert(__FieldTag::__storage_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pool",
                                ));
                            }
                            result.storage_pool =
                                map.next_value::<std::option::Option<crate::model::StoragePool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateStoragePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.storage_pool.is_some() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateStoragePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateStoragePoolRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("storage_pool", &self.storage_pool);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteStoragePoolRequest deletes a Storage Pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteStoragePoolRequest {
    /// Required. Name of the storage pool
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStoragePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteStoragePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteStoragePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteStoragePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteStoragePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteStoragePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteStoragePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteStoragePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteStoragePoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SwitchActiveReplicaZoneRequest switch the active/replica zone for a regional
/// storagePool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SwitchActiveReplicaZoneRequest {
    /// Required. Name of the storage pool
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SwitchActiveReplicaZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SwitchActiveReplicaZoneRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SwitchActiveReplicaZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SwitchActiveReplicaZoneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SwitchActiveReplicaZoneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SwitchActiveReplicaZoneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SwitchActiveReplicaZoneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SwitchActiveReplicaZoneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SwitchActiveReplicaZoneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SwitchActiveReplicaZoneRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SwitchActiveReplicaZoneRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// StoragePool is a container for volumes with a service level and capacity.
/// Volumes can be created in a pool of sufficient available capacity.
/// StoragePool capacity is what you are billed for.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StoragePool {
    /// Identifier. Name of the storage pool
    pub name: std::string::String,

    /// Required. Service level of the storage pool
    pub service_level: crate::model::ServiceLevel,

    /// Required. Capacity in GIB of the pool
    pub capacity_gib: i64,

    /// Output only. Allocated size of all volumes in GIB in the storage pool
    pub volume_capacity_gib: i64,

    /// Output only. Volume count of the storage pool
    pub volume_count: i32,

    /// Output only. State of the storage pool
    pub state: crate::model::storage_pool::State,

    /// Output only. State details of the storage pool
    pub state_details: std::string::String,

    /// Output only. Create time of the storage pool
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the storage pool
    pub description: std::string::String,

    /// Optional. Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. VPC Network name.
    /// Format: projects/{project}/global/networks/{network}
    pub network: std::string::String,

    /// Optional. Specifies the Active Directory to be used for creating a SMB
    /// volume.
    pub active_directory: std::string::String,

    /// Optional. Specifies the KMS config to be used for volume encryption.
    pub kms_config: std::string::String,

    /// Optional. Flag indicating if the pool is NFS LDAP enabled or not.
    pub ldap_enabled: bool,

    /// Optional. This field is not implemented. The values provided in this field
    /// are ignored.
    pub psa_range: std::string::String,

    /// Output only. Specifies the current pool encryption key source.
    pub encryption_type: crate::model::EncryptionType,

    /// Deprecated. Used to allow SO pool to access AD or DNS server from other
    /// regions.
    #[deprecated]
    pub global_access_allowed: std::option::Option<bool>,

    /// Optional. True if the storage pool supports Auto Tiering enabled volumes.
    /// Default is false. Auto-tiering can be enabled after storage pool creation
    /// but it can't be disabled once enabled.
    pub allow_auto_tiering: bool,

    /// Optional. Specifies the replica zone for regional storagePool.
    pub replica_zone: std::string::String,

    /// Optional. Specifies the active zone for regional storagePool.
    pub zone: std::string::String,

    /// Output only. Reserved for future use
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use
    pub satisfies_pzi: bool,

    /// Optional. True if using Independent Scaling of capacity and performance
    /// (Hyperdisk) By default set to false
    pub custom_performance_enabled: bool,

    /// Optional. Custom Performance Total Throughput of the pool (in MiBps)
    pub total_throughput_mibps: i64,

    /// Optional. Custom Performance Total IOPS of the pool
    /// if not provided, it will be calculated based on the total_throughput_mibps
    pub total_iops: i64,

    /// Optional. Total hot tier capacity for the Storage Pool. It is applicable
    /// only to Flex service level. It should be less than the minimum storage pool
    /// size and cannot be more than the current storage pool size. It cannot be
    /// decreased once set.
    pub hot_tier_size_gib: i64,

    /// Optional. Flag indicating that the hot-tier threshold will be
    /// auto-increased by 10% of the hot-tier when it hits 100%. Default is true.
    /// The increment will kick in only if the new size after increment is
    /// still less than or equal to storage pool size.
    pub enable_hot_tier_auto_resize: std::option::Option<bool>,

    /// Optional. QoS (Quality of Service) Type of the storage pool
    pub qos_type: crate::model::QosType,

    /// Output only. Available throughput of the storage pool (in MiB/s).
    pub available_throughput_mibps: f64,

    /// Output only. Total cold tier data rounded down to the nearest GiB used by
    /// the storage pool.
    pub cold_tier_size_used_gib: i64,

    /// Output only. Total hot tier data rounded down to the nearest GiB used by
    /// the storage pool.
    pub hot_tier_size_used_gib: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoragePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoragePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service_level][crate::model::StoragePool::service_level].
    pub fn set_service_level<T: std::convert::Into<crate::model::ServiceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_level = v.into();
        self
    }

    /// Sets the value of [capacity_gib][crate::model::StoragePool::capacity_gib].
    pub fn set_capacity_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gib = v.into();
        self
    }

    /// Sets the value of [volume_capacity_gib][crate::model::StoragePool::volume_capacity_gib].
    pub fn set_volume_capacity_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.volume_capacity_gib = v.into();
        self
    }

    /// Sets the value of [volume_count][crate::model::StoragePool::volume_count].
    pub fn set_volume_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.volume_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::StoragePool::state].
    pub fn set_state<T: std::convert::Into<crate::model::storage_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::StoragePool::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoragePool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::StoragePool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::StoragePool::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::StoragePool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network][crate::model::StoragePool::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::StoragePool::active_directory].
    pub fn set_active_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory = v.into();
        self
    }

    /// Sets the value of [kms_config][crate::model::StoragePool::kms_config].
    pub fn set_kms_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_config = v.into();
        self
    }

    /// Sets the value of [ldap_enabled][crate::model::StoragePool::ldap_enabled].
    pub fn set_ldap_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ldap_enabled = v.into();
        self
    }

    /// Sets the value of [psa_range][crate::model::StoragePool::psa_range].
    pub fn set_psa_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.psa_range = v.into();
        self
    }

    /// Sets the value of [encryption_type][crate::model::StoragePool::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::EncryptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [global_access_allowed][crate::model::StoragePool::global_access_allowed].
    #[deprecated]
    pub fn set_global_access_allowed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.global_access_allowed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [global_access_allowed][crate::model::StoragePool::global_access_allowed].
    #[deprecated]
    pub fn set_or_clear_global_access_allowed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.global_access_allowed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_auto_tiering][crate::model::StoragePool::allow_auto_tiering].
    pub fn set_allow_auto_tiering<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_auto_tiering = v.into();
        self
    }

    /// Sets the value of [replica_zone][crate::model::StoragePool::replica_zone].
    pub fn set_replica_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replica_zone = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::StoragePool::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::StoragePool::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::StoragePool::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [custom_performance_enabled][crate::model::StoragePool::custom_performance_enabled].
    pub fn set_custom_performance_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.custom_performance_enabled = v.into();
        self
    }

    /// Sets the value of [total_throughput_mibps][crate::model::StoragePool::total_throughput_mibps].
    pub fn set_total_throughput_mibps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_throughput_mibps = v.into();
        self
    }

    /// Sets the value of [total_iops][crate::model::StoragePool::total_iops].
    pub fn set_total_iops<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_iops = v.into();
        self
    }

    /// Sets the value of [hot_tier_size_gib][crate::model::StoragePool::hot_tier_size_gib].
    pub fn set_hot_tier_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.hot_tier_size_gib = v.into();
        self
    }

    /// Sets the value of [enable_hot_tier_auto_resize][crate::model::StoragePool::enable_hot_tier_auto_resize].
    pub fn set_enable_hot_tier_auto_resize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_hot_tier_auto_resize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_hot_tier_auto_resize][crate::model::StoragePool::enable_hot_tier_auto_resize].
    pub fn set_or_clear_enable_hot_tier_auto_resize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_hot_tier_auto_resize = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qos_type][crate::model::StoragePool::qos_type].
    pub fn set_qos_type<T: std::convert::Into<crate::model::QosType>>(mut self, v: T) -> Self {
        self.qos_type = v.into();
        self
    }

    /// Sets the value of [available_throughput_mibps][crate::model::StoragePool::available_throughput_mibps].
    pub fn set_available_throughput_mibps<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.available_throughput_mibps = v.into();
        self
    }

    /// Sets the value of [cold_tier_size_used_gib][crate::model::StoragePool::cold_tier_size_used_gib].
    pub fn set_cold_tier_size_used_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cold_tier_size_used_gib = v.into();
        self
    }

    /// Sets the value of [hot_tier_size_used_gib][crate::model::StoragePool::hot_tier_size_used_gib].
    pub fn set_hot_tier_size_used_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.hot_tier_size_used_gib = v.into();
        self
    }
}

impl wkt::message::Message for StoragePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.StoragePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoragePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __service_level,
            __capacity_gib,
            __volume_capacity_gib,
            __volume_count,
            __state,
            __state_details,
            __create_time,
            __description,
            __labels,
            __network,
            __active_directory,
            __kms_config,
            __ldap_enabled,
            __psa_range,
            __encryption_type,
            __global_access_allowed,
            __allow_auto_tiering,
            __replica_zone,
            __zone,
            __satisfies_pzs,
            __satisfies_pzi,
            __custom_performance_enabled,
            __total_throughput_mibps,
            __total_iops,
            __hot_tier_size_gib,
            __enable_hot_tier_auto_resize,
            __qos_type,
            __available_throughput_mibps,
            __cold_tier_size_used_gib,
            __hot_tier_size_used_gib,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoragePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "serviceLevel" => Ok(__FieldTag::__service_level),
                            "service_level" => Ok(__FieldTag::__service_level),
                            "capacityGib" => Ok(__FieldTag::__capacity_gib),
                            "capacity_gib" => Ok(__FieldTag::__capacity_gib),
                            "volumeCapacityGib" => Ok(__FieldTag::__volume_capacity_gib),
                            "volume_capacity_gib" => Ok(__FieldTag::__volume_capacity_gib),
                            "volumeCount" => Ok(__FieldTag::__volume_count),
                            "volume_count" => Ok(__FieldTag::__volume_count),
                            "state" => Ok(__FieldTag::__state),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "network" => Ok(__FieldTag::__network),
                            "activeDirectory" => Ok(__FieldTag::__active_directory),
                            "active_directory" => Ok(__FieldTag::__active_directory),
                            "kmsConfig" => Ok(__FieldTag::__kms_config),
                            "kms_config" => Ok(__FieldTag::__kms_config),
                            "ldapEnabled" => Ok(__FieldTag::__ldap_enabled),
                            "ldap_enabled" => Ok(__FieldTag::__ldap_enabled),
                            "psaRange" => Ok(__FieldTag::__psa_range),
                            "psa_range" => Ok(__FieldTag::__psa_range),
                            "encryptionType" => Ok(__FieldTag::__encryption_type),
                            "encryption_type" => Ok(__FieldTag::__encryption_type),
                            "globalAccessAllowed" => Ok(__FieldTag::__global_access_allowed),
                            "global_access_allowed" => Ok(__FieldTag::__global_access_allowed),
                            "allowAutoTiering" => Ok(__FieldTag::__allow_auto_tiering),
                            "allow_auto_tiering" => Ok(__FieldTag::__allow_auto_tiering),
                            "replicaZone" => Ok(__FieldTag::__replica_zone),
                            "replica_zone" => Ok(__FieldTag::__replica_zone),
                            "zone" => Ok(__FieldTag::__zone),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "customPerformanceEnabled" => {
                                Ok(__FieldTag::__custom_performance_enabled)
                            }
                            "custom_performance_enabled" => {
                                Ok(__FieldTag::__custom_performance_enabled)
                            }
                            "totalThroughputMibps" => Ok(__FieldTag::__total_throughput_mibps),
                            "total_throughput_mibps" => Ok(__FieldTag::__total_throughput_mibps),
                            "totalIops" => Ok(__FieldTag::__total_iops),
                            "total_iops" => Ok(__FieldTag::__total_iops),
                            "hotTierSizeGib" => Ok(__FieldTag::__hot_tier_size_gib),
                            "hot_tier_size_gib" => Ok(__FieldTag::__hot_tier_size_gib),
                            "enableHotTierAutoResize" => {
                                Ok(__FieldTag::__enable_hot_tier_auto_resize)
                            }
                            "enable_hot_tier_auto_resize" => {
                                Ok(__FieldTag::__enable_hot_tier_auto_resize)
                            }
                            "qosType" => Ok(__FieldTag::__qos_type),
                            "qos_type" => Ok(__FieldTag::__qos_type),
                            "availableThroughputMibps" => {
                                Ok(__FieldTag::__available_throughput_mibps)
                            }
                            "available_throughput_mibps" => {
                                Ok(__FieldTag::__available_throughput_mibps)
                            }
                            "coldTierSizeUsedGib" => Ok(__FieldTag::__cold_tier_size_used_gib),
                            "cold_tier_size_used_gib" => Ok(__FieldTag::__cold_tier_size_used_gib),
                            "hotTierSizeUsedGib" => Ok(__FieldTag::__hot_tier_size_used_gib),
                            "hot_tier_size_used_gib" => Ok(__FieldTag::__hot_tier_size_used_gib),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoragePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoragePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_level => {
                            if !fields.insert(__FieldTag::__service_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level",
                                ));
                            }
                            result.service_level = map
                                .next_value::<std::option::Option<crate::model::ServiceLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__capacity_gib => {
                            if !fields.insert(__FieldTag::__capacity_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.capacity_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_capacity_gib => {
                            if !fields.insert(__FieldTag::__volume_capacity_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_capacity_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_capacity_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_count => {
                            if !fields.insert(__FieldTag::__volume_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::storage_pool::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_directory => {
                            if !fields.insert(__FieldTag::__active_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directory",
                                ));
                            }
                            result.active_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_config => {
                            if !fields.insert(__FieldTag::__kms_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_config",
                                ));
                            }
                            result.kms_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ldap_enabled => {
                            if !fields.insert(__FieldTag::__ldap_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ldap_enabled",
                                ));
                            }
                            result.ldap_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psa_range => {
                            if !fields.insert(__FieldTag::__psa_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psa_range",
                                ));
                            }
                            result.psa_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_type => {
                            if !fields.insert(__FieldTag::__encryption_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_type",
                                ));
                            }
                            result.encryption_type = map
                                .next_value::<std::option::Option<crate::model::EncryptionType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__global_access_allowed => {
                            if !fields.insert(__FieldTag::__global_access_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_access_allowed",
                                ));
                            }
                            result.global_access_allowed =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__allow_auto_tiering => {
                            if !fields.insert(__FieldTag::__allow_auto_tiering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_auto_tiering",
                                ));
                            }
                            result.allow_auto_tiering = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_zone => {
                            if !fields.insert(__FieldTag::__replica_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_zone",
                                ));
                            }
                            result.replica_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_performance_enabled => {
                            if !fields.insert(__FieldTag::__custom_performance_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_performance_enabled",
                                ));
                            }
                            result.custom_performance_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_throughput_mibps => {
                            if !fields.insert(__FieldTag::__total_throughput_mibps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_throughput_mibps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_throughput_mibps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_iops => {
                            if !fields.insert(__FieldTag::__total_iops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_iops",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_iops = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hot_tier_size_gib => {
                            if !fields.insert(__FieldTag::__hot_tier_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_tier_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hot_tier_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_hot_tier_auto_resize => {
                            if !fields.insert(__FieldTag::__enable_hot_tier_auto_resize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_hot_tier_auto_resize",
                                ));
                            }
                            result.enable_hot_tier_auto_resize =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__qos_type => {
                            if !fields.insert(__FieldTag::__qos_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qos_type",
                                ));
                            }
                            result.qos_type = map
                                .next_value::<std::option::Option<crate::model::QosType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_throughput_mibps => {
                            if !fields.insert(__FieldTag::__available_throughput_mibps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_throughput_mibps",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_throughput_mibps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cold_tier_size_used_gib => {
                            if !fields.insert(__FieldTag::__cold_tier_size_used_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cold_tier_size_used_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cold_tier_size_used_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hot_tier_size_used_gib => {
                            if !fields.insert(__FieldTag::__hot_tier_size_used_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_tier_size_used_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hot_tier_size_used_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoragePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.service_level) {
            state.serialize_entry("serviceLevel", &self.service_level)?;
        }
        if !wkt::internal::is_default(&self.capacity_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("capacityGib", &__With(&self.capacity_gib))?;
        }
        if !wkt::internal::is_default(&self.volume_capacity_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeCapacityGib", &__With(&self.volume_capacity_gib))?;
        }
        if !wkt::internal::is_default(&self.volume_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeCount", &__With(&self.volume_count))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.active_directory.is_empty() {
            state.serialize_entry("activeDirectory", &self.active_directory)?;
        }
        if !self.kms_config.is_empty() {
            state.serialize_entry("kmsConfig", &self.kms_config)?;
        }
        if !wkt::internal::is_default(&self.ldap_enabled) {
            state.serialize_entry("ldapEnabled", &self.ldap_enabled)?;
        }
        if !self.psa_range.is_empty() {
            state.serialize_entry("psaRange", &self.psa_range)?;
        }
        if !wkt::internal::is_default(&self.encryption_type) {
            state.serialize_entry("encryptionType", &self.encryption_type)?;
        }
        if self.global_access_allowed.is_some() {
            state.serialize_entry("globalAccessAllowed", &self.global_access_allowed)?;
        }
        if !wkt::internal::is_default(&self.allow_auto_tiering) {
            state.serialize_entry("allowAutoTiering", &self.allow_auto_tiering)?;
        }
        if !self.replica_zone.is_empty() {
            state.serialize_entry("replicaZone", &self.replica_zone)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !wkt::internal::is_default(&self.custom_performance_enabled) {
            state.serialize_entry("customPerformanceEnabled", &self.custom_performance_enabled)?;
        }
        if !wkt::internal::is_default(&self.total_throughput_mibps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalThroughputMibps",
                &__With(&self.total_throughput_mibps),
            )?;
        }
        if !wkt::internal::is_default(&self.total_iops) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalIops", &__With(&self.total_iops))?;
        }
        if !wkt::internal::is_default(&self.hot_tier_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hotTierSizeGib", &__With(&self.hot_tier_size_gib))?;
        }
        if self.enable_hot_tier_auto_resize.is_some() {
            state.serialize_entry("enableHotTierAutoResize", &self.enable_hot_tier_auto_resize)?;
        }
        if !wkt::internal::is_default(&self.qos_type) {
            state.serialize_entry("qosType", &self.qos_type)?;
        }
        if !wkt::internal::is_default(&self.available_throughput_mibps) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableThroughputMibps",
                &__With(&self.available_throughput_mibps),
            )?;
        }
        if !wkt::internal::is_default(&self.cold_tier_size_used_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "coldTierSizeUsedGib",
                &__With(&self.cold_tier_size_used_gib),
            )?;
        }
        if !wkt::internal::is_default(&self.hot_tier_size_used_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hotTierSizeUsedGib", &__With(&self.hot_tier_size_used_gib))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StoragePool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StoragePool");
        debug_struct.field("name", &self.name);
        debug_struct.field("service_level", &self.service_level);
        debug_struct.field("capacity_gib", &self.capacity_gib);
        debug_struct.field("volume_capacity_gib", &self.volume_capacity_gib);
        debug_struct.field("volume_count", &self.volume_count);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_details", &self.state_details);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("network", &self.network);
        debug_struct.field("active_directory", &self.active_directory);
        debug_struct.field("kms_config", &self.kms_config);
        debug_struct.field("ldap_enabled", &self.ldap_enabled);
        debug_struct.field("psa_range", &self.psa_range);
        debug_struct.field("encryption_type", &self.encryption_type);
        debug_struct.field("global_access_allowed", &self.global_access_allowed);
        debug_struct.field("allow_auto_tiering", &self.allow_auto_tiering);
        debug_struct.field("replica_zone", &self.replica_zone);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field(
            "custom_performance_enabled",
            &self.custom_performance_enabled,
        );
        debug_struct.field("total_throughput_mibps", &self.total_throughput_mibps);
        debug_struct.field("total_iops", &self.total_iops);
        debug_struct.field("hot_tier_size_gib", &self.hot_tier_size_gib);
        debug_struct.field(
            "enable_hot_tier_auto_resize",
            &self.enable_hot_tier_auto_resize,
        );
        debug_struct.field("qos_type", &self.qos_type);
        debug_struct.field(
            "available_throughput_mibps",
            &self.available_throughput_mibps,
        );
        debug_struct.field("cold_tier_size_used_gib", &self.cold_tier_size_used_gib);
        debug_struct.field("hot_tier_size_used_gib", &self.hot_tier_size_used_gib);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [StoragePool].
pub mod storage_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The Storage Pool States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Storage Pool State
        Unspecified,
        /// Storage Pool State is Ready
        Ready,
        /// Storage Pool State is Creating
        Creating,
        /// Storage Pool State is Deleting
        Deleting,
        /// Storage Pool State is Updating
        Updating,
        /// Storage Pool State is Restoring
        Restoring,
        /// Storage Pool State is Disabled
        Disabled,
        /// Storage Pool State is Error
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Restoring => std::option::Option::Some(5),
                Self::Disabled => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Restoring => std::option::Option::Some("RESTORING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::Restoring,
                6 => Self::Disabled,
                7 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "RESTORING" => Self::Restoring,
                "DISABLED" => Self::Disabled,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Restoring => serializer.serialize_i32(5),
                Self::Disabled => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.StoragePool.State",
            ))
        }
    }
}

/// ValidateDirectoryServiceRequest validates the directory service policy
/// attached to the storage pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateDirectoryServiceRequest {
    /// Required. Name of the storage pool
    pub name: std::string::String,

    /// Type of directory service policy attached to the storage pool.
    pub directory_service_type: crate::model::DirectoryServiceType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateDirectoryServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateDirectoryServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [directory_service_type][crate::model::ValidateDirectoryServiceRequest::directory_service_type].
    pub fn set_directory_service_type<T: std::convert::Into<crate::model::DirectoryServiceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.directory_service_type = v.into();
        self
    }
}

impl wkt::message::Message for ValidateDirectoryServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ValidateDirectoryServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateDirectoryServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __directory_service_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateDirectoryServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "directoryServiceType" => Ok(__FieldTag::__directory_service_type),
                            "directory_service_type" => Ok(__FieldTag::__directory_service_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateDirectoryServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateDirectoryServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__directory_service_type => {
                            if !fields.insert(__FieldTag::__directory_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directory_service_type",
                                ));
                            }
                            result.directory_service_type = map.next_value::<std::option::Option<crate::model::DirectoryServiceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateDirectoryServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.directory_service_type) {
            state.serialize_entry("directoryServiceType", &self.directory_service_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidateDirectoryServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateDirectoryServiceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("directory_service_type", &self.directory_service_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for requesting list of Volumes
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumesRequest {
    /// Required. Parent value for ListVolumesRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVolumesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListVolumesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVolumesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVolumesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing Volumes
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumesResponse {
    /// The list of Volume
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volumes][crate::model::ListVolumesResponse::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListVolumesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumesResponse {
    type PageItem = crate::model::Volume;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volumes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volumes,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumes" => Ok(__FieldTag::__volumes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVolumesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVolumesResponse");
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a Volume
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeRequest {
    /// Required. Name of the volume
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVolumeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVolumeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating a Volume
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVolumeRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. Id of the requesting volume. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a number,
    /// and a 63 character maximum.
    pub volume_id: std::string::String,

    /// Required. The volume being created.
    pub volume: std::option::Option<crate::model::Volume>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVolumeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [volume_id][crate::model::CreateVolumeRequest::volume_id].
    pub fn set_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_id = v.into();
        self
    }

    /// Sets the value of [volume][crate::model::CreateVolumeRequest::volume].
    pub fn set_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [volume][crate::model::CreateVolumeRequest::volume].
    pub fn set_or_clear_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __volume_id,
            __volume,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "volumeId" => Ok(__FieldTag::__volume_id),
                            "volume_id" => Ok(__FieldTag::__volume_id),
                            "volume" => Ok(__FieldTag::__volume),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_id => {
                            if !fields.insert(__FieldTag::__volume_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_id",
                                ));
                            }
                            result.volume_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume => {
                            if !fields.insert(__FieldTag::__volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume",
                                ));
                            }
                            result.volume =
                                map.next_value::<std::option::Option<crate::model::Volume>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.volume_id.is_empty() {
            state.serialize_entry("volumeId", &self.volume_id)?;
        }
        if self.volume.is_some() {
            state.serialize_entry("volume", &self.volume)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVolumeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVolumeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("volume_id", &self.volume_id);
        debug_struct.field("volume", &self.volume);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for updating a Volume
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVolumeRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Volume resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The volume being updated
    pub volume: std::option::Option<crate::model::Volume>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_volume<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_or_clear_volume<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Volume>,
    {
        self.volume = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __volume,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "volume" => Ok(__FieldTag::__volume),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__volume => {
                            if !fields.insert(__FieldTag::__volume) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume",
                                ));
                            }
                            result.volume =
                                map.next_value::<std::option::Option<crate::model::Volume>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.volume.is_some() {
            state.serialize_entry("volume", &self.volume)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateVolumeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateVolumeRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("volume", &self.volume);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for deleting a Volume
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVolumeRequest {
    /// Required. Name of the volume
    pub name: std::string::String,

    /// If this field is set as true, CCFE will not block the volume resource
    /// deletion even if it has any snapshots resource. (Otherwise, the request
    /// will only work if the volume has no snapshots.)
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteVolumeRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteVolumeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVolumeRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RevertVolumeRequest reverts the given volume to the specified snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RevertVolumeRequest {
    /// Required. The resource name of the volume, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}.
    pub name: std::string::String,

    /// Required. The snapshot resource ID, in the format 'my-snapshot', where the
    /// specified ID is the {snapshot_id} of the fully qualified name like
    /// projects/{project_id}/locations/{location_id}/volumes/{volume_id}/snapshots/{snapshot_id}
    pub snapshot_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevertVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevertVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::RevertVolumeRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for RevertVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.RevertVolumeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RevertVolumeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __snapshot_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevertVolumeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "snapshotId" => Ok(__FieldTag::__snapshot_id),
                            "snapshot_id" => Ok(__FieldTag::__snapshot_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RevertVolumeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevertVolumeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_id => {
                            if !fields.insert(__FieldTag::__snapshot_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_id",
                                ));
                            }
                            result.snapshot_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RevertVolumeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.snapshot_id.is_empty() {
            state.serialize_entry("snapshotId", &self.snapshot_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RevertVolumeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RevertVolumeRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("snapshot_id", &self.snapshot_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Volume provides a filesystem that you can mount.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Volume {
    /// Identifier. Name of the volume
    pub name: std::string::String,

    /// Output only. State of the volume
    pub state: crate::model::volume::State,

    /// Output only. State details of the volume
    pub state_details: std::string::String,

    /// Output only. Create time of the volume
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Share name of the volume
    pub share_name: std::string::String,

    /// Output only. This field is not implemented. The values provided in this
    /// field are ignored.
    pub psa_range: std::string::String,

    /// Required. StoragePool name of the volume
    pub storage_pool: std::string::String,

    /// Output only. VPC Network name.
    /// Format: projects/{project}/global/networks/{network}
    pub network: std::string::String,

    /// Output only. Service level of the volume
    pub service_level: crate::model::ServiceLevel,

    /// Required. Capacity in GIB of the volume
    pub capacity_gib: i64,

    /// Optional. Export policy of the volume
    pub export_policy: std::option::Option<crate::model::ExportPolicy>,

    /// Required. Protocols required for the volume
    pub protocols: std::vec::Vec<crate::model::Protocols>,

    /// Optional. SMB share settings for the volume.
    pub smb_settings: std::vec::Vec<crate::model::SMBSettings>,

    /// Output only. Mount options of this volume
    pub mount_options: std::vec::Vec<crate::model::MountOption>,

    /// Optional. Default unix style permission (e.g. 777) the mount point will be
    /// created with. Applicable for NFS protocol types only.
    pub unix_permissions: std::string::String,

    /// Optional. Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the volume
    pub description: std::string::String,

    /// Optional. SnapshotPolicy for a volume.
    pub snapshot_policy: std::option::Option<crate::model::SnapshotPolicy>,

    /// Optional. Snap_reserve specifies percentage of volume storage reserved for
    /// snapshot storage. Default is 0 percent.
    pub snap_reserve: f64,

    /// Optional. Snapshot_directory if enabled (true) the volume will contain a
    /// read-only .snapshot directory which provides access to each of the volume's
    /// snapshots.
    pub snapshot_directory: bool,

    /// Output only. Used capacity in GIB of the volume. This is computed
    /// periodically and it does not represent the realtime usage.
    pub used_gib: i64,

    /// Optional. Security Style of the Volume
    pub security_style: crate::model::SecurityStyle,

    /// Optional. Flag indicating if the volume is a kerberos volume or not, export
    /// policy rules control kerberos security modes (krb5, krb5i, krb5p).
    pub kerberos_enabled: bool,

    /// Output only. Flag indicating if the volume is NFS LDAP enabled or not.
    pub ldap_enabled: bool,

    /// Output only. Specifies the ActiveDirectory name of a SMB volume.
    pub active_directory: std::string::String,

    /// Optional. Specifies the source of the volume to be created from.
    pub restore_parameters: std::option::Option<crate::model::RestoreParameters>,

    /// Output only. Specifies the KMS config to be used for volume encryption.
    pub kms_config: std::string::String,

    /// Output only. Specified the current volume encryption key source.
    pub encryption_type: crate::model::EncryptionType,

    /// Output only. Indicates whether the volume is part of a replication
    /// relationship.
    pub has_replication: bool,

    /// BackupConfig of the volume.
    pub backup_config: std::option::Option<crate::model::BackupConfig>,

    /// Optional. List of actions that are restricted on this volume.
    pub restricted_actions: std::vec::Vec<crate::model::RestrictedAction>,

    /// Optional. Flag indicating if the volume will be a large capacity volume or
    /// a regular volume.
    pub large_capacity: bool,

    /// Optional. Flag indicating if the volume will have an IP address per node
    /// for volumes supporting multiple IP endpoints. Only the volume with
    /// large_capacity will be allowed to have multiple endpoints.
    pub multiple_endpoints: bool,

    /// Tiering policy for the volume.
    pub tiering_policy: std::option::Option<crate::model::TieringPolicy>,

    /// Output only. Specifies the replica zone for regional volume.
    pub replica_zone: std::string::String,

    /// Output only. Specifies the active zone for regional volume.
    pub zone: std::string::String,

    /// Output only. Size of the volume cold tier data rounded down to the nearest
    /// GiB.
    pub cold_tier_size_gib: i64,

    /// Optional. The Hybrid Replication parameters for the volume.
    pub hybrid_replication_parameters:
        std::option::Option<crate::model::HybridReplicationParameters>,

    /// Optional. Throughput of the volume (in MiB/s)
    pub throughput_mibps: f64,

    /// Output only. Total hot tier data rounded down to the nearest GiB used by
    /// the Volume. This field is only used for flex Service Level
    pub hot_tier_size_used_gib: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Volume::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::Volume::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Volume::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Volume::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [share_name][crate::model::Volume::share_name].
    pub fn set_share_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.share_name = v.into();
        self
    }

    /// Sets the value of [psa_range][crate::model::Volume::psa_range].
    pub fn set_psa_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.psa_range = v.into();
        self
    }

    /// Sets the value of [storage_pool][crate::model::Volume::storage_pool].
    pub fn set_storage_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Volume::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_level][crate::model::Volume::service_level].
    pub fn set_service_level<T: std::convert::Into<crate::model::ServiceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_level = v.into();
        self
    }

    /// Sets the value of [capacity_gib][crate::model::Volume::capacity_gib].
    pub fn set_capacity_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gib = v.into();
        self
    }

    /// Sets the value of [export_policy][crate::model::Volume::export_policy].
    pub fn set_export_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExportPolicy>,
    {
        self.export_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_policy][crate::model::Volume::export_policy].
    pub fn set_or_clear_export_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExportPolicy>,
    {
        self.export_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [protocols][crate::model::Volume::protocols].
    pub fn set_protocols<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Protocols>,
    {
        use std::iter::Iterator;
        self.protocols = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [smb_settings][crate::model::Volume::smb_settings].
    pub fn set_smb_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SMBSettings>,
    {
        use std::iter::Iterator;
        self.smb_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mount_options][crate::model::Volume::mount_options].
    pub fn set_mount_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MountOption>,
    {
        use std::iter::Iterator;
        self.mount_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unix_permissions][crate::model::Volume::unix_permissions].
    pub fn set_unix_permissions<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.unix_permissions = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Volume::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Volume::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [snapshot_policy][crate::model::Volume::snapshot_policy].
    pub fn set_snapshot_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SnapshotPolicy>,
    {
        self.snapshot_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_policy][crate::model::Volume::snapshot_policy].
    pub fn set_or_clear_snapshot_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SnapshotPolicy>,
    {
        self.snapshot_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snap_reserve][crate::model::Volume::snap_reserve].
    pub fn set_snap_reserve<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.snap_reserve = v.into();
        self
    }

    /// Sets the value of [snapshot_directory][crate::model::Volume::snapshot_directory].
    pub fn set_snapshot_directory<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshot_directory = v.into();
        self
    }

    /// Sets the value of [used_gib][crate::model::Volume::used_gib].
    pub fn set_used_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.used_gib = v.into();
        self
    }

    /// Sets the value of [security_style][crate::model::Volume::security_style].
    pub fn set_security_style<T: std::convert::Into<crate::model::SecurityStyle>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_style = v.into();
        self
    }

    /// Sets the value of [kerberos_enabled][crate::model::Volume::kerberos_enabled].
    pub fn set_kerberos_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.kerberos_enabled = v.into();
        self
    }

    /// Sets the value of [ldap_enabled][crate::model::Volume::ldap_enabled].
    pub fn set_ldap_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ldap_enabled = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::Volume::active_directory].
    pub fn set_active_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory = v.into();
        self
    }

    /// Sets the value of [restore_parameters][crate::model::Volume::restore_parameters].
    pub fn set_restore_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreParameters>,
    {
        self.restore_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_parameters][crate::model::Volume::restore_parameters].
    pub fn set_or_clear_restore_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreParameters>,
    {
        self.restore_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_config][crate::model::Volume::kms_config].
    pub fn set_kms_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_config = v.into();
        self
    }

    /// Sets the value of [encryption_type][crate::model::Volume::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::EncryptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [has_replication][crate::model::Volume::has_replication].
    pub fn set_has_replication<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_replication = v.into();
        self
    }

    /// Sets the value of [backup_config][crate::model::Volume::backup_config].
    pub fn set_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupConfig>,
    {
        self.backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_config][crate::model::Volume::backup_config].
    pub fn set_or_clear_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupConfig>,
    {
        self.backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restricted_actions][crate::model::Volume::restricted_actions].
    pub fn set_restricted_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RestrictedAction>,
    {
        use std::iter::Iterator;
        self.restricted_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [large_capacity][crate::model::Volume::large_capacity].
    pub fn set_large_capacity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.large_capacity = v.into();
        self
    }

    /// Sets the value of [multiple_endpoints][crate::model::Volume::multiple_endpoints].
    pub fn set_multiple_endpoints<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multiple_endpoints = v.into();
        self
    }

    /// Sets the value of [tiering_policy][crate::model::Volume::tiering_policy].
    pub fn set_tiering_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TieringPolicy>,
    {
        self.tiering_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tiering_policy][crate::model::Volume::tiering_policy].
    pub fn set_or_clear_tiering_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TieringPolicy>,
    {
        self.tiering_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replica_zone][crate::model::Volume::replica_zone].
    pub fn set_replica_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replica_zone = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Volume::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cold_tier_size_gib][crate::model::Volume::cold_tier_size_gib].
    pub fn set_cold_tier_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cold_tier_size_gib = v.into();
        self
    }

    /// Sets the value of [hybrid_replication_parameters][crate::model::Volume::hybrid_replication_parameters].
    pub fn set_hybrid_replication_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HybridReplicationParameters>,
    {
        self.hybrid_replication_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hybrid_replication_parameters][crate::model::Volume::hybrid_replication_parameters].
    pub fn set_or_clear_hybrid_replication_parameters<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::HybridReplicationParameters>,
    {
        self.hybrid_replication_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [throughput_mibps][crate::model::Volume::throughput_mibps].
    pub fn set_throughput_mibps<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.throughput_mibps = v.into();
        self
    }

    /// Sets the value of [hot_tier_size_used_gib][crate::model::Volume::hot_tier_size_used_gib].
    pub fn set_hot_tier_size_used_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.hot_tier_size_used_gib = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Volume"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Volume {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __state_details,
            __create_time,
            __share_name,
            __psa_range,
            __storage_pool,
            __network,
            __service_level,
            __capacity_gib,
            __export_policy,
            __protocols,
            __smb_settings,
            __mount_options,
            __unix_permissions,
            __labels,
            __description,
            __snapshot_policy,
            __snap_reserve,
            __snapshot_directory,
            __used_gib,
            __security_style,
            __kerberos_enabled,
            __ldap_enabled,
            __active_directory,
            __restore_parameters,
            __kms_config,
            __encryption_type,
            __has_replication,
            __backup_config,
            __restricted_actions,
            __large_capacity,
            __multiple_endpoints,
            __tiering_policy,
            __replica_zone,
            __zone,
            __cold_tier_size_gib,
            __hybrid_replication_parameters,
            __throughput_mibps,
            __hot_tier_size_used_gib,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Volume")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateDetails" => Ok(__FieldTag::__state_details),
                            "state_details" => Ok(__FieldTag::__state_details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "shareName" => Ok(__FieldTag::__share_name),
                            "share_name" => Ok(__FieldTag::__share_name),
                            "psaRange" => Ok(__FieldTag::__psa_range),
                            "psa_range" => Ok(__FieldTag::__psa_range),
                            "storagePool" => Ok(__FieldTag::__storage_pool),
                            "storage_pool" => Ok(__FieldTag::__storage_pool),
                            "network" => Ok(__FieldTag::__network),
                            "serviceLevel" => Ok(__FieldTag::__service_level),
                            "service_level" => Ok(__FieldTag::__service_level),
                            "capacityGib" => Ok(__FieldTag::__capacity_gib),
                            "capacity_gib" => Ok(__FieldTag::__capacity_gib),
                            "exportPolicy" => Ok(__FieldTag::__export_policy),
                            "export_policy" => Ok(__FieldTag::__export_policy),
                            "protocols" => Ok(__FieldTag::__protocols),
                            "smbSettings" => Ok(__FieldTag::__smb_settings),
                            "smb_settings" => Ok(__FieldTag::__smb_settings),
                            "mountOptions" => Ok(__FieldTag::__mount_options),
                            "mount_options" => Ok(__FieldTag::__mount_options),
                            "unixPermissions" => Ok(__FieldTag::__unix_permissions),
                            "unix_permissions" => Ok(__FieldTag::__unix_permissions),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "snapshotPolicy" => Ok(__FieldTag::__snapshot_policy),
                            "snapshot_policy" => Ok(__FieldTag::__snapshot_policy),
                            "snapReserve" => Ok(__FieldTag::__snap_reserve),
                            "snap_reserve" => Ok(__FieldTag::__snap_reserve),
                            "snapshotDirectory" => Ok(__FieldTag::__snapshot_directory),
                            "snapshot_directory" => Ok(__FieldTag::__snapshot_directory),
                            "usedGib" => Ok(__FieldTag::__used_gib),
                            "used_gib" => Ok(__FieldTag::__used_gib),
                            "securityStyle" => Ok(__FieldTag::__security_style),
                            "security_style" => Ok(__FieldTag::__security_style),
                            "kerberosEnabled" => Ok(__FieldTag::__kerberos_enabled),
                            "kerberos_enabled" => Ok(__FieldTag::__kerberos_enabled),
                            "ldapEnabled" => Ok(__FieldTag::__ldap_enabled),
                            "ldap_enabled" => Ok(__FieldTag::__ldap_enabled),
                            "activeDirectory" => Ok(__FieldTag::__active_directory),
                            "active_directory" => Ok(__FieldTag::__active_directory),
                            "restoreParameters" => Ok(__FieldTag::__restore_parameters),
                            "restore_parameters" => Ok(__FieldTag::__restore_parameters),
                            "kmsConfig" => Ok(__FieldTag::__kms_config),
                            "kms_config" => Ok(__FieldTag::__kms_config),
                            "encryptionType" => Ok(__FieldTag::__encryption_type),
                            "encryption_type" => Ok(__FieldTag::__encryption_type),
                            "hasReplication" => Ok(__FieldTag::__has_replication),
                            "has_replication" => Ok(__FieldTag::__has_replication),
                            "backupConfig" => Ok(__FieldTag::__backup_config),
                            "backup_config" => Ok(__FieldTag::__backup_config),
                            "restrictedActions" => Ok(__FieldTag::__restricted_actions),
                            "restricted_actions" => Ok(__FieldTag::__restricted_actions),
                            "largeCapacity" => Ok(__FieldTag::__large_capacity),
                            "large_capacity" => Ok(__FieldTag::__large_capacity),
                            "multipleEndpoints" => Ok(__FieldTag::__multiple_endpoints),
                            "multiple_endpoints" => Ok(__FieldTag::__multiple_endpoints),
                            "tieringPolicy" => Ok(__FieldTag::__tiering_policy),
                            "tiering_policy" => Ok(__FieldTag::__tiering_policy),
                            "replicaZone" => Ok(__FieldTag::__replica_zone),
                            "replica_zone" => Ok(__FieldTag::__replica_zone),
                            "zone" => Ok(__FieldTag::__zone),
                            "coldTierSizeGib" => Ok(__FieldTag::__cold_tier_size_gib),
                            "cold_tier_size_gib" => Ok(__FieldTag::__cold_tier_size_gib),
                            "hybridReplicationParameters" => {
                                Ok(__FieldTag::__hybrid_replication_parameters)
                            }
                            "hybrid_replication_parameters" => {
                                Ok(__FieldTag::__hybrid_replication_parameters)
                            }
                            "throughputMibps" => Ok(__FieldTag::__throughput_mibps),
                            "throughput_mibps" => Ok(__FieldTag::__throughput_mibps),
                            "hotTierSizeUsedGib" => Ok(__FieldTag::__hot_tier_size_used_gib),
                            "hot_tier_size_used_gib" => Ok(__FieldTag::__hot_tier_size_used_gib),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Volume;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Volume")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::volume::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_details => {
                            if !fields.insert(__FieldTag::__state_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_details",
                                ));
                            }
                            result.state_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__share_name => {
                            if !fields.insert(__FieldTag::__share_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for share_name",
                                ));
                            }
                            result.share_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psa_range => {
                            if !fields.insert(__FieldTag::__psa_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psa_range",
                                ));
                            }
                            result.psa_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_pool => {
                            if !fields.insert(__FieldTag::__storage_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pool",
                                ));
                            }
                            result.storage_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_level => {
                            if !fields.insert(__FieldTag::__service_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_level",
                                ));
                            }
                            result.service_level = map
                                .next_value::<std::option::Option<crate::model::ServiceLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__capacity_gib => {
                            if !fields.insert(__FieldTag::__capacity_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacity_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.capacity_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__export_policy => {
                            if !fields.insert(__FieldTag::__export_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_policy",
                                ));
                            }
                            result.export_policy = map
                                .next_value::<std::option::Option<crate::model::ExportPolicy>>()?;
                        }
                        __FieldTag::__protocols => {
                            if !fields.insert(__FieldTag::__protocols) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocols",
                                ));
                            }
                            result.protocols = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Protocols>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__smb_settings => {
                            if !fields.insert(__FieldTag::__smb_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smb_settings",
                                ));
                            }
                            result.smb_settings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SMBSettings>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mount_options => {
                            if !fields.insert(__FieldTag::__mount_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mount_options",
                                ));
                            }
                            result.mount_options = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MountOption>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unix_permissions => {
                            if !fields.insert(__FieldTag::__unix_permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unix_permissions",
                                ));
                            }
                            result.unix_permissions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_policy => {
                            if !fields.insert(__FieldTag::__snapshot_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_policy",
                                ));
                            }
                            result.snapshot_policy = map
                                .next_value::<std::option::Option<crate::model::SnapshotPolicy>>(
                                )?;
                        }
                        __FieldTag::__snap_reserve => {
                            if !fields.insert(__FieldTag::__snap_reserve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snap_reserve",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.snap_reserve = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__snapshot_directory => {
                            if !fields.insert(__FieldTag::__snapshot_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_directory",
                                ));
                            }
                            result.snapshot_directory = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__used_gib => {
                            if !fields.insert(__FieldTag::__used_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.used_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__security_style => {
                            if !fields.insert(__FieldTag::__security_style) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_style",
                                ));
                            }
                            result.security_style = map
                                .next_value::<std::option::Option<crate::model::SecurityStyle>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kerberos_enabled => {
                            if !fields.insert(__FieldTag::__kerberos_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_enabled",
                                ));
                            }
                            result.kerberos_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ldap_enabled => {
                            if !fields.insert(__FieldTag::__ldap_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ldap_enabled",
                                ));
                            }
                            result.ldap_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_directory => {
                            if !fields.insert(__FieldTag::__active_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directory",
                                ));
                            }
                            result.active_directory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_parameters => {
                            if !fields.insert(__FieldTag::__restore_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_parameters",
                                ));
                            }
                            result.restore_parameters = map
                                .next_value::<std::option::Option<crate::model::RestoreParameters>>(
                                )?;
                        }
                        __FieldTag::__kms_config => {
                            if !fields.insert(__FieldTag::__kms_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_config",
                                ));
                            }
                            result.kms_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_type => {
                            if !fields.insert(__FieldTag::__encryption_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_type",
                                ));
                            }
                            result.encryption_type = map
                                .next_value::<std::option::Option<crate::model::EncryptionType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__has_replication => {
                            if !fields.insert(__FieldTag::__has_replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_replication",
                                ));
                            }
                            result.has_replication = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_config => {
                            if !fields.insert(__FieldTag::__backup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_config",
                                ));
                            }
                            result.backup_config = map
                                .next_value::<std::option::Option<crate::model::BackupConfig>>()?;
                        }
                        __FieldTag::__restricted_actions => {
                            if !fields.insert(__FieldTag::__restricted_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restricted_actions",
                                ));
                            }
                            result.restricted_actions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RestrictedAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__large_capacity => {
                            if !fields.insert(__FieldTag::__large_capacity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for large_capacity",
                                ));
                            }
                            result.large_capacity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multiple_endpoints => {
                            if !fields.insert(__FieldTag::__multiple_endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multiple_endpoints",
                                ));
                            }
                            result.multiple_endpoints = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tiering_policy => {
                            if !fields.insert(__FieldTag::__tiering_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tiering_policy",
                                ));
                            }
                            result.tiering_policy = map
                                .next_value::<std::option::Option<crate::model::TieringPolicy>>()?;
                        }
                        __FieldTag::__replica_zone => {
                            if !fields.insert(__FieldTag::__replica_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_zone",
                                ));
                            }
                            result.replica_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cold_tier_size_gib => {
                            if !fields.insert(__FieldTag::__cold_tier_size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cold_tier_size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cold_tier_size_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hybrid_replication_parameters => {
                            if !fields.insert(__FieldTag::__hybrid_replication_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_replication_parameters",
                                ));
                            }
                            result.hybrid_replication_parameters = map.next_value::<std::option::Option<crate::model::HybridReplicationParameters>>()?
                                ;
                        }
                        __FieldTag::__throughput_mibps => {
                            if !fields.insert(__FieldTag::__throughput_mibps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for throughput_mibps",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.throughput_mibps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hot_tier_size_used_gib => {
                            if !fields.insert(__FieldTag::__hot_tier_size_used_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_tier_size_used_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hot_tier_size_used_gib =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Volume {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_details.is_empty() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.share_name.is_empty() {
            state.serialize_entry("shareName", &self.share_name)?;
        }
        if !self.psa_range.is_empty() {
            state.serialize_entry("psaRange", &self.psa_range)?;
        }
        if !self.storage_pool.is_empty() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !wkt::internal::is_default(&self.service_level) {
            state.serialize_entry("serviceLevel", &self.service_level)?;
        }
        if !wkt::internal::is_default(&self.capacity_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("capacityGib", &__With(&self.capacity_gib))?;
        }
        if self.export_policy.is_some() {
            state.serialize_entry("exportPolicy", &self.export_policy)?;
        }
        if !self.protocols.is_empty() {
            state.serialize_entry("protocols", &self.protocols)?;
        }
        if !self.smb_settings.is_empty() {
            state.serialize_entry("smbSettings", &self.smb_settings)?;
        }
        if !self.mount_options.is_empty() {
            state.serialize_entry("mountOptions", &self.mount_options)?;
        }
        if !self.unix_permissions.is_empty() {
            state.serialize_entry("unixPermissions", &self.unix_permissions)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.snapshot_policy.is_some() {
            state.serialize_entry("snapshotPolicy", &self.snapshot_policy)?;
        }
        if !wkt::internal::is_default(&self.snap_reserve) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("snapReserve", &__With(&self.snap_reserve))?;
        }
        if !wkt::internal::is_default(&self.snapshot_directory) {
            state.serialize_entry("snapshotDirectory", &self.snapshot_directory)?;
        }
        if !wkt::internal::is_default(&self.used_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("usedGib", &__With(&self.used_gib))?;
        }
        if !wkt::internal::is_default(&self.security_style) {
            state.serialize_entry("securityStyle", &self.security_style)?;
        }
        if !wkt::internal::is_default(&self.kerberos_enabled) {
            state.serialize_entry("kerberosEnabled", &self.kerberos_enabled)?;
        }
        if !wkt::internal::is_default(&self.ldap_enabled) {
            state.serialize_entry("ldapEnabled", &self.ldap_enabled)?;
        }
        if !self.active_directory.is_empty() {
            state.serialize_entry("activeDirectory", &self.active_directory)?;
        }
        if self.restore_parameters.is_some() {
            state.serialize_entry("restoreParameters", &self.restore_parameters)?;
        }
        if !self.kms_config.is_empty() {
            state.serialize_entry("kmsConfig", &self.kms_config)?;
        }
        if !wkt::internal::is_default(&self.encryption_type) {
            state.serialize_entry("encryptionType", &self.encryption_type)?;
        }
        if !wkt::internal::is_default(&self.has_replication) {
            state.serialize_entry("hasReplication", &self.has_replication)?;
        }
        if self.backup_config.is_some() {
            state.serialize_entry("backupConfig", &self.backup_config)?;
        }
        if !self.restricted_actions.is_empty() {
            state.serialize_entry("restrictedActions", &self.restricted_actions)?;
        }
        if !wkt::internal::is_default(&self.large_capacity) {
            state.serialize_entry("largeCapacity", &self.large_capacity)?;
        }
        if !wkt::internal::is_default(&self.multiple_endpoints) {
            state.serialize_entry("multipleEndpoints", &self.multiple_endpoints)?;
        }
        if self.tiering_policy.is_some() {
            state.serialize_entry("tieringPolicy", &self.tiering_policy)?;
        }
        if !self.replica_zone.is_empty() {
            state.serialize_entry("replicaZone", &self.replica_zone)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.cold_tier_size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coldTierSizeGib", &__With(&self.cold_tier_size_gib))?;
        }
        if self.hybrid_replication_parameters.is_some() {
            state.serialize_entry(
                "hybridReplicationParameters",
                &self.hybrid_replication_parameters,
            )?;
        }
        if !wkt::internal::is_default(&self.throughput_mibps) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("throughputMibps", &__With(&self.throughput_mibps))?;
        }
        if !wkt::internal::is_default(&self.hot_tier_size_used_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hotTierSizeUsedGib", &__With(&self.hot_tier_size_used_gib))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Volume");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_details", &self.state_details);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("share_name", &self.share_name);
        debug_struct.field("psa_range", &self.psa_range);
        debug_struct.field("storage_pool", &self.storage_pool);
        debug_struct.field("network", &self.network);
        debug_struct.field("service_level", &self.service_level);
        debug_struct.field("capacity_gib", &self.capacity_gib);
        debug_struct.field("export_policy", &self.export_policy);
        debug_struct.field("protocols", &self.protocols);
        debug_struct.field("smb_settings", &self.smb_settings);
        debug_struct.field("mount_options", &self.mount_options);
        debug_struct.field("unix_permissions", &self.unix_permissions);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field("snapshot_policy", &self.snapshot_policy);
        debug_struct.field("snap_reserve", &self.snap_reserve);
        debug_struct.field("snapshot_directory", &self.snapshot_directory);
        debug_struct.field("used_gib", &self.used_gib);
        debug_struct.field("security_style", &self.security_style);
        debug_struct.field("kerberos_enabled", &self.kerberos_enabled);
        debug_struct.field("ldap_enabled", &self.ldap_enabled);
        debug_struct.field("active_directory", &self.active_directory);
        debug_struct.field("restore_parameters", &self.restore_parameters);
        debug_struct.field("kms_config", &self.kms_config);
        debug_struct.field("encryption_type", &self.encryption_type);
        debug_struct.field("has_replication", &self.has_replication);
        debug_struct.field("backup_config", &self.backup_config);
        debug_struct.field("restricted_actions", &self.restricted_actions);
        debug_struct.field("large_capacity", &self.large_capacity);
        debug_struct.field("multiple_endpoints", &self.multiple_endpoints);
        debug_struct.field("tiering_policy", &self.tiering_policy);
        debug_struct.field("replica_zone", &self.replica_zone);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cold_tier_size_gib", &self.cold_tier_size_gib);
        debug_struct.field(
            "hybrid_replication_parameters",
            &self.hybrid_replication_parameters,
        );
        debug_struct.field("throughput_mibps", &self.throughput_mibps);
        debug_struct.field("hot_tier_size_used_gib", &self.hot_tier_size_used_gib);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Volume].
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    /// The volume states
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Volume State
        Unspecified,
        /// Volume State is Ready
        Ready,
        /// Volume State is Creating
        Creating,
        /// Volume State is Deleting
        Deleting,
        /// Volume State is Updating
        Updating,
        /// Volume State is Restoring
        Restoring,
        /// Volume State is Disabled
        Disabled,
        /// Volume State is Error
        Error,
        /// Volume State is Preparing. Note that this is different from CREATING
        /// where CREATING means the volume is being created, while PREPARING means
        /// the volume is created and now being prepared for the replication.
        Preparing,
        /// Volume State is Read Only
        ReadOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Restoring => std::option::Option::Some(5),
                Self::Disabled => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::Preparing => std::option::Option::Some(8),
                Self::ReadOnly => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Restoring => std::option::Option::Some("RESTORING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Preparing => std::option::Option::Some("PREPARING"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::Restoring,
                6 => Self::Disabled,
                7 => Self::Error,
                8 => Self::Preparing,
                9 => Self::ReadOnly,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "RESTORING" => Self::Restoring,
                "DISABLED" => Self::Disabled,
                "ERROR" => Self::Error,
                "PREPARING" => Self::Preparing,
                "READ_ONLY" => Self::ReadOnly,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Restoring => serializer.serialize_i32(5),
                Self::Disabled => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::Preparing => serializer.serialize_i32(8),
                Self::ReadOnly => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Volume.State",
            ))
        }
    }
}

/// Defines the export policy for the volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportPolicy {
    /// Required. List of export policy rules
    pub rules: std::vec::Vec<crate::model::SimpleExportPolicyRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rules][crate::model::ExportPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SimpleExportPolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ExportPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rules" => Ok(__FieldTag::__rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SimpleExportPolicyRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportPolicy");
        debug_struct.field("rules", &self.rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An export policy rule describing various export options.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SimpleExportPolicyRule {
    /// Comma separated list of allowed clients IP addresses
    pub allowed_clients: std::option::Option<std::string::String>,

    /// Whether Unix root access will be granted.
    pub has_root_access: std::option::Option<std::string::String>,

    /// Access type (ReadWrite, ReadOnly, None)
    pub access_type: std::option::Option<crate::model::AccessType>,

    /// NFS V3 protocol.
    pub nfsv3: std::option::Option<bool>,

    /// NFS V4 protocol.
    pub nfsv4: std::option::Option<bool>,

    /// If enabled (true) the rule defines a read only access for clients matching
    /// the 'allowedClients' specification. It enables nfs clients to mount using
    /// 'authentication' kerberos security mode.
    pub kerberos_5_read_only: std::option::Option<bool>,

    /// If enabled (true) the rule defines read and write access for clients
    /// matching the 'allowedClients' specification. It enables nfs clients to
    /// mount using 'authentication' kerberos security mode. The
    /// 'kerberos5ReadOnly' value be ignored if this is enabled.
    pub kerberos_5_read_write: std::option::Option<bool>,

    /// If enabled (true) the rule defines a read only access for clients matching
    /// the 'allowedClients' specification. It enables nfs clients to mount using
    /// 'integrity' kerberos security mode.
    pub kerberos_5i_read_only: std::option::Option<bool>,

    /// If enabled (true) the rule defines read and write access for clients
    /// matching the 'allowedClients' specification. It enables nfs clients to
    /// mount using 'integrity' kerberos security mode. The 'kerberos5iReadOnly'
    /// value be ignored if this is enabled.
    pub kerberos_5i_read_write: std::option::Option<bool>,

    /// If enabled (true) the rule defines a read only access for clients matching
    /// the 'allowedClients' specification. It enables nfs clients to mount using
    /// 'privacy' kerberos security mode.
    pub kerberos_5p_read_only: std::option::Option<bool>,

    /// If enabled (true) the rule defines read and write access for clients
    /// matching the 'allowedClients' specification. It enables nfs clients to
    /// mount using 'privacy' kerberos security mode. The 'kerberos5pReadOnly'
    /// value be ignored if this is enabled.
    pub kerberos_5p_read_write: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SimpleExportPolicyRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_clients][crate::model::SimpleExportPolicyRule::allowed_clients].
    pub fn set_allowed_clients<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.allowed_clients = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allowed_clients][crate::model::SimpleExportPolicyRule::allowed_clients].
    pub fn set_or_clear_allowed_clients<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.allowed_clients = v.map(|x| x.into());
        self
    }

    /// Sets the value of [has_root_access][crate::model::SimpleExportPolicyRule::has_root_access].
    pub fn set_has_root_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.has_root_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [has_root_access][crate::model::SimpleExportPolicyRule::has_root_access].
    pub fn set_or_clear_has_root_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.has_root_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_type][crate::model::SimpleExportPolicyRule::access_type].
    pub fn set_access_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessType>,
    {
        self.access_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_type][crate::model::SimpleExportPolicyRule::access_type].
    pub fn set_or_clear_access_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessType>,
    {
        self.access_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nfsv3][crate::model::SimpleExportPolicyRule::nfsv3].
    pub fn set_nfsv3<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.nfsv3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfsv3][crate::model::SimpleExportPolicyRule::nfsv3].
    pub fn set_or_clear_nfsv3<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.nfsv3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nfsv4][crate::model::SimpleExportPolicyRule::nfsv4].
    pub fn set_nfsv4<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.nfsv4 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nfsv4][crate::model::SimpleExportPolicyRule::nfsv4].
    pub fn set_or_clear_nfsv4<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.nfsv4 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kerberos_5_read_only][crate::model::SimpleExportPolicyRule::kerberos_5_read_only].
    pub fn set_kerberos_5_read_only<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5_read_only = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_5_read_only][crate::model::SimpleExportPolicyRule::kerberos_5_read_only].
    pub fn set_or_clear_kerberos_5_read_only<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5_read_only = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kerberos_5_read_write][crate::model::SimpleExportPolicyRule::kerberos_5_read_write].
    pub fn set_kerberos_5_read_write<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5_read_write = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_5_read_write][crate::model::SimpleExportPolicyRule::kerberos_5_read_write].
    pub fn set_or_clear_kerberos_5_read_write<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5_read_write = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kerberos_5i_read_only][crate::model::SimpleExportPolicyRule::kerberos_5i_read_only].
    pub fn set_kerberos_5i_read_only<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5i_read_only = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_5i_read_only][crate::model::SimpleExportPolicyRule::kerberos_5i_read_only].
    pub fn set_or_clear_kerberos_5i_read_only<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5i_read_only = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kerberos_5i_read_write][crate::model::SimpleExportPolicyRule::kerberos_5i_read_write].
    pub fn set_kerberos_5i_read_write<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5i_read_write = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_5i_read_write][crate::model::SimpleExportPolicyRule::kerberos_5i_read_write].
    pub fn set_or_clear_kerberos_5i_read_write<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5i_read_write = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kerberos_5p_read_only][crate::model::SimpleExportPolicyRule::kerberos_5p_read_only].
    pub fn set_kerberos_5p_read_only<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5p_read_only = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_5p_read_only][crate::model::SimpleExportPolicyRule::kerberos_5p_read_only].
    pub fn set_or_clear_kerberos_5p_read_only<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5p_read_only = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kerberos_5p_read_write][crate::model::SimpleExportPolicyRule::kerberos_5p_read_write].
    pub fn set_kerberos_5p_read_write<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5p_read_write = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_5p_read_write][crate::model::SimpleExportPolicyRule::kerberos_5p_read_write].
    pub fn set_or_clear_kerberos_5p_read_write<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.kerberos_5p_read_write = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SimpleExportPolicyRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SimpleExportPolicyRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SimpleExportPolicyRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_clients,
            __has_root_access,
            __access_type,
            __nfsv3,
            __nfsv4,
            __kerberos_5_read_only,
            __kerberos_5_read_write,
            __kerberos_5i_read_only,
            __kerberos_5i_read_write,
            __kerberos_5p_read_only,
            __kerberos_5p_read_write,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SimpleExportPolicyRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedClients" => Ok(__FieldTag::__allowed_clients),
                            "allowed_clients" => Ok(__FieldTag::__allowed_clients),
                            "hasRootAccess" => Ok(__FieldTag::__has_root_access),
                            "has_root_access" => Ok(__FieldTag::__has_root_access),
                            "accessType" => Ok(__FieldTag::__access_type),
                            "access_type" => Ok(__FieldTag::__access_type),
                            "nfsv3" => Ok(__FieldTag::__nfsv3),
                            "nfsv4" => Ok(__FieldTag::__nfsv4),
                            "kerberos5ReadOnly" => Ok(__FieldTag::__kerberos_5_read_only),
                            "kerberos_5_read_only" => Ok(__FieldTag::__kerberos_5_read_only),
                            "kerberos5ReadWrite" => Ok(__FieldTag::__kerberos_5_read_write),
                            "kerberos_5_read_write" => Ok(__FieldTag::__kerberos_5_read_write),
                            "kerberos5iReadOnly" => Ok(__FieldTag::__kerberos_5i_read_only),
                            "kerberos_5i_read_only" => Ok(__FieldTag::__kerberos_5i_read_only),
                            "kerberos5iReadWrite" => Ok(__FieldTag::__kerberos_5i_read_write),
                            "kerberos_5i_read_write" => Ok(__FieldTag::__kerberos_5i_read_write),
                            "kerberos5pReadOnly" => Ok(__FieldTag::__kerberos_5p_read_only),
                            "kerberos_5p_read_only" => Ok(__FieldTag::__kerberos_5p_read_only),
                            "kerberos5pReadWrite" => Ok(__FieldTag::__kerberos_5p_read_write),
                            "kerberos_5p_read_write" => Ok(__FieldTag::__kerberos_5p_read_write),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SimpleExportPolicyRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SimpleExportPolicyRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_clients => {
                            if !fields.insert(__FieldTag::__allowed_clients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_clients",
                                ));
                            }
                            result.allowed_clients =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__has_root_access => {
                            if !fields.insert(__FieldTag::__has_root_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_root_access",
                                ));
                            }
                            result.has_root_access =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__access_type => {
                            if !fields.insert(__FieldTag::__access_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_type",
                                ));
                            }
                            result.access_type =
                                map.next_value::<std::option::Option<crate::model::AccessType>>()?;
                        }
                        __FieldTag::__nfsv3 => {
                            if !fields.insert(__FieldTag::__nfsv3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfsv3",
                                ));
                            }
                            result.nfsv3 = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__nfsv4 => {
                            if !fields.insert(__FieldTag::__nfsv4) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfsv4",
                                ));
                            }
                            result.nfsv4 = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kerberos_5_read_only => {
                            if !fields.insert(__FieldTag::__kerberos_5_read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_5_read_only",
                                ));
                            }
                            result.kerberos_5_read_only =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kerberos_5_read_write => {
                            if !fields.insert(__FieldTag::__kerberos_5_read_write) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_5_read_write",
                                ));
                            }
                            result.kerberos_5_read_write =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kerberos_5i_read_only => {
                            if !fields.insert(__FieldTag::__kerberos_5i_read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_5i_read_only",
                                ));
                            }
                            result.kerberos_5i_read_only =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kerberos_5i_read_write => {
                            if !fields.insert(__FieldTag::__kerberos_5i_read_write) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_5i_read_write",
                                ));
                            }
                            result.kerberos_5i_read_write =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kerberos_5p_read_only => {
                            if !fields.insert(__FieldTag::__kerberos_5p_read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_5p_read_only",
                                ));
                            }
                            result.kerberos_5p_read_only =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__kerberos_5p_read_write => {
                            if !fields.insert(__FieldTag::__kerberos_5p_read_write) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_5p_read_write",
                                ));
                            }
                            result.kerberos_5p_read_write =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SimpleExportPolicyRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allowed_clients.is_some() {
            state.serialize_entry("allowedClients", &self.allowed_clients)?;
        }
        if self.has_root_access.is_some() {
            state.serialize_entry("hasRootAccess", &self.has_root_access)?;
        }
        if self.access_type.is_some() {
            state.serialize_entry("accessType", &self.access_type)?;
        }
        if self.nfsv3.is_some() {
            state.serialize_entry("nfsv3", &self.nfsv3)?;
        }
        if self.nfsv4.is_some() {
            state.serialize_entry("nfsv4", &self.nfsv4)?;
        }
        if self.kerberos_5_read_only.is_some() {
            state.serialize_entry("kerberos5ReadOnly", &self.kerberos_5_read_only)?;
        }
        if self.kerberos_5_read_write.is_some() {
            state.serialize_entry("kerberos5ReadWrite", &self.kerberos_5_read_write)?;
        }
        if self.kerberos_5i_read_only.is_some() {
            state.serialize_entry("kerberos5iReadOnly", &self.kerberos_5i_read_only)?;
        }
        if self.kerberos_5i_read_write.is_some() {
            state.serialize_entry("kerberos5iReadWrite", &self.kerberos_5i_read_write)?;
        }
        if self.kerberos_5p_read_only.is_some() {
            state.serialize_entry("kerberos5pReadOnly", &self.kerberos_5p_read_only)?;
        }
        if self.kerberos_5p_read_write.is_some() {
            state.serialize_entry("kerberos5pReadWrite", &self.kerberos_5p_read_write)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SimpleExportPolicyRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SimpleExportPolicyRule");
        debug_struct.field("allowed_clients", &self.allowed_clients);
        debug_struct.field("has_root_access", &self.has_root_access);
        debug_struct.field("access_type", &self.access_type);
        debug_struct.field("nfsv3", &self.nfsv3);
        debug_struct.field("nfsv4", &self.nfsv4);
        debug_struct.field("kerberos_5_read_only", &self.kerberos_5_read_only);
        debug_struct.field("kerberos_5_read_write", &self.kerberos_5_read_write);
        debug_struct.field("kerberos_5i_read_only", &self.kerberos_5i_read_only);
        debug_struct.field("kerberos_5i_read_write", &self.kerberos_5i_read_write);
        debug_struct.field("kerberos_5p_read_only", &self.kerberos_5p_read_only);
        debug_struct.field("kerberos_5p_read_write", &self.kerberos_5p_read_write);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Snapshot Policy for a volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SnapshotPolicy {
    /// If enabled, make snapshots automatically according to the schedules.
    /// Default is false.
    pub enabled: std::option::Option<bool>,

    /// Hourly schedule policy.
    pub hourly_schedule: std::option::Option<crate::model::HourlySchedule>,

    /// Daily schedule policy.
    pub daily_schedule: std::option::Option<crate::model::DailySchedule>,

    /// Weekly schedule policy.
    pub weekly_schedule: std::option::Option<crate::model::WeeklySchedule>,

    /// Monthly schedule policy.
    pub monthly_schedule: std::option::Option<crate::model::MonthlySchedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnapshotPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::SnapshotPolicy::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::SnapshotPolicy::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hourly_schedule][crate::model::SnapshotPolicy::hourly_schedule].
    pub fn set_hourly_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HourlySchedule>,
    {
        self.hourly_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hourly_schedule][crate::model::SnapshotPolicy::hourly_schedule].
    pub fn set_or_clear_hourly_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HourlySchedule>,
    {
        self.hourly_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [daily_schedule][crate::model::SnapshotPolicy::daily_schedule].
    pub fn set_daily_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DailySchedule>,
    {
        self.daily_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [daily_schedule][crate::model::SnapshotPolicy::daily_schedule].
    pub fn set_or_clear_daily_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DailySchedule>,
    {
        self.daily_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [weekly_schedule][crate::model::SnapshotPolicy::weekly_schedule].
    pub fn set_weekly_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WeeklySchedule>,
    {
        self.weekly_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [weekly_schedule][crate::model::SnapshotPolicy::weekly_schedule].
    pub fn set_or_clear_weekly_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WeeklySchedule>,
    {
        self.weekly_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [monthly_schedule][crate::model::SnapshotPolicy::monthly_schedule].
    pub fn set_monthly_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonthlySchedule>,
    {
        self.monthly_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monthly_schedule][crate::model::SnapshotPolicy::monthly_schedule].
    pub fn set_or_clear_monthly_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonthlySchedule>,
    {
        self.monthly_schedule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SnapshotPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SnapshotPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SnapshotPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __hourly_schedule,
            __daily_schedule,
            __weekly_schedule,
            __monthly_schedule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SnapshotPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "hourlySchedule" => Ok(__FieldTag::__hourly_schedule),
                            "hourly_schedule" => Ok(__FieldTag::__hourly_schedule),
                            "dailySchedule" => Ok(__FieldTag::__daily_schedule),
                            "daily_schedule" => Ok(__FieldTag::__daily_schedule),
                            "weeklySchedule" => Ok(__FieldTag::__weekly_schedule),
                            "weekly_schedule" => Ok(__FieldTag::__weekly_schedule),
                            "monthlySchedule" => Ok(__FieldTag::__monthly_schedule),
                            "monthly_schedule" => Ok(__FieldTag::__monthly_schedule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SnapshotPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SnapshotPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__hourly_schedule => {
                            if !fields.insert(__FieldTag::__hourly_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hourly_schedule",
                                ));
                            }
                            result.hourly_schedule = map
                                .next_value::<std::option::Option<crate::model::HourlySchedule>>(
                                )?;
                        }
                        __FieldTag::__daily_schedule => {
                            if !fields.insert(__FieldTag::__daily_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily_schedule",
                                ));
                            }
                            result.daily_schedule = map
                                .next_value::<std::option::Option<crate::model::DailySchedule>>()?;
                        }
                        __FieldTag::__weekly_schedule => {
                            if !fields.insert(__FieldTag::__weekly_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly_schedule",
                                ));
                            }
                            result.weekly_schedule = map
                                .next_value::<std::option::Option<crate::model::WeeklySchedule>>(
                                )?;
                        }
                        __FieldTag::__monthly_schedule => {
                            if !fields.insert(__FieldTag::__monthly_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly_schedule",
                                ));
                            }
                            result.monthly_schedule = map
                                .next_value::<std::option::Option<crate::model::MonthlySchedule>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SnapshotPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.hourly_schedule.is_some() {
            state.serialize_entry("hourlySchedule", &self.hourly_schedule)?;
        }
        if self.daily_schedule.is_some() {
            state.serialize_entry("dailySchedule", &self.daily_schedule)?;
        }
        if self.weekly_schedule.is_some() {
            state.serialize_entry("weeklySchedule", &self.weekly_schedule)?;
        }
        if self.monthly_schedule.is_some() {
            state.serialize_entry("monthlySchedule", &self.monthly_schedule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SnapshotPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SnapshotPolicy");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("hourly_schedule", &self.hourly_schedule);
        debug_struct.field("daily_schedule", &self.daily_schedule);
        debug_struct.field("weekly_schedule", &self.weekly_schedule);
        debug_struct.field("monthly_schedule", &self.monthly_schedule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Make a snapshot every hour e.g. at 04:00, 05:00, 06:00.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HourlySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    pub minute: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HourlySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::HourlySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshots_to_keep][crate::model::HourlySchedule::snapshots_to_keep].
    pub fn set_or_clear_snapshots_to_keep<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = v.map(|x| x.into());
        self
    }

    /// Sets the value of [minute][crate::model::HourlySchedule::minute].
    pub fn set_minute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minute][crate::model::HourlySchedule::minute].
    pub fn set_or_clear_minute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for HourlySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.HourlySchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HourlySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots_to_keep,
            __minute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HourlySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshotsToKeep" => Ok(__FieldTag::__snapshots_to_keep),
                            "snapshots_to_keep" => Ok(__FieldTag::__snapshots_to_keep),
                            "minute" => Ok(__FieldTag::__minute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HourlySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HourlySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots_to_keep => {
                            if !fields.insert(__FieldTag::__snapshots_to_keep) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots_to_keep",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.snapshots_to_keep = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__minute => {
                            if !fields.insert(__FieldTag::__minute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minute",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minute = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HourlySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snapshots_to_keep.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("snapshotsToKeep", &__With(&self.snapshots_to_keep))?;
        }
        if self.minute.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minute", &__With(&self.minute))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HourlySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HourlySchedule");
        debug_struct.field("snapshots_to_keep", &self.snapshots_to_keep);
        debug_struct.field("minute", &self.minute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Make a snapshot every day e.g. at 04:00, 05:20, 23:50
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DailySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    pub minute: std::option::Option<f64>,

    /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
    pub hour: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::DailySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshots_to_keep][crate::model::DailySchedule::snapshots_to_keep].
    pub fn set_or_clear_snapshots_to_keep<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = v.map(|x| x.into());
        self
    }

    /// Sets the value of [minute][crate::model::DailySchedule::minute].
    pub fn set_minute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minute][crate::model::DailySchedule::minute].
    pub fn set_or_clear_minute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hour][crate::model::DailySchedule::hour].
    pub fn set_hour<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.hour = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hour][crate::model::DailySchedule::hour].
    pub fn set_or_clear_hour<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.hour = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DailySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DailySchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DailySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots_to_keep,
            __minute,
            __hour,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DailySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshotsToKeep" => Ok(__FieldTag::__snapshots_to_keep),
                            "snapshots_to_keep" => Ok(__FieldTag::__snapshots_to_keep),
                            "minute" => Ok(__FieldTag::__minute),
                            "hour" => Ok(__FieldTag::__hour),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DailySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DailySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots_to_keep => {
                            if !fields.insert(__FieldTag::__snapshots_to_keep) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots_to_keep",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.snapshots_to_keep = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__minute => {
                            if !fields.insert(__FieldTag::__minute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minute",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minute = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__hour => {
                            if !fields.insert(__FieldTag::__hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hour",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hour = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DailySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snapshots_to_keep.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("snapshotsToKeep", &__With(&self.snapshots_to_keep))?;
        }
        if self.minute.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minute", &__With(&self.minute))?;
        }
        if self.hour.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hour", &__With(&self.hour))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DailySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DailySchedule");
        debug_struct.field("snapshots_to_keep", &self.snapshots_to_keep);
        debug_struct.field("minute", &self.minute);
        debug_struct.field("hour", &self.hour);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Make a snapshot every week e.g. at Monday 04:00, Wednesday 05:20, Sunday
/// 23:50
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WeeklySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    pub minute: std::option::Option<f64>,

    /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
    pub hour: std::option::Option<f64>,

    /// Set the day or days of the week to make a snapshot. Accepts a comma
    /// separated days of the week. Defaults to 'Sunday'.
    pub day: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::WeeklySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshots_to_keep][crate::model::WeeklySchedule::snapshots_to_keep].
    pub fn set_or_clear_snapshots_to_keep<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = v.map(|x| x.into());
        self
    }

    /// Sets the value of [minute][crate::model::WeeklySchedule::minute].
    pub fn set_minute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minute][crate::model::WeeklySchedule::minute].
    pub fn set_or_clear_minute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hour][crate::model::WeeklySchedule::hour].
    pub fn set_hour<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.hour = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hour][crate::model::WeeklySchedule::hour].
    pub fn set_or_clear_hour<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.hour = v.map(|x| x.into());
        self
    }

    /// Sets the value of [day][crate::model::WeeklySchedule::day].
    pub fn set_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [day][crate::model::WeeklySchedule::day].
    pub fn set_or_clear_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.day = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WeeklySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.WeeklySchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WeeklySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots_to_keep,
            __minute,
            __hour,
            __day,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeeklySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshotsToKeep" => Ok(__FieldTag::__snapshots_to_keep),
                            "snapshots_to_keep" => Ok(__FieldTag::__snapshots_to_keep),
                            "minute" => Ok(__FieldTag::__minute),
                            "hour" => Ok(__FieldTag::__hour),
                            "day" => Ok(__FieldTag::__day),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WeeklySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeeklySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots_to_keep => {
                            if !fields.insert(__FieldTag::__snapshots_to_keep) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots_to_keep",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.snapshots_to_keep = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__minute => {
                            if !fields.insert(__FieldTag::__minute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minute",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minute = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__hour => {
                            if !fields.insert(__FieldTag::__hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hour",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hour = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__day => {
                            if !fields.insert(__FieldTag::__day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day",
                                ));
                            }
                            result.day =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WeeklySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snapshots_to_keep.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("snapshotsToKeep", &__With(&self.snapshots_to_keep))?;
        }
        if self.minute.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minute", &__With(&self.minute))?;
        }
        if self.hour.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hour", &__With(&self.hour))?;
        }
        if self.day.is_some() {
            state.serialize_entry("day", &self.day)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WeeklySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WeeklySchedule");
        debug_struct.field("snapshots_to_keep", &self.snapshots_to_keep);
        debug_struct.field("minute", &self.minute);
        debug_struct.field("hour", &self.hour);
        debug_struct.field("day", &self.day);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Make a snapshot once a month e.g. at 2nd 04:00, 7th 05:20, 24th 23:50
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MonthlySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    pub minute: std::option::Option<f64>,

    /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
    pub hour: std::option::Option<f64>,

    /// Set the day or days of the month to make a snapshot (1-31). Accepts a
    /// comma separated number of days. Defaults to '1'.
    pub days_of_month: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonthlySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::MonthlySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshots_to_keep][crate::model::MonthlySchedule::snapshots_to_keep].
    pub fn set_or_clear_snapshots_to_keep<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.snapshots_to_keep = v.map(|x| x.into());
        self
    }

    /// Sets the value of [minute][crate::model::MonthlySchedule::minute].
    pub fn set_minute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minute][crate::model::MonthlySchedule::minute].
    pub fn set_or_clear_minute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.minute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hour][crate::model::MonthlySchedule::hour].
    pub fn set_hour<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.hour = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hour][crate::model::MonthlySchedule::hour].
    pub fn set_or_clear_hour<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.hour = v.map(|x| x.into());
        self
    }

    /// Sets the value of [days_of_month][crate::model::MonthlySchedule::days_of_month].
    pub fn set_days_of_month<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.days_of_month = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [days_of_month][crate::model::MonthlySchedule::days_of_month].
    pub fn set_or_clear_days_of_month<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.days_of_month = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MonthlySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.MonthlySchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MonthlySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots_to_keep,
            __minute,
            __hour,
            __days_of_month,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonthlySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshotsToKeep" => Ok(__FieldTag::__snapshots_to_keep),
                            "snapshots_to_keep" => Ok(__FieldTag::__snapshots_to_keep),
                            "minute" => Ok(__FieldTag::__minute),
                            "hour" => Ok(__FieldTag::__hour),
                            "daysOfMonth" => Ok(__FieldTag::__days_of_month),
                            "days_of_month" => Ok(__FieldTag::__days_of_month),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MonthlySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonthlySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots_to_keep => {
                            if !fields.insert(__FieldTag::__snapshots_to_keep) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots_to_keep",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.snapshots_to_keep = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__minute => {
                            if !fields.insert(__FieldTag::__minute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minute",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minute = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__hour => {
                            if !fields.insert(__FieldTag::__hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hour",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hour = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__days_of_month => {
                            if !fields.insert(__FieldTag::__days_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_month",
                                ));
                            }
                            result.days_of_month =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MonthlySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snapshots_to_keep.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("snapshotsToKeep", &__With(&self.snapshots_to_keep))?;
        }
        if self.minute.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minute", &__With(&self.minute))?;
        }
        if self.hour.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hour", &__With(&self.hour))?;
        }
        if self.days_of_month.is_some() {
            state.serialize_entry("daysOfMonth", &self.days_of_month)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MonthlySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonthlySchedule");
        debug_struct.field("snapshots_to_keep", &self.snapshots_to_keep);
        debug_struct.field("minute", &self.minute);
        debug_struct.field("hour", &self.hour);
        debug_struct.field("days_of_month", &self.days_of_month);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// View only mount options for a volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MountOption {
    /// Export string
    pub export: std::string::String,

    /// Full export string
    pub export_full: std::string::String,

    /// Protocol to mount with.
    pub protocol: crate::model::Protocols,

    /// Instructions for mounting
    pub instructions: std::string::String,

    /// Output only. IP Address.
    pub ip_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MountOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export][crate::model::MountOption::export].
    pub fn set_export<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.export = v.into();
        self
    }

    /// Sets the value of [export_full][crate::model::MountOption::export_full].
    pub fn set_export_full<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.export_full = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::MountOption::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::Protocols>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [instructions][crate::model::MountOption::instructions].
    pub fn set_instructions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instructions = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::MountOption::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for MountOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.MountOption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MountOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __export,
            __export_full,
            __protocol,
            __instructions,
            __ip_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MountOption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "export" => Ok(__FieldTag::__export),
                            "exportFull" => Ok(__FieldTag::__export_full),
                            "export_full" => Ok(__FieldTag::__export_full),
                            "protocol" => Ok(__FieldTag::__protocol),
                            "instructions" => Ok(__FieldTag::__instructions),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MountOption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MountOption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__export => {
                            if !fields.insert(__FieldTag::__export) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export",
                                ));
                            }
                            result.export = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__export_full => {
                            if !fields.insert(__FieldTag::__export_full) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_full",
                                ));
                            }
                            result.export_full = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<crate::model::Protocols>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instructions => {
                            if !fields.insert(__FieldTag::__instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instructions",
                                ));
                            }
                            result.instructions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MountOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.export.is_empty() {
            state.serialize_entry("export", &self.export)?;
        }
        if !self.export_full.is_empty() {
            state.serialize_entry("exportFull", &self.export_full)?;
        }
        if !wkt::internal::is_default(&self.protocol) {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.instructions.is_empty() {
            state.serialize_entry("instructions", &self.instructions)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MountOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MountOption");
        debug_struct.field("export", &self.export);
        debug_struct.field("export_full", &self.export_full);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("instructions", &self.instructions);
        debug_struct.field("ip_address", &self.ip_address);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The RestoreParameters if volume is created from a snapshot or backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreParameters {
    /// The source that the volume is created from.
    pub source: std::option::Option<crate::model::restore_parameters::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::RestoreParameters::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_parameters::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreParameters::source]
    /// if it holds a `SourceSnapshot`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_snapshot(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_parameters::Source::SourceSnapshot(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreParameters::source]
    /// to hold a `SourceSnapshot`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_parameters::Source::SourceSnapshot(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::RestoreParameters::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_parameters::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreParameters::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_parameters::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.RestoreParameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_snapshot,
            __source_backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceSnapshot" => Ok(__FieldTag::__source_snapshot),
                            "source_snapshot" => Ok(__FieldTag::__source_snapshot),
                            "sourceBackup" => Ok(__FieldTag::__source_backup),
                            "source_backup" => Ok(__FieldTag::__source_backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_snapshot => {
                            if !fields.insert(__FieldTag::__source_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_snapshot",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.netapp.v1.RestoreParameters.source_snapshot, latest field was sourceSnapshot",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::restore_parameters::Source::SourceSnapshot(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__source_backup => {
                            if !fields.insert(__FieldTag::__source_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_backup",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.netapp.v1.RestoreParameters.source_backup, latest field was sourceBackup",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::restore_parameters::Source::SourceBackup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.source_snapshot() {
            state.serialize_entry("sourceSnapshot", value)?;
        }
        if let Some(value) = self.source_backup() {
            state.serialize_entry("sourceBackup", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RestoreParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreParameters");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RestoreParameters].
pub mod restore_parameters {
    #[allow(unused_imports)]
    use super::*;

    /// The source that the volume is created from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Full name of the snapshot resource.
        /// Format:
        /// projects/{project}/locations/{location}/volumes/{volume}/snapshots/{snapshot}
        SourceSnapshot(std::string::String),
        /// Full name of the backup resource.
        /// Format:
        /// projects/{project}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}
        SourceBackup(std::string::String),
    }
}

/// BackupConfig contains backup related config on a volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupConfig {
    /// Optional. When specified, schedule backups will be created based on the
    /// policy configuration.
    pub backup_policies: std::vec::Vec<std::string::String>,

    /// Optional. Name of backup vault.
    /// Format:
    /// projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}
    pub backup_vault: std::string::String,

    /// Optional. When set to true, scheduled backup is enabled on the volume.
    /// This field should be nil when there's no backup policy attached.
    pub scheduled_backup_enabled: std::option::Option<bool>,

    /// Output only. Total size of all backups in a chain in bytes = baseline
    /// backup size + sum(incremental backup size).
    pub backup_chain_bytes: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_policies][crate::model::BackupConfig::backup_policies].
    pub fn set_backup_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.backup_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_vault][crate::model::BackupConfig::backup_vault].
    pub fn set_backup_vault<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault = v.into();
        self
    }

    /// Sets the value of [scheduled_backup_enabled][crate::model::BackupConfig::scheduled_backup_enabled].
    pub fn set_scheduled_backup_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.scheduled_backup_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduled_backup_enabled][crate::model::BackupConfig::scheduled_backup_enabled].
    pub fn set_or_clear_scheduled_backup_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.scheduled_backup_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_chain_bytes][crate::model::BackupConfig::backup_chain_bytes].
    pub fn set_backup_chain_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.backup_chain_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_chain_bytes][crate::model::BackupConfig::backup_chain_bytes].
    pub fn set_or_clear_backup_chain_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.backup_chain_bytes = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.BackupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_policies,
            __backup_vault,
            __scheduled_backup_enabled,
            __backup_chain_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPolicies" => Ok(__FieldTag::__backup_policies),
                            "backup_policies" => Ok(__FieldTag::__backup_policies),
                            "backupVault" => Ok(__FieldTag::__backup_vault),
                            "backup_vault" => Ok(__FieldTag::__backup_vault),
                            "scheduledBackupEnabled" => Ok(__FieldTag::__scheduled_backup_enabled),
                            "scheduled_backup_enabled" => {
                                Ok(__FieldTag::__scheduled_backup_enabled)
                            }
                            "backupChainBytes" => Ok(__FieldTag::__backup_chain_bytes),
                            "backup_chain_bytes" => Ok(__FieldTag::__backup_chain_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_policies => {
                            if !fields.insert(__FieldTag::__backup_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_policies",
                                ));
                            }
                            result.backup_policies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__backup_vault => {
                            if !fields.insert(__FieldTag::__backup_vault) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_vault",
                                ));
                            }
                            result.backup_vault = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduled_backup_enabled => {
                            if !fields.insert(__FieldTag::__scheduled_backup_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_backup_enabled",
                                ));
                            }
                            result.scheduled_backup_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__backup_chain_bytes => {
                            if !fields.insert(__FieldTag::__backup_chain_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_chain_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_chain_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_policies.is_empty() {
            state.serialize_entry("backupPolicies", &self.backup_policies)?;
        }
        if !self.backup_vault.is_empty() {
            state.serialize_entry("backupVault", &self.backup_vault)?;
        }
        if self.scheduled_backup_enabled.is_some() {
            state.serialize_entry("scheduledBackupEnabled", &self.scheduled_backup_enabled)?;
        }
        if self.backup_chain_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("backupChainBytes", &__With(&self.backup_chain_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupConfig");
        debug_struct.field("backup_policies", &self.backup_policies);
        debug_struct.field("backup_vault", &self.backup_vault);
        debug_struct.field("scheduled_backup_enabled", &self.scheduled_backup_enabled);
        debug_struct.field("backup_chain_bytes", &self.backup_chain_bytes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines tiering policy for the volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TieringPolicy {
    /// Optional. Flag indicating if the volume has tiering policy enable/pause.
    /// Default is PAUSED.
    pub tier_action: std::option::Option<crate::model::tiering_policy::TierAction>,

    /// Optional. Time in days to mark the volume's data block as cold and make it
    /// eligible for tiering, can be range from 2-183. Default is 31.
    pub cooling_threshold_days: std::option::Option<i32>,

    /// Optional. Flag indicating that the hot tier bypass mode is enabled. Default
    /// is false. This is only applicable to Flex service level.
    pub hot_tier_bypass_mode_enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TieringPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tier_action][crate::model::TieringPolicy::tier_action].
    pub fn set_tier_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::tiering_policy::TierAction>,
    {
        self.tier_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tier_action][crate::model::TieringPolicy::tier_action].
    pub fn set_or_clear_tier_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::tiering_policy::TierAction>,
    {
        self.tier_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cooling_threshold_days][crate::model::TieringPolicy::cooling_threshold_days].
    pub fn set_cooling_threshold_days<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.cooling_threshold_days = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cooling_threshold_days][crate::model::TieringPolicy::cooling_threshold_days].
    pub fn set_or_clear_cooling_threshold_days<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.cooling_threshold_days = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hot_tier_bypass_mode_enabled][crate::model::TieringPolicy::hot_tier_bypass_mode_enabled].
    pub fn set_hot_tier_bypass_mode_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.hot_tier_bypass_mode_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hot_tier_bypass_mode_enabled][crate::model::TieringPolicy::hot_tier_bypass_mode_enabled].
    pub fn set_or_clear_hot_tier_bypass_mode_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.hot_tier_bypass_mode_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TieringPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.TieringPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TieringPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tier_action,
            __cooling_threshold_days,
            __hot_tier_bypass_mode_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TieringPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tierAction" => Ok(__FieldTag::__tier_action),
                            "tier_action" => Ok(__FieldTag::__tier_action),
                            "coolingThresholdDays" => Ok(__FieldTag::__cooling_threshold_days),
                            "cooling_threshold_days" => Ok(__FieldTag::__cooling_threshold_days),
                            "hotTierBypassModeEnabled" => {
                                Ok(__FieldTag::__hot_tier_bypass_mode_enabled)
                            }
                            "hot_tier_bypass_mode_enabled" => {
                                Ok(__FieldTag::__hot_tier_bypass_mode_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TieringPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TieringPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tier_action => {
                            if !fields.insert(__FieldTag::__tier_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier_action",
                                ));
                            }
                            result.tier_action = map.next_value::<std::option::Option<crate::model::tiering_policy::TierAction>>()?
                                ;
                        }
                        __FieldTag::__cooling_threshold_days => {
                            if !fields.insert(__FieldTag::__cooling_threshold_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cooling_threshold_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cooling_threshold_days = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__hot_tier_bypass_mode_enabled => {
                            if !fields.insert(__FieldTag::__hot_tier_bypass_mode_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_tier_bypass_mode_enabled",
                                ));
                            }
                            result.hot_tier_bypass_mode_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TieringPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tier_action.is_some() {
            state.serialize_entry("tierAction", &self.tier_action)?;
        }
        if self.cooling_threshold_days.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "coolingThresholdDays",
                &__With(&self.cooling_threshold_days),
            )?;
        }
        if self.hot_tier_bypass_mode_enabled.is_some() {
            state.serialize_entry(
                "hotTierBypassModeEnabled",
                &self.hot_tier_bypass_mode_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TieringPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TieringPolicy");
        debug_struct.field("tier_action", &self.tier_action);
        debug_struct.field("cooling_threshold_days", &self.cooling_threshold_days);
        debug_struct.field(
            "hot_tier_bypass_mode_enabled",
            &self.hot_tier_bypass_mode_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TieringPolicy].
pub mod tiering_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Tier action for the volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TierAction {
        /// Unspecified.
        Unspecified,
        /// When tiering is enabled, new cold data will be tiered.
        Enabled,
        /// When paused, tiering won't be performed on new data. Existing data stays
        /// tiered until accessed.
        Paused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TierAction::value] or
        /// [TierAction::name].
        UnknownValue(tier_action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tier_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TierAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_ACTION_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TierAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TierAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TierAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Paused,
                _ => Self::UnknownValue(tier_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TierAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_ACTION_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "PAUSED" => Self::Paused,
                _ => Self::UnknownValue(tier_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TierAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TierAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TierAction>::new(
                ".google.cloud.netapp.v1.TieringPolicy.TierAction",
            ))
        }
    }
}

/// The Hybrid Replication parameters for the volume.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HybridReplicationParameters {
    /// Required. Desired name for the replication of this volume.
    pub replication: std::string::String,

    /// Required. Name of the user's local source volume to be peered with the
    /// destination volume.
    pub peer_volume_name: std::string::String,

    /// Required. Name of the user's local source cluster to be peered with the
    /// destination cluster.
    pub peer_cluster_name: std::string::String,

    /// Required. Name of the user's local source vserver svm to be peered with the
    /// destination vserver svm.
    pub peer_svm_name: std::string::String,

    /// Required. List of node ip addresses to be peered with.
    pub peer_ip_addresses: std::vec::Vec<std::string::String>,

    /// Optional. Name of source cluster location associated with the Hybrid
    /// replication. This is a free-form field for the display purpose only.
    pub cluster_location: std::string::String,

    /// Optional. Description of the replication.
    pub description: std::string::String,

    /// Optional. Labels to be added to the replication as the key value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Replication Schedule for the replication created.
    pub replication_schedule: crate::model::HybridReplicationSchedule,

    /// Optional. Type of the hybrid replication.
    pub hybrid_replication_type:
        crate::model::hybrid_replication_parameters::VolumeHybridReplicationType,

    /// Optional. Constituent volume count for large volume.
    pub large_volume_constituent_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridReplicationParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication][crate::model::HybridReplicationParameters::replication].
    pub fn set_replication<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replication = v.into();
        self
    }

    /// Sets the value of [peer_volume_name][crate::model::HybridReplicationParameters::peer_volume_name].
    pub fn set_peer_volume_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_volume_name = v.into();
        self
    }

    /// Sets the value of [peer_cluster_name][crate::model::HybridReplicationParameters::peer_cluster_name].
    pub fn set_peer_cluster_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_cluster_name = v.into();
        self
    }

    /// Sets the value of [peer_svm_name][crate::model::HybridReplicationParameters::peer_svm_name].
    pub fn set_peer_svm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_svm_name = v.into();
        self
    }

    /// Sets the value of [peer_ip_addresses][crate::model::HybridReplicationParameters::peer_ip_addresses].
    pub fn set_peer_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_location][crate::model::HybridReplicationParameters::cluster_location].
    pub fn set_cluster_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_location = v.into();
        self
    }

    /// Sets the value of [description][crate::model::HybridReplicationParameters::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::HybridReplicationParameters::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [replication_schedule][crate::model::HybridReplicationParameters::replication_schedule].
    pub fn set_replication_schedule<
        T: std::convert::Into<crate::model::HybridReplicationSchedule>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_schedule = v.into();
        self
    }

    /// Sets the value of [hybrid_replication_type][crate::model::HybridReplicationParameters::hybrid_replication_type].
    pub fn set_hybrid_replication_type<
        T: std::convert::Into<
                crate::model::hybrid_replication_parameters::VolumeHybridReplicationType,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_replication_type = v.into();
        self
    }

    /// Sets the value of [large_volume_constituent_count][crate::model::HybridReplicationParameters::large_volume_constituent_count].
    pub fn set_large_volume_constituent_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.large_volume_constituent_count = v.into();
        self
    }
}

impl wkt::message::Message for HybridReplicationParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.HybridReplicationParameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HybridReplicationParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __replication,
            __peer_volume_name,
            __peer_cluster_name,
            __peer_svm_name,
            __peer_ip_addresses,
            __cluster_location,
            __description,
            __labels,
            __replication_schedule,
            __hybrid_replication_type,
            __large_volume_constituent_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HybridReplicationParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replication" => Ok(__FieldTag::__replication),
                            "peerVolumeName" => Ok(__FieldTag::__peer_volume_name),
                            "peer_volume_name" => Ok(__FieldTag::__peer_volume_name),
                            "peerClusterName" => Ok(__FieldTag::__peer_cluster_name),
                            "peer_cluster_name" => Ok(__FieldTag::__peer_cluster_name),
                            "peerSvmName" => Ok(__FieldTag::__peer_svm_name),
                            "peer_svm_name" => Ok(__FieldTag::__peer_svm_name),
                            "peerIpAddresses" => Ok(__FieldTag::__peer_ip_addresses),
                            "peer_ip_addresses" => Ok(__FieldTag::__peer_ip_addresses),
                            "clusterLocation" => Ok(__FieldTag::__cluster_location),
                            "cluster_location" => Ok(__FieldTag::__cluster_location),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "replicationSchedule" => Ok(__FieldTag::__replication_schedule),
                            "replication_schedule" => Ok(__FieldTag::__replication_schedule),
                            "hybridReplicationType" => Ok(__FieldTag::__hybrid_replication_type),
                            "hybrid_replication_type" => Ok(__FieldTag::__hybrid_replication_type),
                            "largeVolumeConstituentCount" => {
                                Ok(__FieldTag::__large_volume_constituent_count)
                            }
                            "large_volume_constituent_count" => {
                                Ok(__FieldTag::__large_volume_constituent_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HybridReplicationParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HybridReplicationParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__replication => {
                            if !fields.insert(__FieldTag::__replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication",
                                ));
                            }
                            result.replication = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_volume_name => {
                            if !fields.insert(__FieldTag::__peer_volume_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_volume_name",
                                ));
                            }
                            result.peer_volume_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_cluster_name => {
                            if !fields.insert(__FieldTag::__peer_cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_cluster_name",
                                ));
                            }
                            result.peer_cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_svm_name => {
                            if !fields.insert(__FieldTag::__peer_svm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_svm_name",
                                ));
                            }
                            result.peer_svm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peer_ip_addresses => {
                            if !fields.insert(__FieldTag::__peer_ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peer_ip_addresses",
                                ));
                            }
                            result.peer_ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_location => {
                            if !fields.insert(__FieldTag::__cluster_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_location",
                                ));
                            }
                            result.cluster_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replication_schedule => {
                            if !fields.insert(__FieldTag::__replication_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_schedule",
                                ));
                            }
                            result.replication_schedule = map.next_value::<std::option::Option<crate::model::HybridReplicationSchedule>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hybrid_replication_type => {
                            if !fields.insert(__FieldTag::__hybrid_replication_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hybrid_replication_type",
                                ));
                            }
                            result.hybrid_replication_type = map.next_value::<std::option::Option<crate::model::hybrid_replication_parameters::VolumeHybridReplicationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__large_volume_constituent_count => {
                            if !fields.insert(__FieldTag::__large_volume_constituent_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for large_volume_constituent_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.large_volume_constituent_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HybridReplicationParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.replication.is_empty() {
            state.serialize_entry("replication", &self.replication)?;
        }
        if !self.peer_volume_name.is_empty() {
            state.serialize_entry("peerVolumeName", &self.peer_volume_name)?;
        }
        if !self.peer_cluster_name.is_empty() {
            state.serialize_entry("peerClusterName", &self.peer_cluster_name)?;
        }
        if !self.peer_svm_name.is_empty() {
            state.serialize_entry("peerSvmName", &self.peer_svm_name)?;
        }
        if !self.peer_ip_addresses.is_empty() {
            state.serialize_entry("peerIpAddresses", &self.peer_ip_addresses)?;
        }
        if !self.cluster_location.is_empty() {
            state.serialize_entry("clusterLocation", &self.cluster_location)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.replication_schedule) {
            state.serialize_entry("replicationSchedule", &self.replication_schedule)?;
        }
        if !wkt::internal::is_default(&self.hybrid_replication_type) {
            state.serialize_entry("hybridReplicationType", &self.hybrid_replication_type)?;
        }
        if !wkt::internal::is_default(&self.large_volume_constituent_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "largeVolumeConstituentCount",
                &__With(&self.large_volume_constituent_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HybridReplicationParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HybridReplicationParameters");
        debug_struct.field("replication", &self.replication);
        debug_struct.field("peer_volume_name", &self.peer_volume_name);
        debug_struct.field("peer_cluster_name", &self.peer_cluster_name);
        debug_struct.field("peer_svm_name", &self.peer_svm_name);
        debug_struct.field("peer_ip_addresses", &self.peer_ip_addresses);
        debug_struct.field("cluster_location", &self.cluster_location);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("replication_schedule", &self.replication_schedule);
        debug_struct.field("hybrid_replication_type", &self.hybrid_replication_type);
        debug_struct.field(
            "large_volume_constituent_count",
            &self.large_volume_constituent_count,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [HybridReplicationParameters].
pub mod hybrid_replication_parameters {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the volume's hybrid replication.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeHybridReplicationType {
        /// Unspecified hybrid replication type.
        Unspecified,
        /// Hybrid replication type for migration.
        Migration,
        /// Hybrid replication type for continuous replication.
        ContinuousReplication,
        /// New field for reversible OnPrem replication, to be used for data
        /// protection.
        OnpremReplication,
        /// New field for reversible OnPrem replication, to be used for data
        /// protection.
        ReverseOnpremReplication,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VolumeHybridReplicationType::value] or
        /// [VolumeHybridReplicationType::name].
        UnknownValue(volume_hybrid_replication_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod volume_hybrid_replication_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VolumeHybridReplicationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Migration => std::option::Option::Some(1),
                Self::ContinuousReplication => std::option::Option::Some(2),
                Self::OnpremReplication => std::option::Option::Some(3),
                Self::ReverseOnpremReplication => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("VOLUME_HYBRID_REPLICATION_TYPE_UNSPECIFIED")
                }
                Self::Migration => std::option::Option::Some("MIGRATION"),
                Self::ContinuousReplication => std::option::Option::Some("CONTINUOUS_REPLICATION"),
                Self::OnpremReplication => std::option::Option::Some("ONPREM_REPLICATION"),
                Self::ReverseOnpremReplication => {
                    std::option::Option::Some("REVERSE_ONPREM_REPLICATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VolumeHybridReplicationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VolumeHybridReplicationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VolumeHybridReplicationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Migration,
                2 => Self::ContinuousReplication,
                3 => Self::OnpremReplication,
                4 => Self::ReverseOnpremReplication,
                _ => Self::UnknownValue(volume_hybrid_replication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VolumeHybridReplicationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VOLUME_HYBRID_REPLICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MIGRATION" => Self::Migration,
                "CONTINUOUS_REPLICATION" => Self::ContinuousReplication,
                "ONPREM_REPLICATION" => Self::OnpremReplication,
                "REVERSE_ONPREM_REPLICATION" => Self::ReverseOnpremReplication,
                _ => Self::UnknownValue(volume_hybrid_replication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VolumeHybridReplicationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Migration => serializer.serialize_i32(1),
                Self::ContinuousReplication => serializer.serialize_i32(2),
                Self::OnpremReplication => serializer.serialize_i32(3),
                Self::ReverseOnpremReplication => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VolumeHybridReplicationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumeHybridReplicationType>::new(
                ".google.cloud.netapp.v1.HybridReplicationParameters.VolumeHybridReplicationType"))
        }
    }
}

/// The service level of a storage pool and its volumes.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ServiceLevel {
    /// Unspecified service level.
    Unspecified,
    /// Premium service level.
    Premium,
    /// Extreme service level.
    Extreme,
    /// Standard service level.
    Standard,
    /// Flex service level.
    Flex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ServiceLevel::value] or
    /// [ServiceLevel::name].
    UnknownValue(service_level::UnknownValue),
}

#[doc(hidden)]
pub mod service_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ServiceLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Premium => std::option::Option::Some(1),
            Self::Extreme => std::option::Option::Some(2),
            Self::Standard => std::option::Option::Some(3),
            Self::Flex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SERVICE_LEVEL_UNSPECIFIED"),
            Self::Premium => std::option::Option::Some("PREMIUM"),
            Self::Extreme => std::option::Option::Some("EXTREME"),
            Self::Standard => std::option::Option::Some("STANDARD"),
            Self::Flex => std::option::Option::Some("FLEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ServiceLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ServiceLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ServiceLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Premium,
            2 => Self::Extreme,
            3 => Self::Standard,
            4 => Self::Flex,
            _ => Self::UnknownValue(service_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ServiceLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SERVICE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "PREMIUM" => Self::Premium,
            "EXTREME" => Self::Extreme,
            "STANDARD" => Self::Standard,
            "FLEX" => Self::Flex,
            _ => Self::UnknownValue(service_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ServiceLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Premium => serializer.serialize_i32(1),
            Self::Extreme => serializer.serialize_i32(2),
            Self::Standard => serializer.serialize_i32(3),
            Self::Flex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ServiceLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceLevel>::new(
            ".google.cloud.netapp.v1.ServiceLevel",
        ))
    }
}

/// Flex Storage Pool performance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FlexPerformance {
    /// Unspecified flex performance.
    Unspecified,
    /// Flex Storage Pool with default performance.
    Default,
    /// Flex Storage Pool with custom performance.
    Custom,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FlexPerformance::value] or
    /// [FlexPerformance::name].
    UnknownValue(flex_performance::UnknownValue),
}

#[doc(hidden)]
pub mod flex_performance {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FlexPerformance {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Default => std::option::Option::Some(1),
            Self::Custom => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FLEX_PERFORMANCE_UNSPECIFIED"),
            Self::Default => std::option::Option::Some("FLEX_PERFORMANCE_DEFAULT"),
            Self::Custom => std::option::Option::Some("FLEX_PERFORMANCE_CUSTOM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FlexPerformance {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FlexPerformance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FlexPerformance {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Default,
            2 => Self::Custom,
            _ => Self::UnknownValue(flex_performance::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FlexPerformance {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FLEX_PERFORMANCE_UNSPECIFIED" => Self::Unspecified,
            "FLEX_PERFORMANCE_DEFAULT" => Self::Default,
            "FLEX_PERFORMANCE_CUSTOM" => Self::Custom,
            _ => Self::UnknownValue(flex_performance::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FlexPerformance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Default => serializer.serialize_i32(1),
            Self::Custom => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FlexPerformance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FlexPerformance>::new(
            ".google.cloud.netapp.v1.FlexPerformance",
        ))
    }
}

/// The volume encryption key source.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncryptionType {
    /// The source of the encryption key is not specified.
    Unspecified,
    /// Google managed encryption key.
    ServiceManaged,
    /// Customer managed encryption key, which is stored in KMS.
    CloudKms,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncryptionType::value] or
    /// [EncryptionType::name].
    UnknownValue(encryption_type::UnknownValue),
}

#[doc(hidden)]
pub mod encryption_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncryptionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ServiceManaged => std::option::Option::Some(1),
            Self::CloudKms => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENCRYPTION_TYPE_UNSPECIFIED"),
            Self::ServiceManaged => std::option::Option::Some("SERVICE_MANAGED"),
            Self::CloudKms => std::option::Option::Some("CLOUD_KMS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncryptionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncryptionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncryptionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ServiceManaged,
            2 => Self::CloudKms,
            _ => Self::UnknownValue(encryption_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncryptionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SERVICE_MANAGED" => Self::ServiceManaged,
            "CLOUD_KMS" => Self::CloudKms,
            _ => Self::UnknownValue(encryption_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncryptionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ServiceManaged => serializer.serialize_i32(1),
            Self::CloudKms => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncryptionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionType>::new(
            ".google.cloud.netapp.v1.EncryptionType",
        ))
    }
}

/// Type of directory service
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DirectoryServiceType {
    /// Directory service type is not specified.
    Unspecified,
    /// Active directory policy attached to the storage pool.
    ActiveDirectory,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DirectoryServiceType::value] or
    /// [DirectoryServiceType::name].
    UnknownValue(directory_service_type::UnknownValue),
}

#[doc(hidden)]
pub mod directory_service_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DirectoryServiceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ActiveDirectory => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DIRECTORY_SERVICE_TYPE_UNSPECIFIED"),
            Self::ActiveDirectory => std::option::Option::Some("ACTIVE_DIRECTORY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DirectoryServiceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DirectoryServiceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DirectoryServiceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ActiveDirectory,
            _ => Self::UnknownValue(directory_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DirectoryServiceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DIRECTORY_SERVICE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE_DIRECTORY" => Self::ActiveDirectory,
            _ => Self::UnknownValue(directory_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DirectoryServiceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ActiveDirectory => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DirectoryServiceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DirectoryServiceType>::new(
            ".google.cloud.netapp.v1.DirectoryServiceType",
        ))
    }
}

/// Schedule for Hybrid Replication.
/// New enum values may be added in future to support different frequency of
/// replication.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HybridReplicationSchedule {
    /// Unspecified HybridReplicationSchedule
    Unspecified,
    /// Replication happens once every 10 minutes.
    Every10Minutes,
    /// Replication happens once every hour.
    Hourly,
    /// Replication happens once every day.
    Daily,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HybridReplicationSchedule::value] or
    /// [HybridReplicationSchedule::name].
    UnknownValue(hybrid_replication_schedule::UnknownValue),
}

#[doc(hidden)]
pub mod hybrid_replication_schedule {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl HybridReplicationSchedule {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Every10Minutes => std::option::Option::Some(1),
            Self::Hourly => std::option::Option::Some(2),
            Self::Daily => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("HYBRID_REPLICATION_SCHEDULE_UNSPECIFIED")
            }
            Self::Every10Minutes => std::option::Option::Some("EVERY_10_MINUTES"),
            Self::Hourly => std::option::Option::Some("HOURLY"),
            Self::Daily => std::option::Option::Some("DAILY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for HybridReplicationSchedule {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for HybridReplicationSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for HybridReplicationSchedule {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Every10Minutes,
            2 => Self::Hourly,
            3 => Self::Daily,
            _ => Self::UnknownValue(hybrid_replication_schedule::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for HybridReplicationSchedule {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HYBRID_REPLICATION_SCHEDULE_UNSPECIFIED" => Self::Unspecified,
            "EVERY_10_MINUTES" => Self::Every10Minutes,
            "HOURLY" => Self::Hourly,
            "DAILY" => Self::Daily,
            _ => Self::UnknownValue(hybrid_replication_schedule::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for HybridReplicationSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Every10Minutes => serializer.serialize_i32(1),
            Self::Hourly => serializer.serialize_i32(2),
            Self::Daily => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for HybridReplicationSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<HybridReplicationSchedule>::new(
                ".google.cloud.netapp.v1.HybridReplicationSchedule",
            ),
        )
    }
}

/// QoS (Quality of Service) Types of the storage pool
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum QosType {
    /// Unspecified QoS Type
    Unspecified,
    /// QoS Type is Auto
    Auto,
    /// QoS Type is Manual
    Manual,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [QosType::value] or
    /// [QosType::name].
    UnknownValue(qos_type::UnknownValue),
}

#[doc(hidden)]
pub mod qos_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl QosType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Auto => std::option::Option::Some(1),
            Self::Manual => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("QOS_TYPE_UNSPECIFIED"),
            Self::Auto => std::option::Option::Some("AUTO"),
            Self::Manual => std::option::Option::Some("MANUAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for QosType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for QosType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for QosType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Auto,
            2 => Self::Manual,
            _ => Self::UnknownValue(qos_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for QosType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "QOS_TYPE_UNSPECIFIED" => Self::Unspecified,
            "AUTO" => Self::Auto,
            "MANUAL" => Self::Manual,
            _ => Self::UnknownValue(qos_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for QosType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Auto => serializer.serialize_i32(1),
            Self::Manual => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for QosType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<QosType>::new(
            ".google.cloud.netapp.v1.QosType",
        ))
    }
}

/// Protocols is an enum of all the supported network protocols for a volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Protocols {
    /// Unspecified protocol
    Unspecified,
    /// NFS V3 protocol
    Nfsv3,
    /// NFS V4 protocol
    Nfsv4,
    /// SMB protocol
    Smb,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Protocols::value] or
    /// [Protocols::name].
    UnknownValue(protocols::UnknownValue),
}

#[doc(hidden)]
pub mod protocols {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Protocols {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Nfsv3 => std::option::Option::Some(1),
            Self::Nfsv4 => std::option::Option::Some(2),
            Self::Smb => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PROTOCOLS_UNSPECIFIED"),
            Self::Nfsv3 => std::option::Option::Some("NFSV3"),
            Self::Nfsv4 => std::option::Option::Some("NFSV4"),
            Self::Smb => std::option::Option::Some("SMB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Protocols {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Protocols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Protocols {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Nfsv3,
            2 => Self::Nfsv4,
            3 => Self::Smb,
            _ => Self::UnknownValue(protocols::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Protocols {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PROTOCOLS_UNSPECIFIED" => Self::Unspecified,
            "NFSV3" => Self::Nfsv3,
            "NFSV4" => Self::Nfsv4,
            "SMB" => Self::Smb,
            _ => Self::UnknownValue(protocols::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Protocols {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Nfsv3 => serializer.serialize_i32(1),
            Self::Nfsv4 => serializer.serialize_i32(2),
            Self::Smb => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Protocols {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocols>::new(
            ".google.cloud.netapp.v1.Protocols",
        ))
    }
}

/// AccessType is an enum of all the supported access types for a volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AccessType {
    /// Unspecified Access Type
    Unspecified,
    /// Read Only
    ReadOnly,
    /// Read Write
    ReadWrite,
    /// None
    ReadNone,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AccessType::value] or
    /// [AccessType::name].
    UnknownValue(access_type::UnknownValue),
}

#[doc(hidden)]
pub mod access_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AccessType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ReadOnly => std::option::Option::Some(1),
            Self::ReadWrite => std::option::Option::Some(2),
            Self::ReadNone => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ACCESS_TYPE_UNSPECIFIED"),
            Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
            Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
            Self::ReadNone => std::option::Option::Some("READ_NONE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AccessType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AccessType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ReadOnly,
            2 => Self::ReadWrite,
            3 => Self::ReadNone,
            _ => Self::UnknownValue(access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AccessType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ACCESS_TYPE_UNSPECIFIED" => Self::Unspecified,
            "READ_ONLY" => Self::ReadOnly,
            "READ_WRITE" => Self::ReadWrite,
            "READ_NONE" => Self::ReadNone,
            _ => Self::UnknownValue(access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AccessType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ReadOnly => serializer.serialize_i32(1),
            Self::ReadWrite => serializer.serialize_i32(2),
            Self::ReadNone => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AccessType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessType>::new(
            ".google.cloud.netapp.v1.AccessType",
        ))
    }
}

/// SMBSettings
/// Modifies the behaviour of a SMB volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SMBSettings {
    /// Unspecified default option
    Unspecified,
    /// SMB setting encrypt data
    EncryptData,
    /// SMB setting browsable
    Browsable,
    /// SMB setting notify change
    ChangeNotify,
    /// SMB setting not to notify change
    NonBrowsable,
    /// SMB setting oplocks
    Oplocks,
    /// SMB setting to show snapshots
    ShowSnapshot,
    /// SMB setting to show previous versions
    ShowPreviousVersions,
    /// SMB setting to access volume based on enumerartion
    AccessBasedEnumeration,
    /// Continuously available enumeration
    ContinuouslyAvailable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SMBSettings::value] or
    /// [SMBSettings::name].
    UnknownValue(smb_settings::UnknownValue),
}

#[doc(hidden)]
pub mod smb_settings {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SMBSettings {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EncryptData => std::option::Option::Some(1),
            Self::Browsable => std::option::Option::Some(2),
            Self::ChangeNotify => std::option::Option::Some(3),
            Self::NonBrowsable => std::option::Option::Some(4),
            Self::Oplocks => std::option::Option::Some(5),
            Self::ShowSnapshot => std::option::Option::Some(6),
            Self::ShowPreviousVersions => std::option::Option::Some(7),
            Self::AccessBasedEnumeration => std::option::Option::Some(8),
            Self::ContinuouslyAvailable => std::option::Option::Some(9),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SMB_SETTINGS_UNSPECIFIED"),
            Self::EncryptData => std::option::Option::Some("ENCRYPT_DATA"),
            Self::Browsable => std::option::Option::Some("BROWSABLE"),
            Self::ChangeNotify => std::option::Option::Some("CHANGE_NOTIFY"),
            Self::NonBrowsable => std::option::Option::Some("NON_BROWSABLE"),
            Self::Oplocks => std::option::Option::Some("OPLOCKS"),
            Self::ShowSnapshot => std::option::Option::Some("SHOW_SNAPSHOT"),
            Self::ShowPreviousVersions => std::option::Option::Some("SHOW_PREVIOUS_VERSIONS"),
            Self::AccessBasedEnumeration => std::option::Option::Some("ACCESS_BASED_ENUMERATION"),
            Self::ContinuouslyAvailable => std::option::Option::Some("CONTINUOUSLY_AVAILABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SMBSettings {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SMBSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SMBSettings {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EncryptData,
            2 => Self::Browsable,
            3 => Self::ChangeNotify,
            4 => Self::NonBrowsable,
            5 => Self::Oplocks,
            6 => Self::ShowSnapshot,
            7 => Self::ShowPreviousVersions,
            8 => Self::AccessBasedEnumeration,
            9 => Self::ContinuouslyAvailable,
            _ => Self::UnknownValue(smb_settings::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SMBSettings {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SMB_SETTINGS_UNSPECIFIED" => Self::Unspecified,
            "ENCRYPT_DATA" => Self::EncryptData,
            "BROWSABLE" => Self::Browsable,
            "CHANGE_NOTIFY" => Self::ChangeNotify,
            "NON_BROWSABLE" => Self::NonBrowsable,
            "OPLOCKS" => Self::Oplocks,
            "SHOW_SNAPSHOT" => Self::ShowSnapshot,
            "SHOW_PREVIOUS_VERSIONS" => Self::ShowPreviousVersions,
            "ACCESS_BASED_ENUMERATION" => Self::AccessBasedEnumeration,
            "CONTINUOUSLY_AVAILABLE" => Self::ContinuouslyAvailable,
            _ => Self::UnknownValue(smb_settings::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SMBSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EncryptData => serializer.serialize_i32(1),
            Self::Browsable => serializer.serialize_i32(2),
            Self::ChangeNotify => serializer.serialize_i32(3),
            Self::NonBrowsable => serializer.serialize_i32(4),
            Self::Oplocks => serializer.serialize_i32(5),
            Self::ShowSnapshot => serializer.serialize_i32(6),
            Self::ShowPreviousVersions => serializer.serialize_i32(7),
            Self::AccessBasedEnumeration => serializer.serialize_i32(8),
            Self::ContinuouslyAvailable => serializer.serialize_i32(9),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SMBSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SMBSettings>::new(
            ".google.cloud.netapp.v1.SMBSettings",
        ))
    }
}

/// The security style of the volume, can be either UNIX or NTFS.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecurityStyle {
    /// SecurityStyle is unspecified
    Unspecified,
    /// SecurityStyle uses NTFS
    Ntfs,
    /// SecurityStyle uses UNIX
    Unix,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecurityStyle::value] or
    /// [SecurityStyle::name].
    UnknownValue(security_style::UnknownValue),
}

#[doc(hidden)]
pub mod security_style {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecurityStyle {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ntfs => std::option::Option::Some(1),
            Self::Unix => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SECURITY_STYLE_UNSPECIFIED"),
            Self::Ntfs => std::option::Option::Some("NTFS"),
            Self::Unix => std::option::Option::Some("UNIX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecurityStyle {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecurityStyle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecurityStyle {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ntfs,
            2 => Self::Unix,
            _ => Self::UnknownValue(security_style::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SecurityStyle {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECURITY_STYLE_UNSPECIFIED" => Self::Unspecified,
            "NTFS" => Self::Ntfs,
            "UNIX" => Self::Unix,
            _ => Self::UnknownValue(security_style::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SecurityStyle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ntfs => serializer.serialize_i32(1),
            Self::Unix => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecurityStyle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecurityStyle>::new(
            ".google.cloud.netapp.v1.SecurityStyle",
        ))
    }
}

/// Actions to be restricted for a volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RestrictedAction {
    /// Unspecified restricted action
    Unspecified,
    /// Prevent volume from being deleted when mounted.
    Delete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RestrictedAction::value] or
    /// [RestrictedAction::name].
    UnknownValue(restricted_action::UnknownValue),
}

#[doc(hidden)]
pub mod restricted_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RestrictedAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Delete => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESTRICTED_ACTION_UNSPECIFIED"),
            Self::Delete => std::option::Option::Some("DELETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RestrictedAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RestrictedAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RestrictedAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Delete,
            _ => Self::UnknownValue(restricted_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RestrictedAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESTRICTED_ACTION_UNSPECIFIED" => Self::Unspecified,
            "DELETE" => Self::Delete,
            _ => Self::UnknownValue(restricted_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RestrictedAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Delete => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RestrictedAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestrictedAction>::new(
            ".google.cloud.netapp.v1.RestrictedAction",
        ))
    }
}
