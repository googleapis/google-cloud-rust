// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// ListActiveDirectoriesRequest for requesting multiple active directories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListActiveDirectoriesRequest {
    /// Required. Parent value for ListActiveDirectoriesRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListActiveDirectoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListActiveDirectoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListActiveDirectoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListActiveDirectoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListActiveDirectoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListActiveDirectoriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListActiveDirectoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListActiveDirectoriesRequest"
    }
}

/// ListActiveDirectoriesResponse contains all the active directories requested.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListActiveDirectoriesResponse {
    /// The list of active directories.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub active_directories: std::vec::Vec<crate::model::ActiveDirectory>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListActiveDirectoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [active_directories][crate::model::ListActiveDirectoriesResponse::active_directories].
    pub fn set_active_directories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ActiveDirectory>,
    {
        use std::iter::Iterator;
        self.active_directories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListActiveDirectoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListActiveDirectoriesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListActiveDirectoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListActiveDirectoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListActiveDirectoriesResponse {
    type PageItem = crate::model::ActiveDirectory;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.active_directories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetActiveDirectory for getting a single active directory.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetActiveDirectoryRequest {
    /// Required. Name of the active directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetActiveDirectoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetActiveDirectoryRequest"
    }
}

/// CreateActiveDirectoryRequest for creating an active directory.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateActiveDirectoryRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Fields of the to be created active directory.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_directory: std::option::Option<crate::model::ActiveDirectory>,

    /// Required. ID of the active directory to create. Must be unique within the
    /// parent resource. Must contain only letters, numbers and hyphen, with the
    /// first character a letter , the last a letter or a number, and a 63
    /// character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub active_directory_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateActiveDirectoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::CreateActiveDirectoryRequest::active_directory].
    pub fn set_active_directory<
        T: std::convert::Into<std::option::Option<crate::model::ActiveDirectory>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory = v.into();
        self
    }

    /// Sets the value of [active_directory_id][crate::model::CreateActiveDirectoryRequest::active_directory_id].
    pub fn set_active_directory_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateActiveDirectoryRequest"
    }
}

/// UpdateActiveDirectoryRequest for updating an active directory.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateActiveDirectoryRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Active Directory resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The volume being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_directory: std::option::Option<crate::model::ActiveDirectory>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateActiveDirectoryRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::UpdateActiveDirectoryRequest::active_directory].
    pub fn set_active_directory<
        T: std::convert::Into<std::option::Option<crate::model::ActiveDirectory>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory = v.into();
        self
    }
}

impl wkt::message::Message for UpdateActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateActiveDirectoryRequest"
    }
}

/// DeleteActiveDirectoryRequest for deleting a single active directory.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteActiveDirectoryRequest {
    /// Required. Name of the active directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteActiveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteActiveDirectoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteActiveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteActiveDirectoryRequest"
    }
}

/// ActiveDirectory is the public representation of the active directory config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ActiveDirectory {
    /// Identifier. The resource name of the active directory.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/activeDirectories/{active_directory_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Create time of the active directory.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the AD.
    pub state: crate::model::active_directory::State,

    /// Required. Name of the Active Directory domain
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// The Active Directory site the service will limit Domain Controller
    /// discovery too.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site: std::string::String,

    /// Required. Comma separated list of DNS server IP addresses for the Active
    /// Directory domain.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns: std::string::String,

    /// Required. NetBIOSPrefix is used as a prefix for SMB server name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub net_bios_prefix: std::string::String,

    /// The Organizational Unit (OU) within the Windows Active Directory the user
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub organizational_unit: std::string::String,

    /// If enabled, AES encryption will be enabled for SMB communication.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub aes_encryption: bool,

    /// Required. Username of the Active Directory domain administrator.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Password of the Active Directory domain administrator.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Optional. Users to be added to the Built-in Backup Operator active
    /// directory group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_operators: std::vec::Vec<std::string::String>,

    /// Optional. Users to be added to the Built-in Admininstrators group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub administrators: std::vec::Vec<std::string::String>,

    /// Optional. Domain users to be given the SeSecurityPrivilege.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub security_operators: std::vec::Vec<std::string::String>,

    /// Name of the active directory machine. This optional parameter is used only
    /// while creating kerberos volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kdc_hostname: std::string::String,

    /// KDC server IP address for the active directory machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kdc_ip: std::string::String,

    /// If enabled, will allow access to local users and LDAP users. If access is
    /// needed for only LDAP users, it has to be disabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nfs_users_with_ldap: bool,

    /// Description of the active directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Specifies whether or not the LDAP traffic needs to be signed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ldap_signing: bool,

    /// If enabled, traffic between the SMB server to Domain Controller (DC) will
    /// be encrypted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub encrypt_dc_connections: bool,

    /// Labels for the active directory.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The state details of the Active Directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActiveDirectory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ActiveDirectory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ActiveDirectory::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ActiveDirectory::state].
    pub fn set_state<T: std::convert::Into<crate::model::active_directory::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::ActiveDirectory::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [site][crate::model::ActiveDirectory::site].
    pub fn set_site<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site = v.into();
        self
    }

    /// Sets the value of [dns][crate::model::ActiveDirectory::dns].
    pub fn set_dns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns = v.into();
        self
    }

    /// Sets the value of [net_bios_prefix][crate::model::ActiveDirectory::net_bios_prefix].
    pub fn set_net_bios_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.net_bios_prefix = v.into();
        self
    }

    /// Sets the value of [organizational_unit][crate::model::ActiveDirectory::organizational_unit].
    pub fn set_organizational_unit<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.organizational_unit = v.into();
        self
    }

    /// Sets the value of [aes_encryption][crate::model::ActiveDirectory::aes_encryption].
    pub fn set_aes_encryption<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.aes_encryption = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ActiveDirectory::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::ActiveDirectory::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [backup_operators][crate::model::ActiveDirectory::backup_operators].
    pub fn set_backup_operators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.backup_operators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [administrators][crate::model::ActiveDirectory::administrators].
    pub fn set_administrators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.administrators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_operators][crate::model::ActiveDirectory::security_operators].
    pub fn set_security_operators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.security_operators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kdc_hostname][crate::model::ActiveDirectory::kdc_hostname].
    pub fn set_kdc_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kdc_hostname = v.into();
        self
    }

    /// Sets the value of [kdc_ip][crate::model::ActiveDirectory::kdc_ip].
    pub fn set_kdc_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kdc_ip = v.into();
        self
    }

    /// Sets the value of [nfs_users_with_ldap][crate::model::ActiveDirectory::nfs_users_with_ldap].
    pub fn set_nfs_users_with_ldap<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nfs_users_with_ldap = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ActiveDirectory::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [ldap_signing][crate::model::ActiveDirectory::ldap_signing].
    pub fn set_ldap_signing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ldap_signing = v.into();
        self
    }

    /// Sets the value of [encrypt_dc_connections][crate::model::ActiveDirectory::encrypt_dc_connections].
    pub fn set_encrypt_dc_connections<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.encrypt_dc_connections = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ActiveDirectory::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state_details][crate::model::ActiveDirectory::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }
}

impl wkt::message::Message for ActiveDirectory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ActiveDirectory"
    }
}

/// Defines additional types related to [ActiveDirectory].
pub mod active_directory {
    #[allow(unused_imports)]
    use super::*;

    /// The Active Directory States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Active Directory State
        Unspecified,
        /// Active Directory State is Creating
        Creating,
        /// Active Directory State is Ready
        Ready,
        /// Active Directory State is Updating
        Updating,
        /// Active Directory State is In use
        InUse,
        /// Active Directory State is Deleting
        Deleting,
        /// Active Directory State is Error
        Error,
        /// Active Directory State is Diagnosing.
        Diagnosing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::InUse => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::Diagnosing => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::InUse => std::option::Option::Some("IN_USE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Diagnosing => std::option::Option::Some("DIAGNOSING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                4 => Self::InUse,
                5 => Self::Deleting,
                6 => Self::Error,
                7 => Self::Diagnosing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "IN_USE" => Self::InUse,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "DIAGNOSING" => Self::Diagnosing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::InUse => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::Diagnosing => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.ActiveDirectory.State",
            ))
        }
    }
}

/// A NetApp Backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Identifier. The resource name of the backup.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The backup state.
    pub state: crate::model::backup::State,

    /// A description of the backup with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Size of the file system when the backup was created. When
    /// creating a new volume from the backup, the volume capacity will have to be
    /// at least as big.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub volume_usage_bytes: i64,

    /// Output only. Type of backup, manually created or created by a backup
    /// policy.
    pub backup_type: crate::model::backup::Type,

    /// Volume full name of this backup belongs to.
    /// Format:
    /// `projects/{projects_id}/locations/{location}/volumes/{volume_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_volume: std::string::String,

    /// If specified, backup will be created from the given snapshot.
    /// If not specified, there will be a new snapshot taken to initiate the backup
    /// creation. Format:
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_snapshot: std::option::Option<std::string::String>,

    /// Output only. The time when the backup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Total size of all backups in a chain in bytes = baseline
    /// backup size + sum(incremental backup size)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub chain_storage_bytes: i64,

    /// Output only. Reserved for future use
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [volume_usage_bytes][crate::model::Backup::volume_usage_bytes].
    pub fn set_volume_usage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.volume_usage_bytes = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [source_volume][crate::model::Backup::source_volume].
    pub fn set_source_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_volume = v.into();
        self
    }

    /// Sets the value of [source_snapshot][crate::model::Backup::source_snapshot].
    pub fn set_source_snapshot<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_snapshot = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [chain_storage_bytes][crate::model::Backup::chain_storage_bytes].
    pub fn set_chain_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.chain_storage_bytes = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Backup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Backup"
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// The Backup States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// Backup is being created. While in this state, the snapshot for the backup
        /// point-in-time may not have been created yet, and so the point-in-time may
        /// not have been fixed.
        Creating,
        /// Backup is being uploaded. While in this state, none of the writes to the
        /// volume will be included in the backup.
        Uploading,
        /// Backup is available for use.
        Ready,
        /// Backup is being deleted.
        Deleting,
        /// Backup is not valid and cannot be used for creating new volumes or
        /// restoring existing volumes.
        Error,
        /// Backup is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Uploading => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Updating => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Uploading => std::option::Option::Some("UPLOADING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Uploading,
                3 => Self::Ready,
                4 => Self::Deleting,
                5 => Self::Error,
                6 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPLOADING" => Self::Uploading,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Uploading => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Updating => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Backup.State",
            ))
        }
    }

    /// Backup types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified backup type.
        Unspecified,
        /// Manual backup type.
        Manual,
        /// Scheduled backup type.
        Scheduled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Manual => std::option::Option::Some(1),
                Self::Scheduled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Manual,
                2 => Self::Scheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "MANUAL" => Self::Manual,
                "SCHEDULED" => Self::Scheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Manual => serializer.serialize_i32(1),
                Self::Scheduled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.netapp.v1.Backup.Type",
            ))
        }
    }
}

/// ListBackupsRequest lists backups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The backupVault for which to retrieve backup information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    /// To retrieve backup information for all locations, use "-" for the
    /// `{location}` value.
    /// To retrieve backup information for all backupVaults, use "-" for the
    /// `{backup_vault_id}` value.
    /// To retrieve backup information for a volume, use "-" for the
    /// `{backup_vault_id}` value and specify volume full name with the filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. The service may return fewer
    /// than this value. The maximum value
    /// is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// The standard list filter.
    /// If specified, backups will be returned based on the attribute name that
    /// matches the filter expression. If empty, then no backups are filtered out.
    /// See <https://google.aip.dev/160>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupsRequest"
    }
}

/// ListBackupsResponse is the result of ListBackupsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetBackupRequest gets the state of a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetBackupRequest"
    }
}

/// CreateBackupRequest creates a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. The NetApp backupVault to create the backups of, in the format
    /// `projects/*/locations/*/backupVaults/{backup_vault_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the backup.
    /// The ID must be unique within the specified backupVault.
    /// Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,

    /// Required. A backup resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateBackupRequest"
    }
}

/// DeleteBackupRequest deletes a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. The backup resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteBackupRequest"
    }
}

/// UpdateBackupRequest updates description and/or labels for a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource to be updated.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The backup being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateBackupRequest"
    }
}

/// Backup Policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupPolicy {
    /// Identifier. The resource name of the backup policy.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Number of daily backups to keep. Note that the minimum daily backup limit
    /// is 2.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub daily_backup_limit: std::option::Option<i32>,

    /// Number of weekly backups to keep. Note that the sum of daily, weekly and
    /// monthly backups should be greater than 1.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub weekly_backup_limit: std::option::Option<i32>,

    /// Number of monthly backups to keep. Note that the sum of daily, weekly and
    /// monthly backups should be greater than 1.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monthly_backup_limit: std::option::Option<i32>,

    /// Description of the backup policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// If enabled, make backups automatically according to the schedules.
    /// This will be applied to all volumes that have this policy attached and
    /// enforced on volume level. If not specified, default is true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,

    /// Output only. The total number of volumes assigned by this backup policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assigned_volume_count: std::option::Option<i32>,

    /// Output only. The time when the backup policy was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The backup policy state.
    pub state: crate::model::backup_policy::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [daily_backup_limit][crate::model::BackupPolicy::daily_backup_limit].
    pub fn set_daily_backup_limit<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.daily_backup_limit = v.into();
        self
    }

    /// Sets the value of [weekly_backup_limit][crate::model::BackupPolicy::weekly_backup_limit].
    pub fn set_weekly_backup_limit<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.weekly_backup_limit = v.into();
        self
    }

    /// Sets the value of [monthly_backup_limit][crate::model::BackupPolicy::monthly_backup_limit].
    pub fn set_monthly_backup_limit<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_backup_limit = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupPolicy::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::BackupPolicy::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [assigned_volume_count][crate::model::BackupPolicy::assigned_volume_count].
    pub fn set_assigned_volume_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.assigned_volume_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPolicy::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BackupPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::BackupPolicy::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_policy::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for BackupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.BackupPolicy"
    }
}

/// Defines additional types related to [BackupPolicy].
pub mod backup_policy {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// BackupPolicy is being created.
        Creating,
        /// BackupPolicy is available for use.
        Ready,
        /// BackupPolicy is being deleted.
        Deleting,
        /// BackupPolicy is not valid and cannot be used.
        Error,
        /// BackupPolicy is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Error,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.BackupPolicy.State",
            ))
        }
    }
}

/// CreateBackupPolicyRequest creates a backupPolicy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupPolicyRequest {
    /// Required. The location to create the backup policies of, in the format
    /// `projects/{project_id}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A backupPolicy resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_policy: std::option::Option<crate::model::BackupPolicy>,

    /// Required. The ID to use for the backup policy.
    /// The ID must be unique within the specified location.
    /// Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_policy_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_policy][crate::model::CreateBackupPolicyRequest::backup_policy].
    pub fn set_backup_policy<
        T: std::convert::Into<std::option::Option<crate::model::BackupPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_policy = v.into();
        self
    }

    /// Sets the value of [backup_policy_id][crate::model::CreateBackupPolicyRequest::backup_policy_id].
    pub fn set_backup_policy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_policy_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateBackupPolicyRequest"
    }
}

/// GetBackupPolicyRequest gets the state of a backupPolicy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupPolicyRequest {
    /// Required. The backupPolicy resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetBackupPolicyRequest"
    }
}

/// ListBackupPoliciesRequest for requesting multiple backup policies.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupPoliciesRequest {
    /// Required. Parent value for ListBackupPoliciesRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupPoliciesRequest"
    }
}

/// ListBackupPoliciesResponse contains all the backup policies requested.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupPoliciesResponse {
    /// The list of backup policies.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_policies: std::vec::Vec<crate::model::BackupPolicy>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_policies][crate::model::ListBackupPoliciesResponse::backup_policies].
    pub fn set_backup_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPolicy>,
    {
        use std::iter::Iterator;
        self.backup_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPoliciesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPoliciesResponse {
    type PageItem = crate::model::BackupPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// UpdateBackupPolicyRequest for updating a backup policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupPolicyRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup Policy resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The backup policy being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_policy: std::option::Option<crate::model::BackupPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupPolicyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backup_policy][crate::model::UpdateBackupPolicyRequest::backup_policy].
    pub fn set_backup_policy<
        T: std::convert::Into<std::option::Option<crate::model::BackupPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_policy = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateBackupPolicyRequest"
    }
}

/// DeleteBackupPolicyRequest deletes a backup policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupPolicyRequest {
    /// Required. The backup policy resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteBackupPolicyRequest"
    }
}

/// A NetApp BackupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupVault {
    /// Identifier. The resource name of the backup vault.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The backup vault state.
    pub state: crate::model::backup_vault::State,

    /// Output only. Create time of the backup vault.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Description of the backup vault.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupVault {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupVault::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BackupVault::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_vault::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupVault::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupVault::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BackupVault::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BackupVault {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.BackupVault"
    }
}

/// Defines additional types related to [BackupVault].
pub mod backup_vault {
    #[allow(unused_imports)]
    use super::*;

    /// The Backup Vault States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State not set.
        Unspecified,
        /// BackupVault is being created.
        Creating,
        /// BackupVault is available for use.
        Ready,
        /// BackupVault is being deleted.
        Deleting,
        /// BackupVault is not valid and cannot be used.
        Error,
        /// BackupVault is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                4 => Self::Error,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.BackupVault.State",
            ))
        }
    }
}

/// GetBackupVaultRequest gets the state of a backupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupVaultRequest {
    /// Required. The backupVault resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetBackupVaultRequest"
    }
}

/// ListBackupVaultsRequest lists backupVaults.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupVaultsRequest {
    /// Required. The location for which to retrieve backupVault information,
    /// in the format
    /// `projects/{project_id}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupVaultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupVaultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupVaultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupVaultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupVaultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupVaultsRequest"
    }
}

/// ListBackupVaultsResponse is the result of ListBackupVaultsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupVaultsResponse {
    /// A list of backupVaults in the project for the specified location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_vaults: std::vec::Vec<crate::model::BackupVault>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupVaultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_vaults][crate::model::ListBackupVaultsResponse::backup_vaults].
    pub fn set_backup_vaults<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupVault>,
    {
        use std::iter::Iterator;
        self.backup_vaults = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupVaultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupVaultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupVaultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListBackupVaultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupVaultsResponse {
    type PageItem = crate::model::BackupVault;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_vaults
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// CreateBackupVaultRequest creates a backup vault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupVaultRequest {
    /// Required. The location to create the backup vaults, in the format
    /// `projects/{project_id}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for the backupVault.
    /// The ID must be unique within the specified location.
    /// Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_vault_id: std::string::String,

    /// Required. A backupVault resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupVaultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_vault_id][crate::model::CreateBackupVaultRequest::backup_vault_id].
    pub fn set_backup_vault_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault_id = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::CreateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<
        T: std::convert::Into<std::option::Option<crate::model::BackupVault>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateBackupVaultRequest"
    }
}

/// DeleteBackupVaultRequest deletes a backupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupVaultRequest {
    /// Required. The backupVault resource name, in the format
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupVaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteBackupVaultRequest"
    }
}

/// UpdateBackupVaultRequest updates description and/or labels for a backupVault.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupVaultRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource to be updated.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The backupVault being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_vault: std::option::Option<crate::model::BackupVault>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupVaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupVaultRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backup_vault][crate::model::UpdateBackupVaultRequest::backup_vault].
    pub fn set_backup_vault<
        T: std::convert::Into<std::option::Option<crate::model::BackupVault>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_vault = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupVaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateBackupVaultRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been canceled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.OperationMetadata"
    }
}

/// Metadata for a given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Output only. Supported service levels in a location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_service_levels: std::vec::Vec<crate::model::ServiceLevel>,

    /// Output only. Supported flex performance in a location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_flex_performance: std::vec::Vec<crate::model::FlexPerformance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [supported_service_levels][crate::model::LocationMetadata::supported_service_levels].
    pub fn set_supported_service_levels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceLevel>,
    {
        use std::iter::Iterator;
        self.supported_service_levels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_flex_performance][crate::model::LocationMetadata::supported_flex_performance].
    pub fn set_supported_flex_performance<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FlexPerformance>,
    {
        use std::iter::Iterator;
        self.supported_flex_performance = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.LocationMetadata"
    }
}

/// GetKmsConfigRequest gets a KMS Config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetKmsConfigRequest {
    /// Required. Name of the KmsConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKmsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetKmsConfigRequest"
    }
}

/// ListKmsConfigsRequest lists KMS Configs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKmsConfigsRequest {
    /// Required. Parent value
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKmsConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKmsConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKmsConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKmsConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListKmsConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKmsConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListKmsConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListKmsConfigsRequest"
    }
}

/// ListKmsConfigsResponse is the response to a ListKmsConfigsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKmsConfigsResponse {
    /// The list of KmsConfigs
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub kms_configs: std::vec::Vec<crate::model::KmsConfig>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKmsConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_configs][crate::model::ListKmsConfigsResponse::kms_configs].
    pub fn set_kms_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KmsConfig>,
    {
        use std::iter::Iterator;
        self.kms_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKmsConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListKmsConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListKmsConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListKmsConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKmsConfigsResponse {
    type PageItem = crate::model::KmsConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.kms_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// CreateKmsConfigRequest creates a KMS Config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateKmsConfigRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting KmsConfig. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_config_id: std::string::String,

    /// Required. The required parameters to create a new KmsConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kms_config: std::option::Option<crate::model::KmsConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKmsConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [kms_config_id][crate::model::CreateKmsConfigRequest::kms_config_id].
    pub fn set_kms_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_config_id = v.into();
        self
    }

    /// Sets the value of [kms_config][crate::model::CreateKmsConfigRequest::kms_config].
    pub fn set_kms_config<T: std::convert::Into<std::option::Option<crate::model::KmsConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateKmsConfigRequest"
    }
}

/// UpdateKmsConfigRequest updates a KMS Config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateKmsConfigRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// KmsConfig resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The KmsConfig being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kms_config: std::option::Option<crate::model::KmsConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateKmsConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [kms_config][crate::model::UpdateKmsConfigRequest::kms_config].
    pub fn set_kms_config<T: std::convert::Into<std::option::Option<crate::model::KmsConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_config = v.into();
        self
    }
}

impl wkt::message::Message for UpdateKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateKmsConfigRequest"
    }
}

/// DeleteKmsConfigRequest deletes a KMS Config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteKmsConfigRequest {
    /// Required. Name of the KmsConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteKmsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteKmsConfigRequest"
    }
}

/// EncryptVolumesRequest specifies the KMS config to encrypt existing volumes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptVolumesRequest {
    /// Required. Name of the KmsConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptVolumesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.EncryptVolumesRequest"
    }
}

/// VerifyKmsConfigRequest specifies the KMS config to be validated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyKmsConfigRequest {
    /// Required. Name of the KMS Config to be verified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyKmsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyKmsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for VerifyKmsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.VerifyKmsConfigRequest"
    }
}

/// VerifyKmsConfigResponse contains the information if the config is correctly
/// and error message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyKmsConfigResponse {
    /// Output only. If the customer key configured correctly to the encrypt
    /// volume.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub healthy: bool,

    /// Output only. Error message if config is not healthy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub health_error: std::string::String,

    /// Output only. Instructions for the customers to provide the access to the
    /// encryption key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instructions: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyKmsConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [healthy][crate::model::VerifyKmsConfigResponse::healthy].
    pub fn set_healthy<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.healthy = v.into();
        self
    }

    /// Sets the value of [health_error][crate::model::VerifyKmsConfigResponse::health_error].
    pub fn set_health_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.health_error = v.into();
        self
    }

    /// Sets the value of [instructions][crate::model::VerifyKmsConfigResponse::instructions].
    pub fn set_instructions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instructions = v.into();
        self
    }
}

impl wkt::message::Message for VerifyKmsConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.VerifyKmsConfigResponse"
    }
}

/// KmsConfig is the customer managed encryption key(CMEK) configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KmsConfig {
    /// Identifier. Name of the KmsConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Customer managed crypto key resource full name. Format:
    /// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{key}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crypto_key_name: std::string::String,

    /// Output only. State of the KmsConfig.
    pub state: crate::model::kms_config::State,

    /// Output only. State details of the KmsConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// Output only. Create time of the KmsConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Description of the KmsConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Instructions to provide the access to the customer provided
    /// encryption key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instructions: std::string::String,

    /// Output only. The Service account which will have access to the customer
    /// provided encryption key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KmsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KmsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [crypto_key_name][crate::model::KmsConfig::crypto_key_name].
    pub fn set_crypto_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crypto_key_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::KmsConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::kms_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::KmsConfig::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::KmsConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::KmsConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::KmsConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [instructions][crate::model::KmsConfig::instructions].
    pub fn set_instructions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instructions = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::KmsConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for KmsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.KmsConfig"
    }
}

/// Defines additional types related to [KmsConfig].
pub mod kms_config {
    #[allow(unused_imports)]
    use super::*;

    /// The KmsConfig States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified KmsConfig State
        Unspecified,
        /// KmsConfig State is Ready
        Ready,
        /// KmsConfig State is Creating
        Creating,
        /// KmsConfig State is Deleting
        Deleting,
        /// KmsConfig State is Updating
        Updating,
        /// KmsConfig State is In Use.
        InUse,
        /// KmsConfig State is Error
        Error,
        /// KmsConfig State is Pending to verify crypto key access.
        KeyCheckPending,
        /// KmsConfig State is Not accessbile by the SDE service account to the
        /// crypto key.
        KeyNotReachable,
        /// KmsConfig State is Disabling.
        Disabling,
        /// KmsConfig State is Disabled.
        Disabled,
        /// KmsConfig State is Migrating.
        /// The existing volumes are migrating from SMEK to CMEK.
        Migrating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::InUse => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::KeyCheckPending => std::option::Option::Some(7),
                Self::KeyNotReachable => std::option::Option::Some(8),
                Self::Disabling => std::option::Option::Some(9),
                Self::Disabled => std::option::Option::Some(10),
                Self::Migrating => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::InUse => std::option::Option::Some("IN_USE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::KeyCheckPending => std::option::Option::Some("KEY_CHECK_PENDING"),
                Self::KeyNotReachable => std::option::Option::Some("KEY_NOT_REACHABLE"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Migrating => std::option::Option::Some("MIGRATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::InUse,
                6 => Self::Error,
                7 => Self::KeyCheckPending,
                8 => Self::KeyNotReachable,
                9 => Self::Disabling,
                10 => Self::Disabled,
                11 => Self::Migrating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "IN_USE" => Self::InUse,
                "ERROR" => Self::Error,
                "KEY_CHECK_PENDING" => Self::KeyCheckPending,
                "KEY_NOT_REACHABLE" => Self::KeyNotReachable,
                "DISABLING" => Self::Disabling,
                "DISABLED" => Self::Disabled,
                "MIGRATING" => Self::Migrating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::InUse => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::KeyCheckPending => serializer.serialize_i32(7),
                Self::KeyNotReachable => serializer.serialize_i32(8),
                Self::Disabling => serializer.serialize_i32(9),
                Self::Disabled => serializer.serialize_i32(10),
                Self::Migrating => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.KmsConfig.State",
            ))
        }
    }
}

/// ListQuotaRulesRequest for listing quota rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQuotaRulesRequest {
    /// Required. Parent value for ListQuotaRulesRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, the server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQuotaRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQuotaRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQuotaRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQuotaRulesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListQuotaRulesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListQuotaRulesRequest"
    }
}

/// ListQuotaRulesResponse is the response to a ListQuotaRulesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQuotaRulesResponse {
    /// List of quota rules
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quota_rules: std::vec::Vec<crate::model::QuotaRule>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota_rules][crate::model::ListQuotaRulesResponse::quota_rules].
    pub fn set_quota_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaRule>,
    {
        use std::iter::Iterator;
        self.quota_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQuotaRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListQuotaRulesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListQuotaRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListQuotaRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQuotaRulesResponse {
    type PageItem = crate::model::QuotaRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.quota_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetQuotaRuleRequest for getting a quota rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQuotaRuleRequest {
    /// Required. Name of the quota rule
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQuotaRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetQuotaRuleRequest"
    }
}

/// CreateQuotaRuleRequest for creating a quota rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateQuotaRuleRequest {
    /// Required. Parent value for CreateQuotaRuleRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Fields of the to be created quota rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quota_rule: std::option::Option<crate::model::QuotaRule>,

    /// Required. ID of the quota rule to create. Must be unique within the parent
    /// resource. Must contain only letters, numbers, underscore and hyphen, with
    /// the first character a letter or underscore, the last a letter or underscore
    /// or a number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub quota_rule_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQuotaRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [quota_rule][crate::model::CreateQuotaRuleRequest::quota_rule].
    pub fn set_quota_rule<T: std::convert::Into<std::option::Option<crate::model::QuotaRule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_rule = v.into();
        self
    }

    /// Sets the value of [quota_rule_id][crate::model::CreateQuotaRuleRequest::quota_rule_id].
    pub fn set_quota_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quota_rule_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateQuotaRuleRequest"
    }
}

/// UpdateQuotaRuleRequest for updating a quota rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateQuotaRuleRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Quota Rule resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The quota rule being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quota_rule: std::option::Option<crate::model::QuotaRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateQuotaRuleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [quota_rule][crate::model::UpdateQuotaRuleRequest::quota_rule].
    pub fn set_quota_rule<T: std::convert::Into<std::option::Option<crate::model::QuotaRule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_rule = v.into();
        self
    }
}

impl wkt::message::Message for UpdateQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateQuotaRuleRequest"
    }
}

/// DeleteQuotaRuleRequest for deleting a single quota rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteQuotaRuleRequest {
    /// Required. Name of the quota rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQuotaRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQuotaRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQuotaRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteQuotaRuleRequest"
    }
}

/// QuotaRule specifies the maximum disk space a user or group can use within a
/// volume. They can be used for creating default and individual quota rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaRule {
    /// Identifier. The resource name of the quota rule.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/volumes/volumes/{volume_id}/quotaRules/{quota_rule_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The quota rule applies to the specified user or group, identified
    /// by a Unix UID/GID, Windows SID, or null for default.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Required. The type of quota rule.
    #[serde(rename = "type")]
    pub r#type: crate::model::quota_rule::Type,

    /// Required. The maximum allowed disk space in MiB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disk_limit_mib: i32,

    /// Output only. State of the quota rule
    pub state: crate::model::quota_rule::State,

    /// Output only. State details of the quota rule
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// Output only. Create time of the quota rule
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the quota rule
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Labels of the quota rule
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QuotaRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::QuotaRule::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::QuotaRule::type].
    pub fn set_type<T: std::convert::Into<crate::model::quota_rule::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [disk_limit_mib][crate::model::QuotaRule::disk_limit_mib].
    pub fn set_disk_limit_mib<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_limit_mib = v.into();
        self
    }

    /// Sets the value of [state][crate::model::QuotaRule::state].
    pub fn set_state<T: std::convert::Into<crate::model::quota_rule::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::QuotaRule::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QuotaRule::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::QuotaRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::QuotaRule::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for QuotaRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.QuotaRule"
    }
}

/// Defines additional types related to [QuotaRule].
pub mod quota_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Types of Quota Rule
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified type for quota rule
        Unspecified,
        /// Individual user quota rule
        IndividualUserQuota,
        /// Individual group quota rule
        IndividualGroupQuota,
        /// Default user quota rule
        DefaultUserQuota,
        /// Default group quota rule
        DefaultGroupQuota,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::IndividualUserQuota => std::option::Option::Some(1),
                Self::IndividualGroupQuota => std::option::Option::Some(2),
                Self::DefaultUserQuota => std::option::Option::Some(3),
                Self::DefaultGroupQuota => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::IndividualUserQuota => std::option::Option::Some("INDIVIDUAL_USER_QUOTA"),
                Self::IndividualGroupQuota => std::option::Option::Some("INDIVIDUAL_GROUP_QUOTA"),
                Self::DefaultUserQuota => std::option::Option::Some("DEFAULT_USER_QUOTA"),
                Self::DefaultGroupQuota => std::option::Option::Some("DEFAULT_GROUP_QUOTA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::IndividualUserQuota,
                2 => Self::IndividualGroupQuota,
                3 => Self::DefaultUserQuota,
                4 => Self::DefaultGroupQuota,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INDIVIDUAL_USER_QUOTA" => Self::IndividualUserQuota,
                "INDIVIDUAL_GROUP_QUOTA" => Self::IndividualGroupQuota,
                "DEFAULT_USER_QUOTA" => Self::DefaultUserQuota,
                "DEFAULT_GROUP_QUOTA" => Self::DefaultGroupQuota,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::IndividualUserQuota => serializer.serialize_i32(1),
                Self::IndividualGroupQuota => serializer.serialize_i32(2),
                Self::DefaultUserQuota => serializer.serialize_i32(3),
                Self::DefaultGroupQuota => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.netapp.v1.QuotaRule.Type",
            ))
        }
    }

    /// Quota Rule states
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state for quota rule
        Unspecified,
        /// Quota rule is creating
        Creating,
        /// Quota rule is updating
        Updating,
        /// Quota rule is deleting
        Deleting,
        /// Quota rule is ready
        Ready,
        /// Quota rule is in error state.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Ready => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Updating,
                3 => Self::Deleting,
                4 => Self::Ready,
                5 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "READY" => Self::Ready,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Ready => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.QuotaRule.State",
            ))
        }
    }
}

/// TransferStats reports all statistics related to replication transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransferStats {
    /// Cumulative bytes trasferred so far for the replication relatinonship.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub transfer_bytes: std::option::Option<i64>,

    /// Cumulative time taken across all transfers for the replication
    /// relationship.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_transfer_duration: std::option::Option<wkt::Duration>,

    /// Last transfer size in bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub last_transfer_bytes: std::option::Option<i64>,

    /// Time taken during last transfer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_transfer_duration: std::option::Option<wkt::Duration>,

    /// Lag duration indicates the duration by which Destination region volume
    /// content lags behind the primary region volume content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lag_duration: std::option::Option<wkt::Duration>,

    /// Time when progress was updated last.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Time when last transfer completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_transfer_end_time: std::option::Option<wkt::Timestamp>,

    /// A message describing the cause of the last transfer failure.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_transfer_error: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransferStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transfer_bytes][crate::model::TransferStats::transfer_bytes].
    pub fn set_transfer_bytes<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_bytes = v.into();
        self
    }

    /// Sets the value of [total_transfer_duration][crate::model::TransferStats::total_transfer_duration].
    pub fn set_total_transfer_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.total_transfer_duration = v.into();
        self
    }

    /// Sets the value of [last_transfer_bytes][crate::model::TransferStats::last_transfer_bytes].
    pub fn set_last_transfer_bytes<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_transfer_bytes = v.into();
        self
    }

    /// Sets the value of [last_transfer_duration][crate::model::TransferStats::last_transfer_duration].
    pub fn set_last_transfer_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_transfer_duration = v.into();
        self
    }

    /// Sets the value of [lag_duration][crate::model::TransferStats::lag_duration].
    pub fn set_lag_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lag_duration = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TransferStats::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_transfer_end_time][crate::model::TransferStats::last_transfer_end_time].
    pub fn set_last_transfer_end_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_transfer_end_time = v.into();
        self
    }

    /// Sets the value of [last_transfer_error][crate::model::TransferStats::last_transfer_error].
    pub fn set_last_transfer_error<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_transfer_error = v.into();
        self
    }
}

impl wkt::message::Message for TransferStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.TransferStats"
    }
}

/// Replication is a nested resource under Volume, that describes a
/// cross-region replication relationship between 2 volumes in different
/// regions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Replication {
    /// Identifier. The resource name of the Replication.
    /// Format:
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. State of the replication.
    pub state: crate::model::replication::State,

    /// Output only. State details of the replication.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// Output only. Indicates whether this points to source or destination.
    pub role: crate::model::replication::ReplicationRole,

    /// Required. Indicates the schedule for replication.
    pub replication_schedule: crate::model::replication::ReplicationSchedule,

    /// Output only. Indicates the state of mirroring.
    pub mirror_state: crate::model::replication::MirrorState,

    /// Output only. Condition of the relationship. Can be one of the following:
    ///
    /// - true: The replication relationship is healthy. It has not missed the most
    ///   recent scheduled transfer.
    /// - false: The replication relationship is not healthy. It has missed the
    ///   most recent scheduled transfer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub healthy: std::option::Option<bool>,

    /// Output only. Replication create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Full name of destination volume resource.
    /// Example : "projects/{project}/locations/{location}/volumes/{volume_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_volume: std::string::String,

    /// Output only. Replication transfer statistics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transfer_stats: std::option::Option<crate::model::TransferStats>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A description about this replication relationship.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Required. Input only. Destination volume parameters
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_volume_parameters:
        std::option::Option<crate::model::DestinationVolumeParameters>,

    /// Output only. Full name of source volume resource.
    /// Example : "projects/{project}/locations/{location}/volumes/{volume_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_volume: std::string::String,

    /// Output only. Hybrid peering details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hybrid_peering_details: std::option::Option<crate::model::HybridPeeringDetails>,

    /// Optional. Location of the user cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_location: std::string::String,

    /// Output only. Type of the hybrid replication.
    pub hybrid_replication_type: crate::model::replication::HybridReplicationType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Replication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Replication::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Replication::state].
    pub fn set_state<T: std::convert::Into<crate::model::replication::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::Replication::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [role][crate::model::Replication::role].
    pub fn set_role<T: std::convert::Into<crate::model::replication::ReplicationRole>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [replication_schedule][crate::model::Replication::replication_schedule].
    pub fn set_replication_schedule<
        T: std::convert::Into<crate::model::replication::ReplicationSchedule>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_schedule = v.into();
        self
    }

    /// Sets the value of [mirror_state][crate::model::Replication::mirror_state].
    pub fn set_mirror_state<T: std::convert::Into<crate::model::replication::MirrorState>>(
        mut self,
        v: T,
    ) -> Self {
        self.mirror_state = v.into();
        self
    }

    /// Sets the value of [healthy][crate::model::Replication::healthy].
    pub fn set_healthy<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.healthy = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Replication::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [destination_volume][crate::model::Replication::destination_volume].
    pub fn set_destination_volume<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_volume = v.into();
        self
    }

    /// Sets the value of [transfer_stats][crate::model::Replication::transfer_stats].
    pub fn set_transfer_stats<
        T: std::convert::Into<std::option::Option<crate::model::TransferStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_stats = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Replication::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Replication::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [destination_volume_parameters][crate::model::Replication::destination_volume_parameters].
    pub fn set_destination_volume_parameters<
        T: std::convert::Into<std::option::Option<crate::model::DestinationVolumeParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_volume_parameters = v.into();
        self
    }

    /// Sets the value of [source_volume][crate::model::Replication::source_volume].
    pub fn set_source_volume<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_volume = v.into();
        self
    }

    /// Sets the value of [hybrid_peering_details][crate::model::Replication::hybrid_peering_details].
    pub fn set_hybrid_peering_details<
        T: std::convert::Into<std::option::Option<crate::model::HybridPeeringDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_peering_details = v.into();
        self
    }

    /// Sets the value of [cluster_location][crate::model::Replication::cluster_location].
    pub fn set_cluster_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_location = v.into();
        self
    }

    /// Sets the value of [hybrid_replication_type][crate::model::Replication::hybrid_replication_type].
    pub fn set_hybrid_replication_type<
        T: std::convert::Into<crate::model::replication::HybridReplicationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_replication_type = v.into();
        self
    }
}

impl wkt::message::Message for Replication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Replication"
    }
}

/// Defines additional types related to [Replication].
pub mod replication {
    #[allow(unused_imports)]
    use super::*;

    /// The replication states
    /// New enum values may be added in future to indicate possible new states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified replication State
        Unspecified,
        /// Replication is creating.
        Creating,
        /// Replication is ready.
        Ready,
        /// Replication is updating.
        Updating,
        /// Replication is deleting.
        Deleting,
        /// Replication is in error state.
        Error,
        /// Replication is waiting for cluster peering to be established.
        PendingClusterPeering,
        /// Replication is waiting for SVM peering to be established.
        PendingSvmPeering,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::PendingClusterPeering => std::option::Option::Some(8),
                Self::PendingSvmPeering => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::PendingClusterPeering => std::option::Option::Some("PENDING_CLUSTER_PEERING"),
                Self::PendingSvmPeering => std::option::Option::Some("PENDING_SVM_PEERING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                5 => Self::Deleting,
                6 => Self::Error,
                8 => Self::PendingClusterPeering,
                9 => Self::PendingSvmPeering,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "PENDING_CLUSTER_PEERING" => Self::PendingClusterPeering,
                "PENDING_SVM_PEERING" => Self::PendingSvmPeering,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::PendingClusterPeering => serializer.serialize_i32(8),
                Self::PendingSvmPeering => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Replication.State",
            ))
        }
    }

    /// New enum values may be added in future to support different replication
    /// topology.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicationRole {
        /// Unspecified replication role
        Unspecified,
        /// Indicates Source volume.
        Source,
        /// Indicates Destination volume.
        Destination,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicationRole::value] or
        /// [ReplicationRole::name].
        UnknownValue(replication_role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replication_role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicationRole {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Source => std::option::Option::Some(1),
                Self::Destination => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPLICATION_ROLE_UNSPECIFIED"),
                Self::Source => std::option::Option::Some("SOURCE"),
                Self::Destination => std::option::Option::Some("DESTINATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicationRole {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicationRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicationRole {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Source,
                2 => Self::Destination,
                _ => Self::UnknownValue(replication_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicationRole {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPLICATION_ROLE_UNSPECIFIED" => Self::Unspecified,
                "SOURCE" => Self::Source,
                "DESTINATION" => Self::Destination,
                _ => Self::UnknownValue(replication_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicationRole {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Source => serializer.serialize_i32(1),
                Self::Destination => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicationRole {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicationRole>::new(
                ".google.cloud.netapp.v1.Replication.ReplicationRole",
            ))
        }
    }

    /// Schedule for Replication.
    /// New enum values may be added in future to support different frequency of
    /// replication.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicationSchedule {
        /// Unspecified ReplicationSchedule
        Unspecified,
        /// Replication happens once every 10 minutes.
        Every10Minutes,
        /// Replication happens once every hour.
        Hourly,
        /// Replication happens once every day.
        Daily,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicationSchedule::value] or
        /// [ReplicationSchedule::name].
        UnknownValue(replication_schedule::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replication_schedule {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicationSchedule {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Every10Minutes => std::option::Option::Some(1),
                Self::Hourly => std::option::Option::Some(2),
                Self::Daily => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPLICATION_SCHEDULE_UNSPECIFIED"),
                Self::Every10Minutes => std::option::Option::Some("EVERY_10_MINUTES"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicationSchedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicationSchedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicationSchedule {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Every10Minutes,
                2 => Self::Hourly,
                3 => Self::Daily,
                _ => Self::UnknownValue(replication_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicationSchedule {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPLICATION_SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                "EVERY_10_MINUTES" => Self::Every10Minutes,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                _ => Self::UnknownValue(replication_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicationSchedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Every10Minutes => serializer.serialize_i32(1),
                Self::Hourly => serializer.serialize_i32(2),
                Self::Daily => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicationSchedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicationSchedule>::new(
                ".google.cloud.netapp.v1.Replication.ReplicationSchedule",
            ))
        }
    }

    /// Mirroring states.
    /// No new value is expected to be added in future.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MirrorState {
        /// Unspecified MirrorState
        Unspecified,
        /// Destination volume is being prepared.
        Preparing,
        /// Destination volume has been initialized and is ready to receive
        /// replication transfers.
        Mirrored,
        /// Destination volume is not receiving replication transfers.
        Stopped,
        /// Incremental replication is in progress.
        Transferring,
        /// Baseline replication is in progress.
        BaselineTransferring,
        /// Replication is aborted.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MirrorState::value] or
        /// [MirrorState::name].
        UnknownValue(mirror_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mirror_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MirrorState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Preparing => std::option::Option::Some(1),
                Self::Mirrored => std::option::Option::Some(2),
                Self::Stopped => std::option::Option::Some(3),
                Self::Transferring => std::option::Option::Some(4),
                Self::BaselineTransferring => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIRROR_STATE_UNSPECIFIED"),
                Self::Preparing => std::option::Option::Some("PREPARING"),
                Self::Mirrored => std::option::Option::Some("MIRRORED"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Transferring => std::option::Option::Some("TRANSFERRING"),
                Self::BaselineTransferring => std::option::Option::Some("BASELINE_TRANSFERRING"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MirrorState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MirrorState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MirrorState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Preparing,
                2 => Self::Mirrored,
                3 => Self::Stopped,
                4 => Self::Transferring,
                5 => Self::BaselineTransferring,
                6 => Self::Aborted,
                _ => Self::UnknownValue(mirror_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MirrorState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIRROR_STATE_UNSPECIFIED" => Self::Unspecified,
                "PREPARING" => Self::Preparing,
                "MIRRORED" => Self::Mirrored,
                "STOPPED" => Self::Stopped,
                "TRANSFERRING" => Self::Transferring,
                "BASELINE_TRANSFERRING" => Self::BaselineTransferring,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(mirror_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MirrorState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Preparing => serializer.serialize_i32(1),
                Self::Mirrored => serializer.serialize_i32(2),
                Self::Stopped => serializer.serialize_i32(3),
                Self::Transferring => serializer.serialize_i32(4),
                Self::BaselineTransferring => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MirrorState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MirrorState>::new(
                ".google.cloud.netapp.v1.Replication.MirrorState",
            ))
        }
    }

    /// Hybrid replication type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HybridReplicationType {
        /// Unspecified hybrid replication type.
        Unspecified,
        /// Hybrid replication type for migration.
        Migration,
        /// Hybrid replication type for continuous replication.
        ContinuousReplication,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HybridReplicationType::value] or
        /// [HybridReplicationType::name].
        UnknownValue(hybrid_replication_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod hybrid_replication_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HybridReplicationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Migration => std::option::Option::Some(1),
                Self::ContinuousReplication => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("HYBRID_REPLICATION_TYPE_UNSPECIFIED")
                }
                Self::Migration => std::option::Option::Some("MIGRATION"),
                Self::ContinuousReplication => std::option::Option::Some("CONTINUOUS_REPLICATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HybridReplicationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HybridReplicationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HybridReplicationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Migration,
                2 => Self::ContinuousReplication,
                _ => Self::UnknownValue(hybrid_replication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HybridReplicationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HYBRID_REPLICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MIGRATION" => Self::Migration,
                "CONTINUOUS_REPLICATION" => Self::ContinuousReplication,
                _ => Self::UnknownValue(hybrid_replication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HybridReplicationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Migration => serializer.serialize_i32(1),
                Self::ContinuousReplication => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HybridReplicationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HybridReplicationType>::new(
                ".google.cloud.netapp.v1.Replication.HybridReplicationType",
            ))
        }
    }
}

/// HybridPeeringDetails contains details about the hybrid peering.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridPeeringDetails {
    /// Optional. IP address of the subnet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_ip: std::string::String,

    /// Optional. Copy-paste-able commands to be used on user's ONTAP to accept
    /// peering requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub command: std::string::String,

    /// Optional. Expiration time for the peering command to be executed on user's
    /// ONTAP.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub command_expiry_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Temporary passphrase generated to accept cluster peering command.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub passphrase: std::string::String,

    /// Optional. Name of the user's local source volume to be peered with the
    /// destination volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_volume_name: std::string::String,

    /// Optional. Name of the user's local source cluster to be peered with the
    /// destination cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_cluster_name: std::string::String,

    /// Optional. Name of the user's local source vserver svm to be peered with the
    /// destination vserver svm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_svm_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridPeeringDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnet_ip][crate::model::HybridPeeringDetails::subnet_ip].
    pub fn set_subnet_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet_ip = v.into();
        self
    }

    /// Sets the value of [command][crate::model::HybridPeeringDetails::command].
    pub fn set_command<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.command = v.into();
        self
    }

    /// Sets the value of [command_expiry_time][crate::model::HybridPeeringDetails::command_expiry_time].
    pub fn set_command_expiry_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.command_expiry_time = v.into();
        self
    }

    /// Sets the value of [passphrase][crate::model::HybridPeeringDetails::passphrase].
    pub fn set_passphrase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.passphrase = v.into();
        self
    }

    /// Sets the value of [peer_volume_name][crate::model::HybridPeeringDetails::peer_volume_name].
    pub fn set_peer_volume_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_volume_name = v.into();
        self
    }

    /// Sets the value of [peer_cluster_name][crate::model::HybridPeeringDetails::peer_cluster_name].
    pub fn set_peer_cluster_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_cluster_name = v.into();
        self
    }

    /// Sets the value of [peer_svm_name][crate::model::HybridPeeringDetails::peer_svm_name].
    pub fn set_peer_svm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_svm_name = v.into();
        self
    }
}

impl wkt::message::Message for HybridPeeringDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.HybridPeeringDetails"
    }
}

/// ListReplications lists replications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReplicationsRequest {
    /// Required. The volume for which to retrieve replication information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReplicationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReplicationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReplicationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReplicationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReplicationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListReplicationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListReplicationsRequest"
    }
}

/// ListReplicationsResponse is the result of ListReplicationsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReplicationsResponse {
    /// A list of replications in the project for the specified volume.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replications: std::vec::Vec<crate::model::Replication>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replications][crate::model::ListReplicationsResponse::replications].
    pub fn set_replications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Replication>,
    {
        use std::iter::Iterator;
        self.replications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReplicationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReplicationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReplicationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListReplicationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReplicationsResponse {
    type PageItem = crate::model::Replication;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.replications
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetReplicationRequest gets the state of a replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReplicationRequest {
    /// Required. The replication resource name, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetReplicationRequest"
    }
}

/// DestinationVolumeParameters specify input parameters used for creating
/// destination volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestinationVolumeParameters {
    /// Required. Existing destination StoragePool name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_pool: std::string::String,

    /// Desired destination volume resource id. If not specified, source volume's
    /// resource id will be used.
    /// This value must start with a lowercase letter followed by up to 62
    /// lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume_id: std::string::String,

    /// Destination volume's share name. If not specified, source volume's share
    /// name will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub share_name: std::string::String,

    /// Description for the destination volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Optional. Tiering policy for the volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tiering_policy: std::option::Option<crate::model::TieringPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestinationVolumeParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_pool][crate::model::DestinationVolumeParameters::storage_pool].
    pub fn set_storage_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool = v.into();
        self
    }

    /// Sets the value of [volume_id][crate::model::DestinationVolumeParameters::volume_id].
    pub fn set_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_id = v.into();
        self
    }

    /// Sets the value of [share_name][crate::model::DestinationVolumeParameters::share_name].
    pub fn set_share_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.share_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DestinationVolumeParameters::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [tiering_policy][crate::model::DestinationVolumeParameters::tiering_policy].
    pub fn set_tiering_policy<
        T: std::convert::Into<std::option::Option<crate::model::TieringPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tiering_policy = v.into();
        self
    }
}

impl wkt::message::Message for DestinationVolumeParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DestinationVolumeParameters"
    }
}

/// CreateReplicationRequest creates a replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReplicationRequest {
    /// Required. The NetApp volume to create the replications of, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A replication resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication: std::option::Option<crate::model::Replication>,

    /// Required. ID of the replication to create. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub replication_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReplicationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [replication][crate::model::CreateReplicationRequest::replication].
    pub fn set_replication<
        T: std::convert::Into<std::option::Option<crate::model::Replication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication = v.into();
        self
    }

    /// Sets the value of [replication_id][crate::model::CreateReplicationRequest::replication_id].
    pub fn set_replication_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replication_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateReplicationRequest"
    }
}

/// DeleteReplicationRequest deletes a replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteReplicationRequest {
    /// Required. The replication resource name, in the format
    /// `projects/*/locations/*/volumes/*/replications/{replication_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteReplicationRequest"
    }
}

/// UpdateReplicationRequest updates description and/or labels for a replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateReplicationRequest {
    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A replication resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication: std::option::Option<crate::model::Replication>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateReplicationRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [replication][crate::model::UpdateReplicationRequest::replication].
    pub fn set_replication<
        T: std::convert::Into<std::option::Option<crate::model::Replication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication = v.into();
        self
    }
}

impl wkt::message::Message for UpdateReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateReplicationRequest"
    }
}

/// StopReplicationRequest stops a replication until resumed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopReplicationRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates whether to stop replication forcefully while data transfer is in
    /// progress.
    /// Warning! if force is true, this will abort any current transfers
    /// and can lead to data loss due to partial transfer.
    /// If force is false, stop replication will fail while data transfer is in
    /// progress and you will need to retry later.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::StopReplicationRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for StopReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.StopReplicationRequest"
    }
}

/// ResumeReplicationRequest resumes a stopped replication.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeReplicationRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ResumeReplicationRequest"
    }
}

/// ReverseReplicationDirectionRequest reverses direction of replication. Source
/// becomes destination and destination becomes source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReverseReplicationDirectionRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReverseReplicationDirectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReverseReplicationDirectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ReverseReplicationDirectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ReverseReplicationDirectionRequest"
    }
}

/// EstablishPeeringRequest establishes cluster and svm peerings between the
/// source and the destination replications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EstablishPeeringRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Name of the user's local source cluster to be peered with the
    /// destination cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_cluster_name: std::string::String,

    /// Required. Name of the user's local source vserver svm to be peered with the
    /// destination vserver svm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_svm_name: std::string::String,

    /// Optional. List of IPv4 ip addresses to be used for peering.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub peer_ip_addresses: std::vec::Vec<std::string::String>,

    /// Required. Name of the user's local source volume to be peered with the
    /// destination volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_volume_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EstablishPeeringRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EstablishPeeringRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [peer_cluster_name][crate::model::EstablishPeeringRequest::peer_cluster_name].
    pub fn set_peer_cluster_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_cluster_name = v.into();
        self
    }

    /// Sets the value of [peer_svm_name][crate::model::EstablishPeeringRequest::peer_svm_name].
    pub fn set_peer_svm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_svm_name = v.into();
        self
    }

    /// Sets the value of [peer_ip_addresses][crate::model::EstablishPeeringRequest::peer_ip_addresses].
    pub fn set_peer_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [peer_volume_name][crate::model::EstablishPeeringRequest::peer_volume_name].
    pub fn set_peer_volume_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_volume_name = v.into();
        self
    }
}

impl wkt::message::Message for EstablishPeeringRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.EstablishPeeringRequest"
    }
}

/// SyncReplicationRequest syncs the replication from source to destination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncReplicationRequest {
    /// Required. The resource name of the replication, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyncReplicationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SyncReplicationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SyncReplicationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SyncReplicationRequest"
    }
}

/// ListSnapshotsRequest lists snapshots.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The volume for which to retrieve snapshot information,
    /// in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSnapshotsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSnapshotsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListSnapshotsRequest"
    }
}

/// ListSnapshotsResponse is the result of ListSnapshotsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// A list of snapshots in the project for the specified volume.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// The token you can use to retrieve the next page of results. Not returned
    /// if there are no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSnapshotsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetSnapshotRequest gets the state of a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetSnapshotRequest"
    }
}

/// CreateSnapshotRequest creates a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. The NetApp volume to create the snapshots of, in the format
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A snapshot resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,

    /// Required. ID of the snapshot to create. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a
    /// number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::CreateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::CreateSnapshotRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateSnapshotRequest"
    }
}

/// DeleteSnapshotRequest deletes a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The snapshot resource name, in the format
    /// `projects/*/locations/*/volumes/*/snapshots/{snapshot_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteSnapshotRequest"
    }
}

/// UpdateSnapshotRequest updates description and/or labels for a snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. Mask of fields to update.  At least one path must be supplied in
    /// this field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. A snapshot resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::Snapshot>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::Snapshot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateSnapshotRequest"
    }
}

/// Snapshot is a point-in-time version of a Volume's content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Snapshot {
    /// Identifier. The resource name of the snapshot.
    /// Format:
    /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The snapshot state.
    pub state: crate::model::snapshot::State,

    /// Output only. State details of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// A description of the snapshot with 2048 characters or less.
    /// Requests with longer descriptions will be rejected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Current storage usage for the snapshot in bytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub used_bytes: f64,

    /// Output only. The time when the snapshot was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource labels to represent user provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::Snapshot::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [used_bytes][crate::model::Snapshot::used_bytes].
    pub fn set_used_bytes<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.used_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Snapshot"
    }
}

/// Defines additional types related to [Snapshot].
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// The Snapshot States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Snapshot State
        Unspecified,
        /// Snapshot State is Ready
        Ready,
        /// Snapshot State is Creating
        Creating,
        /// Snapshot State is Deleting
        Deleting,
        /// Snapshot State is Updating
        Updating,
        /// Snapshot State is Disabled
        Disabled,
        /// Snapshot State is Error
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Disabled => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::Disabled,
                6 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "DISABLED" => Self::Disabled,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Disabled => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Snapshot.State",
            ))
        }
    }
}

/// GetStoragePoolRequest gets a Storage Pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStoragePoolRequest {
    /// Required. Name of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStoragePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetStoragePoolRequest"
    }
}

/// ListStoragePoolsRequest lists Storage Pools.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStoragePoolsRequest {
    /// Required. Parent value
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The next_page_token value to use if there are additional
    /// results to retrieve for this list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Sort results. Supported values are "name", "name desc" or ""
    /// (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoragePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListStoragePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListStoragePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListStoragePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListStoragePoolsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListStoragePoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListStoragePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListStoragePoolsRequest"
    }
}

/// ListStoragePoolsResponse is the response to a ListStoragePoolsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListStoragePoolsResponse {
    /// The list of StoragePools
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub storage_pools: std::vec::Vec<crate::model::StoragePool>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListStoragePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_pools][crate::model::ListStoragePoolsResponse::storage_pools].
    pub fn set_storage_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StoragePool>,
    {
        use std::iter::Iterator;
        self.storage_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListStoragePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListStoragePoolsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListStoragePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListStoragePoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListStoragePoolsResponse {
    type PageItem = crate::model::StoragePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.storage_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// CreateStoragePoolRequest creates a Storage Pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStoragePoolRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting storage pool. Must be unique within the
    /// parent resource. Must contain only letters, numbers and hyphen, with the
    /// first character a letter, the last a letter or a number, and a 63 character
    /// maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_pool_id: std::string::String,

    /// Required. The required parameters to create a new storage pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_pool: std::option::Option<crate::model::StoragePool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateStoragePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [storage_pool_id][crate::model::CreateStoragePoolRequest::storage_pool_id].
    pub fn set_storage_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool_id = v.into();
        self
    }

    /// Sets the value of [storage_pool][crate::model::CreateStoragePoolRequest::storage_pool].
    pub fn set_storage_pool<
        T: std::convert::Into<std::option::Option<crate::model::StoragePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_pool = v.into();
        self
    }
}

impl wkt::message::Message for CreateStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateStoragePoolRequest"
    }
}

/// UpdateStoragePoolRequest updates a Storage Pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateStoragePoolRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// StoragePool resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The pool being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_pool: std::option::Option<crate::model::StoragePool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateStoragePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [storage_pool][crate::model::UpdateStoragePoolRequest::storage_pool].
    pub fn set_storage_pool<
        T: std::convert::Into<std::option::Option<crate::model::StoragePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_pool = v.into();
        self
    }
}

impl wkt::message::Message for UpdateStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateStoragePoolRequest"
    }
}

/// DeleteStoragePoolRequest deletes a Storage Pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteStoragePoolRequest {
    /// Required. Name of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteStoragePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteStoragePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteStoragePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteStoragePoolRequest"
    }
}

/// SwitchActiveReplicaZoneRequest switch the active/replica zone for a regional
/// storagePool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SwitchActiveReplicaZoneRequest {
    /// Required. Name of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SwitchActiveReplicaZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SwitchActiveReplicaZoneRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SwitchActiveReplicaZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SwitchActiveReplicaZoneRequest"
    }
}

/// StoragePool is a container for volumes with a service level and capacity.
/// Volumes can be created in a pool of sufficient available capacity.
/// StoragePool capacity is what you are billed for.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoragePool {
    /// Identifier. Name of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Service level of the storage pool
    pub service_level: crate::model::ServiceLevel,

    /// Required. Capacity in GIB of the pool
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gib: i64,

    /// Output only. Allocated size of all volumes in GIB in the storage pool
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub volume_capacity_gib: i64,

    /// Output only. Volume count of the storage pool
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub volume_count: i32,

    /// Output only. State of the storage pool
    pub state: crate::model::storage_pool::State,

    /// Output only. State details of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// Output only. Create time of the storage pool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. VPC Network name.
    /// Format: projects/{project}/global/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. Specifies the Active Directory to be used for creating a SMB
    /// volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub active_directory: std::string::String,

    /// Optional. Specifies the KMS config to be used for volume encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_config: std::string::String,

    /// Optional. Flag indicating if the pool is NFS LDAP enabled or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ldap_enabled: bool,

    /// Optional. This field is not implemented. The values provided in this field
    /// are ignored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psa_range: std::string::String,

    /// Output only. Specifies the current pool encryption key source.
    pub encryption_type: crate::model::EncryptionType,

    /// Deprecated. Used to allow SO pool to access AD or DNS server from other
    /// regions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub global_access_allowed: std::option::Option<bool>,

    /// Optional. True if the storage pool supports Auto Tiering enabled volumes.
    /// Default is false. Auto-tiering can be enabled after storage pool creation
    /// but it can't be disabled once enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_auto_tiering: bool,

    /// Optional. Specifies the replica zone for regional storagePool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub replica_zone: std::string::String,

    /// Optional. Specifies the active zone for regional storagePool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Output only. Reserved for future use
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzi: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoragePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StoragePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service_level][crate::model::StoragePool::service_level].
    pub fn set_service_level<T: std::convert::Into<crate::model::ServiceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_level = v.into();
        self
    }

    /// Sets the value of [capacity_gib][crate::model::StoragePool::capacity_gib].
    pub fn set_capacity_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gib = v.into();
        self
    }

    /// Sets the value of [volume_capacity_gib][crate::model::StoragePool::volume_capacity_gib].
    pub fn set_volume_capacity_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.volume_capacity_gib = v.into();
        self
    }

    /// Sets the value of [volume_count][crate::model::StoragePool::volume_count].
    pub fn set_volume_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.volume_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::StoragePool::state].
    pub fn set_state<T: std::convert::Into<crate::model::storage_pool::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::StoragePool::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::StoragePool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::StoragePool::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::StoragePool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network][crate::model::StoragePool::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::StoragePool::active_directory].
    pub fn set_active_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory = v.into();
        self
    }

    /// Sets the value of [kms_config][crate::model::StoragePool::kms_config].
    pub fn set_kms_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_config = v.into();
        self
    }

    /// Sets the value of [ldap_enabled][crate::model::StoragePool::ldap_enabled].
    pub fn set_ldap_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ldap_enabled = v.into();
        self
    }

    /// Sets the value of [psa_range][crate::model::StoragePool::psa_range].
    pub fn set_psa_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.psa_range = v.into();
        self
    }

    /// Sets the value of [encryption_type][crate::model::StoragePool::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::EncryptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [global_access_allowed][crate::model::StoragePool::global_access_allowed].
    #[deprecated]
    pub fn set_global_access_allowed<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.global_access_allowed = v.into();
        self
    }

    /// Sets the value of [allow_auto_tiering][crate::model::StoragePool::allow_auto_tiering].
    pub fn set_allow_auto_tiering<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_auto_tiering = v.into();
        self
    }

    /// Sets the value of [replica_zone][crate::model::StoragePool::replica_zone].
    pub fn set_replica_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replica_zone = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::StoragePool::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::StoragePool::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::StoragePool::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for StoragePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.StoragePool"
    }
}

/// Defines additional types related to [StoragePool].
pub mod storage_pool {
    #[allow(unused_imports)]
    use super::*;

    /// The Storage Pool States
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Storage Pool State
        Unspecified,
        /// Storage Pool State is Ready
        Ready,
        /// Storage Pool State is Creating
        Creating,
        /// Storage Pool State is Deleting
        Deleting,
        /// Storage Pool State is Updating
        Updating,
        /// Storage Pool State is Restoring
        Restoring,
        /// Storage Pool State is Disabled
        Disabled,
        /// Storage Pool State is Error
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Restoring => std::option::Option::Some(5),
                Self::Disabled => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Restoring => std::option::Option::Some("RESTORING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::Restoring,
                6 => Self::Disabled,
                7 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "RESTORING" => Self::Restoring,
                "DISABLED" => Self::Disabled,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Restoring => serializer.serialize_i32(5),
                Self::Disabled => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.StoragePool.State",
            ))
        }
    }
}

/// ValidateDirectoryServiceRequest validates the directory service policy
/// attached to the storage pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidateDirectoryServiceRequest {
    /// Required. Name of the storage pool
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Type of directory service policy attached to the storage pool.
    pub directory_service_type: crate::model::DirectoryServiceType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateDirectoryServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateDirectoryServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [directory_service_type][crate::model::ValidateDirectoryServiceRequest::directory_service_type].
    pub fn set_directory_service_type<T: std::convert::Into<crate::model::DirectoryServiceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.directory_service_type = v.into();
        self
    }
}

impl wkt::message::Message for ValidateDirectoryServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ValidateDirectoryServiceRequest"
    }
}

/// Message for requesting list of Volumes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVolumesRequest {
    /// Required. Parent value for ListVolumesRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, the server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVolumesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListVolumesRequest"
    }
}

/// Message for response to listing Volumes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVolumesResponse {
    /// The list of Volume
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volumes][crate::model::ListVolumesResponse::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVolumesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVolumesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ListVolumesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumesResponse {
    type PageItem = crate::model::Volume;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volumes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Volume
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVolumeRequest {
    /// Required. Name of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.GetVolumeRequest"
    }
}

/// Message for creating a Volume
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVolumeRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting volume. Must be unique within the parent
    /// resource. Must contain only letters, numbers and hyphen, with the first
    /// character a letter, the last a letter or a number,
    /// and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub volume_id: std::string::String,

    /// Required. The volume being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub volume: std::option::Option<crate::model::Volume>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVolumeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [volume_id][crate::model::CreateVolumeRequest::volume_id].
    pub fn set_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_id = v.into();
        self
    }

    /// Sets the value of [volume][crate::model::CreateVolumeRequest::volume].
    pub fn set_volume<T: std::convert::Into<std::option::Option<crate::model::Volume>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume = v.into();
        self
    }
}

impl wkt::message::Message for CreateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.CreateVolumeRequest"
    }
}

/// Message for updating a Volume
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVolumeRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Volume resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The volume being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub volume: std::option::Option<crate::model::Volume>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateVolumeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [volume][crate::model::UpdateVolumeRequest::volume].
    pub fn set_volume<T: std::convert::Into<std::option::Option<crate::model::Volume>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume = v.into();
        self
    }
}

impl wkt::message::Message for UpdateVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.UpdateVolumeRequest"
    }
}

/// Message for deleting a Volume
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVolumeRequest {
    /// Required. Name of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If this field is set as true, CCFE will not block the volume resource
    /// deletion even if it has any snapshots resource. (Otherwise, the request
    /// will only work if the volume has no snapshots.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteVolumeRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DeleteVolumeRequest"
    }
}

/// RevertVolumeRequest reverts the given volume to the specified snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevertVolumeRequest {
    /// Required. The resource name of the volume, in the format of
    /// projects/{project_id}/locations/{location}/volumes/{volume_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The snapshot resource ID, in the format 'my-snapshot', where the
    /// specified ID is the {snapshot_id} of the fully qualified name like
    /// projects/{project_id}/locations/{location_id}/volumes/{volume_id}/snapshots/{snapshot_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevertVolumeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevertVolumeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::RevertVolumeRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }
}

impl wkt::message::Message for RevertVolumeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.RevertVolumeRequest"
    }
}

/// Volume provides a filesystem that you can mount.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Identifier. Name of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. State of the volume
    pub state: crate::model::volume::State,

    /// Output only. State details of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_details: std::string::String,

    /// Output only. Create time of the volume
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Share name of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub share_name: std::string::String,

    /// Output only. This field is not implemented. The values provided in this
    /// field are ignored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psa_range: std::string::String,

    /// Required. StoragePool name of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_pool: std::string::String,

    /// Output only. VPC Network name.
    /// Format: projects/{project}/global/networks/{network}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Output only. Service level of the volume
    pub service_level: crate::model::ServiceLevel,

    /// Required. Capacity in GIB of the volume
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub capacity_gib: i64,

    /// Optional. Export policy of the volume
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_policy: std::option::Option<crate::model::ExportPolicy>,

    /// Required. Protocols required for the volume
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub protocols: std::vec::Vec<crate::model::Protocols>,

    /// Optional. SMB share settings for the volume.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub smb_settings: std::vec::Vec<crate::model::SMBSettings>,

    /// Output only. Mount options of this volume
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mount_options: std::vec::Vec<crate::model::MountOption>,

    /// Optional. Default unix style permission (e.g. 777) the mount point will be
    /// created with. Applicable for NFS protocol types only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub unix_permissions: std::string::String,

    /// Optional. Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the volume
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. SnapshotPolicy for a volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_policy: std::option::Option<crate::model::SnapshotPolicy>,

    /// Optional. Snap_reserve specifies percentage of volume storage reserved for
    /// snapshot storage. Default is 0 percent.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub snap_reserve: f64,

    /// Optional. Snapshot_directory if enabled (true) the volume will contain a
    /// read-only .snapshot directory which provides access to each of the volume's
    /// snapshots.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub snapshot_directory: bool,

    /// Output only. Used capacity in GIB of the volume. This is computed
    /// periodically and it does not represent the realtime usage.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub used_gib: i64,

    /// Optional. Security Style of the Volume
    pub security_style: crate::model::SecurityStyle,

    /// Optional. Flag indicating if the volume is a kerberos volume or not, export
    /// policy rules control kerberos security modes (krb5, krb5i, krb5p).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub kerberos_enabled: bool,

    /// Output only. Flag indicating if the volume is NFS LDAP enabled or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ldap_enabled: bool,

    /// Output only. Specifies the ActiveDirectory name of a SMB volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub active_directory: std::string::String,

    /// Optional. Specifies the source of the volume to be created from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_parameters: std::option::Option<crate::model::RestoreParameters>,

    /// Output only. Specifies the KMS config to be used for volume encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_config: std::string::String,

    /// Output only. Specified the current volume encryption key source.
    pub encryption_type: crate::model::EncryptionType,

    /// Output only. Indicates whether the volume is part of a replication
    /// relationship.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub has_replication: bool,

    /// BackupConfig of the volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_config: std::option::Option<crate::model::BackupConfig>,

    /// Optional. List of actions that are restricted on this volume.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub restricted_actions: std::vec::Vec<crate::model::RestrictedAction>,

    /// Optional. Flag indicating if the volume will be a large capacity volume or
    /// a regular volume.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub large_capacity: bool,

    /// Optional. Flag indicating if the volume will have an IP address per node
    /// for volumes supporting multiple IP endpoints. Only the volume with
    /// large_capacity will be allowed to have multiple endpoints.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub multiple_endpoints: bool,

    /// Tiering policy for the volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tiering_policy: std::option::Option<crate::model::TieringPolicy>,

    /// Output only. Specifies the replica zone for regional volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub replica_zone: std::string::String,

    /// Output only. Specifies the active zone for regional volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Output only. Size of the volume cold tier data in GiB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub cold_tier_size_gib: i64,

    /// Optional. The Hybrid Replication parameters for the volume.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hybrid_replication_parameters:
        std::option::Option<crate::model::HybridReplicationParameters>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Volume::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_details][crate::model::Volume::state_details].
    pub fn set_state_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_details = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Volume::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [share_name][crate::model::Volume::share_name].
    pub fn set_share_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.share_name = v.into();
        self
    }

    /// Sets the value of [psa_range][crate::model::Volume::psa_range].
    pub fn set_psa_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.psa_range = v.into();
        self
    }

    /// Sets the value of [storage_pool][crate::model::Volume::storage_pool].
    pub fn set_storage_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Volume::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_level][crate::model::Volume::service_level].
    pub fn set_service_level<T: std::convert::Into<crate::model::ServiceLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_level = v.into();
        self
    }

    /// Sets the value of [capacity_gib][crate::model::Volume::capacity_gib].
    pub fn set_capacity_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.capacity_gib = v.into();
        self
    }

    /// Sets the value of [export_policy][crate::model::Volume::export_policy].
    pub fn set_export_policy<
        T: std::convert::Into<std::option::Option<crate::model::ExportPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_policy = v.into();
        self
    }

    /// Sets the value of [protocols][crate::model::Volume::protocols].
    pub fn set_protocols<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Protocols>,
    {
        use std::iter::Iterator;
        self.protocols = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [smb_settings][crate::model::Volume::smb_settings].
    pub fn set_smb_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SMBSettings>,
    {
        use std::iter::Iterator;
        self.smb_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mount_options][crate::model::Volume::mount_options].
    pub fn set_mount_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MountOption>,
    {
        use std::iter::Iterator;
        self.mount_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unix_permissions][crate::model::Volume::unix_permissions].
    pub fn set_unix_permissions<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.unix_permissions = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Volume::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Volume::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [snapshot_policy][crate::model::Volume::snapshot_policy].
    pub fn set_snapshot_policy<
        T: std::convert::Into<std::option::Option<crate::model::SnapshotPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_policy = v.into();
        self
    }

    /// Sets the value of [snap_reserve][crate::model::Volume::snap_reserve].
    pub fn set_snap_reserve<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.snap_reserve = v.into();
        self
    }

    /// Sets the value of [snapshot_directory][crate::model::Volume::snapshot_directory].
    pub fn set_snapshot_directory<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.snapshot_directory = v.into();
        self
    }

    /// Sets the value of [used_gib][crate::model::Volume::used_gib].
    pub fn set_used_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.used_gib = v.into();
        self
    }

    /// Sets the value of [security_style][crate::model::Volume::security_style].
    pub fn set_security_style<T: std::convert::Into<crate::model::SecurityStyle>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_style = v.into();
        self
    }

    /// Sets the value of [kerberos_enabled][crate::model::Volume::kerberos_enabled].
    pub fn set_kerberos_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.kerberos_enabled = v.into();
        self
    }

    /// Sets the value of [ldap_enabled][crate::model::Volume::ldap_enabled].
    pub fn set_ldap_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ldap_enabled = v.into();
        self
    }

    /// Sets the value of [active_directory][crate::model::Volume::active_directory].
    pub fn set_active_directory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_directory = v.into();
        self
    }

    /// Sets the value of [restore_parameters][crate::model::Volume::restore_parameters].
    pub fn set_restore_parameters<
        T: std::convert::Into<std::option::Option<crate::model::RestoreParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restore_parameters = v.into();
        self
    }

    /// Sets the value of [kms_config][crate::model::Volume::kms_config].
    pub fn set_kms_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_config = v.into();
        self
    }

    /// Sets the value of [encryption_type][crate::model::Volume::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::EncryptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [has_replication][crate::model::Volume::has_replication].
    pub fn set_has_replication<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_replication = v.into();
        self
    }

    /// Sets the value of [backup_config][crate::model::Volume::backup_config].
    pub fn set_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::BackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_config = v.into();
        self
    }

    /// Sets the value of [restricted_actions][crate::model::Volume::restricted_actions].
    pub fn set_restricted_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RestrictedAction>,
    {
        use std::iter::Iterator;
        self.restricted_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [large_capacity][crate::model::Volume::large_capacity].
    pub fn set_large_capacity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.large_capacity = v.into();
        self
    }

    /// Sets the value of [multiple_endpoints][crate::model::Volume::multiple_endpoints].
    pub fn set_multiple_endpoints<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.multiple_endpoints = v.into();
        self
    }

    /// Sets the value of [tiering_policy][crate::model::Volume::tiering_policy].
    pub fn set_tiering_policy<
        T: std::convert::Into<std::option::Option<crate::model::TieringPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tiering_policy = v.into();
        self
    }

    /// Sets the value of [replica_zone][crate::model::Volume::replica_zone].
    pub fn set_replica_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replica_zone = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Volume::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cold_tier_size_gib][crate::model::Volume::cold_tier_size_gib].
    pub fn set_cold_tier_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cold_tier_size_gib = v.into();
        self
    }

    /// Sets the value of [hybrid_replication_parameters][crate::model::Volume::hybrid_replication_parameters].
    pub fn set_hybrid_replication_parameters<
        T: std::convert::Into<std::option::Option<crate::model::HybridReplicationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hybrid_replication_parameters = v.into();
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.Volume"
    }
}

/// Defines additional types related to [Volume].
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    /// The volume states
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified Volume State
        Unspecified,
        /// Volume State is Ready
        Ready,
        /// Volume State is Creating
        Creating,
        /// Volume State is Deleting
        Deleting,
        /// Volume State is Updating
        Updating,
        /// Volume State is Restoring
        Restoring,
        /// Volume State is Disabled
        Disabled,
        /// Volume State is Error
        Error,
        /// Volume State is Preparing. Note that this is different from CREATING
        /// where CREATING means the volume is being created, while PREPARING means
        /// the volume is created and now being prepared for the replication.
        Preparing,
        /// Volume State is Read Only
        ReadOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Restoring => std::option::Option::Some(5),
                Self::Disabled => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::Preparing => std::option::Option::Some(8),
                Self::ReadOnly => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Restoring => std::option::Option::Some("RESTORING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Preparing => std::option::Option::Some("PREPARING"),
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Deleting,
                4 => Self::Updating,
                5 => Self::Restoring,
                6 => Self::Disabled,
                7 => Self::Error,
                8 => Self::Preparing,
                9 => Self::ReadOnly,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "RESTORING" => Self::Restoring,
                "DISABLED" => Self::Disabled,
                "ERROR" => Self::Error,
                "PREPARING" => Self::Preparing,
                "READ_ONLY" => Self::ReadOnly,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Restoring => serializer.serialize_i32(5),
                Self::Disabled => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::Preparing => serializer.serialize_i32(8),
                Self::ReadOnly => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.netapp.v1.Volume.State",
            ))
        }
    }
}

/// Defines the export policy for the volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportPolicy {
    /// Required. List of export policy rules
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::SimpleExportPolicyRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rules][crate::model::ExportPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SimpleExportPolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.ExportPolicy"
    }
}

/// An export policy rule describing various export options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SimpleExportPolicyRule {
    /// Comma separated list of allowed clients IP addresses
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allowed_clients: std::option::Option<std::string::String>,

    /// Whether Unix root access will be granted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub has_root_access: std::option::Option<std::string::String>,

    /// Access type (ReadWrite, ReadOnly, None)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access_type: std::option::Option<crate::model::AccessType>,

    /// NFS V3 protocol.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nfsv3: std::option::Option<bool>,

    /// NFS V4 protocol.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nfsv4: std::option::Option<bool>,

    /// If enabled (true) the rule defines a read only access for clients matching
    /// the 'allowedClients' specification. It enables nfs clients to mount using
    /// 'authentication' kerberos security mode.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_5_read_only: std::option::Option<bool>,

    /// If enabled (true) the rule defines read and write access for clients
    /// matching the 'allowedClients' specification. It enables nfs clients to
    /// mount using 'authentication' kerberos security mode. The
    /// 'kerberos5ReadOnly' value be ignored if this is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_5_read_write: std::option::Option<bool>,

    /// If enabled (true) the rule defines a read only access for clients matching
    /// the 'allowedClients' specification. It enables nfs clients to mount using
    /// 'integrity' kerberos security mode.
    #[serde(rename = "kerberos5iReadOnly")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_5i_read_only: std::option::Option<bool>,

    /// If enabled (true) the rule defines read and write access for clients
    /// matching the 'allowedClients' specification. It enables nfs clients to
    /// mount using 'integrity' kerberos security mode. The 'kerberos5iReadOnly'
    /// value be ignored if this is enabled.
    #[serde(rename = "kerberos5iReadWrite")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_5i_read_write: std::option::Option<bool>,

    /// If enabled (true) the rule defines a read only access for clients matching
    /// the 'allowedClients' specification. It enables nfs clients to mount using
    /// 'privacy' kerberos security mode.
    #[serde(rename = "kerberos5pReadOnly")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_5p_read_only: std::option::Option<bool>,

    /// If enabled (true) the rule defines read and write access for clients
    /// matching the 'allowedClients' specification. It enables nfs clients to
    /// mount using 'privacy' kerberos security mode. The 'kerberos5pReadOnly'
    /// value be ignored if this is enabled.
    #[serde(rename = "kerberos5pReadWrite")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_5p_read_write: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SimpleExportPolicyRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_clients][crate::model::SimpleExportPolicyRule::allowed_clients].
    pub fn set_allowed_clients<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allowed_clients = v.into();
        self
    }

    /// Sets the value of [has_root_access][crate::model::SimpleExportPolicyRule::has_root_access].
    pub fn set_has_root_access<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.has_root_access = v.into();
        self
    }

    /// Sets the value of [access_type][crate::model::SimpleExportPolicyRule::access_type].
    pub fn set_access_type<T: std::convert::Into<std::option::Option<crate::model::AccessType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.access_type = v.into();
        self
    }

    /// Sets the value of [nfsv3][crate::model::SimpleExportPolicyRule::nfsv3].
    pub fn set_nfsv3<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.nfsv3 = v.into();
        self
    }

    /// Sets the value of [nfsv4][crate::model::SimpleExportPolicyRule::nfsv4].
    pub fn set_nfsv4<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.nfsv4 = v.into();
        self
    }

    /// Sets the value of [kerberos_5_read_only][crate::model::SimpleExportPolicyRule::kerberos_5_read_only].
    pub fn set_kerberos_5_read_only<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_5_read_only = v.into();
        self
    }

    /// Sets the value of [kerberos_5_read_write][crate::model::SimpleExportPolicyRule::kerberos_5_read_write].
    pub fn set_kerberos_5_read_write<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_5_read_write = v.into();
        self
    }

    /// Sets the value of [kerberos_5i_read_only][crate::model::SimpleExportPolicyRule::kerberos_5i_read_only].
    pub fn set_kerberos_5i_read_only<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_5i_read_only = v.into();
        self
    }

    /// Sets the value of [kerberos_5i_read_write][crate::model::SimpleExportPolicyRule::kerberos_5i_read_write].
    pub fn set_kerberos_5i_read_write<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_5i_read_write = v.into();
        self
    }

    /// Sets the value of [kerberos_5p_read_only][crate::model::SimpleExportPolicyRule::kerberos_5p_read_only].
    pub fn set_kerberos_5p_read_only<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_5p_read_only = v.into();
        self
    }

    /// Sets the value of [kerberos_5p_read_write][crate::model::SimpleExportPolicyRule::kerberos_5p_read_write].
    pub fn set_kerberos_5p_read_write<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_5p_read_write = v.into();
        self
    }
}

impl wkt::message::Message for SimpleExportPolicyRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SimpleExportPolicyRule"
    }
}

/// Snapshot Policy for a volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SnapshotPolicy {
    /// If enabled, make snapshots automatically according to the schedules.
    /// Default is false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,

    /// Hourly schedule policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hourly_schedule: std::option::Option<crate::model::HourlySchedule>,

    /// Daily schedule policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub daily_schedule: std::option::Option<crate::model::DailySchedule>,

    /// Weekly schedule policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub weekly_schedule: std::option::Option<crate::model::WeeklySchedule>,

    /// Monthly schedule policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monthly_schedule: std::option::Option<crate::model::MonthlySchedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnapshotPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::SnapshotPolicy::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [hourly_schedule][crate::model::SnapshotPolicy::hourly_schedule].
    pub fn set_hourly_schedule<
        T: std::convert::Into<std::option::Option<crate::model::HourlySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hourly_schedule = v.into();
        self
    }

    /// Sets the value of [daily_schedule][crate::model::SnapshotPolicy::daily_schedule].
    pub fn set_daily_schedule<
        T: std::convert::Into<std::option::Option<crate::model::DailySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.daily_schedule = v.into();
        self
    }

    /// Sets the value of [weekly_schedule][crate::model::SnapshotPolicy::weekly_schedule].
    pub fn set_weekly_schedule<
        T: std::convert::Into<std::option::Option<crate::model::WeeklySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.weekly_schedule = v.into();
        self
    }

    /// Sets the value of [monthly_schedule][crate::model::SnapshotPolicy::monthly_schedule].
    pub fn set_monthly_schedule<
        T: std::convert::Into<std::option::Option<crate::model::MonthlySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monthly_schedule = v.into();
        self
    }
}

impl wkt::message::Message for SnapshotPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.SnapshotPolicy"
    }
}

/// Make a snapshot every hour e.g. at 04:00, 05:00, 06:00.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HourlySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub minute: std::option::Option<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HourlySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::HourlySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshots_to_keep = v.into();
        self
    }

    /// Sets the value of [minute][crate::model::HourlySchedule::minute].
    pub fn set_minute<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.minute = v.into();
        self
    }
}

impl wkt::message::Message for HourlySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.HourlySchedule"
    }
}

/// Make a snapshot every day e.g. at 04:00, 05:20, 23:50
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DailySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub minute: std::option::Option<f64>,

    /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub hour: std::option::Option<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::DailySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshots_to_keep = v.into();
        self
    }

    /// Sets the value of [minute][crate::model::DailySchedule::minute].
    pub fn set_minute<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.minute = v.into();
        self
    }

    /// Sets the value of [hour][crate::model::DailySchedule::hour].
    pub fn set_hour<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.hour = v.into();
        self
    }
}

impl wkt::message::Message for DailySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.DailySchedule"
    }
}

/// Make a snapshot every week e.g. at Monday 04:00, Wednesday 05:20, Sunday
/// 23:50
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeeklySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub minute: std::option::Option<f64>,

    /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub hour: std::option::Option<f64>,

    /// Set the day or days of the week to make a snapshot. Accepts a comma
    /// separated days of the week. Defaults to 'Sunday'.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub day: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::WeeklySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshots_to_keep = v.into();
        self
    }

    /// Sets the value of [minute][crate::model::WeeklySchedule::minute].
    pub fn set_minute<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.minute = v.into();
        self
    }

    /// Sets the value of [hour][crate::model::WeeklySchedule::hour].
    pub fn set_hour<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.hour = v.into();
        self
    }

    /// Sets the value of [day][crate::model::WeeklySchedule::day].
    pub fn set_day<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.day = v.into();
        self
    }
}

impl wkt::message::Message for WeeklySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.WeeklySchedule"
    }
}

/// Make a snapshot once a month e.g. at 2nd 04:00, 7th 05:20, 24th 23:50
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MonthlySchedule {
    /// The maximum number of Snapshots to keep for the hourly schedule
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub snapshots_to_keep: std::option::Option<f64>,

    /// Set the minute of the hour to start the snapshot (0-59), defaults to the
    /// top of the hour (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub minute: std::option::Option<f64>,

    /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub hour: std::option::Option<f64>,

    /// Set the day or days of the month to make a snapshot (1-31). Accepts a
    /// comma separated number of days. Defaults to '1'.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub days_of_month: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonthlySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots_to_keep][crate::model::MonthlySchedule::snapshots_to_keep].
    pub fn set_snapshots_to_keep<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshots_to_keep = v.into();
        self
    }

    /// Sets the value of [minute][crate::model::MonthlySchedule::minute].
    pub fn set_minute<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.minute = v.into();
        self
    }

    /// Sets the value of [hour][crate::model::MonthlySchedule::hour].
    pub fn set_hour<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.hour = v.into();
        self
    }

    /// Sets the value of [days_of_month][crate::model::MonthlySchedule::days_of_month].
    pub fn set_days_of_month<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.days_of_month = v.into();
        self
    }
}

impl wkt::message::Message for MonthlySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.MonthlySchedule"
    }
}

/// View only mount options for a volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MountOption {
    /// Export string
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub export: std::string::String,

    /// Full export string
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub export_full: std::string::String,

    /// Protocol to mount with.
    pub protocol: crate::model::Protocols,

    /// Instructions for mounting
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instructions: std::string::String,

    /// Output only. IP Address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MountOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export][crate::model::MountOption::export].
    pub fn set_export<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.export = v.into();
        self
    }

    /// Sets the value of [export_full][crate::model::MountOption::export_full].
    pub fn set_export_full<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.export_full = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::MountOption::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::Protocols>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [instructions][crate::model::MountOption::instructions].
    pub fn set_instructions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instructions = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::MountOption::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }
}

impl wkt::message::Message for MountOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.MountOption"
    }
}

/// The RestoreParameters if volume is created from a snapshot or backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreParameters {
    /// The source that the volume is created from.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::restore_parameters::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::RestoreParameters::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_parameters::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreParameters::source]
    /// if it holds a `SourceSnapshot`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_snapshot(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_parameters::Source::SourceSnapshot(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreParameters::source]
    /// to hold a `SourceSnapshot`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_parameters::Source::SourceSnapshot(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::RestoreParameters::source]
    /// if it holds a `SourceBackup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_parameters::Source::SourceBackup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreParameters::source]
    /// to hold a `SourceBackup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_parameters::Source::SourceBackup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.RestoreParameters"
    }
}

/// Defines additional types related to [RestoreParameters].
pub mod restore_parameters {
    #[allow(unused_imports)]
    use super::*;

    /// The source that the volume is created from.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Full name of the snapshot resource.
        /// Format:
        /// projects/{project}/locations/{location}/volumes/{volume}/snapshots/{snapshot}
        SourceSnapshot(std::string::String),
        /// Full name of the backup resource.
        /// Format:
        /// projects/{project}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}
        SourceBackup(std::string::String),
    }
}

/// BackupConfig contains backup related config on a volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupConfig {
    /// Optional. When specified, schedule backups will be created based on the
    /// policy configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_policies: std::vec::Vec<std::string::String>,

    /// Optional. Name of backup vault.
    /// Format:
    /// projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_vault: std::string::String,

    /// Optional. When set to true, scheduled backup is enabled on the volume.
    /// This field should be nil when there's no backup policy attached.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduled_backup_enabled: std::option::Option<bool>,

    /// Output only. Total size of all backups in a chain in bytes = baseline
    /// backup size + sum(incremental backup size).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub backup_chain_bytes: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_policies][crate::model::BackupConfig::backup_policies].
    pub fn set_backup_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.backup_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_vault][crate::model::BackupConfig::backup_vault].
    pub fn set_backup_vault<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_vault = v.into();
        self
    }

    /// Sets the value of [scheduled_backup_enabled][crate::model::BackupConfig::scheduled_backup_enabled].
    pub fn set_scheduled_backup_enabled<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scheduled_backup_enabled = v.into();
        self
    }

    /// Sets the value of [backup_chain_bytes][crate::model::BackupConfig::backup_chain_bytes].
    pub fn set_backup_chain_bytes<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_chain_bytes = v.into();
        self
    }
}

impl wkt::message::Message for BackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.BackupConfig"
    }
}

/// Defines tiering policy for the volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TieringPolicy {
    /// Optional. Flag indicating if the volume has tiering policy enable/pause.
    /// Default is PAUSED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tier_action: std::option::Option<crate::model::tiering_policy::TierAction>,

    /// Optional. Time in days to mark the volume's data block as cold and make it
    /// eligible for tiering, can be range from 2-183. Default is 31.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cooling_threshold_days: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TieringPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tier_action][crate::model::TieringPolicy::tier_action].
    pub fn set_tier_action<
        T: std::convert::Into<std::option::Option<crate::model::tiering_policy::TierAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tier_action = v.into();
        self
    }

    /// Sets the value of [cooling_threshold_days][crate::model::TieringPolicy::cooling_threshold_days].
    pub fn set_cooling_threshold_days<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cooling_threshold_days = v.into();
        self
    }
}

impl wkt::message::Message for TieringPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.TieringPolicy"
    }
}

/// Defines additional types related to [TieringPolicy].
pub mod tiering_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Tier action for the volume.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TierAction {
        /// Unspecified.
        Unspecified,
        /// When tiering is enabled, new cold data will be tiered.
        Enabled,
        /// When paused, tiering won't be performed on new data. Existing data stays
        /// tiered until accessed.
        Paused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TierAction::value] or
        /// [TierAction::name].
        UnknownValue(tier_action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tier_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TierAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_ACTION_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TierAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TierAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TierAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Paused,
                _ => Self::UnknownValue(tier_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TierAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_ACTION_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "PAUSED" => Self::Paused,
                _ => Self::UnknownValue(tier_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TierAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TierAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TierAction>::new(
                ".google.cloud.netapp.v1.TieringPolicy.TierAction",
            ))
        }
    }
}

/// The Hybrid Replication parameters for the volume.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HybridReplicationParameters {
    /// Required. Desired name for the replication of this volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub replication: std::string::String,

    /// Required. Name of the user's local source volume to be peered with the
    /// destination volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_volume_name: std::string::String,

    /// Required. Name of the user's local source cluster to be peered with the
    /// destination cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_cluster_name: std::string::String,

    /// Required. Name of the user's local source vserver svm to be peered with the
    /// destination vserver svm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peer_svm_name: std::string::String,

    /// Required. List of node ip addresses to be peered with.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub peer_ip_addresses: std::vec::Vec<std::string::String>,

    /// Optional. Name of source cluster location associated with the Hybrid
    /// replication. This is a free-form field for the display purpose only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_location: std::string::String,

    /// Optional. Description of the replication.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Labels to be added to the replication as the key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HybridReplicationParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication][crate::model::HybridReplicationParameters::replication].
    pub fn set_replication<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.replication = v.into();
        self
    }

    /// Sets the value of [peer_volume_name][crate::model::HybridReplicationParameters::peer_volume_name].
    pub fn set_peer_volume_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_volume_name = v.into();
        self
    }

    /// Sets the value of [peer_cluster_name][crate::model::HybridReplicationParameters::peer_cluster_name].
    pub fn set_peer_cluster_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.peer_cluster_name = v.into();
        self
    }

    /// Sets the value of [peer_svm_name][crate::model::HybridReplicationParameters::peer_svm_name].
    pub fn set_peer_svm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peer_svm_name = v.into();
        self
    }

    /// Sets the value of [peer_ip_addresses][crate::model::HybridReplicationParameters::peer_ip_addresses].
    pub fn set_peer_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.peer_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_location][crate::model::HybridReplicationParameters::cluster_location].
    pub fn set_cluster_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_location = v.into();
        self
    }

    /// Sets the value of [description][crate::model::HybridReplicationParameters::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::HybridReplicationParameters::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HybridReplicationParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.netapp.v1.HybridReplicationParameters"
    }
}

/// The service level of a storage pool and its volumes.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ServiceLevel {
    /// Unspecified service level.
    Unspecified,
    /// Premium service level.
    Premium,
    /// Extreme service level.
    Extreme,
    /// Standard service level.
    Standard,
    /// Flex service level.
    Flex,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ServiceLevel::value] or
    /// [ServiceLevel::name].
    UnknownValue(service_level::UnknownValue),
}

#[doc(hidden)]
pub mod service_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ServiceLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Premium => std::option::Option::Some(1),
            Self::Extreme => std::option::Option::Some(2),
            Self::Standard => std::option::Option::Some(3),
            Self::Flex => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SERVICE_LEVEL_UNSPECIFIED"),
            Self::Premium => std::option::Option::Some("PREMIUM"),
            Self::Extreme => std::option::Option::Some("EXTREME"),
            Self::Standard => std::option::Option::Some("STANDARD"),
            Self::Flex => std::option::Option::Some("FLEX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ServiceLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ServiceLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ServiceLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Premium,
            2 => Self::Extreme,
            3 => Self::Standard,
            4 => Self::Flex,
            _ => Self::UnknownValue(service_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ServiceLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SERVICE_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "PREMIUM" => Self::Premium,
            "EXTREME" => Self::Extreme,
            "STANDARD" => Self::Standard,
            "FLEX" => Self::Flex,
            _ => Self::UnknownValue(service_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ServiceLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Premium => serializer.serialize_i32(1),
            Self::Extreme => serializer.serialize_i32(2),
            Self::Standard => serializer.serialize_i32(3),
            Self::Flex => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ServiceLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceLevel>::new(
            ".google.cloud.netapp.v1.ServiceLevel",
        ))
    }
}

/// Flex Storage Pool performance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FlexPerformance {
    /// Unspecified flex performance.
    Unspecified,
    /// Flex Storage Pool with default performance.
    Default,
    /// Flex Storage Pool with custom performance.
    Custom,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FlexPerformance::value] or
    /// [FlexPerformance::name].
    UnknownValue(flex_performance::UnknownValue),
}

#[doc(hidden)]
pub mod flex_performance {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FlexPerformance {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Default => std::option::Option::Some(1),
            Self::Custom => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FLEX_PERFORMANCE_UNSPECIFIED"),
            Self::Default => std::option::Option::Some("FLEX_PERFORMANCE_DEFAULT"),
            Self::Custom => std::option::Option::Some("FLEX_PERFORMANCE_CUSTOM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FlexPerformance {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FlexPerformance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FlexPerformance {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Default,
            2 => Self::Custom,
            _ => Self::UnknownValue(flex_performance::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FlexPerformance {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FLEX_PERFORMANCE_UNSPECIFIED" => Self::Unspecified,
            "FLEX_PERFORMANCE_DEFAULT" => Self::Default,
            "FLEX_PERFORMANCE_CUSTOM" => Self::Custom,
            _ => Self::UnknownValue(flex_performance::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FlexPerformance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Default => serializer.serialize_i32(1),
            Self::Custom => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FlexPerformance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FlexPerformance>::new(
            ".google.cloud.netapp.v1.FlexPerformance",
        ))
    }
}

/// The volume encryption key source.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncryptionType {
    /// The source of the encryption key is not specified.
    Unspecified,
    /// Google managed encryption key.
    ServiceManaged,
    /// Customer managed encryption key, which is stored in KMS.
    CloudKms,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncryptionType::value] or
    /// [EncryptionType::name].
    UnknownValue(encryption_type::UnknownValue),
}

#[doc(hidden)]
pub mod encryption_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncryptionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ServiceManaged => std::option::Option::Some(1),
            Self::CloudKms => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENCRYPTION_TYPE_UNSPECIFIED"),
            Self::ServiceManaged => std::option::Option::Some("SERVICE_MANAGED"),
            Self::CloudKms => std::option::Option::Some("CLOUD_KMS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncryptionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncryptionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncryptionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ServiceManaged,
            2 => Self::CloudKms,
            _ => Self::UnknownValue(encryption_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncryptionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SERVICE_MANAGED" => Self::ServiceManaged,
            "CLOUD_KMS" => Self::CloudKms,
            _ => Self::UnknownValue(encryption_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncryptionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ServiceManaged => serializer.serialize_i32(1),
            Self::CloudKms => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncryptionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionType>::new(
            ".google.cloud.netapp.v1.EncryptionType",
        ))
    }
}

/// Type of directory service
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DirectoryServiceType {
    /// Directory service type is not specified.
    Unspecified,
    /// Active directory policy attached to the storage pool.
    ActiveDirectory,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DirectoryServiceType::value] or
    /// [DirectoryServiceType::name].
    UnknownValue(directory_service_type::UnknownValue),
}

#[doc(hidden)]
pub mod directory_service_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DirectoryServiceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ActiveDirectory => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DIRECTORY_SERVICE_TYPE_UNSPECIFIED"),
            Self::ActiveDirectory => std::option::Option::Some("ACTIVE_DIRECTORY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DirectoryServiceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DirectoryServiceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DirectoryServiceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ActiveDirectory,
            _ => Self::UnknownValue(directory_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DirectoryServiceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DIRECTORY_SERVICE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE_DIRECTORY" => Self::ActiveDirectory,
            _ => Self::UnknownValue(directory_service_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DirectoryServiceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ActiveDirectory => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DirectoryServiceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DirectoryServiceType>::new(
            ".google.cloud.netapp.v1.DirectoryServiceType",
        ))
    }
}

/// Protocols is an enum of all the supported network protocols for a volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Protocols {
    /// Unspecified protocol
    Unspecified,
    /// NFS V3 protocol
    Nfsv3,
    /// NFS V4 protocol
    Nfsv4,
    /// SMB protocol
    Smb,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Protocols::value] or
    /// [Protocols::name].
    UnknownValue(protocols::UnknownValue),
}

#[doc(hidden)]
pub mod protocols {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Protocols {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Nfsv3 => std::option::Option::Some(1),
            Self::Nfsv4 => std::option::Option::Some(2),
            Self::Smb => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PROTOCOLS_UNSPECIFIED"),
            Self::Nfsv3 => std::option::Option::Some("NFSV3"),
            Self::Nfsv4 => std::option::Option::Some("NFSV4"),
            Self::Smb => std::option::Option::Some("SMB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Protocols {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Protocols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Protocols {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Nfsv3,
            2 => Self::Nfsv4,
            3 => Self::Smb,
            _ => Self::UnknownValue(protocols::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Protocols {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PROTOCOLS_UNSPECIFIED" => Self::Unspecified,
            "NFSV3" => Self::Nfsv3,
            "NFSV4" => Self::Nfsv4,
            "SMB" => Self::Smb,
            _ => Self::UnknownValue(protocols::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Protocols {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Nfsv3 => serializer.serialize_i32(1),
            Self::Nfsv4 => serializer.serialize_i32(2),
            Self::Smb => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Protocols {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocols>::new(
            ".google.cloud.netapp.v1.Protocols",
        ))
    }
}

/// AccessType is an enum of all the supported access types for a volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AccessType {
    /// Unspecified Access Type
    Unspecified,
    /// Read Only
    ReadOnly,
    /// Read Write
    ReadWrite,
    /// None
    ReadNone,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AccessType::value] or
    /// [AccessType::name].
    UnknownValue(access_type::UnknownValue),
}

#[doc(hidden)]
pub mod access_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AccessType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ReadOnly => std::option::Option::Some(1),
            Self::ReadWrite => std::option::Option::Some(2),
            Self::ReadNone => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ACCESS_TYPE_UNSPECIFIED"),
            Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
            Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
            Self::ReadNone => std::option::Option::Some("READ_NONE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AccessType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AccessType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ReadOnly,
            2 => Self::ReadWrite,
            3 => Self::ReadNone,
            _ => Self::UnknownValue(access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AccessType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ACCESS_TYPE_UNSPECIFIED" => Self::Unspecified,
            "READ_ONLY" => Self::ReadOnly,
            "READ_WRITE" => Self::ReadWrite,
            "READ_NONE" => Self::ReadNone,
            _ => Self::UnknownValue(access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AccessType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ReadOnly => serializer.serialize_i32(1),
            Self::ReadWrite => serializer.serialize_i32(2),
            Self::ReadNone => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AccessType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessType>::new(
            ".google.cloud.netapp.v1.AccessType",
        ))
    }
}

/// SMBSettings
/// Modifies the behaviour of a SMB volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SMBSettings {
    /// Unspecified default option
    Unspecified,
    /// SMB setting encrypt data
    EncryptData,
    /// SMB setting browsable
    Browsable,
    /// SMB setting notify change
    ChangeNotify,
    /// SMB setting not to notify change
    NonBrowsable,
    /// SMB setting oplocks
    Oplocks,
    /// SMB setting to show snapshots
    ShowSnapshot,
    /// SMB setting to show previous versions
    ShowPreviousVersions,
    /// SMB setting to access volume based on enumerartion
    AccessBasedEnumeration,
    /// Continuously available enumeration
    ContinuouslyAvailable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SMBSettings::value] or
    /// [SMBSettings::name].
    UnknownValue(smb_settings::UnknownValue),
}

#[doc(hidden)]
pub mod smb_settings {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SMBSettings {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EncryptData => std::option::Option::Some(1),
            Self::Browsable => std::option::Option::Some(2),
            Self::ChangeNotify => std::option::Option::Some(3),
            Self::NonBrowsable => std::option::Option::Some(4),
            Self::Oplocks => std::option::Option::Some(5),
            Self::ShowSnapshot => std::option::Option::Some(6),
            Self::ShowPreviousVersions => std::option::Option::Some(7),
            Self::AccessBasedEnumeration => std::option::Option::Some(8),
            Self::ContinuouslyAvailable => std::option::Option::Some(9),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SMB_SETTINGS_UNSPECIFIED"),
            Self::EncryptData => std::option::Option::Some("ENCRYPT_DATA"),
            Self::Browsable => std::option::Option::Some("BROWSABLE"),
            Self::ChangeNotify => std::option::Option::Some("CHANGE_NOTIFY"),
            Self::NonBrowsable => std::option::Option::Some("NON_BROWSABLE"),
            Self::Oplocks => std::option::Option::Some("OPLOCKS"),
            Self::ShowSnapshot => std::option::Option::Some("SHOW_SNAPSHOT"),
            Self::ShowPreviousVersions => std::option::Option::Some("SHOW_PREVIOUS_VERSIONS"),
            Self::AccessBasedEnumeration => std::option::Option::Some("ACCESS_BASED_ENUMERATION"),
            Self::ContinuouslyAvailable => std::option::Option::Some("CONTINUOUSLY_AVAILABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SMBSettings {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SMBSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SMBSettings {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EncryptData,
            2 => Self::Browsable,
            3 => Self::ChangeNotify,
            4 => Self::NonBrowsable,
            5 => Self::Oplocks,
            6 => Self::ShowSnapshot,
            7 => Self::ShowPreviousVersions,
            8 => Self::AccessBasedEnumeration,
            9 => Self::ContinuouslyAvailable,
            _ => Self::UnknownValue(smb_settings::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SMBSettings {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SMB_SETTINGS_UNSPECIFIED" => Self::Unspecified,
            "ENCRYPT_DATA" => Self::EncryptData,
            "BROWSABLE" => Self::Browsable,
            "CHANGE_NOTIFY" => Self::ChangeNotify,
            "NON_BROWSABLE" => Self::NonBrowsable,
            "OPLOCKS" => Self::Oplocks,
            "SHOW_SNAPSHOT" => Self::ShowSnapshot,
            "SHOW_PREVIOUS_VERSIONS" => Self::ShowPreviousVersions,
            "ACCESS_BASED_ENUMERATION" => Self::AccessBasedEnumeration,
            "CONTINUOUSLY_AVAILABLE" => Self::ContinuouslyAvailable,
            _ => Self::UnknownValue(smb_settings::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SMBSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EncryptData => serializer.serialize_i32(1),
            Self::Browsable => serializer.serialize_i32(2),
            Self::ChangeNotify => serializer.serialize_i32(3),
            Self::NonBrowsable => serializer.serialize_i32(4),
            Self::Oplocks => serializer.serialize_i32(5),
            Self::ShowSnapshot => serializer.serialize_i32(6),
            Self::ShowPreviousVersions => serializer.serialize_i32(7),
            Self::AccessBasedEnumeration => serializer.serialize_i32(8),
            Self::ContinuouslyAvailable => serializer.serialize_i32(9),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SMBSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SMBSettings>::new(
            ".google.cloud.netapp.v1.SMBSettings",
        ))
    }
}

/// The security style of the volume, can be either UNIX or NTFS.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SecurityStyle {
    /// SecurityStyle is unspecified
    Unspecified,
    /// SecurityStyle uses NTFS
    Ntfs,
    /// SecurityStyle uses UNIX
    Unix,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SecurityStyle::value] or
    /// [SecurityStyle::name].
    UnknownValue(security_style::UnknownValue),
}

#[doc(hidden)]
pub mod security_style {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SecurityStyle {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ntfs => std::option::Option::Some(1),
            Self::Unix => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SECURITY_STYLE_UNSPECIFIED"),
            Self::Ntfs => std::option::Option::Some("NTFS"),
            Self::Unix => std::option::Option::Some("UNIX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SecurityStyle {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SecurityStyle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SecurityStyle {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ntfs,
            2 => Self::Unix,
            _ => Self::UnknownValue(security_style::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SecurityStyle {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SECURITY_STYLE_UNSPECIFIED" => Self::Unspecified,
            "NTFS" => Self::Ntfs,
            "UNIX" => Self::Unix,
            _ => Self::UnknownValue(security_style::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SecurityStyle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ntfs => serializer.serialize_i32(1),
            Self::Unix => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SecurityStyle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecurityStyle>::new(
            ".google.cloud.netapp.v1.SecurityStyle",
        ))
    }
}

/// Actions to be restricted for a volume.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RestrictedAction {
    /// Unspecified restricted action
    Unspecified,
    /// Prevent volume from being deleted when mounted.
    Delete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RestrictedAction::value] or
    /// [RestrictedAction::name].
    UnknownValue(restricted_action::UnknownValue),
}

#[doc(hidden)]
pub mod restricted_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RestrictedAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Delete => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESTRICTED_ACTION_UNSPECIFIED"),
            Self::Delete => std::option::Option::Some("DELETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RestrictedAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RestrictedAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RestrictedAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Delete,
            _ => Self::UnknownValue(restricted_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RestrictedAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESTRICTED_ACTION_UNSPECIFIED" => Self::Unspecified,
            "DELETE" => Self::Delete,
            _ => Self::UnknownValue(restricted_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RestrictedAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Delete => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RestrictedAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestrictedAction>::new(
            ".google.cloud.netapp.v1.RestrictedAction",
        ))
    }
}
