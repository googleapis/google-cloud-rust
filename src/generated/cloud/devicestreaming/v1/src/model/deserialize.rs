// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeviceMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status_update,
            __stream_status,
            __stream_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeviceMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "statusUpdate" => Ok(__FieldTag::__status_update),
                            "status_update" => Ok(__FieldTag::__status_update),
                            "streamStatus" => Ok(__FieldTag::__stream_status),
                            "stream_status" => Ok(__FieldTag::__stream_status),
                            "streamData" => Ok(__FieldTag::__stream_data),
                            "stream_data" => Ok(__FieldTag::__stream_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeviceMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeviceMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status_update => {
                            if !fields.insert(__FieldTag::__status_update) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status_update"));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceMessage.status_update, latest field was statusUpdate",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::device_message::Contents::StatusUpdate(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StatusUpdate>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__stream_status => {
                            if !fields.insert(__FieldTag::__stream_status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stream_status"));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceMessage.stream_status, latest field was streamStatus",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::device_message::Contents::StreamStatus(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamStatus>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__stream_data => {
                            if !fields.insert(__FieldTag::__stream_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stream_data"));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceMessage.stream_data, latest field was streamData",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::device_message::Contents::StreamData(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamData>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdbMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __open,
            __stream_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdbMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "open" => Ok(__FieldTag::__open),
                            "streamData" => Ok(__FieldTag::__stream_data),
                            "stream_data" => Ok(__FieldTag::__stream_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdbMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdbMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__open => {
                            if !fields.insert(__FieldTag::__open) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for open"));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.AdbMessage.open, latest field was open",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::adb_message::Contents::Open(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Open>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__stream_data => {
                            if !fields.insert(__FieldTag::__stream_data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stream_data"));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.AdbMessage.stream_data, latest field was streamData",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::adb_message::Contents::StreamData(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamData>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StatusUpdate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __properties,
            __features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatusUpdate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "properties" => Ok(__FieldTag::__properties),
                            "features" => Ok(__FieldTag::__features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StatusUpdate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatusUpdate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::status_update::DeviceState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for properties"));
                            }
                            result.properties = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for features"));
                            }
                            result.features = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __okay,
            __fail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "okay" => Ok(__FieldTag::__okay),
                            "fail" => Ok(__FieldTag::__fail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stream_id"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__okay => {
                            if !fields.insert(__FieldTag::__okay) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for okay"));
                            }
                            if result.status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `status`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamStatus.okay, latest field was okay",
                                ));
                            }
                            result.status = std::option::Option::Some(
                                crate::model::stream_status::Status::Okay(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Okay>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__fail => {
                            if !fields.insert(__FieldTag::__fail) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for fail"));
                            }
                            if result.status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `status`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamStatus.fail, latest field was fail",
                                ));
                            }
                            result.status = std::option::Option::Some(
                                crate::model::stream_status::Status::Fail(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Fail>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Open {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Open")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Open;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Open")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stream_id"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for service"));
                            }
                            result.service = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __data,
            __close,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "data" => Ok(__FieldTag::__data),
                            "close" => Ok(__FieldTag::__close),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for stream_id"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_id = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for data"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamData.data, latest field was data",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::stream_data::Contents::Data(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__close => {
                            if !fields.insert(__FieldTag::__close) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for close"));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamData.close, latest field was close",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::stream_data::Contents::Close(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Close>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Okay {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Okay")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Okay;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Okay")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Fail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Fail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for reason"));
                            }
                            result.reason = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Close {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Close")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Close;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Close")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __device_session,
            __device_session_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deviceSession" => Ok(__FieldTag::__device_session),
                            "device_session" => Ok(__FieldTag::__device_session),
                            "deviceSessionId" => Ok(__FieldTag::__device_session_id),
                            "device_session_id" => Ok(__FieldTag::__device_session_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__device_session => {
                            if !fields.insert(__FieldTag::__device_session) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for device_session"));
                            }
                            result.device_session = map.next_value::<std::option::Option<crate::model::DeviceSession>>()?
                                ;
                        },
                        __FieldTag::__device_session_id => {
                            if !fields.insert(__FieldTag::__device_session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for device_session_id"));
                            }
                            result.device_session_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDeviceSessionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeviceSessionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDeviceSessionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeviceSessionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDeviceSessionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __device_sessions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeviceSessionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deviceSessions" => Ok(__FieldTag::__device_sessions),
                            "device_sessions" => Ok(__FieldTag::__device_sessions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDeviceSessionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeviceSessionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__device_sessions => {
                            if !fields.insert(__FieldTag::__device_sessions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for device_sessions"));
                            }
                            result.device_sessions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DeviceSession>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CancelDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CancelDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __device_session,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deviceSession" => Ok(__FieldTag::__device_session),
                            "device_session" => Ok(__FieldTag::__device_session),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__device_session => {
                            if !fields.insert(__FieldTag::__device_session) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for device_session"));
                            }
                            result.device_session = map.next_value::<std::option::Option<crate::model::DeviceSession>>()?
                                ;
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeviceSession {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __state_histories,
            __ttl,
            __expire_time,
            __inactivity_timeout,
            __create_time,
            __active_start_time,
            __android_device,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeviceSession")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "stateHistories" => Ok(__FieldTag::__state_histories),
                            "state_histories" => Ok(__FieldTag::__state_histories),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "inactivityTimeout" => Ok(__FieldTag::__inactivity_timeout),
                            "inactivity_timeout" => Ok(__FieldTag::__inactivity_timeout),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "activeStartTime" => Ok(__FieldTag::__active_start_time),
                            "active_start_time" => Ok(__FieldTag::__active_start_time),
                            "androidDevice" => Ok(__FieldTag::__android_device),
                            "android_device" => Ok(__FieldTag::__android_device),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeviceSession;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeviceSession")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for display_name"));
                            }
                            result.display_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state"));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::device_session::SessionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__state_histories => {
                            if !fields.insert(__FieldTag::__state_histories) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state_histories"));
                            }
                            result.state_histories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::device_session::SessionStateEvent>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ttl"));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceSession.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::device_session::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for expire_time"));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceSession.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::device_session::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__inactivity_timeout => {
                            if !fields.insert(__FieldTag::__inactivity_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for inactivity_timeout"));
                            }
                            result.inactivity_timeout = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__active_start_time => {
                            if !fields.insert(__FieldTag::__active_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for active_start_time"));
                            }
                            result.active_start_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__android_device => {
                            if !fields.insert(__FieldTag::__android_device) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for android_device"));
                            }
                            result.android_device = map.next_value::<std::option::Option<crate::model::AndroidDevice>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::device_session::SessionStateEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_state,
            __event_time,
            __state_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionStateEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionState" => Ok(__FieldTag::__session_state),
                            "session_state" => Ok(__FieldTag::__session_state),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::device_session::SessionStateEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionStateEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_state => {
                            if !fields.insert(__FieldTag::__session_state) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for session_state"));
                            }
                            result.session_state = map.next_value::<std::option::Option<crate::model::device_session::SessionState>>()?.unwrap_or_default();
                        },
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for event_time"));
                            }
                            result.event_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for state_message"));
                            }
                            result.state_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AndroidDevice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __android_model_id,
            __android_version_id,
            __locale,
            __orientation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AndroidDevice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "androidModelId" => Ok(__FieldTag::__android_model_id),
                            "android_model_id" => Ok(__FieldTag::__android_model_id),
                            "androidVersionId" => Ok(__FieldTag::__android_version_id),
                            "android_version_id" => Ok(__FieldTag::__android_version_id),
                            "locale" => Ok(__FieldTag::__locale),
                            "orientation" => Ok(__FieldTag::__orientation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AndroidDevice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AndroidDevice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__android_model_id => {
                            if !fields.insert(__FieldTag::__android_model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for android_model_id"));
                            }
                            result.android_model_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__android_version_id => {
                            if !fields.insert(__FieldTag::__android_version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for android_version_id"));
                            }
                            result.android_version_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__locale => {
                            if !fields.insert(__FieldTag::__locale) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for locale"));
                            }
                            result.locale = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__orientation => {
                            if !fields.insert(__FieldTag::__orientation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for orientation"));
                            }
                            result.orientation = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
