// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A message returned from a device.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeviceMessage {
    pub contents: std::option::Option<crate::model::device_message::Contents>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeviceMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::DeviceMessage::contents].
    ///
    /// Note that all the setters affecting `contents` are mutually
    /// exclusive.
    pub fn set_contents<
        T: std::convert::Into<std::option::Option<crate::model::device_message::Contents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.contents = v.into();
        self
    }

    /// The value of [contents][crate::model::DeviceMessage::contents]
    /// if it holds a `StatusUpdate`, `None` if the field is not set or
    /// holds a different branch.
    pub fn status_update(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StatusUpdate>> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::device_message::Contents::StatusUpdate(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::DeviceMessage::contents]
    /// to hold a `StatusUpdate`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_status_update<T: std::convert::Into<std::boxed::Box<crate::model::StatusUpdate>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contents = std::option::Option::Some(
            crate::model::device_message::Contents::StatusUpdate(v.into()),
        );
        self
    }

    /// The value of [contents][crate::model::DeviceMessage::contents]
    /// if it holds a `StreamStatus`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_status(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamStatus>> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::device_message::Contents::StreamStatus(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::DeviceMessage::contents]
    /// to hold a `StreamStatus`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_stream_status<T: std::convert::Into<std::boxed::Box<crate::model::StreamStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contents = std::option::Option::Some(
            crate::model::device_message::Contents::StreamStatus(v.into()),
        );
        self
    }

    /// The value of [contents][crate::model::DeviceMessage::contents]
    /// if it holds a `StreamData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::StreamData>> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::device_message::Contents::StreamData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::DeviceMessage::contents]
    /// to hold a `StreamData`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_stream_data<T: std::convert::Into<std::boxed::Box<crate::model::StreamData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contents =
            std::option::Option::Some(crate::model::device_message::Contents::StreamData(v.into()));
        self
    }
}

impl wkt::message::Message for DeviceMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.DeviceMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeviceMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status_update,
            __stream_status,
            __stream_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeviceMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "statusUpdate" => Ok(__FieldTag::__status_update),
                            "status_update" => Ok(__FieldTag::__status_update),
                            "streamStatus" => Ok(__FieldTag::__stream_status),
                            "stream_status" => Ok(__FieldTag::__stream_status),
                            "streamData" => Ok(__FieldTag::__stream_data),
                            "stream_data" => Ok(__FieldTag::__stream_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeviceMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeviceMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status_update => {
                            if !fields.insert(__FieldTag::__status_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_update",
                                ));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceMessage.status_update, latest field was statusUpdate",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::device_message::Contents::StatusUpdate(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StatusUpdate>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__stream_status => {
                            if !fields.insert(__FieldTag::__stream_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_status",
                                ));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceMessage.stream_status, latest field was streamStatus",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::device_message::Contents::StreamStatus(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StreamStatus>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__stream_data => {
                            if !fields.insert(__FieldTag::__stream_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_data",
                                ));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceMessage.stream_data, latest field was streamData",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::device_message::Contents::StreamData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StreamData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeviceMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.status_update() {
            state.serialize_entry("statusUpdate", value)?;
        }
        if let Some(value) = self.stream_status() {
            state.serialize_entry("streamStatus", value)?;
        }
        if let Some(value) = self.stream_data() {
            state.serialize_entry("streamData", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DeviceMessage].
pub mod device_message {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Contents {
        /// Information about the device's state.
        StatusUpdate(std::boxed::Box<crate::model::StatusUpdate>),
        /// The result of a device stream from ADB.
        StreamStatus(std::boxed::Box<crate::model::StreamStatus>),
        /// Data from an open stream.
        StreamData(std::boxed::Box<crate::model::StreamData>),
    }
}

/// A message to an ADB server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdbMessage {
    pub contents: std::option::Option<crate::model::adb_message::Contents>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdbMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::AdbMessage::contents].
    ///
    /// Note that all the setters affecting `contents` are mutually
    /// exclusive.
    pub fn set_contents<
        T: std::convert::Into<std::option::Option<crate::model::adb_message::Contents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.contents = v.into();
        self
    }

    /// The value of [contents][crate::model::AdbMessage::contents]
    /// if it holds a `Open`, `None` if the field is not set or
    /// holds a different branch.
    pub fn open(&self) -> std::option::Option<&std::boxed::Box<crate::model::Open>> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::adb_message::Contents::Open(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::AdbMessage::contents]
    /// to hold a `Open`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_open<T: std::convert::Into<std::boxed::Box<crate::model::Open>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contents =
            std::option::Option::Some(crate::model::adb_message::Contents::Open(v.into()));
        self
    }

    /// The value of [contents][crate::model::AdbMessage::contents]
    /// if it holds a `StreamData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stream_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::StreamData>> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::adb_message::Contents::StreamData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::AdbMessage::contents]
    /// to hold a `StreamData`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_stream_data<T: std::convert::Into<std::boxed::Box<crate::model::StreamData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contents =
            std::option::Option::Some(crate::model::adb_message::Contents::StreamData(v.into()));
        self
    }
}

impl wkt::message::Message for AdbMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.AdbMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdbMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __open,
            __stream_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdbMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "open" => Ok(__FieldTag::__open),
                            "streamData" => Ok(__FieldTag::__stream_data),
                            "stream_data" => Ok(__FieldTag::__stream_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdbMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdbMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__open => {
                            if !fields.insert(__FieldTag::__open) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for open",
                                ));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.AdbMessage.open, latest field was open",
                                ));
                            }
                            result.contents =
                                std::option::Option::Some(
                                    crate::model::adb_message::Contents::Open(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Open>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__stream_data => {
                            if !fields.insert(__FieldTag::__stream_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_data",
                                ));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.AdbMessage.stream_data, latest field was streamData",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::adb_message::Contents::StreamData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StreamData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdbMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.open() {
            state.serialize_entry("open", value)?;
        }
        if let Some(value) = self.stream_data() {
            state.serialize_entry("streamData", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AdbMessage].
pub mod adb_message {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Contents {
        /// Open a new stream.
        Open(std::boxed::Box<crate::model::Open>),
        /// Send data to a stream.
        StreamData(std::boxed::Box<crate::model::StreamData>),
    }
}

/// A StatusUpdate message given over the ADB protocol for the device state.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StatusUpdate {
    /// The device's state
    pub state: crate::model::status_update::DeviceState,

    /// A map of properties with information about this device.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// A comma-separated list of "features" that this device supports.
    pub features: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatusUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::StatusUpdate::state].
    pub fn set_state<T: std::convert::Into<crate::model::status_update::DeviceState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::StatusUpdate::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [features][crate::model::StatusUpdate::features].
    pub fn set_features<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.features = v.into();
        self
    }
}

impl wkt::message::Message for StatusUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.StatusUpdate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StatusUpdate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __properties,
            __features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatusUpdate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "properties" => Ok(__FieldTag::__properties),
                            "features" => Ok(__FieldTag::__features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StatusUpdate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatusUpdate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::status_update::DeviceState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StatusUpdate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StatusUpdate].
pub mod status_update {
    #[allow(unused_imports)]
    use super::*;

    /// The state displayed with the ADB Device when running "adb devices"
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeviceState {
        /// The device state is unknown.
        Unspecified,
        /// The ADB device is in the "device" status.
        Device,
        /// The ADB device is in the "recovery" status.
        Recovery,
        /// The ADB device is in the "rescue" status.
        Rescue,
        /// The ADB device is in the "sideload" status.
        Sideload,
        /// The ADB device is in the "missing" status.
        Missing,
        /// The ADB device is in the "offline" status.
        Offline,
        /// The ADB device is in the "unauthorized" status.
        Unauthorized,
        /// The ADB device is in the "authorizing" status.
        Authorizing,
        /// The ADB device is in the "connecting" status.
        Connecting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeviceState::value] or
        /// [DeviceState::name].
        UnknownValue(device_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod device_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DeviceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Device => std::option::Option::Some(1),
                Self::Recovery => std::option::Option::Some(2),
                Self::Rescue => std::option::Option::Some(3),
                Self::Sideload => std::option::Option::Some(4),
                Self::Missing => std::option::Option::Some(10),
                Self::Offline => std::option::Option::Some(11),
                Self::Unauthorized => std::option::Option::Some(12),
                Self::Authorizing => std::option::Option::Some(13),
                Self::Connecting => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DEVICE_STATE_UNSPECIFIED"),
                Self::Device => std::option::Option::Some("DEVICE"),
                Self::Recovery => std::option::Option::Some("RECOVERY"),
                Self::Rescue => std::option::Option::Some("RESCUE"),
                Self::Sideload => std::option::Option::Some("SIDELOAD"),
                Self::Missing => std::option::Option::Some("MISSING"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::Unauthorized => std::option::Option::Some("UNAUTHORIZED"),
                Self::Authorizing => std::option::Option::Some("AUTHORIZING"),
                Self::Connecting => std::option::Option::Some("CONNECTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DeviceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DeviceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DeviceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Device,
                2 => Self::Recovery,
                3 => Self::Rescue,
                4 => Self::Sideload,
                10 => Self::Missing,
                11 => Self::Offline,
                12 => Self::Unauthorized,
                13 => Self::Authorizing,
                14 => Self::Connecting,
                _ => Self::UnknownValue(device_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DeviceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEVICE_STATE_UNSPECIFIED" => Self::Unspecified,
                "DEVICE" => Self::Device,
                "RECOVERY" => Self::Recovery,
                "RESCUE" => Self::Rescue,
                "SIDELOAD" => Self::Sideload,
                "MISSING" => Self::Missing,
                "OFFLINE" => Self::Offline,
                "UNAUTHORIZED" => Self::Unauthorized,
                "AUTHORIZING" => Self::Authorizing,
                "CONNECTING" => Self::Connecting,
                _ => Self::UnknownValue(device_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DeviceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Device => serializer.serialize_i32(1),
                Self::Recovery => serializer.serialize_i32(2),
                Self::Rescue => serializer.serialize_i32(3),
                Self::Sideload => serializer.serialize_i32(4),
                Self::Missing => serializer.serialize_i32(10),
                Self::Offline => serializer.serialize_i32(11),
                Self::Unauthorized => serializer.serialize_i32(12),
                Self::Authorizing => serializer.serialize_i32(13),
                Self::Connecting => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DeviceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeviceState>::new(
                ".google.cloud.devicestreaming.v1.StatusUpdate.DeviceState",
            ))
        }
    }
}

/// The result of a stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamStatus {
    /// The unique ID of this stream, assigned by the client.
    pub stream_id: i32,

    /// The result of the stream. Either "Okay" for success or "Fail" for failure.
    pub status: std::option::Option<crate::model::stream_status::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stream_id][crate::model::StreamStatus::stream_id].
    pub fn set_stream_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.stream_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::StreamStatus::status].
    ///
    /// Note that all the setters affecting `status` are mutually
    /// exclusive.
    pub fn set_status<
        T: std::convert::Into<std::option::Option<crate::model::stream_status::Status>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// The value of [status][crate::model::StreamStatus::status]
    /// if it holds a `Okay`, `None` if the field is not set or
    /// holds a different branch.
    pub fn okay(&self) -> std::option::Option<&std::boxed::Box<crate::model::Okay>> {
        #[allow(unreachable_patterns)]
        self.status.as_ref().and_then(|v| match v {
            crate::model::stream_status::Status::Okay(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [status][crate::model::StreamStatus::status]
    /// to hold a `Okay`.
    ///
    /// Note that all the setters affecting `status` are
    /// mutually exclusive.
    pub fn set_okay<T: std::convert::Into<std::boxed::Box<crate::model::Okay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status =
            std::option::Option::Some(crate::model::stream_status::Status::Okay(v.into()));
        self
    }

    /// The value of [status][crate::model::StreamStatus::status]
    /// if it holds a `Fail`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fail(&self) -> std::option::Option<&std::boxed::Box<crate::model::Fail>> {
        #[allow(unreachable_patterns)]
        self.status.as_ref().and_then(|v| match v {
            crate::model::stream_status::Status::Fail(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [status][crate::model::StreamStatus::status]
    /// to hold a `Fail`.
    ///
    /// Note that all the setters affecting `status` are
    /// mutually exclusive.
    pub fn set_fail<T: std::convert::Into<std::boxed::Box<crate::model::Fail>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status =
            std::option::Option::Some(crate::model::stream_status::Status::Fail(v.into()));
        self
    }
}

impl wkt::message::Message for StreamStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.StreamStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __okay,
            __fail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "okay" => Ok(__FieldTag::__okay),
                            "fail" => Ok(__FieldTag::__fail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__okay => {
                            if !fields.insert(__FieldTag::__okay) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for okay",
                                ));
                            }
                            if result.status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `status`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamStatus.okay, latest field was okay",
                                ));
                            }
                            result.status =
                                std::option::Option::Some(
                                    crate::model::stream_status::Status::Okay(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Okay>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__fail => {
                            if !fields.insert(__FieldTag::__fail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fail",
                                ));
                            }
                            if result.status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `status`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamStatus.fail, latest field was fail",
                                ));
                            }
                            result.status =
                                std::option::Option::Some(
                                    crate::model::stream_status::Status::Fail(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Fail>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.stream_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("streamId", &__With(&self.stream_id))?;
        }
        if let Some(value) = self.okay() {
            state.serialize_entry("okay", value)?;
        }
        if let Some(value) = self.fail() {
            state.serialize_entry("fail", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamStatus].
pub mod stream_status {
    #[allow(unused_imports)]
    use super::*;

    /// The result of the stream. Either "Okay" for success or "Fail" for failure.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Okay for success.
        Okay(std::boxed::Box<crate::model::Okay>),
        /// Fail for failure.
        Fail(std::boxed::Box<crate::model::Fail>),
    }
}

/// Message for opening a new stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Open {
    /// Required. The unique ID that will be used to talk to this stream. This
    /// should probably just be a number that increments for each new Open request.
    pub stream_id: i32,

    /// Optional. An ADB service to use in the new stream.
    pub service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Open {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stream_id][crate::model::Open::stream_id].
    pub fn set_stream_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.stream_id = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Open::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for Open {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.Open"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Open {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Open")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Open;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Open")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Open {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.stream_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("streamId", &__With(&self.stream_id))?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Data for a stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamData {
    /// Required. The unique ID of this stream, assigned by the client.
    pub stream_id: i32,

    /// The data of the stream, either bytes or "Close", indicating that the stream
    /// is done.
    pub contents: std::option::Option<crate::model::stream_data::Contents>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stream_id][crate::model::StreamData::stream_id].
    pub fn set_stream_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.stream_id = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::StreamData::contents].
    ///
    /// Note that all the setters affecting `contents` are mutually
    /// exclusive.
    pub fn set_contents<
        T: std::convert::Into<std::option::Option<crate::model::stream_data::Contents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.contents = v.into();
        self
    }

    /// The value of [contents][crate::model::StreamData::contents]
    /// if it holds a `Data`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::stream_data::Contents::Data(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::StreamData::contents]
    /// to hold a `Data`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.contents =
            std::option::Option::Some(crate::model::stream_data::Contents::Data(v.into()));
        self
    }

    /// The value of [contents][crate::model::StreamData::contents]
    /// if it holds a `Close`, `None` if the field is not set or
    /// holds a different branch.
    pub fn close(&self) -> std::option::Option<&std::boxed::Box<crate::model::Close>> {
        #[allow(unreachable_patterns)]
        self.contents.as_ref().and_then(|v| match v {
            crate::model::stream_data::Contents::Close(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [contents][crate::model::StreamData::contents]
    /// to hold a `Close`.
    ///
    /// Note that all the setters affecting `contents` are
    /// mutually exclusive.
    pub fn set_close<T: std::convert::Into<std::boxed::Box<crate::model::Close>>>(
        mut self,
        v: T,
    ) -> Self {
        self.contents =
            std::option::Option::Some(crate::model::stream_data::Contents::Close(v.into()));
        self
    }
}

impl wkt::message::Message for StreamData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.StreamData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __data,
            __close,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "data" => Ok(__FieldTag::__data),
                            "close" => Ok(__FieldTag::__close),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamData.data, latest field was data",
                                ));
                            }
                            result.contents = std::option::Option::Some(
                                crate::model::stream_data::Contents::Data(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__close => {
                            if !fields.insert(__FieldTag::__close) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for close",
                                ));
                            }
                            if result.contents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `contents`, a oneof with full ID .google.cloud.devicestreaming.v1.StreamData.close, latest field was close",
                                ));
                            }
                            result.contents =
                                std::option::Option::Some(
                                    crate::model::stream_data::Contents::Close(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Close>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.stream_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("streamId", &__With(&self.stream_id))?;
        }
        if let Some(value) = self.data() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(value))?;
        }
        if let Some(value) = self.close() {
            state.serialize_entry("close", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamData].
pub mod stream_data {
    #[allow(unused_imports)]
    use super::*;

    /// The data of the stream, either bytes or "Close", indicating that the stream
    /// is done.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Contents {
        /// Data in the stream.
        Data(::bytes::Bytes),
        /// The stream is closing. EOF.
        Close(std::boxed::Box<crate::model::Close>),
    }
}

/// Message signifying that the stream is open
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Okay {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Okay {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Okay {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.Okay"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Okay {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Okay")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Okay;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Okay")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Okay {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message signifying that the stream failed to open
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Fail {
    /// A user-displayable failure reason.
    pub reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reason][crate::model::Fail::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for Fail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.Fail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Fail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message signifying that the stream closed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Close {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Close {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Close {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.Close"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Close {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Close")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Close;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Close")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Close {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DirectAccessService.CreateDeviceSession.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDeviceSessionRequest {
    /// Required. The Compute Engine project under which this device will be
    /// allocated. "projects/{project_id}"
    pub parent: std::string::String,

    /// Required. A DeviceSession to create.
    pub device_session: std::option::Option<crate::model::DeviceSession>,

    /// Optional. The ID to use for the DeviceSession, which will become the final
    /// component of the DeviceSession's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    pub device_session_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeviceSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeviceSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [device_session][crate::model::CreateDeviceSessionRequest::device_session].
    pub fn set_device_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeviceSession>,
    {
        self.device_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_session][crate::model::CreateDeviceSessionRequest::device_session].
    pub fn set_or_clear_device_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeviceSession>,
    {
        self.device_session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [device_session_id][crate::model::CreateDeviceSessionRequest::device_session_id].
    pub fn set_device_session_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.device_session_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeviceSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.CreateDeviceSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __device_session,
            __device_session_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deviceSession" => Ok(__FieldTag::__device_session),
                            "device_session" => Ok(__FieldTag::__device_session),
                            "deviceSessionId" => Ok(__FieldTag::__device_session_id),
                            "device_session_id" => Ok(__FieldTag::__device_session_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__device_session => {
                            if !fields.insert(__FieldTag::__device_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_session",
                                ));
                            }
                            result.device_session = map
                                .next_value::<std::option::Option<crate::model::DeviceSession>>()?;
                        }
                        __FieldTag::__device_session_id => {
                            if !fields.insert(__FieldTag::__device_session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_session_id",
                                ));
                            }
                            result.device_session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDeviceSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.device_session.is_some() {
            state.serialize_entry("deviceSession", &self.device_session)?;
        }
        if !self.device_session_id.is_empty() {
            state.serialize_entry("deviceSessionId", &self.device_session_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DirectAccessService.ListDeviceSessions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeviceSessionsRequest {
    /// Required. The name of the parent to request, e.g. "projects/{project_id}"
    pub parent: std::string::String,

    /// Optional. The maximum number of DeviceSessions to return.
    pub page_size: i32,

    /// Optional. A continuation token for paging.
    pub page_token: std::string::String,

    /// Optional. If specified, responses will be filtered by the given filter.
    /// Allowed fields are: session_state.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeviceSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeviceSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeviceSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeviceSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeviceSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDeviceSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.ListDeviceSessionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeviceSessionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeviceSessionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeviceSessionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeviceSessionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeviceSessionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for DirectAccessService.ListDeviceSessions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeviceSessionsResponse {
    /// The sessions matching the specified filter in the given cloud project.
    pub device_sessions: std::vec::Vec<crate::model::DeviceSession>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeviceSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [device_sessions][crate::model::ListDeviceSessionsResponse::device_sessions].
    pub fn set_device_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeviceSession>,
    {
        use std::iter::Iterator;
        self.device_sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeviceSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDeviceSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.ListDeviceSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeviceSessionsResponse {
    type PageItem = crate::model::DeviceSession;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.device_sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeviceSessionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __device_sessions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeviceSessionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deviceSessions" => Ok(__FieldTag::__device_sessions),
                            "device_sessions" => Ok(__FieldTag::__device_sessions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeviceSessionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeviceSessionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__device_sessions => {
                            if !fields.insert(__FieldTag::__device_sessions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_sessions",
                                ));
                            }
                            result.device_sessions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DeviceSession>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeviceSessionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.device_sessions.is_empty() {
            state.serialize_entry("deviceSessions", &self.device_sessions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DirectAccessService.GetDeviceSession.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDeviceSessionRequest {
    /// Required. Name of the DeviceSession, e.g.
    /// "projects/{project_id}/deviceSessions/{session_id}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeviceSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeviceSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeviceSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.GetDeviceSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDeviceSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DirectAccessService.CancelDeviceSession.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelDeviceSessionRequest {
    /// Required. Name of the DeviceSession, e.g.
    /// "projects/{project_id}/deviceSessions/{session_id}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelDeviceSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDeviceSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelDeviceSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.CancelDeviceSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelDeviceSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DirectAccessService.UpdateDeviceSession.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDeviceSessionRequest {
    /// Required. DeviceSession to update.
    /// The DeviceSession's `name` field is used to identify the session to update
    /// "projects/{project_id}/deviceSessions/{session_id}"
    pub device_session: std::option::Option<crate::model::DeviceSession>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeviceSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [device_session][crate::model::UpdateDeviceSessionRequest::device_session].
    pub fn set_device_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeviceSession>,
    {
        self.device_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_session][crate::model::UpdateDeviceSessionRequest::device_session].
    pub fn set_or_clear_device_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeviceSession>,
    {
        self.device_session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeviceSessionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeviceSessionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDeviceSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.UpdateDeviceSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDeviceSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __device_session,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDeviceSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deviceSession" => Ok(__FieldTag::__device_session),
                            "device_session" => Ok(__FieldTag::__device_session),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDeviceSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDeviceSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__device_session => {
                            if !fields.insert(__FieldTag::__device_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_session",
                                ));
                            }
                            result.device_session = map
                                .next_value::<std::option::Option<crate::model::DeviceSession>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDeviceSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.device_session.is_some() {
            state.serialize_entry("deviceSession", &self.device_session)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Protobuf message describing the device message, used from several RPCs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeviceSession {
    /// Optional. Name of the DeviceSession, e.g.
    /// "projects/{project_id}/deviceSessions/{session_id}"
    pub name: std::string::String,

    /// Output only. The title of the DeviceSession to be presented in the UI.
    pub display_name: std::string::String,

    /// Output only. Current state of the DeviceSession.
    pub state: crate::model::device_session::SessionState,

    /// Output only. The historical state transitions of the session_state message
    /// including the current session state.
    pub state_histories: std::vec::Vec<crate::model::device_session::SessionStateEvent>,

    /// Output only. The interval of time that this device must be interacted with
    /// before it transitions from ACTIVE to TIMEOUT_INACTIVITY.
    pub inactivity_timeout: std::option::Option<wkt::Duration>,

    /// Output only. The time that the Session was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp that the session first became ACTIVE.
    pub active_start_time: std::option::Option<wkt::Timestamp>,

    /// Required. The requested device
    pub android_device: std::option::Option<crate::model::AndroidDevice>,

    /// The amount of time that a device will be initially allocated for.
    pub expiration: std::option::Option<crate::model::device_session::Expiration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeviceSession {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeviceSession::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DeviceSession::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DeviceSession::state].
    pub fn set_state<T: std::convert::Into<crate::model::device_session::SessionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_histories][crate::model::DeviceSession::state_histories].
    pub fn set_state_histories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::device_session::SessionStateEvent>,
    {
        use std::iter::Iterator;
        self.state_histories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inactivity_timeout][crate::model::DeviceSession::inactivity_timeout].
    pub fn set_inactivity_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.inactivity_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inactivity_timeout][crate::model::DeviceSession::inactivity_timeout].
    pub fn set_or_clear_inactivity_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.inactivity_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::DeviceSession::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeviceSession::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [active_start_time][crate::model::DeviceSession::active_start_time].
    pub fn set_active_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.active_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [active_start_time][crate::model::DeviceSession::active_start_time].
    pub fn set_or_clear_active_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.active_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [android_device][crate::model::DeviceSession::android_device].
    pub fn set_android_device<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AndroidDevice>,
    {
        self.android_device = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [android_device][crate::model::DeviceSession::android_device].
    pub fn set_or_clear_android_device<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AndroidDevice>,
    {
        self.android_device = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expiration][crate::model::DeviceSession::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::device_session::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::DeviceSession::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::device_session::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::DeviceSession::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::device_session::Expiration::Ttl(v.into()));
        self
    }

    /// The value of [expiration][crate::model::DeviceSession::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::device_session::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::DeviceSession::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::device_session::Expiration::ExpireTime(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeviceSession {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.DeviceSession"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeviceSession {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __state_histories,
            __ttl,
            __expire_time,
            __inactivity_timeout,
            __create_time,
            __active_start_time,
            __android_device,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeviceSession")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "stateHistories" => Ok(__FieldTag::__state_histories),
                            "state_histories" => Ok(__FieldTag::__state_histories),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "inactivityTimeout" => Ok(__FieldTag::__inactivity_timeout),
                            "inactivity_timeout" => Ok(__FieldTag::__inactivity_timeout),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "activeStartTime" => Ok(__FieldTag::__active_start_time),
                            "active_start_time" => Ok(__FieldTag::__active_start_time),
                            "androidDevice" => Ok(__FieldTag::__android_device),
                            "android_device" => Ok(__FieldTag::__android_device),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeviceSession;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeviceSession")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::device_session::SessionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_histories => {
                            if !fields.insert(__FieldTag::__state_histories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_histories",
                                ));
                            }
                            result.state_histories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::device_session::SessionStateEvent>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceSession.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::device_session::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.devicestreaming.v1.DeviceSession.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::device_session::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__inactivity_timeout => {
                            if !fields.insert(__FieldTag::__inactivity_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inactivity_timeout",
                                ));
                            }
                            result.inactivity_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__active_start_time => {
                            if !fields.insert(__FieldTag::__active_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_start_time",
                                ));
                            }
                            result.active_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__android_device => {
                            if !fields.insert(__FieldTag::__android_device) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for android_device",
                                ));
                            }
                            result.android_device = map
                                .next_value::<std::option::Option<crate::model::AndroidDevice>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeviceSession {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_histories.is_empty() {
            state.serialize_entry("stateHistories", &self.state_histories)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if let Some(value) = self.expire_time() {
            state.serialize_entry("expireTime", value)?;
        }
        if self.inactivity_timeout.is_some() {
            state.serialize_entry("inactivityTimeout", &self.inactivity_timeout)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.active_start_time.is_some() {
            state.serialize_entry("activeStartTime", &self.active_start_time)?;
        }
        if self.android_device.is_some() {
            state.serialize_entry("androidDevice", &self.android_device)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DeviceSession].
pub mod device_session {
    #[allow(unused_imports)]
    use super::*;

    /// A message encapsulating a series of Session states and the time that the
    /// DeviceSession first entered those states.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SessionStateEvent {
        /// Output only. The session_state tracked by this event
        pub session_state: crate::model::device_session::SessionState,

        /// Output only. The time that the session_state first encountered that
        /// state.
        pub event_time: std::option::Option<wkt::Timestamp>,

        /// Output only. A human-readable message to explain the state.
        pub state_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionStateEvent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [session_state][crate::model::device_session::SessionStateEvent::session_state].
        pub fn set_session_state<
            T: std::convert::Into<crate::model::device_session::SessionState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.session_state = v.into();
            self
        }

        /// Sets the value of [event_time][crate::model::device_session::SessionStateEvent::event_time].
        pub fn set_event_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.event_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [event_time][crate::model::device_session::SessionStateEvent::event_time].
        pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.event_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [state_message][crate::model::device_session::SessionStateEvent::state_message].
        pub fn set_state_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_message = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionStateEvent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.devicestreaming.v1.DeviceSession.SessionStateEvent"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SessionStateEvent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __session_state,
                __event_time,
                __state_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SessionStateEvent")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sessionState" => Ok(__FieldTag::__session_state),
                                "session_state" => Ok(__FieldTag::__session_state),
                                "eventTime" => Ok(__FieldTag::__event_time),
                                "event_time" => Ok(__FieldTag::__event_time),
                                "stateMessage" => Ok(__FieldTag::__state_message),
                                "state_message" => Ok(__FieldTag::__state_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SessionStateEvent;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SessionStateEvent")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__session_state => {
                                if !fields.insert(__FieldTag::__session_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for session_state",
                                    ));
                                }
                                result.session_state =
                                    map.next_value::<std::option::Option<
                                        crate::model::device_session::SessionState,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__event_time => {
                                if !fields.insert(__FieldTag::__event_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for event_time",
                                    ));
                                }
                                result.event_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__state_message => {
                                if !fields.insert(__FieldTag::__state_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state_message",
                                    ));
                                }
                                result.state_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SessionStateEvent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.session_state) {
                state.serialize_entry("sessionState", &self.session_state)?;
            }
            if self.event_time.is_some() {
                state.serialize_entry("eventTime", &self.event_time)?;
            }
            if !self.state_message.is_empty() {
                state.serialize_entry("stateMessage", &self.state_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The state that the DeviceSession resides.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionState {
        /// Default value. This value is unused.
        Unspecified,
        /// Initial state of a session request. The session is being validated for
        /// correctness and a device is not yet requested.
        Requested,
        /// The session has been validated and is in the queue for a device.
        Pending,
        /// The session has been granted and the device is accepting
        /// connections.
        Active,
        /// The session duration exceeded the device's reservation time period and
        /// timed out automatically.
        Expired,
        /// The user is finished with the session and it was canceled by the user
        /// while the request was still getting allocated or after allocation and
        /// during device usage period.
        Finished,
        /// Unable to complete the session because the device was unavailable and
        /// it failed to allocate through the scheduler. For example, a device not
        /// in the catalog was requested or the request expired in the allocation
        /// queue.
        Unavailable,
        /// Unable to complete the session for an internal reason, such as an
        /// infrastructure failure.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SessionState::value] or
        /// [SessionState::name].
        UnknownValue(session_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod session_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SessionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Requested => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::Expired => std::option::Option::Some(4),
                Self::Finished => std::option::Option::Some(5),
                Self::Unavailable => std::option::Option::Some(6),
                Self::Error => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SESSION_STATE_UNSPECIFIED"),
                Self::Requested => std::option::Option::Some("REQUESTED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::Finished => std::option::Option::Some("FINISHED"),
                Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SessionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SessionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SessionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Requested,
                2 => Self::Pending,
                3 => Self::Active,
                4 => Self::Expired,
                5 => Self::Finished,
                6 => Self::Unavailable,
                7 => Self::Error,
                _ => Self::UnknownValue(session_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SessionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SESSION_STATE_UNSPECIFIED" => Self::Unspecified,
                "REQUESTED" => Self::Requested,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "EXPIRED" => Self::Expired,
                "FINISHED" => Self::Finished,
                "UNAVAILABLE" => Self::Unavailable,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(session_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SessionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Requested => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::Expired => serializer.serialize_i32(4),
                Self::Finished => serializer.serialize_i32(5),
                Self::Unavailable => serializer.serialize_i32(6),
                Self::Error => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SessionState>::new(
                ".google.cloud.devicestreaming.v1.DeviceSession.SessionState",
            ))
        }
    }

    /// The amount of time that a device will be initially allocated for.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Expiration {
        /// Optional. The amount of time that a device will be initially allocated
        /// for. This can eventually be extended with the UpdateDeviceSession RPC.
        /// Default: 15 minutes.
        Ttl(std::boxed::Box<wkt::Duration>),
        /// Optional. If the device is still in use at this time, any connections
        /// will be ended and the SessionState will transition from ACTIVE to
        /// FINISHED.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
    }
}

/// A single Android device.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AndroidDevice {
    /// Required. The id of the Android device to be used.
    /// Use the TestEnvironmentDiscoveryService to get supported options.
    pub android_model_id: std::string::String,

    /// Required. The id of the Android OS version to be used.
    /// Use the TestEnvironmentDiscoveryService to get supported options.
    pub android_version_id: std::string::String,

    /// Optional. The locale the test device used for testing.
    /// Use the TestEnvironmentDiscoveryService to get supported options.
    pub locale: std::string::String,

    /// Optional. How the device is oriented during the test.
    /// Use the TestEnvironmentDiscoveryService to get supported options.
    pub orientation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AndroidDevice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [android_model_id][crate::model::AndroidDevice::android_model_id].
    pub fn set_android_model_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.android_model_id = v.into();
        self
    }

    /// Sets the value of [android_version_id][crate::model::AndroidDevice::android_version_id].
    pub fn set_android_version_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.android_version_id = v.into();
        self
    }

    /// Sets the value of [locale][crate::model::AndroidDevice::locale].
    pub fn set_locale<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.locale = v.into();
        self
    }

    /// Sets the value of [orientation][crate::model::AndroidDevice::orientation].
    pub fn set_orientation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.orientation = v.into();
        self
    }
}

impl wkt::message::Message for AndroidDevice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.devicestreaming.v1.AndroidDevice"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AndroidDevice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __android_model_id,
            __android_version_id,
            __locale,
            __orientation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AndroidDevice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "androidModelId" => Ok(__FieldTag::__android_model_id),
                            "android_model_id" => Ok(__FieldTag::__android_model_id),
                            "androidVersionId" => Ok(__FieldTag::__android_version_id),
                            "android_version_id" => Ok(__FieldTag::__android_version_id),
                            "locale" => Ok(__FieldTag::__locale),
                            "orientation" => Ok(__FieldTag::__orientation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AndroidDevice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AndroidDevice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__android_model_id => {
                            if !fields.insert(__FieldTag::__android_model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for android_model_id",
                                ));
                            }
                            result.android_model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__android_version_id => {
                            if !fields.insert(__FieldTag::__android_version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for android_version_id",
                                ));
                            }
                            result.android_version_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locale => {
                            if !fields.insert(__FieldTag::__locale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locale",
                                ));
                            }
                            result.locale = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__orientation => {
                            if !fields.insert(__FieldTag::__orientation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for orientation",
                                ));
                            }
                            result.orientation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AndroidDevice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.android_model_id.is_empty() {
            state.serialize_entry("androidModelId", &self.android_model_id)?;
        }
        if !self.android_version_id.is_empty() {
            state.serialize_entry("androidVersionId", &self.android_version_id)?;
        }
        if !self.locale.is_empty() {
            state.serialize_entry("locale", &self.locale)?;
        }
        if !self.orientation.is_empty() {
            state.serialize_entry("orientation", &self.orientation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
