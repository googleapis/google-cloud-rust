// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The create assessment request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAssessmentRequest {
    /// Required. The name of the project in which the assessment is created,
    /// in the format `projects/{project}`.
    pub parent: std::string::String,

    /// Required. The assessment details.
    pub assessment: std::option::Option<crate::model::Assessment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssessmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssessmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [assessment][crate::model::CreateAssessmentRequest::assessment].
    pub fn set_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Assessment>,
    {
        self.assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment][crate::model::CreateAssessmentRequest::assessment].
    pub fn set_or_clear_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Assessment>,
    {
        self.assessment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAssessmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateAssessmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAssessmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __assessment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAssessmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "assessment" => Ok(__FieldTag::__assessment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAssessmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAssessmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assessment => {
                            if !fields.insert(__FieldTag::__assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assessment",
                                ));
                            }
                            result.assessment =
                                map.next_value::<std::option::Option<crate::model::Assessment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAssessmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.assessment.is_some() {
            state.serialize_entry("assessment", &self.assessment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes an event in the lifecycle of a payment transaction.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransactionEvent {
    /// Optional. The type of this transaction event.
    pub event_type: crate::model::transaction_event::TransactionEventType,

    /// Optional. The reason or standardized code that corresponds with this
    /// transaction event, if one exists. For example, a CHARGEBACK event with code
    /// 6005.
    pub reason: std::string::String,

    /// Optional. The value that corresponds with this transaction event, if one
    /// exists. For example, a refund event where $5.00 was refunded. Currency is
    /// obtained from the original transaction data.
    pub value: f64,

    /// Optional. Timestamp when this transaction event occurred; otherwise assumed
    /// to be the time of the API call.
    pub event_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_type][crate::model::TransactionEvent::event_type].
    pub fn set_event_type<
        T: std::convert::Into<crate::model::transaction_event::TransactionEventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::TransactionEvent::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TransactionEvent::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::TransactionEvent::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::TransactionEvent::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransactionEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransactionEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event_type,
            __reason,
            __value,
            __event_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransactionEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            "reason" => Ok(__FieldTag::__reason),
                            "value" => Ok(__FieldTag::__value),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransactionEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransactionEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map
                                .next_value::<std::option::Option<
                                    crate::model::transaction_event::TransactionEventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_time",
                                ));
                            }
                            result.event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransactionEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransactionEvent].
pub mod transaction_event {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents an event in the payment transaction lifecycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransactionEventType {
        /// Default, unspecified event type.
        Unspecified,
        /// Indicates that the transaction is approved by the merchant. The
        /// accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
        /// 'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantApprove,
        /// Indicates that the transaction is denied and concluded due to risks
        /// detected by the merchant. The accompanying reasons can include terms such
        /// as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantDeny,
        /// Indicates that the transaction is being evaluated by a human, due to
        /// suspicion or risk.
        ManualReview,
        /// Indicates that the authorization attempt with the card issuer succeeded.
        Authorization,
        /// Indicates that the authorization attempt with the card issuer failed.
        /// The accompanying reasons can include Visa's '54' indicating that the card
        /// is expired, or '82' indicating that the CVV is incorrect.
        AuthorizationDecline,
        /// Indicates that the transaction is completed because the funds were
        /// settled.
        PaymentCapture,
        /// Indicates that the transaction could not be completed because the funds
        /// were not settled.
        PaymentCaptureDecline,
        /// Indicates that the transaction has been canceled. Specify the reason
        /// for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
        Cancel,
        /// Indicates that the merchant has received a chargeback inquiry due to
        /// fraud for the transaction, requesting additional information before a
        /// fraud chargeback is officially issued and a formal chargeback
        /// notification is sent.
        ChargebackInquiry,
        /// Indicates that the merchant has received a chargeback alert due to fraud
        /// for the transaction. The process of resolving the dispute without
        /// involving the payment network is started.
        ChargebackAlert,
        /// Indicates that a fraud notification is issued for the transaction, sent
        /// by the payment instrument's issuing bank because the transaction appears
        /// to be fraudulent. We recommend including TC40 or SAFE data in the
        /// `reason` field for this event type. For partial chargebacks, we recommend
        /// that you include an amount in the `value` field.
        FraudNotification,
        /// Indicates that the merchant is informed by the payment network that the
        /// transaction has entered the chargeback process due to fraud. Reason code
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        Chargeback,
        /// Indicates that the transaction has entered the chargeback process due to
        /// fraud, and that the merchant has chosen to enter representment. Reason
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        ChargebackRepresentment,
        /// Indicates that the transaction has had a fraud chargeback which was
        /// illegitimate and was reversed as a result. For partial chargebacks, we
        /// recommend that you include an amount in the `value` field.
        ChargebackReverse,
        /// Indicates that the merchant has received a refund for a completed
        /// transaction. For partial refunds, we recommend that you include an amount
        /// in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
        /// exempt tax)
        RefundRequest,
        /// Indicates that the merchant has received a refund request for this
        /// transaction, but that they have declined it. For partial refunds, we
        /// recommend that you include an amount in the `value` field. Reason
        /// example: 'TAX_EXEMPT' (partial refund of exempt tax)
        RefundDecline,
        /// Indicates that the completed transaction was refunded by the merchant.
        /// For partial refunds, we recommend that you include an amount in the
        /// `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
        /// tax)
        Refund,
        /// Indicates that the completed transaction was refunded by the merchant,
        /// and that this refund was reversed. For partial refunds, we recommend that
        /// you include an amount in the `value` field.
        RefundReverse,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransactionEventType::value] or
        /// [TransactionEventType::name].
        UnknownValue(transaction_event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transaction_event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransactionEventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MerchantApprove => std::option::Option::Some(1),
                Self::MerchantDeny => std::option::Option::Some(2),
                Self::ManualReview => std::option::Option::Some(3),
                Self::Authorization => std::option::Option::Some(4),
                Self::AuthorizationDecline => std::option::Option::Some(5),
                Self::PaymentCapture => std::option::Option::Some(6),
                Self::PaymentCaptureDecline => std::option::Option::Some(7),
                Self::Cancel => std::option::Option::Some(8),
                Self::ChargebackInquiry => std::option::Option::Some(9),
                Self::ChargebackAlert => std::option::Option::Some(10),
                Self::FraudNotification => std::option::Option::Some(11),
                Self::Chargeback => std::option::Option::Some(12),
                Self::ChargebackRepresentment => std::option::Option::Some(13),
                Self::ChargebackReverse => std::option::Option::Some(14),
                Self::RefundRequest => std::option::Option::Some(15),
                Self::RefundDecline => std::option::Option::Some(16),
                Self::Refund => std::option::Option::Some(17),
                Self::RefundReverse => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSACTION_EVENT_TYPE_UNSPECIFIED")
                }
                Self::MerchantApprove => std::option::Option::Some("MERCHANT_APPROVE"),
                Self::MerchantDeny => std::option::Option::Some("MERCHANT_DENY"),
                Self::ManualReview => std::option::Option::Some("MANUAL_REVIEW"),
                Self::Authorization => std::option::Option::Some("AUTHORIZATION"),
                Self::AuthorizationDecline => std::option::Option::Some("AUTHORIZATION_DECLINE"),
                Self::PaymentCapture => std::option::Option::Some("PAYMENT_CAPTURE"),
                Self::PaymentCaptureDecline => std::option::Option::Some("PAYMENT_CAPTURE_DECLINE"),
                Self::Cancel => std::option::Option::Some("CANCEL"),
                Self::ChargebackInquiry => std::option::Option::Some("CHARGEBACK_INQUIRY"),
                Self::ChargebackAlert => std::option::Option::Some("CHARGEBACK_ALERT"),
                Self::FraudNotification => std::option::Option::Some("FRAUD_NOTIFICATION"),
                Self::Chargeback => std::option::Option::Some("CHARGEBACK"),
                Self::ChargebackRepresentment => {
                    std::option::Option::Some("CHARGEBACK_REPRESENTMENT")
                }
                Self::ChargebackReverse => std::option::Option::Some("CHARGEBACK_REVERSE"),
                Self::RefundRequest => std::option::Option::Some("REFUND_REQUEST"),
                Self::RefundDecline => std::option::Option::Some("REFUND_DECLINE"),
                Self::Refund => std::option::Option::Some("REFUND"),
                Self::RefundReverse => std::option::Option::Some("REFUND_REVERSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransactionEventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransactionEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransactionEventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MerchantApprove,
                2 => Self::MerchantDeny,
                3 => Self::ManualReview,
                4 => Self::Authorization,
                5 => Self::AuthorizationDecline,
                6 => Self::PaymentCapture,
                7 => Self::PaymentCaptureDecline,
                8 => Self::Cancel,
                9 => Self::ChargebackInquiry,
                10 => Self::ChargebackAlert,
                11 => Self::FraudNotification,
                12 => Self::Chargeback,
                13 => Self::ChargebackRepresentment,
                14 => Self::ChargebackReverse,
                15 => Self::RefundRequest,
                16 => Self::RefundDecline,
                17 => Self::Refund,
                18 => Self::RefundReverse,
                _ => Self::UnknownValue(transaction_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransactionEventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSACTION_EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MERCHANT_APPROVE" => Self::MerchantApprove,
                "MERCHANT_DENY" => Self::MerchantDeny,
                "MANUAL_REVIEW" => Self::ManualReview,
                "AUTHORIZATION" => Self::Authorization,
                "AUTHORIZATION_DECLINE" => Self::AuthorizationDecline,
                "PAYMENT_CAPTURE" => Self::PaymentCapture,
                "PAYMENT_CAPTURE_DECLINE" => Self::PaymentCaptureDecline,
                "CANCEL" => Self::Cancel,
                "CHARGEBACK_INQUIRY" => Self::ChargebackInquiry,
                "CHARGEBACK_ALERT" => Self::ChargebackAlert,
                "FRAUD_NOTIFICATION" => Self::FraudNotification,
                "CHARGEBACK" => Self::Chargeback,
                "CHARGEBACK_REPRESENTMENT" => Self::ChargebackRepresentment,
                "CHARGEBACK_REVERSE" => Self::ChargebackReverse,
                "REFUND_REQUEST" => Self::RefundRequest,
                "REFUND_DECLINE" => Self::RefundDecline,
                "REFUND" => Self::Refund,
                "REFUND_REVERSE" => Self::RefundReverse,
                _ => Self::UnknownValue(transaction_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransactionEventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MerchantApprove => serializer.serialize_i32(1),
                Self::MerchantDeny => serializer.serialize_i32(2),
                Self::ManualReview => serializer.serialize_i32(3),
                Self::Authorization => serializer.serialize_i32(4),
                Self::AuthorizationDecline => serializer.serialize_i32(5),
                Self::PaymentCapture => serializer.serialize_i32(6),
                Self::PaymentCaptureDecline => serializer.serialize_i32(7),
                Self::Cancel => serializer.serialize_i32(8),
                Self::ChargebackInquiry => serializer.serialize_i32(9),
                Self::ChargebackAlert => serializer.serialize_i32(10),
                Self::FraudNotification => serializer.serialize_i32(11),
                Self::Chargeback => serializer.serialize_i32(12),
                Self::ChargebackRepresentment => serializer.serialize_i32(13),
                Self::ChargebackReverse => serializer.serialize_i32(14),
                Self::RefundRequest => serializer.serialize_i32(15),
                Self::RefundDecline => serializer.serialize_i32(16),
                Self::Refund => serializer.serialize_i32(17),
                Self::RefundReverse => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransactionEventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransactionEventType>::new(
                ".google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType",
            ))
        }
    }
}

/// The request message to annotate an Assessment.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateAssessmentRequest {
    /// Required. The resource name of the Assessment, in the format
    /// `projects/{project}/assessments/{assessment}`.
    pub name: std::string::String,

    /// Optional. The annotation that is assigned to the Event. This field can be
    /// left empty to provide reasons that apply to an event without concluding
    /// whether the event is legitimate or fraudulent.
    pub annotation: crate::model::annotate_assessment_request::Annotation,

    /// Optional. Reasons for the annotation that are assigned to the event.
    pub reasons: std::vec::Vec<crate::model::annotate_assessment_request::Reason>,

    /// Optional. A stable account identifier to apply to the assessment. This is
    /// an alternative to setting `account_id` in `CreateAssessment`, for example
    /// when a stable account identifier is not yet known in the initial request.
    pub account_id: std::string::String,

    /// Optional. A stable hashed account identifier to apply to the assessment.
    /// This is an alternative to setting `hashed_account_id` in
    /// `CreateAssessment`, for example when a stable account identifier is not yet
    /// known in the initial request.
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. If the assessment is part of a payment transaction, provide
    /// details on payment lifecycle events that occur in the transaction.
    pub transaction_event: std::option::Option<crate::model::TransactionEvent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateAssessmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnnotateAssessmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [annotation][crate::model::AnnotateAssessmentRequest::annotation].
    pub fn set_annotation<
        T: std::convert::Into<crate::model::annotate_assessment_request::Annotation>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::AnnotateAssessmentRequest::reasons].
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::annotate_assessment_request::Reason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [account_id][crate::model::AnnotateAssessmentRequest::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::AnnotateAssessmentRequest::hashed_account_id].
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [transaction_event][crate::model::AnnotateAssessmentRequest::transaction_event].
    pub fn set_transaction_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransactionEvent>,
    {
        self.transaction_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_event][crate::model::AnnotateAssessmentRequest::transaction_event].
    pub fn set_or_clear_transaction_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransactionEvent>,
    {
        self.transaction_event = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnnotateAssessmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateAssessmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __annotation,
            __reasons,
            __account_id,
            __hashed_account_id,
            __transaction_event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateAssessmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "annotation" => Ok(__FieldTag::__annotation),
                            "reasons" => Ok(__FieldTag::__reasons),
                            "accountId" => Ok(__FieldTag::__account_id),
                            "account_id" => Ok(__FieldTag::__account_id),
                            "hashedAccountId" => Ok(__FieldTag::__hashed_account_id),
                            "hashed_account_id" => Ok(__FieldTag::__hashed_account_id),
                            "transactionEvent" => Ok(__FieldTag::__transaction_event),
                            "transaction_event" => Ok(__FieldTag::__transaction_event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateAssessmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateAssessmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotation => {
                            if !fields.insert(__FieldTag::__annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotation",
                                ));
                            }
                            result.annotation = map
                                .next_value::<std::option::Option<
                                    crate::model::annotate_assessment_request::Annotation,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reasons => {
                            if !fields.insert(__FieldTag::__reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reasons",
                                ));
                            }
                            result.reasons = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::annotate_assessment_request::Reason,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_id => {
                            if !fields.insert(__FieldTag::__account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_id",
                                ));
                            }
                            result.account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hashed_account_id => {
                            if !fields.insert(__FieldTag::__hashed_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hashed_account_id",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hashed_account_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__transaction_event => {
                            if !fields.insert(__FieldTag::__transaction_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_event",
                                ));
                            }
                            result.transaction_event = map
                                .next_value::<std::option::Option<crate::model::TransactionEvent>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateAssessmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.annotation) {
            state.serialize_entry("annotation", &self.annotation)?;
        }
        if !self.reasons.is_empty() {
            state.serialize_entry("reasons", &self.reasons)?;
        }
        if !self.account_id.is_empty() {
            state.serialize_entry("accountId", &self.account_id)?;
        }
        if !self.hashed_account_id.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hashedAccountId", &__With(&self.hashed_account_id))?;
        }
        if self.transaction_event.is_some() {
            state.serialize_entry("transactionEvent", &self.transaction_event)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AnnotateAssessmentRequest].
pub mod annotate_assessment_request {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the types of annotations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Annotation {
        /// Default unspecified type.
        Unspecified,
        /// Provides information that the event turned out to be legitimate.
        Legitimate,
        /// Provides information that the event turned out to be fraudulent.
        Fraudulent,
        /// Provides information that the event was related to a login event in which
        /// the user typed the correct password. Deprecated, prefer indicating
        /// CORRECT_PASSWORD through the reasons field instead.
        #[deprecated]
        PasswordCorrect,
        /// Provides information that the event was related to a login event in which
        /// the user typed the incorrect password. Deprecated, prefer indicating
        /// INCORRECT_PASSWORD through the reasons field instead.
        #[deprecated]
        PasswordIncorrect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Annotation::value] or
        /// [Annotation::name].
        UnknownValue(annotation::UnknownValue),
    }

    #[doc(hidden)]
    pub mod annotation {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Annotation {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Legitimate => std::option::Option::Some(1),
                Self::Fraudulent => std::option::Option::Some(2),
                Self::PasswordCorrect => std::option::Option::Some(3),
                Self::PasswordIncorrect => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANNOTATION_UNSPECIFIED"),
                Self::Legitimate => std::option::Option::Some("LEGITIMATE"),
                Self::Fraudulent => std::option::Option::Some("FRAUDULENT"),
                Self::PasswordCorrect => std::option::Option::Some("PASSWORD_CORRECT"),
                Self::PasswordIncorrect => std::option::Option::Some("PASSWORD_INCORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Annotation {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Annotation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Annotation {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Legitimate,
                2 => Self::Fraudulent,
                3 => Self::PasswordCorrect,
                4 => Self::PasswordIncorrect,
                _ => Self::UnknownValue(annotation::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Annotation {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANNOTATION_UNSPECIFIED" => Self::Unspecified,
                "LEGITIMATE" => Self::Legitimate,
                "FRAUDULENT" => Self::Fraudulent,
                "PASSWORD_CORRECT" => Self::PasswordCorrect,
                "PASSWORD_INCORRECT" => Self::PasswordIncorrect,
                _ => Self::UnknownValue(annotation::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Annotation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Legitimate => serializer.serialize_i32(1),
                Self::Fraudulent => serializer.serialize_i32(2),
                Self::PasswordCorrect => serializer.serialize_i32(3),
                Self::PasswordIncorrect => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Annotation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Annotation>::new(
                ".google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation",
            ))
        }
    }

    /// Enum that represents potential reasons for annotating an assessment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reason {
        /// Unspecified reason. Do not use.
        Unspecified,
        /// Indicates that the transaction had a chargeback issued with no other
        /// details. When possible, specify the type by using CHARGEBACK_FRAUD or
        /// CHARGEBACK_DISPUTE instead.
        Chargeback,
        /// Indicates that the transaction had a chargeback issued related to an
        /// alleged unauthorized transaction from the cardholder's perspective (for
        /// example, the card number was stolen).
        ChargebackFraud,
        /// Indicates that the transaction had a chargeback issued related to the
        /// cardholder having provided their card details but allegedly not being
        /// satisfied with the purchase (for example, misrepresentation, attempted
        /// cancellation).
        ChargebackDispute,
        /// Indicates that the completed payment transaction was refunded by the
        /// seller.
        Refund,
        /// Indicates that the completed payment transaction was determined to be
        /// fraudulent by the seller, and was cancelled and refunded as a result.
        RefundFraud,
        /// Indicates that the payment transaction was accepted, and the user was
        /// charged.
        TransactionAccepted,
        /// Indicates that the payment transaction was declined, for example due to
        /// invalid card details.
        TransactionDeclined,
        /// Indicates the transaction associated with the assessment is suspected of
        /// being fraudulent based on the payment method, billing details, shipping
        /// address or other transaction information.
        PaymentHeuristics,
        /// Indicates that the user was served a 2FA challenge. An old assessment
        /// with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
        /// overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
        /// This is equivalent to `FAILED_TWO_FACTOR`.
        InitiatedTwoFactor,
        /// Indicates that the user passed a 2FA challenge.
        PassedTwoFactor,
        /// Indicates that the user failed a 2FA challenge.
        FailedTwoFactor,
        /// Indicates the user provided the correct password.
        CorrectPassword,
        /// Indicates the user provided an incorrect password.
        IncorrectPassword,
        /// Indicates that the user sent unwanted and abusive messages to other users
        /// of the platform, such as spam, scams, phishing, or social engineering.
        SocialSpam,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reason::value] or
        /// [Reason::name].
        UnknownValue(reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Chargeback => std::option::Option::Some(1),
                Self::ChargebackFraud => std::option::Option::Some(8),
                Self::ChargebackDispute => std::option::Option::Some(9),
                Self::Refund => std::option::Option::Some(10),
                Self::RefundFraud => std::option::Option::Some(11),
                Self::TransactionAccepted => std::option::Option::Some(12),
                Self::TransactionDeclined => std::option::Option::Some(13),
                Self::PaymentHeuristics => std::option::Option::Some(2),
                Self::InitiatedTwoFactor => std::option::Option::Some(7),
                Self::PassedTwoFactor => std::option::Option::Some(3),
                Self::FailedTwoFactor => std::option::Option::Some(4),
                Self::CorrectPassword => std::option::Option::Some(5),
                Self::IncorrectPassword => std::option::Option::Some(6),
                Self::SocialSpam => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                Self::Chargeback => std::option::Option::Some("CHARGEBACK"),
                Self::ChargebackFraud => std::option::Option::Some("CHARGEBACK_FRAUD"),
                Self::ChargebackDispute => std::option::Option::Some("CHARGEBACK_DISPUTE"),
                Self::Refund => std::option::Option::Some("REFUND"),
                Self::RefundFraud => std::option::Option::Some("REFUND_FRAUD"),
                Self::TransactionAccepted => std::option::Option::Some("TRANSACTION_ACCEPTED"),
                Self::TransactionDeclined => std::option::Option::Some("TRANSACTION_DECLINED"),
                Self::PaymentHeuristics => std::option::Option::Some("PAYMENT_HEURISTICS"),
                Self::InitiatedTwoFactor => std::option::Option::Some("INITIATED_TWO_FACTOR"),
                Self::PassedTwoFactor => std::option::Option::Some("PASSED_TWO_FACTOR"),
                Self::FailedTwoFactor => std::option::Option::Some("FAILED_TWO_FACTOR"),
                Self::CorrectPassword => std::option::Option::Some("CORRECT_PASSWORD"),
                Self::IncorrectPassword => std::option::Option::Some("INCORRECT_PASSWORD"),
                Self::SocialSpam => std::option::Option::Some("SOCIAL_SPAM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Chargeback,
                2 => Self::PaymentHeuristics,
                3 => Self::PassedTwoFactor,
                4 => Self::FailedTwoFactor,
                5 => Self::CorrectPassword,
                6 => Self::IncorrectPassword,
                7 => Self::InitiatedTwoFactor,
                8 => Self::ChargebackFraud,
                9 => Self::ChargebackDispute,
                10 => Self::Refund,
                11 => Self::RefundFraud,
                12 => Self::TransactionAccepted,
                13 => Self::TransactionDeclined,
                14 => Self::SocialSpam,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REASON_UNSPECIFIED" => Self::Unspecified,
                "CHARGEBACK" => Self::Chargeback,
                "CHARGEBACK_FRAUD" => Self::ChargebackFraud,
                "CHARGEBACK_DISPUTE" => Self::ChargebackDispute,
                "REFUND" => Self::Refund,
                "REFUND_FRAUD" => Self::RefundFraud,
                "TRANSACTION_ACCEPTED" => Self::TransactionAccepted,
                "TRANSACTION_DECLINED" => Self::TransactionDeclined,
                "PAYMENT_HEURISTICS" => Self::PaymentHeuristics,
                "INITIATED_TWO_FACTOR" => Self::InitiatedTwoFactor,
                "PASSED_TWO_FACTOR" => Self::PassedTwoFactor,
                "FAILED_TWO_FACTOR" => Self::FailedTwoFactor,
                "CORRECT_PASSWORD" => Self::CorrectPassword,
                "INCORRECT_PASSWORD" => Self::IncorrectPassword,
                "SOCIAL_SPAM" => Self::SocialSpam,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Chargeback => serializer.serialize_i32(1),
                Self::ChargebackFraud => serializer.serialize_i32(8),
                Self::ChargebackDispute => serializer.serialize_i32(9),
                Self::Refund => serializer.serialize_i32(10),
                Self::RefundFraud => serializer.serialize_i32(11),
                Self::TransactionAccepted => serializer.serialize_i32(12),
                Self::TransactionDeclined => serializer.serialize_i32(13),
                Self::PaymentHeuristics => serializer.serialize_i32(2),
                Self::InitiatedTwoFactor => serializer.serialize_i32(7),
                Self::PassedTwoFactor => serializer.serialize_i32(3),
                Self::FailedTwoFactor => serializer.serialize_i32(4),
                Self::CorrectPassword => serializer.serialize_i32(5),
                Self::IncorrectPassword => serializer.serialize_i32(6),
                Self::SocialSpam => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                ".google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason",
            ))
        }
    }
}

/// Empty response for AnnotateAssessment.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateAssessmentResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateAssessmentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AnnotateAssessmentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AnnotateAssessmentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateAssessmentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateAssessmentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateAssessmentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateAssessmentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateAssessmentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about a verification endpoint that can be used for 2FA.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EndpointVerificationInfo {
    /// Output only. Token to provide to the client to trigger endpoint
    /// verification. It must be used within 15 minutes.
    pub request_token: std::string::String,

    /// Output only. Timestamp of the last successful verification for the
    /// endpoint, if any.
    pub last_verification_time: std::option::Option<wkt::Timestamp>,

    pub endpoint: std::option::Option<crate::model::endpoint_verification_info::Endpoint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_token][crate::model::EndpointVerificationInfo::request_token].
    pub fn set_request_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_token = v.into();
        self
    }

    /// Sets the value of [last_verification_time][crate::model::EndpointVerificationInfo::last_verification_time].
    pub fn set_last_verification_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_verification_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_verification_time][crate::model::EndpointVerificationInfo::last_verification_time].
    pub fn set_or_clear_last_verification_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_verification_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint].
    ///
    /// Note that all the setters affecting `endpoint` are mutually
    /// exclusive.
    pub fn set_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::endpoint_verification_info::Endpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// The value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// if it holds a `EmailAddress`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email_address(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.endpoint.as_ref().and_then(|v| match v {
            crate::model::endpoint_verification_info::Endpoint::EmailAddress(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// to hold a `EmailAddress`.
    ///
    /// Note that all the setters affecting `endpoint` are
    /// mutually exclusive.
    pub fn set_email_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = std::option::Option::Some(
            crate::model::endpoint_verification_info::Endpoint::EmailAddress(v.into()),
        );
        self
    }

    /// The value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// if it holds a `PhoneNumber`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.endpoint.as_ref().and_then(|v| match v {
            crate::model::endpoint_verification_info::Endpoint::PhoneNumber(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// to hold a `PhoneNumber`.
    ///
    /// Note that all the setters affecting `endpoint` are
    /// mutually exclusive.
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = std::option::Option::Some(
            crate::model::endpoint_verification_info::Endpoint::PhoneNumber(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EndpointVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EndpointVerificationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email_address,
            __phone_number,
            __request_token,
            __last_verification_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EndpointVerificationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "emailAddress" => Ok(__FieldTag::__email_address),
                            "email_address" => Ok(__FieldTag::__email_address),
                            "phoneNumber" => Ok(__FieldTag::__phone_number),
                            "phone_number" => Ok(__FieldTag::__phone_number),
                            "requestToken" => Ok(__FieldTag::__request_token),
                            "request_token" => Ok(__FieldTag::__request_token),
                            "lastVerificationTime" => Ok(__FieldTag::__last_verification_time),
                            "last_verification_time" => Ok(__FieldTag::__last_verification_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EndpointVerificationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EndpointVerificationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email_address => {
                            if !fields.insert(__FieldTag::__email_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_address",
                                ));
                            }
                            if result.endpoint.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `endpoint`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo.email_address, latest field was emailAddress",
                                ));
                            }
                            result.endpoint = std::option::Option::Some(
                                crate::model::endpoint_verification_info::Endpoint::EmailAddress(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__phone_number => {
                            if !fields.insert(__FieldTag::__phone_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phone_number",
                                ));
                            }
                            if result.endpoint.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `endpoint`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo.phone_number, latest field was phoneNumber",
                                ));
                            }
                            result.endpoint = std::option::Option::Some(
                                crate::model::endpoint_verification_info::Endpoint::PhoneNumber(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__request_token => {
                            if !fields.insert(__FieldTag::__request_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_token",
                                ));
                            }
                            result.request_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_verification_time => {
                            if !fields.insert(__FieldTag::__last_verification_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_verification_time",
                                ));
                            }
                            result.last_verification_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EndpointVerificationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.email_address() {
            state.serialize_entry("emailAddress", value)?;
        }
        if let Some(value) = self.phone_number() {
            state.serialize_entry("phoneNumber", value)?;
        }
        if !self.request_token.is_empty() {
            state.serialize_entry("requestToken", &self.request_token)?;
        }
        if self.last_verification_time.is_some() {
            state.serialize_entry("lastVerificationTime", &self.last_verification_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EndpointVerificationInfo].
pub mod endpoint_verification_info {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Endpoint {
        /// Email address for which to trigger a verification request.
        EmailAddress(std::string::String),
        /// Phone number for which to trigger a verification request. Should be given
        /// in E.164 format.
        PhoneNumber(std::string::String),
    }
}

/// Information about account verification, used for identity verification.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccountVerificationInfo {
    /// Optional. Endpoints that can be used for identity verification.
    pub endpoints: std::vec::Vec<crate::model::EndpointVerificationInfo>,

    /// Optional. Language code preference for the verification message, set as a
    /// IETF BCP 47 language code.
    pub language_code: std::string::String,

    /// Output only. Result of the latest account verification challenge.
    pub latest_verification_result: crate::model::account_verification_info::Result,

    /// Username of the account that is being verified. Deprecated. Customers
    /// should now provide the `account_id` field in `event.user_info`.
    #[deprecated]
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoints][crate::model::AccountVerificationInfo::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EndpointVerificationInfo>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::AccountVerificationInfo::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [latest_verification_result][crate::model::AccountVerificationInfo::latest_verification_result].
    pub fn set_latest_verification_result<
        T: std::convert::Into<crate::model::account_verification_info::Result>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_verification_result = v.into();
        self
    }

    /// Sets the value of [username][crate::model::AccountVerificationInfo::username].
    #[deprecated]
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AccountVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AccountVerificationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccountVerificationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoints,
            __language_code,
            __latest_verification_result,
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccountVerificationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "latestVerificationResult" => {
                                Ok(__FieldTag::__latest_verification_result)
                            }
                            "latest_verification_result" => {
                                Ok(__FieldTag::__latest_verification_result)
                            }
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccountVerificationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccountVerificationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EndpointVerificationInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_verification_result => {
                            if !fields.insert(__FieldTag::__latest_verification_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_verification_result",
                                ));
                            }
                            result.latest_verification_result = map
                                .next_value::<std::option::Option<
                                    crate::model::account_verification_info::Result,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccountVerificationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.latest_verification_result) {
            state.serialize_entry("latestVerificationResult", &self.latest_verification_result)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccountVerificationInfo].
pub mod account_verification_info {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the account verification as contained in the verdict token issued
    /// at the end of the verification flow.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// No information about the latest account verification.
        Unspecified,
        /// The user was successfully verified. This means the account verification
        /// challenge was successfully completed.
        SuccessUserVerified,
        /// The user failed the verification challenge.
        ErrorUserNotVerified,
        /// The site is not properly onboarded to use the account verification
        /// feature.
        ErrorSiteOnboardingIncomplete,
        /// The recipient is not allowed for account verification. This can occur
        /// during integration but should not occur in production.
        ErrorRecipientNotAllowed,
        /// The recipient has already been sent too many verification codes in a
        /// short amount of time.
        ErrorRecipientAbuseLimitExhausted,
        /// The verification flow could not be completed due to a critical internal
        /// error.
        ErrorCriticalInternal,
        /// The client has exceeded their two factor request quota for this period of
        /// time.
        ErrorCustomerQuotaExhausted,
        /// The request cannot be processed at the time because of an incident. This
        /// bypass can be restricted to a problematic destination email domain, a
        /// customer, or could affect the entire service.
        ErrorVerificationBypassed,
        /// The request parameters do not match with the token provided and cannot be
        /// processed.
        ErrorVerdictMismatch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SuccessUserVerified => std::option::Option::Some(1),
                Self::ErrorUserNotVerified => std::option::Option::Some(2),
                Self::ErrorSiteOnboardingIncomplete => std::option::Option::Some(3),
                Self::ErrorRecipientNotAllowed => std::option::Option::Some(4),
                Self::ErrorRecipientAbuseLimitExhausted => std::option::Option::Some(5),
                Self::ErrorCriticalInternal => std::option::Option::Some(6),
                Self::ErrorCustomerQuotaExhausted => std::option::Option::Some(7),
                Self::ErrorVerificationBypassed => std::option::Option::Some(8),
                Self::ErrorVerdictMismatch => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::SuccessUserVerified => std::option::Option::Some("SUCCESS_USER_VERIFIED"),
                Self::ErrorUserNotVerified => std::option::Option::Some("ERROR_USER_NOT_VERIFIED"),
                Self::ErrorSiteOnboardingIncomplete => {
                    std::option::Option::Some("ERROR_SITE_ONBOARDING_INCOMPLETE")
                }
                Self::ErrorRecipientNotAllowed => {
                    std::option::Option::Some("ERROR_RECIPIENT_NOT_ALLOWED")
                }
                Self::ErrorRecipientAbuseLimitExhausted => {
                    std::option::Option::Some("ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED")
                }
                Self::ErrorCriticalInternal => std::option::Option::Some("ERROR_CRITICAL_INTERNAL"),
                Self::ErrorCustomerQuotaExhausted => {
                    std::option::Option::Some("ERROR_CUSTOMER_QUOTA_EXHAUSTED")
                }
                Self::ErrorVerificationBypassed => {
                    std::option::Option::Some("ERROR_VERIFICATION_BYPASSED")
                }
                Self::ErrorVerdictMismatch => std::option::Option::Some("ERROR_VERDICT_MISMATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SuccessUserVerified,
                2 => Self::ErrorUserNotVerified,
                3 => Self::ErrorSiteOnboardingIncomplete,
                4 => Self::ErrorRecipientNotAllowed,
                5 => Self::ErrorRecipientAbuseLimitExhausted,
                6 => Self::ErrorCriticalInternal,
                7 => Self::ErrorCustomerQuotaExhausted,
                8 => Self::ErrorVerificationBypassed,
                9 => Self::ErrorVerdictMismatch,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS_USER_VERIFIED" => Self::SuccessUserVerified,
                "ERROR_USER_NOT_VERIFIED" => Self::ErrorUserNotVerified,
                "ERROR_SITE_ONBOARDING_INCOMPLETE" => Self::ErrorSiteOnboardingIncomplete,
                "ERROR_RECIPIENT_NOT_ALLOWED" => Self::ErrorRecipientNotAllowed,
                "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED" => Self::ErrorRecipientAbuseLimitExhausted,
                "ERROR_CRITICAL_INTERNAL" => Self::ErrorCriticalInternal,
                "ERROR_CUSTOMER_QUOTA_EXHAUSTED" => Self::ErrorCustomerQuotaExhausted,
                "ERROR_VERIFICATION_BYPASSED" => Self::ErrorVerificationBypassed,
                "ERROR_VERDICT_MISMATCH" => Self::ErrorVerdictMismatch,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SuccessUserVerified => serializer.serialize_i32(1),
                Self::ErrorUserNotVerified => serializer.serialize_i32(2),
                Self::ErrorSiteOnboardingIncomplete => serializer.serialize_i32(3),
                Self::ErrorRecipientNotAllowed => serializer.serialize_i32(4),
                Self::ErrorRecipientAbuseLimitExhausted => serializer.serialize_i32(5),
                Self::ErrorCriticalInternal => serializer.serialize_i32(6),
                Self::ErrorCustomerQuotaExhausted => serializer.serialize_i32(7),
                Self::ErrorVerificationBypassed => serializer.serialize_i32(8),
                Self::ErrorVerdictMismatch => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result",
            ))
        }
    }
}

/// Private password leak verification info.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivatePasswordLeakVerification {
    /// Required. Exactly 26-bit prefix of the SHA-256 hash of the canonicalized
    /// username. It is used to look up password leaks associated with that hash
    /// prefix.
    pub lookup_hash_prefix: ::bytes::Bytes,

    /// Optional. Encrypted Scrypt hash of the canonicalized username+password. It
    /// is re-encrypted by the server and returned through
    /// `reencrypted_user_credentials_hash`.
    pub encrypted_user_credentials_hash: ::bytes::Bytes,

    /// Output only. List of prefixes of the encrypted potential password leaks
    /// that matched the given parameters. They must be compared with the
    /// client-side decryption prefix of `reencrypted_user_credentials_hash`
    pub encrypted_leak_match_prefixes: std::vec::Vec<::bytes::Bytes>,

    /// Output only. Corresponds to the re-encryption of the
    /// `encrypted_user_credentials_hash` field. It is used to match potential
    /// password leaks within `encrypted_leak_match_prefixes`.
    pub reencrypted_user_credentials_hash: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePasswordLeakVerification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lookup_hash_prefix][crate::model::PrivatePasswordLeakVerification::lookup_hash_prefix].
    pub fn set_lookup_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.lookup_hash_prefix = v.into();
        self
    }

    /// Sets the value of [encrypted_user_credentials_hash][crate::model::PrivatePasswordLeakVerification::encrypted_user_credentials_hash].
    pub fn set_encrypted_user_credentials_hash<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.encrypted_user_credentials_hash = v.into();
        self
    }

    /// Sets the value of [encrypted_leak_match_prefixes][crate::model::PrivatePasswordLeakVerification::encrypted_leak_match_prefixes].
    pub fn set_encrypted_leak_match_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.encrypted_leak_match_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reencrypted_user_credentials_hash][crate::model::PrivatePasswordLeakVerification::reencrypted_user_credentials_hash].
    pub fn set_reencrypted_user_credentials_hash<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.reencrypted_user_credentials_hash = v.into();
        self
    }
}

impl wkt::message::Message for PrivatePasswordLeakVerification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivatePasswordLeakVerification {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lookup_hash_prefix,
            __encrypted_user_credentials_hash,
            __encrypted_leak_match_prefixes,
            __reencrypted_user_credentials_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivatePasswordLeakVerification")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lookupHashPrefix" => Ok(__FieldTag::__lookup_hash_prefix),
                            "lookup_hash_prefix" => Ok(__FieldTag::__lookup_hash_prefix),
                            "encryptedUserCredentialsHash" => {
                                Ok(__FieldTag::__encrypted_user_credentials_hash)
                            }
                            "encrypted_user_credentials_hash" => {
                                Ok(__FieldTag::__encrypted_user_credentials_hash)
                            }
                            "encryptedLeakMatchPrefixes" => {
                                Ok(__FieldTag::__encrypted_leak_match_prefixes)
                            }
                            "encrypted_leak_match_prefixes" => {
                                Ok(__FieldTag::__encrypted_leak_match_prefixes)
                            }
                            "reencryptedUserCredentialsHash" => {
                                Ok(__FieldTag::__reencrypted_user_credentials_hash)
                            }
                            "reencrypted_user_credentials_hash" => {
                                Ok(__FieldTag::__reencrypted_user_credentials_hash)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivatePasswordLeakVerification;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivatePasswordLeakVerification")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lookup_hash_prefix => {
                            if !fields.insert(__FieldTag::__lookup_hash_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lookup_hash_prefix",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lookup_hash_prefix =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encrypted_user_credentials_hash => {
                            if !fields.insert(__FieldTag::__encrypted_user_credentials_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encrypted_user_credentials_hash",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.encrypted_user_credentials_hash =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encrypted_leak_match_prefixes => {
                            if !fields.insert(__FieldTag::__encrypted_leak_match_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encrypted_leak_match_prefixes",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.encrypted_leak_match_prefixes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__reencrypted_user_credentials_hash => {
                            if !fields.insert(__FieldTag::__reencrypted_user_credentials_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reencrypted_user_credentials_hash",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.reencrypted_user_credentials_hash =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivatePasswordLeakVerification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.lookup_hash_prefix.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lookupHashPrefix", &__With(&self.lookup_hash_prefix))?;
        }
        if !self.encrypted_user_credentials_hash.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "encryptedUserCredentialsHash",
                &__With(&self.encrypted_user_credentials_hash),
            )?;
        }
        if !self.encrypted_leak_match_prefixes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "encryptedLeakMatchPrefixes",
                &__With(&self.encrypted_leak_match_prefixes),
            )?;
        }
        if !self.reencrypted_user_credentials_hash.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "reencryptedUserCredentialsHash",
                &__With(&self.reencrypted_user_credentials_hash),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A reCAPTCHA Enterprise assessment resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Assessment {
    /// Output only. Identifier. The resource name for the Assessment in the format
    /// `projects/{project}/assessments/{assessment}`.
    pub name: std::string::String,

    /// Optional. The event being assessed.
    pub event: std::option::Option<crate::model::Event>,

    /// Output only. The risk analysis result for the event being assessed.
    pub risk_analysis: std::option::Option<crate::model::RiskAnalysis>,

    /// Output only. Properties of the provided event token.
    pub token_properties: std::option::Option<crate::model::TokenProperties>,

    /// Optional. Account verification information for identity verification. The
    /// assessment event must include a token and site key to use this feature.
    pub account_verification: std::option::Option<crate::model::AccountVerificationInfo>,

    /// Output only. Assessment returned by account defender when an account
    /// identifier is provided.
    pub account_defender_assessment: std::option::Option<crate::model::AccountDefenderAssessment>,

    /// Optional. The private password leak verification field contains the
    /// parameters that are used to to check for leaks privately without sharing
    /// user credentials.
    pub private_password_leak_verification:
        std::option::Option<crate::model::PrivatePasswordLeakVerification>,

    /// Output only. Assessment returned when firewall policies belonging to the
    /// project are evaluated using the field firewall_policy_evaluation.
    pub firewall_policy_assessment: std::option::Option<crate::model::FirewallPolicyAssessment>,

    /// Output only. Assessment returned by Fraud Prevention when TransactionData
    /// is provided.
    pub fraud_prevention_assessment: std::option::Option<crate::model::FraudPreventionAssessment>,

    /// Output only. Fraud Signals specific to the users involved in a payment
    /// transaction.
    pub fraud_signals: std::option::Option<crate::model::FraudSignals>,

    /// Output only. Assessment returned when a site key, a token, and a phone
    /// number as `user_id` are provided. Account defender and SMS toll fraud
    /// protection need to be enabled.
    pub phone_fraud_assessment: std::option::Option<crate::model::PhoneFraudAssessment>,

    /// Optional. The environment creating the assessment. This describes your
    /// environment (the system invoking CreateAssessment), NOT the environment of
    /// your user.
    pub assessment_environment: std::option::Option<crate::model::AssessmentEnvironment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Assessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Assessment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event][crate::model::Assessment::event].
    pub fn set_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Event>,
    {
        self.event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event][crate::model::Assessment::event].
    pub fn set_or_clear_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Event>,
    {
        self.event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [risk_analysis][crate::model::Assessment::risk_analysis].
    pub fn set_risk_analysis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RiskAnalysis>,
    {
        self.risk_analysis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [risk_analysis][crate::model::Assessment::risk_analysis].
    pub fn set_or_clear_risk_analysis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RiskAnalysis>,
    {
        self.risk_analysis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [token_properties][crate::model::Assessment::token_properties].
    pub fn set_token_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TokenProperties>,
    {
        self.token_properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [token_properties][crate::model::Assessment::token_properties].
    pub fn set_or_clear_token_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TokenProperties>,
    {
        self.token_properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_verification][crate::model::Assessment::account_verification].
    pub fn set_account_verification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccountVerificationInfo>,
    {
        self.account_verification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_verification][crate::model::Assessment::account_verification].
    pub fn set_or_clear_account_verification<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccountVerificationInfo>,
    {
        self.account_verification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_defender_assessment][crate::model::Assessment::account_defender_assessment].
    pub fn set_account_defender_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccountDefenderAssessment>,
    {
        self.account_defender_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_defender_assessment][crate::model::Assessment::account_defender_assessment].
    pub fn set_or_clear_account_defender_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccountDefenderAssessment>,
    {
        self.account_defender_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_password_leak_verification][crate::model::Assessment::private_password_leak_verification].
    pub fn set_private_password_leak_verification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivatePasswordLeakVerification>,
    {
        self.private_password_leak_verification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_password_leak_verification][crate::model::Assessment::private_password_leak_verification].
    pub fn set_or_clear_private_password_leak_verification<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::PrivatePasswordLeakVerification>,
    {
        self.private_password_leak_verification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [firewall_policy_assessment][crate::model::Assessment::firewall_policy_assessment].
    pub fn set_firewall_policy_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyAssessment>,
    {
        self.firewall_policy_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy_assessment][crate::model::Assessment::firewall_policy_assessment].
    pub fn set_or_clear_firewall_policy_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyAssessment>,
    {
        self.firewall_policy_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fraud_prevention_assessment][crate::model::Assessment::fraud_prevention_assessment].
    pub fn set_fraud_prevention_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FraudPreventionAssessment>,
    {
        self.fraud_prevention_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fraud_prevention_assessment][crate::model::Assessment::fraud_prevention_assessment].
    pub fn set_or_clear_fraud_prevention_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FraudPreventionAssessment>,
    {
        self.fraud_prevention_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fraud_signals][crate::model::Assessment::fraud_signals].
    pub fn set_fraud_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FraudSignals>,
    {
        self.fraud_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fraud_signals][crate::model::Assessment::fraud_signals].
    pub fn set_or_clear_fraud_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FraudSignals>,
    {
        self.fraud_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [phone_fraud_assessment][crate::model::Assessment::phone_fraud_assessment].
    pub fn set_phone_fraud_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhoneFraudAssessment>,
    {
        self.phone_fraud_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phone_fraud_assessment][crate::model::Assessment::phone_fraud_assessment].
    pub fn set_or_clear_phone_fraud_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhoneFraudAssessment>,
    {
        self.phone_fraud_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assessment_environment][crate::model::Assessment::assessment_environment].
    pub fn set_assessment_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssessmentEnvironment>,
    {
        self.assessment_environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment_environment][crate::model::Assessment::assessment_environment].
    pub fn set_or_clear_assessment_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssessmentEnvironment>,
    {
        self.assessment_environment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Assessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Assessment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Assessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __event,
            __risk_analysis,
            __token_properties,
            __account_verification,
            __account_defender_assessment,
            __private_password_leak_verification,
            __firewall_policy_assessment,
            __fraud_prevention_assessment,
            __fraud_signals,
            __phone_fraud_assessment,
            __assessment_environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Assessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "event" => Ok(__FieldTag::__event),
                            "riskAnalysis" => Ok(__FieldTag::__risk_analysis),
                            "risk_analysis" => Ok(__FieldTag::__risk_analysis),
                            "tokenProperties" => Ok(__FieldTag::__token_properties),
                            "token_properties" => Ok(__FieldTag::__token_properties),
                            "accountVerification" => Ok(__FieldTag::__account_verification),
                            "account_verification" => Ok(__FieldTag::__account_verification),
                            "accountDefenderAssessment" => {
                                Ok(__FieldTag::__account_defender_assessment)
                            }
                            "account_defender_assessment" => {
                                Ok(__FieldTag::__account_defender_assessment)
                            }
                            "privatePasswordLeakVerification" => {
                                Ok(__FieldTag::__private_password_leak_verification)
                            }
                            "private_password_leak_verification" => {
                                Ok(__FieldTag::__private_password_leak_verification)
                            }
                            "firewallPolicyAssessment" => {
                                Ok(__FieldTag::__firewall_policy_assessment)
                            }
                            "firewall_policy_assessment" => {
                                Ok(__FieldTag::__firewall_policy_assessment)
                            }
                            "fraudPreventionAssessment" => {
                                Ok(__FieldTag::__fraud_prevention_assessment)
                            }
                            "fraud_prevention_assessment" => {
                                Ok(__FieldTag::__fraud_prevention_assessment)
                            }
                            "fraudSignals" => Ok(__FieldTag::__fraud_signals),
                            "fraud_signals" => Ok(__FieldTag::__fraud_signals),
                            "phoneFraudAssessment" => Ok(__FieldTag::__phone_fraud_assessment),
                            "phone_fraud_assessment" => Ok(__FieldTag::__phone_fraud_assessment),
                            "assessmentEnvironment" => Ok(__FieldTag::__assessment_environment),
                            "assessment_environment" => Ok(__FieldTag::__assessment_environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Assessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Assessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            result.event =
                                map.next_value::<std::option::Option<crate::model::Event>>()?;
                        }
                        __FieldTag::__risk_analysis => {
                            if !fields.insert(__FieldTag::__risk_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risk_analysis",
                                ));
                            }
                            result.risk_analysis = map
                                .next_value::<std::option::Option<crate::model::RiskAnalysis>>()?;
                        }
                        __FieldTag::__token_properties => {
                            if !fields.insert(__FieldTag::__token_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_properties",
                                ));
                            }
                            result.token_properties = map
                                .next_value::<std::option::Option<crate::model::TokenProperties>>(
                                )?;
                        }
                        __FieldTag::__account_verification => {
                            if !fields.insert(__FieldTag::__account_verification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_verification",
                                ));
                            }
                            result.account_verification = map.next_value::<std::option::Option<crate::model::AccountVerificationInfo>>()?
                                ;
                        }
                        __FieldTag::__account_defender_assessment => {
                            if !fields.insert(__FieldTag::__account_defender_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_defender_assessment",
                                ));
                            }
                            result.account_defender_assessment = map.next_value::<std::option::Option<crate::model::AccountDefenderAssessment>>()?
                                ;
                        }
                        __FieldTag::__private_password_leak_verification => {
                            if !fields.insert(__FieldTag::__private_password_leak_verification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_password_leak_verification",
                                ));
                            }
                            result.private_password_leak_verification = map
                                .next_value::<std::option::Option<
                                    crate::model::PrivatePasswordLeakVerification,
                                >>()?;
                        }
                        __FieldTag::__firewall_policy_assessment => {
                            if !fields.insert(__FieldTag::__firewall_policy_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_policy_assessment",
                                ));
                            }
                            result.firewall_policy_assessment = map.next_value::<std::option::Option<crate::model::FirewallPolicyAssessment>>()?
                                ;
                        }
                        __FieldTag::__fraud_prevention_assessment => {
                            if !fields.insert(__FieldTag::__fraud_prevention_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fraud_prevention_assessment",
                                ));
                            }
                            result.fraud_prevention_assessment = map.next_value::<std::option::Option<crate::model::FraudPreventionAssessment>>()?
                                ;
                        }
                        __FieldTag::__fraud_signals => {
                            if !fields.insert(__FieldTag::__fraud_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fraud_signals",
                                ));
                            }
                            result.fraud_signals = map
                                .next_value::<std::option::Option<crate::model::FraudSignals>>()?;
                        }
                        __FieldTag::__phone_fraud_assessment => {
                            if !fields.insert(__FieldTag::__phone_fraud_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phone_fraud_assessment",
                                ));
                            }
                            result.phone_fraud_assessment = map.next_value::<std::option::Option<crate::model::PhoneFraudAssessment>>()?
                                ;
                        }
                        __FieldTag::__assessment_environment => {
                            if !fields.insert(__FieldTag::__assessment_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assessment_environment",
                                ));
                            }
                            result.assessment_environment = map.next_value::<std::option::Option<crate::model::AssessmentEnvironment>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Assessment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.event.is_some() {
            state.serialize_entry("event", &self.event)?;
        }
        if self.risk_analysis.is_some() {
            state.serialize_entry("riskAnalysis", &self.risk_analysis)?;
        }
        if self.token_properties.is_some() {
            state.serialize_entry("tokenProperties", &self.token_properties)?;
        }
        if self.account_verification.is_some() {
            state.serialize_entry("accountVerification", &self.account_verification)?;
        }
        if self.account_defender_assessment.is_some() {
            state.serialize_entry(
                "accountDefenderAssessment",
                &self.account_defender_assessment,
            )?;
        }
        if self.private_password_leak_verification.is_some() {
            state.serialize_entry(
                "privatePasswordLeakVerification",
                &self.private_password_leak_verification,
            )?;
        }
        if self.firewall_policy_assessment.is_some() {
            state.serialize_entry("firewallPolicyAssessment", &self.firewall_policy_assessment)?;
        }
        if self.fraud_prevention_assessment.is_some() {
            state.serialize_entry(
                "fraudPreventionAssessment",
                &self.fraud_prevention_assessment,
            )?;
        }
        if self.fraud_signals.is_some() {
            state.serialize_entry("fraudSignals", &self.fraud_signals)?;
        }
        if self.phone_fraud_assessment.is_some() {
            state.serialize_entry("phoneFraudAssessment", &self.phone_fraud_assessment)?;
        }
        if self.assessment_environment.is_some() {
            state.serialize_entry("assessmentEnvironment", &self.assessment_environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The event being assessed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// Optional. The user response token provided by the reCAPTCHA Enterprise
    /// client-side integration on your site.
    pub token: std::string::String,

    /// Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
    /// site and generate the token.
    pub site_key: std::string::String,

    /// Optional. The user agent present in the request from the user's device
    /// related to this event.
    pub user_agent: std::string::String,

    /// Optional. The IP address in the request from the user's device related to
    /// this event.
    pub user_ip_address: std::string::String,

    /// Optional. The expected action for this type of event. This should be the
    /// same action provided at token generation time on client-side platforms
    /// already integrated with recaptcha enterprise.
    pub expected_action: std::string::String,

    /// Optional. Deprecated: use `user_info.account_id` instead.
    /// Unique stable hashed user identifier for the request. The identifier must
    /// be hashed using hmac-sha256 with stable secret.
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. Flag for a reCAPTCHA express request for an assessment without a
    /// token. If enabled, `site_key` must reference an Express site key.
    pub express: bool,

    /// Optional. The URI resource the user requested that triggered an assessment.
    pub requested_uri: std::string::String,

    /// Optional. Flag for running WAF token assessment.
    /// If enabled, the token must be specified, and have been created by a
    /// WAF-enabled key.
    pub waf_token_assessment: bool,

    /// Optional. JA3 fingerprint for SSL clients. To learn how to compute this
    /// fingerprint, please refer to <https://github.com/salesforce/ja3>.
    pub ja3: std::string::String,

    /// Optional. JA4 fingerprint for SSL clients. To learn how to compute this
    /// fingerprint, please refer to <https://github.com/FoxIO-LLC/ja4>.
    pub ja4: std::string::String,

    /// Optional. HTTP header information about the request.
    pub headers: std::vec::Vec<std::string::String>,

    /// Optional. Flag for enabling firewall policy config assessment.
    /// If this flag is enabled, the firewall policy is evaluated and a
    /// suggested firewall action is returned in the response.
    pub firewall_policy_evaluation: bool,

    /// Optional. Data describing a payment transaction to be assessed. Sending
    /// this data enables reCAPTCHA Enterprise Fraud Prevention and the
    /// FraudPreventionAssessment component in the response.
    pub transaction_data: std::option::Option<crate::model::TransactionData>,

    /// Optional. Information about the user that generates this event, when they
    /// can be identified. They are often identified through the use of an account
    /// for logged-in requests or login/registration requests, or by providing user
    /// identifiers for guest actions like checkout.
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// Optional. The Fraud Prevention setting for this assessment.
    pub fraud_prevention: crate::model::event::FraudPrevention,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::Event::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [site_key][crate::model::Event::site_key].
    pub fn set_site_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site_key = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::Event::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [user_ip_address][crate::model::Event::user_ip_address].
    pub fn set_user_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_ip_address = v.into();
        self
    }

    /// Sets the value of [expected_action][crate::model::Event::expected_action].
    pub fn set_expected_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expected_action = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::Event::hashed_account_id].
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [express][crate::model::Event::express].
    pub fn set_express<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.express = v.into();
        self
    }

    /// Sets the value of [requested_uri][crate::model::Event::requested_uri].
    pub fn set_requested_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.requested_uri = v.into();
        self
    }

    /// Sets the value of [waf_token_assessment][crate::model::Event::waf_token_assessment].
    pub fn set_waf_token_assessment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.waf_token_assessment = v.into();
        self
    }

    /// Sets the value of [ja3][crate::model::Event::ja3].
    pub fn set_ja3<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ja3 = v.into();
        self
    }

    /// Sets the value of [ja4][crate::model::Event::ja4].
    pub fn set_ja4<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ja4 = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::Event::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [firewall_policy_evaluation][crate::model::Event::firewall_policy_evaluation].
    pub fn set_firewall_policy_evaluation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.firewall_policy_evaluation = v.into();
        self
    }

    /// Sets the value of [transaction_data][crate::model::Event::transaction_data].
    pub fn set_transaction_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransactionData>,
    {
        self.transaction_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_data][crate::model::Event::transaction_data].
    pub fn set_or_clear_transaction_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransactionData>,
    {
        self.transaction_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_info][crate::model::Event::user_info].
    pub fn set_user_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_info][crate::model::Event::user_info].
    pub fn set_or_clear_user_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fraud_prevention][crate::model::Event::fraud_prevention].
    pub fn set_fraud_prevention<T: std::convert::Into<crate::model::event::FraudPrevention>>(
        mut self,
        v: T,
    ) -> Self {
        self.fraud_prevention = v.into();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Event"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token,
            __site_key,
            __user_agent,
            __user_ip_address,
            __expected_action,
            __hashed_account_id,
            __express,
            __requested_uri,
            __waf_token_assessment,
            __ja3,
            __ja4,
            __headers,
            __firewall_policy_evaluation,
            __transaction_data,
            __user_info,
            __fraud_prevention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Event")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "token" => Ok(__FieldTag::__token),
                            "siteKey" => Ok(__FieldTag::__site_key),
                            "site_key" => Ok(__FieldTag::__site_key),
                            "userAgent" => Ok(__FieldTag::__user_agent),
                            "user_agent" => Ok(__FieldTag::__user_agent),
                            "userIpAddress" => Ok(__FieldTag::__user_ip_address),
                            "user_ip_address" => Ok(__FieldTag::__user_ip_address),
                            "expectedAction" => Ok(__FieldTag::__expected_action),
                            "expected_action" => Ok(__FieldTag::__expected_action),
                            "hashedAccountId" => Ok(__FieldTag::__hashed_account_id),
                            "hashed_account_id" => Ok(__FieldTag::__hashed_account_id),
                            "express" => Ok(__FieldTag::__express),
                            "requestedUri" => Ok(__FieldTag::__requested_uri),
                            "requested_uri" => Ok(__FieldTag::__requested_uri),
                            "wafTokenAssessment" => Ok(__FieldTag::__waf_token_assessment),
                            "waf_token_assessment" => Ok(__FieldTag::__waf_token_assessment),
                            "ja3" => Ok(__FieldTag::__ja3),
                            "ja4" => Ok(__FieldTag::__ja4),
                            "headers" => Ok(__FieldTag::__headers),
                            "firewallPolicyEvaluation" => {
                                Ok(__FieldTag::__firewall_policy_evaluation)
                            }
                            "firewall_policy_evaluation" => {
                                Ok(__FieldTag::__firewall_policy_evaluation)
                            }
                            "transactionData" => Ok(__FieldTag::__transaction_data),
                            "transaction_data" => Ok(__FieldTag::__transaction_data),
                            "userInfo" => Ok(__FieldTag::__user_info),
                            "user_info" => Ok(__FieldTag::__user_info),
                            "fraudPrevention" => Ok(__FieldTag::__fraud_prevention),
                            "fraud_prevention" => Ok(__FieldTag::__fraud_prevention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Event;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Event")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token => {
                            if !fields.insert(__FieldTag::__token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token",
                                ));
                            }
                            result.token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__site_key => {
                            if !fields.insert(__FieldTag::__site_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for site_key",
                                ));
                            }
                            result.site_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_agent => {
                            if !fields.insert(__FieldTag::__user_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_agent",
                                ));
                            }
                            result.user_agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_ip_address => {
                            if !fields.insert(__FieldTag::__user_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_ip_address",
                                ));
                            }
                            result.user_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expected_action => {
                            if !fields.insert(__FieldTag::__expected_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expected_action",
                                ));
                            }
                            result.expected_action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hashed_account_id => {
                            if !fields.insert(__FieldTag::__hashed_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hashed_account_id",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hashed_account_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__express => {
                            if !fields.insert(__FieldTag::__express) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for express",
                                ));
                            }
                            result.express = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_uri => {
                            if !fields.insert(__FieldTag::__requested_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_uri",
                                ));
                            }
                            result.requested_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__waf_token_assessment => {
                            if !fields.insert(__FieldTag::__waf_token_assessment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for waf_token_assessment",
                                ));
                            }
                            result.waf_token_assessment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ja3 => {
                            if !fields.insert(__FieldTag::__ja3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ja3",
                                ));
                            }
                            result.ja3 = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ja4 => {
                            if !fields.insert(__FieldTag::__ja4) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ja4",
                                ));
                            }
                            result.ja4 = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__firewall_policy_evaluation => {
                            if !fields.insert(__FieldTag::__firewall_policy_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_policy_evaluation",
                                ));
                            }
                            result.firewall_policy_evaluation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transaction_data => {
                            if !fields.insert(__FieldTag::__transaction_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_data",
                                ));
                            }
                            result.transaction_data = map
                                .next_value::<std::option::Option<crate::model::TransactionData>>(
                                )?;
                        }
                        __FieldTag::__user_info => {
                            if !fields.insert(__FieldTag::__user_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_info",
                                ));
                            }
                            result.user_info =
                                map.next_value::<std::option::Option<crate::model::UserInfo>>()?;
                        }
                        __FieldTag::__fraud_prevention => {
                            if !fields.insert(__FieldTag::__fraud_prevention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fraud_prevention",
                                ));
                            }
                            result.fraud_prevention = map.next_value::<std::option::Option<crate::model::event::FraudPrevention>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.token.is_empty() {
            state.serialize_entry("token", &self.token)?;
        }
        if !self.site_key.is_empty() {
            state.serialize_entry("siteKey", &self.site_key)?;
        }
        if !self.user_agent.is_empty() {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !self.user_ip_address.is_empty() {
            state.serialize_entry("userIpAddress", &self.user_ip_address)?;
        }
        if !self.expected_action.is_empty() {
            state.serialize_entry("expectedAction", &self.expected_action)?;
        }
        if !self.hashed_account_id.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hashedAccountId", &__With(&self.hashed_account_id))?;
        }
        if !wkt::internal::is_default(&self.express) {
            state.serialize_entry("express", &self.express)?;
        }
        if !self.requested_uri.is_empty() {
            state.serialize_entry("requestedUri", &self.requested_uri)?;
        }
        if !wkt::internal::is_default(&self.waf_token_assessment) {
            state.serialize_entry("wafTokenAssessment", &self.waf_token_assessment)?;
        }
        if !self.ja3.is_empty() {
            state.serialize_entry("ja3", &self.ja3)?;
        }
        if !self.ja4.is_empty() {
            state.serialize_entry("ja4", &self.ja4)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !wkt::internal::is_default(&self.firewall_policy_evaluation) {
            state.serialize_entry("firewallPolicyEvaluation", &self.firewall_policy_evaluation)?;
        }
        if self.transaction_data.is_some() {
            state.serialize_entry("transactionData", &self.transaction_data)?;
        }
        if self.user_info.is_some() {
            state.serialize_entry("userInfo", &self.user_info)?;
        }
        if !wkt::internal::is_default(&self.fraud_prevention) {
            state.serialize_entry("fraudPrevention", &self.fraud_prevention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Setting that controls Fraud Prevention assessments.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FraudPrevention {
        /// Default, unspecified setting. `fraud_prevention_assessment` is returned
        /// if `transaction_data` is present in `Event` and Fraud Prevention is
        /// enabled in the Google Cloud console.
        Unspecified,
        /// Enable Fraud Prevention for this assessment, if Fraud Prevention is
        /// enabled in the Google Cloud console.
        Enabled,
        /// Disable Fraud Prevention for this assessment, regardless of the Google
        /// Cloud console settings.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FraudPrevention::value] or
        /// [FraudPrevention::name].
        UnknownValue(fraud_prevention::UnknownValue),
    }

    #[doc(hidden)]
    pub mod fraud_prevention {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FraudPrevention {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FRAUD_PREVENTION_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FraudPrevention {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FraudPrevention {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FraudPrevention {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(fraud_prevention::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FraudPrevention {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FRAUD_PREVENTION_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(fraud_prevention::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FraudPrevention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FraudPrevention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FraudPrevention>::new(
                ".google.cloud.recaptchaenterprise.v1.Event.FraudPrevention",
            ))
        }
    }
}

/// Transaction data associated with a payment protected by reCAPTCHA Enterprise.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransactionData {
    /// Unique identifier for the transaction. This custom identifier can be used
    /// to reference this transaction in the future, for example, labeling a refund
    /// or chargeback event. Two attempts at the same transaction should use the
    /// same transaction id.
    pub transaction_id: std::option::Option<std::string::String>,

    /// Optional. The payment method for the transaction. The allowed values are:
    ///
    /// * credit-card
    /// * debit-card
    /// * gift-card
    /// * processor-{name} (If a third-party is used, for example,
    ///   processor-paypal)
    /// * custom-{name} (If an alternative method is used, for example,
    ///   custom-crypto)
    pub payment_method: std::string::String,

    /// Optional. The Bank Identification Number - generally the first 6 or 8
    /// digits of the card.
    pub card_bin: std::string::String,

    /// Optional. The last four digits of the card.
    pub card_last_four: std::string::String,

    /// Optional. The currency code in ISO-4217 format.
    pub currency_code: std::string::String,

    /// Optional. The decimal value of the transaction in the specified currency.
    pub value: f64,

    /// Optional. The value of shipping in the specified currency. 0 for free or no
    /// shipping.
    pub shipping_value: f64,

    /// Optional. Destination address if this transaction involves shipping a
    /// physical item.
    pub shipping_address: std::option::Option<crate::model::transaction_data::Address>,

    /// Optional. Address associated with the payment method when applicable.
    pub billing_address: std::option::Option<crate::model::transaction_data::Address>,

    /// Optional. Information about the user paying/initiating the transaction.
    pub user: std::option::Option<crate::model::transaction_data::User>,

    /// Optional. Information about the user or users fulfilling the transaction.
    pub merchants: std::vec::Vec<crate::model::transaction_data::User>,

    /// Optional. Items purchased in this transaction.
    pub items: std::vec::Vec<crate::model::transaction_data::Item>,

    /// Optional. Information about the payment gateway's response to the
    /// transaction.
    pub gateway_info: std::option::Option<crate::model::transaction_data::GatewayInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transaction_id][crate::model::TransactionData::transaction_id].
    pub fn set_transaction_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.transaction_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_id][crate::model::TransactionData::transaction_id].
    pub fn set_or_clear_transaction_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.transaction_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payment_method][crate::model::TransactionData::payment_method].
    pub fn set_payment_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payment_method = v.into();
        self
    }

    /// Sets the value of [card_bin][crate::model::TransactionData::card_bin].
    pub fn set_card_bin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.card_bin = v.into();
        self
    }

    /// Sets the value of [card_last_four][crate::model::TransactionData::card_last_four].
    pub fn set_card_last_four<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.card_last_four = v.into();
        self
    }

    /// Sets the value of [currency_code][crate::model::TransactionData::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TransactionData::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [shipping_value][crate::model::TransactionData::shipping_value].
    pub fn set_shipping_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.shipping_value = v.into();
        self
    }

    /// Sets the value of [shipping_address][crate::model::TransactionData::shipping_address].
    pub fn set_shipping_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.shipping_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shipping_address][crate::model::TransactionData::shipping_address].
    pub fn set_or_clear_shipping_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.shipping_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [billing_address][crate::model::TransactionData::billing_address].
    pub fn set_billing_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.billing_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [billing_address][crate::model::TransactionData::billing_address].
    pub fn set_or_clear_billing_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.billing_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::TransactionData::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::TransactionData::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [merchants][crate::model::TransactionData::merchants].
    pub fn set_merchants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transaction_data::User>,
    {
        use std::iter::Iterator;
        self.merchants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [items][crate::model::TransactionData::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transaction_data::Item>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gateway_info][crate::model::TransactionData::gateway_info].
    pub fn set_gateway_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::GatewayInfo>,
    {
        self.gateway_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gateway_info][crate::model::TransactionData::gateway_info].
    pub fn set_or_clear_gateway_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::GatewayInfo>,
    {
        self.gateway_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransactionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransactionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transaction_id,
            __payment_method,
            __card_bin,
            __card_last_four,
            __currency_code,
            __value,
            __shipping_value,
            __shipping_address,
            __billing_address,
            __user,
            __merchants,
            __items,
            __gateway_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransactionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transactionId" => Ok(__FieldTag::__transaction_id),
                            "transaction_id" => Ok(__FieldTag::__transaction_id),
                            "paymentMethod" => Ok(__FieldTag::__payment_method),
                            "payment_method" => Ok(__FieldTag::__payment_method),
                            "cardBin" => Ok(__FieldTag::__card_bin),
                            "card_bin" => Ok(__FieldTag::__card_bin),
                            "cardLastFour" => Ok(__FieldTag::__card_last_four),
                            "card_last_four" => Ok(__FieldTag::__card_last_four),
                            "currencyCode" => Ok(__FieldTag::__currency_code),
                            "currency_code" => Ok(__FieldTag::__currency_code),
                            "value" => Ok(__FieldTag::__value),
                            "shippingValue" => Ok(__FieldTag::__shipping_value),
                            "shipping_value" => Ok(__FieldTag::__shipping_value),
                            "shippingAddress" => Ok(__FieldTag::__shipping_address),
                            "shipping_address" => Ok(__FieldTag::__shipping_address),
                            "billingAddress" => Ok(__FieldTag::__billing_address),
                            "billing_address" => Ok(__FieldTag::__billing_address),
                            "user" => Ok(__FieldTag::__user),
                            "merchants" => Ok(__FieldTag::__merchants),
                            "items" => Ok(__FieldTag::__items),
                            "gatewayInfo" => Ok(__FieldTag::__gateway_info),
                            "gateway_info" => Ok(__FieldTag::__gateway_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransactionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransactionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transaction_id => {
                            if !fields.insert(__FieldTag::__transaction_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_id",
                                ));
                            }
                            result.transaction_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__payment_method => {
                            if !fields.insert(__FieldTag::__payment_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payment_method",
                                ));
                            }
                            result.payment_method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__card_bin => {
                            if !fields.insert(__FieldTag::__card_bin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for card_bin",
                                ));
                            }
                            result.card_bin = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__card_last_four => {
                            if !fields.insert(__FieldTag::__card_last_four) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for card_last_four",
                                ));
                            }
                            result.card_last_four = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__currency_code => {
                            if !fields.insert(__FieldTag::__currency_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_code",
                                ));
                            }
                            result.currency_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shipping_value => {
                            if !fields.insert(__FieldTag::__shipping_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipping_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shipping_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shipping_address => {
                            if !fields.insert(__FieldTag::__shipping_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipping_address",
                                ));
                            }
                            result.shipping_address = map.next_value::<std::option::Option<crate::model::transaction_data::Address>>()?
                                ;
                        }
                        __FieldTag::__billing_address => {
                            if !fields.insert(__FieldTag::__billing_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_address",
                                ));
                            }
                            result.billing_address = map.next_value::<std::option::Option<crate::model::transaction_data::Address>>()?
                                ;
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map.next_value::<std::option::Option<crate::model::transaction_data::User>>()?
                                ;
                        }
                        __FieldTag::__merchants => {
                            if !fields.insert(__FieldTag::__merchants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for merchants",
                                ));
                            }
                            result.merchants = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::transaction_data::User>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::transaction_data::Item>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gateway_info => {
                            if !fields.insert(__FieldTag::__gateway_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gateway_info",
                                ));
                            }
                            result.gateway_info =
                                map.next_value::<std::option::Option<
                                    crate::model::transaction_data::GatewayInfo,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransactionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transaction_id.is_some() {
            state.serialize_entry("transactionId", &self.transaction_id)?;
        }
        if !self.payment_method.is_empty() {
            state.serialize_entry("paymentMethod", &self.payment_method)?;
        }
        if !self.card_bin.is_empty() {
            state.serialize_entry("cardBin", &self.card_bin)?;
        }
        if !self.card_last_four.is_empty() {
            state.serialize_entry("cardLastFour", &self.card_last_four)?;
        }
        if !self.currency_code.is_empty() {
            state.serialize_entry("currencyCode", &self.currency_code)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !wkt::internal::is_default(&self.shipping_value) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shippingValue", &__With(&self.shipping_value))?;
        }
        if self.shipping_address.is_some() {
            state.serialize_entry("shippingAddress", &self.shipping_address)?;
        }
        if self.billing_address.is_some() {
            state.serialize_entry("billingAddress", &self.billing_address)?;
        }
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.merchants.is_empty() {
            state.serialize_entry("merchants", &self.merchants)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.gateway_info.is_some() {
            state.serialize_entry("gatewayInfo", &self.gateway_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransactionData].
pub mod transaction_data {
    #[allow(unused_imports)]
    use super::*;

    /// Structured address format for billing and shipping addresses.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Address {
        /// Optional. The recipient name, potentially including information such as
        /// "care of".
        pub recipient: std::string::String,

        /// Optional. The first lines of the address. The first line generally
        /// contains the street name and number, and further lines may include
        /// information such as an apartment number.
        pub address: std::vec::Vec<std::string::String>,

        /// Optional. The town/city of the address.
        pub locality: std::string::String,

        /// Optional. The state, province, or otherwise administrative area of the
        /// address.
        pub administrative_area: std::string::String,

        /// Optional. The CLDR country/region of the address.
        pub region_code: std::string::String,

        /// Optional. The postal or ZIP code of the address.
        pub postal_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Address {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recipient][crate::model::transaction_data::Address::recipient].
        pub fn set_recipient<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.recipient = v.into();
            self
        }

        /// Sets the value of [address][crate::model::transaction_data::Address::address].
        pub fn set_address<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.address = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [locality][crate::model::transaction_data::Address::locality].
        pub fn set_locality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.locality = v.into();
            self
        }

        /// Sets the value of [administrative_area][crate::model::transaction_data::Address::administrative_area].
        pub fn set_administrative_area<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.administrative_area = v.into();
            self
        }

        /// Sets the value of [region_code][crate::model::transaction_data::Address::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [postal_code][crate::model::transaction_data::Address::postal_code].
        pub fn set_postal_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.postal_code = v.into();
            self
        }
    }

    impl wkt::message::Message for Address {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.Address"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Address {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __recipient,
                __address,
                __locality,
                __administrative_area,
                __region_code,
                __postal_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Address")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "recipient" => Ok(__FieldTag::__recipient),
                                "address" => Ok(__FieldTag::__address),
                                "locality" => Ok(__FieldTag::__locality),
                                "administrativeArea" => Ok(__FieldTag::__administrative_area),
                                "administrative_area" => Ok(__FieldTag::__administrative_area),
                                "regionCode" => Ok(__FieldTag::__region_code),
                                "region_code" => Ok(__FieldTag::__region_code),
                                "postalCode" => Ok(__FieldTag::__postal_code),
                                "postal_code" => Ok(__FieldTag::__postal_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Address;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Address")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__recipient => {
                                if !fields.insert(__FieldTag::__recipient) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recipient",
                                    ));
                                }
                                result.recipient = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__address => {
                                if !fields.insert(__FieldTag::__address) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for address",
                                    ));
                                }
                                result.address = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__locality => {
                                if !fields.insert(__FieldTag::__locality) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for locality",
                                    ));
                                }
                                result.locality = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__administrative_area => {
                                if !fields.insert(__FieldTag::__administrative_area) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for administrative_area",
                                    ));
                                }
                                result.administrative_area = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__region_code => {
                                if !fields.insert(__FieldTag::__region_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for region_code",
                                    ));
                                }
                                result.region_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__postal_code => {
                                if !fields.insert(__FieldTag::__postal_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for postal_code",
                                    ));
                                }
                                result.postal_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Address {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.recipient.is_empty() {
                state.serialize_entry("recipient", &self.recipient)?;
            }
            if !self.address.is_empty() {
                state.serialize_entry("address", &self.address)?;
            }
            if !self.locality.is_empty() {
                state.serialize_entry("locality", &self.locality)?;
            }
            if !self.administrative_area.is_empty() {
                state.serialize_entry("administrativeArea", &self.administrative_area)?;
            }
            if !self.region_code.is_empty() {
                state.serialize_entry("regionCode", &self.region_code)?;
            }
            if !self.postal_code.is_empty() {
                state.serialize_entry("postalCode", &self.postal_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details about a user's account involved in the transaction.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct User {
        /// Optional. Unique account identifier for this user. If using account
        /// defender, this should match the hashed_account_id field. Otherwise, a
        /// unique and persistent identifier for this account.
        pub account_id: std::string::String,

        /// Optional. The epoch milliseconds of the user's account creation.
        pub creation_ms: i64,

        /// Optional. The email address of the user.
        pub email: std::string::String,

        /// Optional. Whether the email has been verified to be accessible by the
        /// user (OTP or similar).
        pub email_verified: bool,

        /// Optional. The phone number of the user, with country code.
        pub phone_number: std::string::String,

        /// Optional. Whether the phone number has been verified to be accessible by
        /// the user (OTP or similar).
        pub phone_verified: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl User {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [account_id][crate::model::transaction_data::User::account_id].
        pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.account_id = v.into();
            self
        }

        /// Sets the value of [creation_ms][crate::model::transaction_data::User::creation_ms].
        pub fn set_creation_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.creation_ms = v.into();
            self
        }

        /// Sets the value of [email][crate::model::transaction_data::User::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }

        /// Sets the value of [email_verified][crate::model::transaction_data::User::email_verified].
        pub fn set_email_verified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.email_verified = v.into();
            self
        }

        /// Sets the value of [phone_number][crate::model::transaction_data::User::phone_number].
        pub fn set_phone_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.phone_number = v.into();
            self
        }

        /// Sets the value of [phone_verified][crate::model::transaction_data::User::phone_verified].
        pub fn set_phone_verified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.phone_verified = v.into();
            self
        }
    }

    impl wkt::message::Message for User {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.User"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for User {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __account_id,
                __creation_ms,
                __email,
                __email_verified,
                __phone_number,
                __phone_verified,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for User")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accountId" => Ok(__FieldTag::__account_id),
                                "account_id" => Ok(__FieldTag::__account_id),
                                "creationMs" => Ok(__FieldTag::__creation_ms),
                                "creation_ms" => Ok(__FieldTag::__creation_ms),
                                "email" => Ok(__FieldTag::__email),
                                "emailVerified" => Ok(__FieldTag::__email_verified),
                                "email_verified" => Ok(__FieldTag::__email_verified),
                                "phoneNumber" => Ok(__FieldTag::__phone_number),
                                "phone_number" => Ok(__FieldTag::__phone_number),
                                "phoneVerified" => Ok(__FieldTag::__phone_verified),
                                "phone_verified" => Ok(__FieldTag::__phone_verified),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = User;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct User")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__account_id => {
                                if !fields.insert(__FieldTag::__account_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for account_id",
                                    ));
                                }
                                result.account_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__creation_ms => {
                                if !fields.insert(__FieldTag::__creation_ms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for creation_ms",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.creation_ms =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__email => {
                                if !fields.insert(__FieldTag::__email) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for email",
                                    ));
                                }
                                result.email = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__email_verified => {
                                if !fields.insert(__FieldTag::__email_verified) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for email_verified",
                                    ));
                                }
                                result.email_verified = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__phone_number => {
                                if !fields.insert(__FieldTag::__phone_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for phone_number",
                                    ));
                                }
                                result.phone_number = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__phone_verified => {
                                if !fields.insert(__FieldTag::__phone_verified) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for phone_verified",
                                    ));
                                }
                                result.phone_verified = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for User {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.account_id.is_empty() {
                state.serialize_entry("accountId", &self.account_id)?;
            }
            if !wkt::internal::is_default(&self.creation_ms) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("creationMs", &__With(&self.creation_ms))?;
            }
            if !self.email.is_empty() {
                state.serialize_entry("email", &self.email)?;
            }
            if !wkt::internal::is_default(&self.email_verified) {
                state.serialize_entry("emailVerified", &self.email_verified)?;
            }
            if !self.phone_number.is_empty() {
                state.serialize_entry("phoneNumber", &self.phone_number)?;
            }
            if !wkt::internal::is_default(&self.phone_verified) {
                state.serialize_entry("phoneVerified", &self.phone_verified)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Line items being purchased in this transaction.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Item {
        /// Optional. The full name of the item.
        pub name: std::string::String,

        /// Optional. The value per item that the user is paying, in the transaction
        /// currency, after discounts.
        pub value: f64,

        /// Optional. The quantity of this item that is being purchased.
        pub quantity: i64,

        /// Optional. When a merchant is specified, its corresponding account_id.
        /// Necessary to populate marketplace-style transactions.
        pub merchant_account_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Item {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::transaction_data::Item::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::transaction_data::Item::value].
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [quantity][crate::model::transaction_data::Item::quantity].
        pub fn set_quantity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.quantity = v.into();
            self
        }

        /// Sets the value of [merchant_account_id][crate::model::transaction_data::Item::merchant_account_id].
        pub fn set_merchant_account_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.merchant_account_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Item {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.Item"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Item {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __value,
                __quantity,
                __merchant_account_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Item")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "value" => Ok(__FieldTag::__value),
                                "quantity" => Ok(__FieldTag::__quantity),
                                "merchantAccountId" => Ok(__FieldTag::__merchant_account_id),
                                "merchant_account_id" => Ok(__FieldTag::__merchant_account_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Item;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Item")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__quantity => {
                                if !fields.insert(__FieldTag::__quantity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quantity",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.quantity = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__merchant_account_id => {
                                if !fields.insert(__FieldTag::__merchant_account_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for merchant_account_id",
                                    ));
                                }
                                result.merchant_account_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Item {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.value) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("value", &__With(&self.value))?;
            }
            if !wkt::internal::is_default(&self.quantity) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("quantity", &__With(&self.quantity))?;
            }
            if !self.merchant_account_id.is_empty() {
                state.serialize_entry("merchantAccountId", &self.merchant_account_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details about the transaction from the gateway.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GatewayInfo {
        /// Optional. Name of the gateway service (for example, stripe, square,
        /// paypal).
        pub name: std::string::String,

        /// Optional. Gateway response code describing the state of the transaction.
        pub gateway_response_code: std::string::String,

        /// Optional. AVS response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        pub avs_response_code: std::string::String,

        /// Optional. CVV response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        pub cvv_response_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GatewayInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::transaction_data::GatewayInfo::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [gateway_response_code][crate::model::transaction_data::GatewayInfo::gateway_response_code].
        pub fn set_gateway_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gateway_response_code = v.into();
            self
        }

        /// Sets the value of [avs_response_code][crate::model::transaction_data::GatewayInfo::avs_response_code].
        pub fn set_avs_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.avs_response_code = v.into();
            self
        }

        /// Sets the value of [cvv_response_code][crate::model::transaction_data::GatewayInfo::cvv_response_code].
        pub fn set_cvv_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cvv_response_code = v.into();
            self
        }
    }

    impl wkt::message::Message for GatewayInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GatewayInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __gateway_response_code,
                __avs_response_code,
                __cvv_response_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GatewayInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "gatewayResponseCode" => Ok(__FieldTag::__gateway_response_code),
                                "gateway_response_code" => Ok(__FieldTag::__gateway_response_code),
                                "avsResponseCode" => Ok(__FieldTag::__avs_response_code),
                                "avs_response_code" => Ok(__FieldTag::__avs_response_code),
                                "cvvResponseCode" => Ok(__FieldTag::__cvv_response_code),
                                "cvv_response_code" => Ok(__FieldTag::__cvv_response_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GatewayInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GatewayInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gateway_response_code => {
                                if !fields.insert(__FieldTag::__gateway_response_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gateway_response_code",
                                    ));
                                }
                                result.gateway_response_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__avs_response_code => {
                                if !fields.insert(__FieldTag::__avs_response_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for avs_response_code",
                                    ));
                                }
                                result.avs_response_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cvv_response_code => {
                                if !fields.insert(__FieldTag::__cvv_response_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cvv_response_code",
                                    ));
                                }
                                result.cvv_response_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GatewayInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.gateway_response_code.is_empty() {
                state.serialize_entry("gatewayResponseCode", &self.gateway_response_code)?;
            }
            if !self.avs_response_code.is_empty() {
                state.serialize_entry("avsResponseCode", &self.avs_response_code)?;
            }
            if !self.cvv_response_code.is_empty() {
                state.serialize_entry("cvvResponseCode", &self.cvv_response_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// User information associated with a request protected by reCAPTCHA Enterprise.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserInfo {
    /// Optional. Creation time for this account associated with this user. Leave
    /// blank for non logged-in actions, guest checkout, or when there is no
    /// account associated with the current user.
    pub create_account_time: std::option::Option<wkt::Timestamp>,

    /// Optional. For logged-in requests or login/registration requests, the unique
    /// account identifier associated with this user. You can use the username if
    /// it is stable (meaning it is the same for every request associated with the
    /// same user), or any stable user ID of your choice. Leave blank for non
    /// logged-in actions or guest checkout.
    pub account_id: std::string::String,

    /// Optional. Identifiers associated with this user or request.
    pub user_ids: std::vec::Vec<crate::model::UserId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_account_time][crate::model::UserInfo::create_account_time].
    pub fn set_create_account_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_account_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_account_time][crate::model::UserInfo::create_account_time].
    pub fn set_or_clear_create_account_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_account_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_id][crate::model::UserInfo::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [user_ids][crate::model::UserInfo::user_ids].
    pub fn set_user_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserId>,
    {
        use std::iter::Iterator;
        self.user_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UserInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_account_time,
            __account_id,
            __user_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createAccountTime" => Ok(__FieldTag::__create_account_time),
                            "create_account_time" => Ok(__FieldTag::__create_account_time),
                            "accountId" => Ok(__FieldTag::__account_id),
                            "account_id" => Ok(__FieldTag::__account_id),
                            "userIds" => Ok(__FieldTag::__user_ids),
                            "user_ids" => Ok(__FieldTag::__user_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_account_time => {
                            if !fields.insert(__FieldTag::__create_account_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_account_time",
                                ));
                            }
                            result.create_account_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__account_id => {
                            if !fields.insert(__FieldTag::__account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_id",
                                ));
                            }
                            result.account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_ids => {
                            if !fields.insert(__FieldTag::__user_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_ids",
                                ));
                            }
                            result.user_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::UserId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_account_time.is_some() {
            state.serialize_entry("createAccountTime", &self.create_account_time)?;
        }
        if !self.account_id.is_empty() {
            state.serialize_entry("accountId", &self.account_id)?;
        }
        if !self.user_ids.is_empty() {
            state.serialize_entry("userIds", &self.user_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An identifier associated with a user.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserId {
    pub id_oneof: std::option::Option<crate::model::user_id::IdOneof>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof].
    ///
    /// Note that all the setters affecting `id_oneof` are mutually
    /// exclusive.
    pub fn set_id_oneof<
        T: std::convert::Into<std::option::Option<crate::model::user_id::IdOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.id_oneof = v.into();
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `Email`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::Email(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `Email`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof = std::option::Option::Some(crate::model::user_id::IdOneof::Email(v.into()));
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `PhoneNumber`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::PhoneNumber(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `PhoneNumber`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof =
            std::option::Option::Some(crate::model::user_id::IdOneof::PhoneNumber(v.into()));
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `Username`, `None` if the field is not set or
    /// holds a different branch.
    pub fn username(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::Username(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `Username`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof =
            std::option::Option::Some(crate::model::user_id::IdOneof::Username(v.into()));
        self
    }
}

impl wkt::message::Message for UserId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UserId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            __phone_number,
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            "phoneNumber" => Ok(__FieldTag::__phone_number),
                            "phone_number" => Ok(__FieldTag::__phone_number),
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            if result.id_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.UserId.email, latest field was email",
                                ));
                            }
                            result.id_oneof =
                                std::option::Option::Some(crate::model::user_id::IdOneof::Email(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__phone_number => {
                            if !fields.insert(__FieldTag::__phone_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phone_number",
                                ));
                            }
                            if result.id_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.UserId.phone_number, latest field was phoneNumber",
                                ));
                            }
                            result.id_oneof = std::option::Option::Some(
                                crate::model::user_id::IdOneof::PhoneNumber(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            if result.id_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `id_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.UserId.username, latest field was username",
                                ));
                            }
                            result.id_oneof = std::option::Option::Some(
                                crate::model::user_id::IdOneof::Username(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.email() {
            state.serialize_entry("email", value)?;
        }
        if let Some(value) = self.phone_number() {
            state.serialize_entry("phoneNumber", value)?;
        }
        if let Some(value) = self.username() {
            state.serialize_entry("username", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UserId].
pub mod user_id {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IdOneof {
        /// Optional. An email address.
        Email(std::string::String),
        /// Optional. A phone number. Should use the E.164 format.
        PhoneNumber(std::string::String),
        /// Optional. A unique username, if different from all the other identifiers
        /// and `account_id` that are provided. Can be a unique login handle or
        /// display name for a user.
        Username(std::string::String),
    }
}

/// Risk analysis result for an event.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RiskAnalysis {
    /// Output only. Legitimate event score from 0.0 to 1.0.
    /// (1.0 means very likely legitimate traffic while 0.0 means very likely
    /// non-legitimate traffic).
    pub score: f32,

    /// Output only. Reasons contributing to the risk analysis verdict.
    pub reasons: std::vec::Vec<crate::model::risk_analysis::ClassificationReason>,

    /// Output only. Extended verdict reasons to be used for experimentation only.
    /// The set of possible reasons is subject to change.
    pub extended_verdict_reasons: std::vec::Vec<std::string::String>,

    /// Output only. Challenge information for SCORE_AND_CHALLENGE and INVISIBLE
    /// keys
    pub challenge: crate::model::risk_analysis::Challenge,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiskAnalysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::RiskAnalysis::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::RiskAnalysis::reasons].
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::risk_analysis::ClassificationReason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [extended_verdict_reasons][crate::model::RiskAnalysis::extended_verdict_reasons].
    pub fn set_extended_verdict_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.extended_verdict_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [challenge][crate::model::RiskAnalysis::challenge].
    pub fn set_challenge<T: std::convert::Into<crate::model::risk_analysis::Challenge>>(
        mut self,
        v: T,
    ) -> Self {
        self.challenge = v.into();
        self
    }
}

impl wkt::message::Message for RiskAnalysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RiskAnalysis"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RiskAnalysis {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            __reasons,
            __extended_verdict_reasons,
            __challenge,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RiskAnalysis")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            "reasons" => Ok(__FieldTag::__reasons),
                            "extendedVerdictReasons" => Ok(__FieldTag::__extended_verdict_reasons),
                            "extended_verdict_reasons" => {
                                Ok(__FieldTag::__extended_verdict_reasons)
                            }
                            "challenge" => Ok(__FieldTag::__challenge),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RiskAnalysis;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RiskAnalysis")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__reasons => {
                            if !fields.insert(__FieldTag::__reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reasons",
                                ));
                            }
                            result.reasons = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::risk_analysis::ClassificationReason,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__extended_verdict_reasons => {
                            if !fields.insert(__FieldTag::__extended_verdict_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extended_verdict_reasons",
                                ));
                            }
                            result.extended_verdict_reasons = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__challenge => {
                            if !fields.insert(__FieldTag::__challenge) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for challenge",
                                ));
                            }
                            result.challenge = map.next_value::<std::option::Option<crate::model::risk_analysis::Challenge>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RiskAnalysis {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self.reasons.is_empty() {
            state.serialize_entry("reasons", &self.reasons)?;
        }
        if !self.extended_verdict_reasons.is_empty() {
            state.serialize_entry("extendedVerdictReasons", &self.extended_verdict_reasons)?;
        }
        if !wkt::internal::is_default(&self.challenge) {
            state.serialize_entry("challenge", &self.challenge)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RiskAnalysis].
pub mod risk_analysis {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons contributing to the risk analysis verdict.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClassificationReason {
        /// Default unspecified type.
        Unspecified,
        /// Interactions matched the behavior of an automated agent.
        Automation,
        /// The event originated from an illegitimate environment.
        UnexpectedEnvironment,
        /// Traffic volume from the event source is higher than normal.
        TooMuchTraffic,
        /// Interactions with the site were significantly different than expected
        /// patterns.
        UnexpectedUsagePatterns,
        /// Too little traffic has been received from this site thus far to generate
        /// quality risk analysis.
        LowConfidenceScore,
        /// The request matches behavioral characteristics of a carding attack.
        SuspectedCarding,
        /// The request matches behavioral characteristics of chargebacks for fraud.
        SuspectedChargeback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClassificationReason::value] or
        /// [ClassificationReason::name].
        UnknownValue(classification_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod classification_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClassificationReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automation => std::option::Option::Some(1),
                Self::UnexpectedEnvironment => std::option::Option::Some(2),
                Self::TooMuchTraffic => std::option::Option::Some(3),
                Self::UnexpectedUsagePatterns => std::option::Option::Some(4),
                Self::LowConfidenceScore => std::option::Option::Some(5),
                Self::SuspectedCarding => std::option::Option::Some(6),
                Self::SuspectedChargeback => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLASSIFICATION_REASON_UNSPECIFIED"),
                Self::Automation => std::option::Option::Some("AUTOMATION"),
                Self::UnexpectedEnvironment => std::option::Option::Some("UNEXPECTED_ENVIRONMENT"),
                Self::TooMuchTraffic => std::option::Option::Some("TOO_MUCH_TRAFFIC"),
                Self::UnexpectedUsagePatterns => {
                    std::option::Option::Some("UNEXPECTED_USAGE_PATTERNS")
                }
                Self::LowConfidenceScore => std::option::Option::Some("LOW_CONFIDENCE_SCORE"),
                Self::SuspectedCarding => std::option::Option::Some("SUSPECTED_CARDING"),
                Self::SuspectedChargeback => std::option::Option::Some("SUSPECTED_CHARGEBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClassificationReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClassificationReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClassificationReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automation,
                2 => Self::UnexpectedEnvironment,
                3 => Self::TooMuchTraffic,
                4 => Self::UnexpectedUsagePatterns,
                5 => Self::LowConfidenceScore,
                6 => Self::SuspectedCarding,
                7 => Self::SuspectedChargeback,
                _ => Self::UnknownValue(classification_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClassificationReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLASSIFICATION_REASON_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATION" => Self::Automation,
                "UNEXPECTED_ENVIRONMENT" => Self::UnexpectedEnvironment,
                "TOO_MUCH_TRAFFIC" => Self::TooMuchTraffic,
                "UNEXPECTED_USAGE_PATTERNS" => Self::UnexpectedUsagePatterns,
                "LOW_CONFIDENCE_SCORE" => Self::LowConfidenceScore,
                "SUSPECTED_CARDING" => Self::SuspectedCarding,
                "SUSPECTED_CHARGEBACK" => Self::SuspectedChargeback,
                _ => Self::UnknownValue(classification_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClassificationReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automation => serializer.serialize_i32(1),
                Self::UnexpectedEnvironment => serializer.serialize_i32(2),
                Self::TooMuchTraffic => serializer.serialize_i32(3),
                Self::UnexpectedUsagePatterns => serializer.serialize_i32(4),
                Self::LowConfidenceScore => serializer.serialize_i32(5),
                Self::SuspectedCarding => serializer.serialize_i32(6),
                Self::SuspectedChargeback => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClassificationReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClassificationReason>::new(
                ".google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason",
            ))
        }
    }

    /// Challenge information for SCORE_AND_CHALLENGE and INVISIBLE keys
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Challenge {
        /// Default unspecified type.
        Unspecified,
        /// No challenge was presented for solving.
        Nocaptcha,
        /// A solution was submitted that was correct.
        Passed,
        /// A solution was submitted that was incorrect or otherwise
        /// deemed suspicious.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Challenge::value] or
        /// [Challenge::name].
        UnknownValue(challenge::UnknownValue),
    }

    #[doc(hidden)]
    pub mod challenge {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Challenge {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nocaptcha => std::option::Option::Some(1),
                Self::Passed => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHALLENGE_UNSPECIFIED"),
                Self::Nocaptcha => std::option::Option::Some("NOCAPTCHA"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Challenge {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Challenge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Challenge {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nocaptcha,
                2 => Self::Passed,
                3 => Self::Failed,
                _ => Self::UnknownValue(challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Challenge {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHALLENGE_UNSPECIFIED" => Self::Unspecified,
                "NOCAPTCHA" => Self::Nocaptcha,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Challenge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nocaptcha => serializer.serialize_i32(1),
                Self::Passed => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Challenge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Challenge>::new(
                ".google.cloud.recaptchaenterprise.v1.RiskAnalysis.Challenge",
            ))
        }
    }
}

/// Properties of the provided event token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TokenProperties {
    /// Output only. Whether the provided user response token is valid. When valid
    /// = false, the reason could be specified in invalid_reason or it could also
    /// be due to a user failing to solve a challenge or a sitekey mismatch (i.e
    /// the sitekey used to generate the token was different than the one specified
    /// in the assessment).
    pub valid: bool,

    /// Output only. Reason associated with the response when valid = false.
    pub invalid_reason: crate::model::token_properties::InvalidReason,

    /// Output only. The timestamp corresponding to the generation of the token.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The hostname of the page on which the token was generated (Web
    /// keys only).
    pub hostname: std::string::String,

    /// Output only. The name of the Android package with which the token was
    /// generated (Android keys only).
    pub android_package_name: std::string::String,

    /// Output only. The ID of the iOS bundle with which the token was generated
    /// (iOS keys only).
    pub ios_bundle_id: std::string::String,

    /// Output only. Action name provided at token generation.
    pub action: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TokenProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [valid][crate::model::TokenProperties::valid].
    pub fn set_valid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.valid = v.into();
        self
    }

    /// Sets the value of [invalid_reason][crate::model::TokenProperties::invalid_reason].
    pub fn set_invalid_reason<
        T: std::convert::Into<crate::model::token_properties::InvalidReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.invalid_reason = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TokenProperties::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TokenProperties::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hostname][crate::model::TokenProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [android_package_name][crate::model::TokenProperties::android_package_name].
    pub fn set_android_package_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.android_package_name = v.into();
        self
    }

    /// Sets the value of [ios_bundle_id][crate::model::TokenProperties::ios_bundle_id].
    pub fn set_ios_bundle_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ios_bundle_id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::TokenProperties::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }
}

impl wkt::message::Message for TokenProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TokenProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TokenProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __valid,
            __invalid_reason,
            __create_time,
            __hostname,
            __android_package_name,
            __ios_bundle_id,
            __action,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TokenProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "valid" => Ok(__FieldTag::__valid),
                            "invalidReason" => Ok(__FieldTag::__invalid_reason),
                            "invalid_reason" => Ok(__FieldTag::__invalid_reason),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "androidPackageName" => Ok(__FieldTag::__android_package_name),
                            "android_package_name" => Ok(__FieldTag::__android_package_name),
                            "iosBundleId" => Ok(__FieldTag::__ios_bundle_id),
                            "ios_bundle_id" => Ok(__FieldTag::__ios_bundle_id),
                            "action" => Ok(__FieldTag::__action),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TokenProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TokenProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__valid => {
                            if !fields.insert(__FieldTag::__valid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid",
                                ));
                            }
                            result.valid = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invalid_reason => {
                            if !fields.insert(__FieldTag::__invalid_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalid_reason",
                                ));
                            }
                            result.invalid_reason =
                                map.next_value::<std::option::Option<
                                    crate::model::token_properties::InvalidReason,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__android_package_name => {
                            if !fields.insert(__FieldTag::__android_package_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for android_package_name",
                                ));
                            }
                            result.android_package_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ios_bundle_id => {
                            if !fields.insert(__FieldTag::__ios_bundle_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ios_bundle_id",
                                ));
                            }
                            result.ios_bundle_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TokenProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.valid) {
            state.serialize_entry("valid", &self.valid)?;
        }
        if !wkt::internal::is_default(&self.invalid_reason) {
            state.serialize_entry("invalidReason", &self.invalid_reason)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self.android_package_name.is_empty() {
            state.serialize_entry("androidPackageName", &self.android_package_name)?;
        }
        if !self.ios_bundle_id.is_empty() {
            state.serialize_entry("iosBundleId", &self.ios_bundle_id)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TokenProperties].
pub mod token_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the types of invalid token reasons.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InvalidReason {
        /// Default unspecified type.
        Unspecified,
        /// If the failure reason was not accounted for.
        UnknownInvalidReason,
        /// The provided user verification token was malformed.
        Malformed,
        /// The user verification token had expired.
        Expired,
        /// The user verification had already been seen.
        Dupe,
        /// The user verification token was not present.
        Missing,
        /// A retriable error (such as network failure) occurred on the browser.
        /// Could easily be simulated by an attacker.
        BrowserError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InvalidReason::value] or
        /// [InvalidReason::name].
        UnknownValue(invalid_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod invalid_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InvalidReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownInvalidReason => std::option::Option::Some(1),
                Self::Malformed => std::option::Option::Some(2),
                Self::Expired => std::option::Option::Some(3),
                Self::Dupe => std::option::Option::Some(4),
                Self::Missing => std::option::Option::Some(5),
                Self::BrowserError => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INVALID_REASON_UNSPECIFIED"),
                Self::UnknownInvalidReason => std::option::Option::Some("UNKNOWN_INVALID_REASON"),
                Self::Malformed => std::option::Option::Some("MALFORMED"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::Dupe => std::option::Option::Some("DUPE"),
                Self::Missing => std::option::Option::Some("MISSING"),
                Self::BrowserError => std::option::Option::Some("BROWSER_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InvalidReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InvalidReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InvalidReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownInvalidReason,
                2 => Self::Malformed,
                3 => Self::Expired,
                4 => Self::Dupe,
                5 => Self::Missing,
                6 => Self::BrowserError,
                _ => Self::UnknownValue(invalid_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InvalidReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INVALID_REASON_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_INVALID_REASON" => Self::UnknownInvalidReason,
                "MALFORMED" => Self::Malformed,
                "EXPIRED" => Self::Expired,
                "DUPE" => Self::Dupe,
                "MISSING" => Self::Missing,
                "BROWSER_ERROR" => Self::BrowserError,
                _ => Self::UnknownValue(invalid_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InvalidReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownInvalidReason => serializer.serialize_i32(1),
                Self::Malformed => serializer.serialize_i32(2),
                Self::Expired => serializer.serialize_i32(3),
                Self::Dupe => serializer.serialize_i32(4),
                Self::Missing => serializer.serialize_i32(5),
                Self::BrowserError => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InvalidReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InvalidReason>::new(
                ".google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason",
            ))
        }
    }
}

/// Assessment for Fraud Prevention.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FraudPreventionAssessment {
    /// Output only. Probability of this transaction being fraudulent. Summarizes
    /// the combined risk of attack vectors below. Values are from 0.0 (lowest)
    /// to 1.0 (highest).
    pub transaction_risk: f32,

    /// Output only. Assessment of this transaction for risk of a stolen
    /// instrument.
    pub stolen_instrument_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,

    /// Output only. Assessment of this transaction for risk of being part of a
    /// card testing attack.
    pub card_testing_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::CardTestingVerdict>,

    /// Output only. Assessment of this transaction for behavioral trust.
    pub behavioral_trust_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FraudPreventionAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transaction_risk][crate::model::FraudPreventionAssessment::transaction_risk].
    pub fn set_transaction_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.transaction_risk = v.into();
        self
    }

    /// Sets the value of [stolen_instrument_verdict][crate::model::FraudPreventionAssessment::stolen_instrument_verdict].
    pub fn set_stolen_instrument_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,
    {
        self.stolen_instrument_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stolen_instrument_verdict][crate::model::FraudPreventionAssessment::stolen_instrument_verdict].
    pub fn set_or_clear_stolen_instrument_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,
    {
        self.stolen_instrument_verdict = v.map(|x| x.into());
        self
    }

    /// Sets the value of [card_testing_verdict][crate::model::FraudPreventionAssessment::card_testing_verdict].
    pub fn set_card_testing_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::CardTestingVerdict>,
    {
        self.card_testing_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [card_testing_verdict][crate::model::FraudPreventionAssessment::card_testing_verdict].
    pub fn set_or_clear_card_testing_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::CardTestingVerdict>,
    {
        self.card_testing_verdict = v.map(|x| x.into());
        self
    }

    /// Sets the value of [behavioral_trust_verdict][crate::model::FraudPreventionAssessment::behavioral_trust_verdict].
    pub fn set_behavioral_trust_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,
    {
        self.behavioral_trust_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [behavioral_trust_verdict][crate::model::FraudPreventionAssessment::behavioral_trust_verdict].
    pub fn set_or_clear_behavioral_trust_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,
    {
        self.behavioral_trust_verdict = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FraudPreventionAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FraudPreventionAssessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transaction_risk,
            __stolen_instrument_verdict,
            __card_testing_verdict,
            __behavioral_trust_verdict,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FraudPreventionAssessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transactionRisk" => Ok(__FieldTag::__transaction_risk),
                            "transaction_risk" => Ok(__FieldTag::__transaction_risk),
                            "stolenInstrumentVerdict" => {
                                Ok(__FieldTag::__stolen_instrument_verdict)
                            }
                            "stolen_instrument_verdict" => {
                                Ok(__FieldTag::__stolen_instrument_verdict)
                            }
                            "cardTestingVerdict" => Ok(__FieldTag::__card_testing_verdict),
                            "card_testing_verdict" => Ok(__FieldTag::__card_testing_verdict),
                            "behavioralTrustVerdict" => Ok(__FieldTag::__behavioral_trust_verdict),
                            "behavioral_trust_verdict" => {
                                Ok(__FieldTag::__behavioral_trust_verdict)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FraudPreventionAssessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FraudPreventionAssessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transaction_risk => {
                            if !fields.insert(__FieldTag::__transaction_risk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_risk",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction_risk =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__stolen_instrument_verdict => {
                            if !fields.insert(__FieldTag::__stolen_instrument_verdict) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stolen_instrument_verdict",
                                ));
                            }
                            result.stolen_instrument_verdict = map
                                .next_value::<std::option::Option<
                                crate::model::fraud_prevention_assessment::StolenInstrumentVerdict,
                            >>(
                            )?;
                        }
                        __FieldTag::__card_testing_verdict => {
                            if !fields.insert(__FieldTag::__card_testing_verdict) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for card_testing_verdict",
                                ));
                            }
                            result.card_testing_verdict = map.next_value::<std::option::Option<
                                crate::model::fraud_prevention_assessment::CardTestingVerdict,
                            >>()?;
                        }
                        __FieldTag::__behavioral_trust_verdict => {
                            if !fields.insert(__FieldTag::__behavioral_trust_verdict) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for behavioral_trust_verdict",
                                ));
                            }
                            result.behavioral_trust_verdict = map
                                .next_value::<std::option::Option<
                                crate::model::fraud_prevention_assessment::BehavioralTrustVerdict,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FraudPreventionAssessment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.transaction_risk) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transactionRisk", &__With(&self.transaction_risk))?;
        }
        if self.stolen_instrument_verdict.is_some() {
            state.serialize_entry("stolenInstrumentVerdict", &self.stolen_instrument_verdict)?;
        }
        if self.card_testing_verdict.is_some() {
            state.serialize_entry("cardTestingVerdict", &self.card_testing_verdict)?;
        }
        if self.behavioral_trust_verdict.is_some() {
            state.serialize_entry("behavioralTrustVerdict", &self.behavioral_trust_verdict)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FraudPreventionAssessment].
pub mod fraud_prevention_assessment {
    #[allow(unused_imports)]
    use super::*;

    /// Information about stolen instrument fraud, where the user is not the
    /// legitimate owner of the instrument being used for the purchase.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StolenInstrumentVerdict {
        /// Output only. Probability of this transaction being executed with a stolen
        /// instrument. Values are from 0.0 (lowest) to 1.0 (highest).
        pub risk: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StolenInstrumentVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [risk][crate::model::fraud_prevention_assessment::StolenInstrumentVerdict::risk].
        pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.risk = v.into();
            self
        }
    }

    impl wkt::message::Message for StolenInstrumentVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StolenInstrumentVerdict {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __risk,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StolenInstrumentVerdict")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "risk" => Ok(__FieldTag::__risk),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StolenInstrumentVerdict;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StolenInstrumentVerdict")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__risk => {
                                if !fields.insert(__FieldTag::__risk) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for risk",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.risk = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StolenInstrumentVerdict {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.risk) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("risk", &__With(&self.risk))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Information about card testing fraud, where an adversary is testing
    /// fraudulently obtained cards or brute forcing their details.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CardTestingVerdict {
        /// Output only. Probability of this transaction attempt being part of a card
        /// testing attack. Values are from 0.0 (lowest) to 1.0 (highest).
        pub risk: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CardTestingVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [risk][crate::model::fraud_prevention_assessment::CardTestingVerdict::risk].
        pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.risk = v.into();
            self
        }
    }

    impl wkt::message::Message for CardTestingVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CardTestingVerdict {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __risk,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CardTestingVerdict")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "risk" => Ok(__FieldTag::__risk),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CardTestingVerdict;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CardTestingVerdict")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__risk => {
                                if !fields.insert(__FieldTag::__risk) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for risk",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.risk = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CardTestingVerdict {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.risk) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("risk", &__With(&self.risk))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Information about behavioral trust of the transaction.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BehavioralTrustVerdict {
        /// Output only. Probability of this transaction attempt being executed in a
        /// behaviorally trustworthy way. Values are from 0.0 (lowest) to 1.0
        /// (highest).
        pub trust: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BehavioralTrustVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trust][crate::model::fraud_prevention_assessment::BehavioralTrustVerdict::trust].
        pub fn set_trust<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.trust = v.into();
            self
        }
    }

    impl wkt::message::Message for BehavioralTrustVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BehavioralTrustVerdict {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __trust,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BehavioralTrustVerdict")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trust" => Ok(__FieldTag::__trust),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BehavioralTrustVerdict;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BehavioralTrustVerdict")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__trust => {
                                if !fields.insert(__FieldTag::__trust) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for trust",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.trust = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BehavioralTrustVerdict {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.trust) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("trust", &__With(&self.trust))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Fraud signals describing users and cards involved in the transaction.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FraudSignals {
    /// Output only. Signals describing the end user in this transaction.
    pub user_signals: std::option::Option<crate::model::fraud_signals::UserSignals>,

    /// Output only. Signals describing the payment card or cards used in this
    /// transaction.
    pub card_signals: std::option::Option<crate::model::fraud_signals::CardSignals>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FraudSignals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_signals][crate::model::FraudSignals::user_signals].
    pub fn set_user_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::UserSignals>,
    {
        self.user_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_signals][crate::model::FraudSignals::user_signals].
    pub fn set_or_clear_user_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::UserSignals>,
    {
        self.user_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [card_signals][crate::model::FraudSignals::card_signals].
    pub fn set_card_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::CardSignals>,
    {
        self.card_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [card_signals][crate::model::FraudSignals::card_signals].
    pub fn set_or_clear_card_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::CardSignals>,
    {
        self.card_signals = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FraudSignals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FraudSignals {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_signals,
            __card_signals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FraudSignals")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userSignals" => Ok(__FieldTag::__user_signals),
                            "user_signals" => Ok(__FieldTag::__user_signals),
                            "cardSignals" => Ok(__FieldTag::__card_signals),
                            "card_signals" => Ok(__FieldTag::__card_signals),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FraudSignals;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FraudSignals")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_signals => {
                            if !fields.insert(__FieldTag::__user_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_signals",
                                ));
                            }
                            result.user_signals = map.next_value::<std::option::Option<crate::model::fraud_signals::UserSignals>>()?
                                ;
                        }
                        __FieldTag::__card_signals => {
                            if !fields.insert(__FieldTag::__card_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for card_signals",
                                ));
                            }
                            result.card_signals = map.next_value::<std::option::Option<crate::model::fraud_signals::CardSignals>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FraudSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user_signals.is_some() {
            state.serialize_entry("userSignals", &self.user_signals)?;
        }
        if self.card_signals.is_some() {
            state.serialize_entry("cardSignals", &self.card_signals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FraudSignals].
pub mod fraud_signals {
    #[allow(unused_imports)]
    use super::*;

    /// Signals describing the user involved in this transaction.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserSignals {
        /// Output only. This user (based on email, phone, and other identifiers) has
        /// been seen on the internet for at least this number of days.
        pub active_days_lower_bound: i32,

        /// Output only. Likelihood (from 0.0 to 1.0) this user includes synthetic
        /// components in their identity, such as a randomly generated email address,
        /// temporary phone number, or fake shipping address.
        pub synthetic_risk: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [active_days_lower_bound][crate::model::fraud_signals::UserSignals::active_days_lower_bound].
        pub fn set_active_days_lower_bound<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.active_days_lower_bound = v.into();
            self
        }

        /// Sets the value of [synthetic_risk][crate::model::fraud_signals::UserSignals::synthetic_risk].
        pub fn set_synthetic_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.synthetic_risk = v.into();
            self
        }
    }

    impl wkt::message::Message for UserSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserSignals {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __active_days_lower_bound,
                __synthetic_risk,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserSignals")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "activeDaysLowerBound" => Ok(__FieldTag::__active_days_lower_bound),
                                "active_days_lower_bound" => {
                                    Ok(__FieldTag::__active_days_lower_bound)
                                }
                                "syntheticRisk" => Ok(__FieldTag::__synthetic_risk),
                                "synthetic_risk" => Ok(__FieldTag::__synthetic_risk),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserSignals;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserSignals")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__active_days_lower_bound => {
                                if !fields.insert(__FieldTag::__active_days_lower_bound) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for active_days_lower_bound",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.active_days_lower_bound =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__synthetic_risk => {
                                if !fields.insert(__FieldTag::__synthetic_risk) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for synthetic_risk",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.synthetic_risk =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserSignals {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.active_days_lower_bound) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "activeDaysLowerBound",
                    &__With(&self.active_days_lower_bound),
                )?;
            }
            if !wkt::internal::is_default(&self.synthetic_risk) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("syntheticRisk", &__With(&self.synthetic_risk))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Signals describing the payment card used in this transaction.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CardSignals {
        /// Output only. The labels for the payment card in this transaction.
        pub card_labels: std::vec::Vec<crate::model::fraud_signals::card_signals::CardLabel>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CardSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [card_labels][crate::model::fraud_signals::CardSignals::card_labels].
        pub fn set_card_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::fraud_signals::card_signals::CardLabel>,
        {
            use std::iter::Iterator;
            self.card_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CardSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CardSignals {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __card_labels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CardSignals")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cardLabels" => Ok(__FieldTag::__card_labels),
                                "card_labels" => Ok(__FieldTag::__card_labels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CardSignals;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CardSignals")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__card_labels => {
                                if !fields.insert(__FieldTag::__card_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for card_labels",
                                    ));
                                }
                                result.card_labels = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::fraud_signals::card_signals::CardLabel,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CardSignals {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.card_labels.is_empty() {
                state.serialize_entry("cardLabels", &self.card_labels)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [CardSignals].
    pub mod card_signals {
        #[allow(unused_imports)]
        use super::*;

        /// Risk labels describing the card being assessed, such as its funding
        /// mechanism.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CardLabel {
            /// No label specified.
            Unspecified,
            /// This card has been detected as prepaid.
            Prepaid,
            /// This card has been detected as virtual, such as a card number generated
            /// for a single transaction or merchant.
            Virtual,
            /// This card has been detected as being used in an unexpected geographic
            /// location.
            UnexpectedLocation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [CardLabel::value] or
            /// [CardLabel::name].
            UnknownValue(card_label::UnknownValue),
        }

        #[doc(hidden)]
        pub mod card_label {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl CardLabel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Prepaid => std::option::Option::Some(1),
                    Self::Virtual => std::option::Option::Some(2),
                    Self::UnexpectedLocation => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CARD_LABEL_UNSPECIFIED"),
                    Self::Prepaid => std::option::Option::Some("PREPAID"),
                    Self::Virtual => std::option::Option::Some("VIRTUAL"),
                    Self::UnexpectedLocation => std::option::Option::Some("UNEXPECTED_LOCATION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for CardLabel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for CardLabel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for CardLabel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Prepaid,
                    2 => Self::Virtual,
                    3 => Self::UnexpectedLocation,
                    _ => Self::UnknownValue(card_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for CardLabel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CARD_LABEL_UNSPECIFIED" => Self::Unspecified,
                    "PREPAID" => Self::Prepaid,
                    "VIRTUAL" => Self::Virtual,
                    "UNEXPECTED_LOCATION" => Self::UnexpectedLocation,
                    _ => Self::UnknownValue(card_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for CardLabel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Prepaid => serializer.serialize_i32(1),
                    Self::Virtual => serializer.serialize_i32(2),
                    Self::UnexpectedLocation => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for CardLabel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<CardLabel>::new(
                    ".google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel",
                ))
            }
        }
    }
}

/// Information about SMS toll fraud.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SmsTollFraudVerdict {
    /// Output only. Probability of an SMS event being fraudulent.
    /// Values are from 0.0 (lowest) to 1.0 (highest).
    pub risk: f32,

    /// Output only. Reasons contributing to the SMS toll fraud verdict.
    pub reasons: std::vec::Vec<crate::model::sms_toll_fraud_verdict::SmsTollFraudReason>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmsTollFraudVerdict {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [risk][crate::model::SmsTollFraudVerdict::risk].
    pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.risk = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::SmsTollFraudVerdict::reasons].
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sms_toll_fraud_verdict::SmsTollFraudReason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SmsTollFraudVerdict {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SmsTollFraudVerdict {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __risk,
            __reasons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmsTollFraudVerdict")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "risk" => Ok(__FieldTag::__risk),
                            "reasons" => Ok(__FieldTag::__reasons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SmsTollFraudVerdict;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmsTollFraudVerdict")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__risk => {
                            if !fields.insert(__FieldTag::__risk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risk",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.risk = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__reasons => {
                            if !fields.insert(__FieldTag::__reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reasons",
                                ));
                            }
                            result.reasons = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::sms_toll_fraud_verdict::SmsTollFraudReason,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SmsTollFraudVerdict {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.risk) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("risk", &__With(&self.risk))?;
        }
        if !self.reasons.is_empty() {
            state.serialize_entry("reasons", &self.reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SmsTollFraudVerdict].
pub mod sms_toll_fraud_verdict {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons contributing to the SMS toll fraud verdict.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SmsTollFraudReason {
        /// Default unspecified reason
        Unspecified,
        /// The provided phone number was invalid
        InvalidPhoneNumber,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SmsTollFraudReason::value] or
        /// [SmsTollFraudReason::name].
        UnknownValue(sms_toll_fraud_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sms_toll_fraud_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SmsTollFraudReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InvalidPhoneNumber => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SMS_TOLL_FRAUD_REASON_UNSPECIFIED"),
                Self::InvalidPhoneNumber => std::option::Option::Some("INVALID_PHONE_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SmsTollFraudReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SmsTollFraudReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SmsTollFraudReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InvalidPhoneNumber,
                _ => Self::UnknownValue(sms_toll_fraud_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SmsTollFraudReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SMS_TOLL_FRAUD_REASON_UNSPECIFIED" => Self::Unspecified,
                "INVALID_PHONE_NUMBER" => Self::InvalidPhoneNumber,
                _ => Self::UnknownValue(sms_toll_fraud_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SmsTollFraudReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InvalidPhoneNumber => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SmsTollFraudReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SmsTollFraudReason>::new(
                ".google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason",
            ))
        }
    }
}

/// Assessment for Phone Fraud
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PhoneFraudAssessment {
    /// Output only. Assessment of this phone event for risk of SMS toll fraud.
    pub sms_toll_fraud_verdict: std::option::Option<crate::model::SmsTollFraudVerdict>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhoneFraudAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sms_toll_fraud_verdict][crate::model::PhoneFraudAssessment::sms_toll_fraud_verdict].
    pub fn set_sms_toll_fraud_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SmsTollFraudVerdict>,
    {
        self.sms_toll_fraud_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sms_toll_fraud_verdict][crate::model::PhoneFraudAssessment::sms_toll_fraud_verdict].
    pub fn set_or_clear_sms_toll_fraud_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SmsTollFraudVerdict>,
    {
        self.sms_toll_fraud_verdict = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PhoneFraudAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhoneFraudAssessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sms_toll_fraud_verdict,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhoneFraudAssessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "smsTollFraudVerdict" => Ok(__FieldTag::__sms_toll_fraud_verdict),
                            "sms_toll_fraud_verdict" => Ok(__FieldTag::__sms_toll_fraud_verdict),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhoneFraudAssessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhoneFraudAssessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sms_toll_fraud_verdict => {
                            if !fields.insert(__FieldTag::__sms_toll_fraud_verdict) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sms_toll_fraud_verdict",
                                ));
                            }
                            result.sms_toll_fraud_verdict = map.next_value::<std::option::Option<crate::model::SmsTollFraudVerdict>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhoneFraudAssessment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.sms_toll_fraud_verdict.is_some() {
            state.serialize_entry("smsTollFraudVerdict", &self.sms_toll_fraud_verdict)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Account defender risk assessment.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccountDefenderAssessment {
    /// Output only. Labels for this request.
    pub labels: std::vec::Vec<crate::model::account_defender_assessment::AccountDefenderLabel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountDefenderAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::AccountDefenderAssessment::labels].
    pub fn set_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::account_defender_assessment::AccountDefenderLabel>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccountDefenderAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccountDefenderAssessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccountDefenderAssessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccountDefenderAssessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccountDefenderAssessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::account_defender_assessment::AccountDefenderLabel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccountDefenderAssessment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccountDefenderAssessment].
pub mod account_defender_assessment {
    #[allow(unused_imports)]
    use super::*;

    /// Labels returned by account defender for this request.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccountDefenderLabel {
        /// Default unspecified type.
        Unspecified,
        /// The request matches a known good profile for the user.
        ProfileMatch,
        /// The request is potentially a suspicious login event and must be further
        /// verified either through multi-factor authentication or another system.
        SuspiciousLoginActivity,
        /// The request matched a profile that previously had suspicious account
        /// creation behavior. This can mean that this is a fake account.
        SuspiciousAccountCreation,
        /// The account in the request has a high number of related accounts. It does
        /// not necessarily imply that the account is bad but can require further
        /// investigation.
        RelatedAccountsNumberHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccountDefenderLabel::value] or
        /// [AccountDefenderLabel::name].
        UnknownValue(account_defender_label::UnknownValue),
    }

    #[doc(hidden)]
    pub mod account_defender_label {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccountDefenderLabel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ProfileMatch => std::option::Option::Some(1),
                Self::SuspiciousLoginActivity => std::option::Option::Some(2),
                Self::SuspiciousAccountCreation => std::option::Option::Some(3),
                Self::RelatedAccountsNumberHigh => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("ACCOUNT_DEFENDER_LABEL_UNSPECIFIED")
                }
                Self::ProfileMatch => std::option::Option::Some("PROFILE_MATCH"),
                Self::SuspiciousLoginActivity => {
                    std::option::Option::Some("SUSPICIOUS_LOGIN_ACTIVITY")
                }
                Self::SuspiciousAccountCreation => {
                    std::option::Option::Some("SUSPICIOUS_ACCOUNT_CREATION")
                }
                Self::RelatedAccountsNumberHigh => {
                    std::option::Option::Some("RELATED_ACCOUNTS_NUMBER_HIGH")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccountDefenderLabel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccountDefenderLabel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccountDefenderLabel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ProfileMatch,
                2 => Self::SuspiciousLoginActivity,
                3 => Self::SuspiciousAccountCreation,
                4 => Self::RelatedAccountsNumberHigh,
                _ => Self::UnknownValue(account_defender_label::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccountDefenderLabel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED" => Self::Unspecified,
                "PROFILE_MATCH" => Self::ProfileMatch,
                "SUSPICIOUS_LOGIN_ACTIVITY" => Self::SuspiciousLoginActivity,
                "SUSPICIOUS_ACCOUNT_CREATION" => Self::SuspiciousAccountCreation,
                "RELATED_ACCOUNTS_NUMBER_HIGH" => Self::RelatedAccountsNumberHigh,
                _ => Self::UnknownValue(account_defender_label::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccountDefenderLabel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ProfileMatch => serializer.serialize_i32(1),
                Self::SuspiciousLoginActivity => serializer.serialize_i32(2),
                Self::SuspiciousAccountCreation => serializer.serialize_i32(3),
                Self::RelatedAccountsNumberHigh => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccountDefenderLabel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccountDefenderLabel>::new(
                ".google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel"))
        }
    }
}

/// The create key request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKeyRequest {
    /// Required. The name of the project in which the key is created, in the
    /// format `projects/{project}`.
    pub parent: std::string::String,

    /// Required. Information to create a reCAPTCHA Enterprise key.
    pub key: std::option::Option<crate::model::Key>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key][crate::model::CreateKeyRequest::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::CreateKeyRequest::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key =
                                map.next_value::<std::option::Option<crate::model::Key>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The list keys request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeysRequest {
    /// Required. The name of the project that contains the keys that is
    /// listed, in the format `projects/{project}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of keys to return. Default is 10. Max limit is
    /// 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous.
    /// ListKeysRequest, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response to request to list keys in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeysResponse {
    /// Key details.
    pub keys: std::vec::Vec<crate::model::Key>,

    /// Token to retrieve the next page of results. It is set to empty if no keys
    /// remain in results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::ListKeysResponse::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Key>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKeysResponse {
    type PageItem = crate::model::Key;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKeysResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __keys,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKeysResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keys" => Ok(__FieldTag::__keys),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKeysResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKeysResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__keys => {
                            if !fields.insert(__FieldTag::__keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keys",
                                ));
                            }
                            result.keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Key>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListKeysResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.keys.is_empty() {
            state.serialize_entry("keys", &self.keys)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The retrieve legacy secret key request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveLegacySecretKeyRequest {
    /// Required. The public key name linked to the requested secret key in the
    /// format `projects/{project}/keys/{key}`.
    pub key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveLegacySecretKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::RetrieveLegacySecretKeyRequest::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveLegacySecretKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetrieveLegacySecretKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetrieveLegacySecretKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetrieveLegacySecretKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetrieveLegacySecretKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetrieveLegacySecretKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The get key request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetKeyRequest {
    /// Required. The name of the requested key, in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The update key request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateKeyRequest {
    /// Required. The key to update.
    pub key: std::option::Option<crate::model::Key>,

    /// Optional. The mask to control which fields of the key get updated. If the
    /// mask is not present, all fields are updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::UpdateKeyRequest::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::UpdateKeyRequest::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateKeyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateKeyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UpdateKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key =
                                map.next_value::<std::option::Option<crate::model::Key>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The delete key request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteKeyRequest {
    /// Required. The name of the key to be deleted, in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.DeleteKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The create firewall policy request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFirewallPolicyRequest {
    /// Required. The name of the project this policy applies to, in the format
    /// `projects/{project}`.
    pub parent: std::string::String,

    /// Required. Information to create the policy.
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFirewallPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [firewall_policy][crate::model::CreateFirewallPolicyRequest::firewall_policy].
    pub fn set_firewall_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy][crate::model::CreateFirewallPolicyRequest::firewall_policy].
    pub fn set_or_clear_firewall_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateFirewallPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFirewallPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __firewall_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFirewallPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "firewallPolicy" => Ok(__FieldTag::__firewall_policy),
                            "firewall_policy" => Ok(__FieldTag::__firewall_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFirewallPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFirewallPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__firewall_policy => {
                            if !fields.insert(__FieldTag::__firewall_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_policy",
                                ));
                            }
                            result.firewall_policy = map
                                .next_value::<std::option::Option<crate::model::FirewallPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateFirewallPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.firewall_policy.is_some() {
            state.serialize_entry("firewallPolicy", &self.firewall_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The list firewall policies request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of policies to return. Default is 10. Max
    /// limit is 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous.
    /// ListFirewallPoliciesRequest, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFirewallPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFirewallPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFirewallPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFirewallPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFirewallPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFirewallPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFirewallPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFirewallPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFirewallPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFirewallPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response to request to list firewall policies belonging to a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFirewallPoliciesResponse {
    /// Policy details.
    pub firewall_policies: std::vec::Vec<crate::model::FirewallPolicy>,

    /// Token to retrieve the next page of results. It is set to empty if no
    /// policies remain in results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFirewallPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policies][crate::model::ListFirewallPoliciesResponse::firewall_policies].
    pub fn set_firewall_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicy>,
    {
        use std::iter::Iterator;
        self.firewall_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFirewallPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFirewallPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFirewallPoliciesResponse {
    type PageItem = crate::model::FirewallPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.firewall_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFirewallPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __firewall_policies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFirewallPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firewallPolicies" => Ok(__FieldTag::__firewall_policies),
                            "firewall_policies" => Ok(__FieldTag::__firewall_policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFirewallPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFirewallPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__firewall_policies => {
                            if !fields.insert(__FieldTag::__firewall_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_policies",
                                ));
                            }
                            result.firewall_policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FirewallPolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFirewallPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.firewall_policies.is_empty() {
            state.serialize_entry("firewallPolicies", &self.firewall_policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The get firewall policy request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFirewallPolicyRequest {
    /// Required. The name of the requested policy, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFirewallPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetFirewallPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFirewallPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFirewallPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFirewallPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFirewallPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFirewallPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The update firewall policy request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFirewallPolicyRequest {
    /// Required. The policy to update.
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    /// Optional. The mask to control which fields of the policy get updated. If
    /// the mask is not present, all fields are updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policy][crate::model::UpdateFirewallPolicyRequest::firewall_policy].
    pub fn set_firewall_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy][crate::model::UpdateFirewallPolicyRequest::firewall_policy].
    pub fn set_or_clear_firewall_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFirewallPolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFirewallPolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UpdateFirewallPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFirewallPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __firewall_policy,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFirewallPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firewallPolicy" => Ok(__FieldTag::__firewall_policy),
                            "firewall_policy" => Ok(__FieldTag::__firewall_policy),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFirewallPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFirewallPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__firewall_policy => {
                            if !fields.insert(__FieldTag::__firewall_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_policy",
                                ));
                            }
                            result.firewall_policy = map
                                .next_value::<std::option::Option<crate::model::FirewallPolicy>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFirewallPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.firewall_policy.is_some() {
            state.serialize_entry("firewallPolicy", &self.firewall_policy)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The delete firewall policy request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFirewallPolicyRequest {
    /// Required. The name of the policy to be deleted, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFirewallPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.DeleteFirewallPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFirewallPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFirewallPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFirewallPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFirewallPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteFirewallPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The reorder firewall policies request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReorderFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    pub parent: std::string::String,

    /// Required. A list containing all policy names, in the new order. Each name
    /// is in the format `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReorderFirewallPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReorderFirewallPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::ReorderFirewallPoliciesRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReorderFirewallPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReorderFirewallPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReorderFirewallPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReorderFirewallPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReorderFirewallPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReorderFirewallPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The reorder firewall policies response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReorderFirewallPoliciesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReorderFirewallPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReorderFirewallPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReorderFirewallPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReorderFirewallPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReorderFirewallPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReorderFirewallPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReorderFirewallPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The migrate key request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrateKeyRequest {
    /// Required. The name of the key to be migrated, in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Optional. If true, skips the billing check.
    /// A reCAPTCHA Enterprise key or migrated key behaves differently than a
    /// reCAPTCHA (non-Enterprise version) key when you reach a quota limit (see
    /// <https://cloud.google.com/recaptcha/quotas#quota_limit>). To avoid
    /// any disruption of your usage, we check that a billing account is present.
    /// If your usage of reCAPTCHA is under the free quota, you can safely skip the
    /// billing check and proceed with the migration. See
    /// <https://cloud.google.com/recaptcha/docs/billing-information>.
    pub skip_billing_check: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrateKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_billing_check][crate::model::MigrateKeyRequest::skip_billing_check].
    pub fn set_skip_billing_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_billing_check = v.into();
        self
    }
}

impl wkt::message::Message for MigrateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.MigrateKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrateKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __skip_billing_check,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrateKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "skipBillingCheck" => Ok(__FieldTag::__skip_billing_check),
                            "skip_billing_check" => Ok(__FieldTag::__skip_billing_check),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrateKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrateKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_billing_check => {
                            if !fields.insert(__FieldTag::__skip_billing_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_billing_check",
                                ));
                            }
                            result.skip_billing_check = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrateKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.skip_billing_check) {
            state.serialize_entry("skipBillingCheck", &self.skip_billing_check)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The get metrics request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMetricsRequest {
    /// Required. The name of the requested metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetricsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetMetricsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMetricsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMetricsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMetricsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMetricsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMetricsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metrics for a single Key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Metrics {
    /// Output only. Identifier. The name of the metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    pub name: std::string::String,

    /// Inclusive start time aligned to a day in the America/Los_Angeles (Pacific)
    /// timezone.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. All Key types should have score-based data.
    pub score_metrics: std::vec::Vec<crate::model::ScoreMetrics>,

    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. Only challenge-based keys (CHECKBOX, INVISIBLE) have
    /// challenge-based data.
    pub challenge_metrics: std::vec::Vec<crate::model::ChallengeMetrics>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Metrics::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Metrics::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Metrics::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [score_metrics][crate::model::Metrics::score_metrics].
    pub fn set_score_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScoreMetrics>,
    {
        use std::iter::Iterator;
        self.score_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [challenge_metrics][crate::model::Metrics::challenge_metrics].
    pub fn set_challenge_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChallengeMetrics>,
    {
        use std::iter::Iterator;
        self.challenge_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Metrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Metrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Metrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __start_time,
            __score_metrics,
            __challenge_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "scoreMetrics" => Ok(__FieldTag::__score_metrics),
                            "score_metrics" => Ok(__FieldTag::__score_metrics),
                            "challengeMetrics" => Ok(__FieldTag::__challenge_metrics),
                            "challenge_metrics" => Ok(__FieldTag::__challenge_metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Metrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__score_metrics => {
                            if !fields.insert(__FieldTag::__score_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score_metrics",
                                ));
                            }
                            result.score_metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ScoreMetrics>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__challenge_metrics => {
                            if !fields.insert(__FieldTag::__challenge_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for challenge_metrics",
                                ));
                            }
                            result.challenge_metrics =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ChallengeMetrics>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Metrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.score_metrics.is_empty() {
            state.serialize_entry("scoreMetrics", &self.score_metrics)?;
        }
        if !self.challenge_metrics.is_empty() {
            state.serialize_entry("challengeMetrics", &self.challenge_metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Secret key is used only in legacy reCAPTCHA. It must be used in a 3rd party
/// integration with legacy reCAPTCHA.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveLegacySecretKeyResponse {
    /// The secret key (also known as shared secret) authorizes communication
    /// between your application backend and the reCAPTCHA Enterprise server to
    /// create an assessment.
    /// The secret key needs to be kept safe for security purposes.
    pub legacy_secret_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveLegacySecretKeyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [legacy_secret_key][crate::model::RetrieveLegacySecretKeyResponse::legacy_secret_key].
    pub fn set_legacy_secret_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_secret_key = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveLegacySecretKeyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetrieveLegacySecretKeyResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __legacy_secret_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetrieveLegacySecretKeyResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "legacySecretKey" => Ok(__FieldTag::__legacy_secret_key),
                            "legacy_secret_key" => Ok(__FieldTag::__legacy_secret_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetrieveLegacySecretKeyResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetrieveLegacySecretKeyResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__legacy_secret_key => {
                            if !fields.insert(__FieldTag::__legacy_secret_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_secret_key",
                                ));
                            }
                            result.legacy_secret_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetrieveLegacySecretKeyResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.legacy_secret_key.is_empty() {
            state.serialize_entry("legacySecretKey", &self.legacy_secret_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A key used to identify and configure applications (web and/or mobile) that
/// use reCAPTCHA Enterprise.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Key {
    /// Identifier. The resource name for the Key in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Required. Human-readable display name of this key. Modifiable by user.
    pub display_name: std::string::String,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/recaptcha/docs/labels>).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The timestamp corresponding to the creation of this key.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Options for user acceptance testing.
    pub testing_options: std::option::Option<crate::model::TestingOptions>,

    /// Optional. Settings for WAF
    pub waf_settings: std::option::Option<crate::model::WafSettings>,

    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    pub platform_settings: std::option::Option<crate::model::key::PlatformSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Key {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Key::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Key::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Key::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Key::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Key::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [testing_options][crate::model::Key::testing_options].
    pub fn set_testing_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestingOptions>,
    {
        self.testing_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [testing_options][crate::model::Key::testing_options].
    pub fn set_or_clear_testing_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestingOptions>,
    {
        self.testing_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [waf_settings][crate::model::Key::waf_settings].
    pub fn set_waf_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WafSettings>,
    {
        self.waf_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [waf_settings][crate::model::Key::waf_settings].
    pub fn set_or_clear_waf_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WafSettings>,
    {
        self.waf_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings].
    ///
    /// Note that all the setters affecting `platform_settings` are mutually
    /// exclusive.
    pub fn set_platform_settings<
        T: std::convert::Into<std::option::Option<crate::model::key::PlatformSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = v.into();
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `WebSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn web_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WebKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::WebSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `WebSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_web_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::WebKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings =
            std::option::Option::Some(crate::model::key::PlatformSettings::WebSettings(v.into()));
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `AndroidSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn android_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AndroidKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::AndroidSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `AndroidSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_android_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::AndroidKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = std::option::Option::Some(
            crate::model::key::PlatformSettings::AndroidSettings(v.into()),
        );
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `IosSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ios_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IOSKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::IosSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `IosSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_ios_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::IOSKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings =
            std::option::Option::Some(crate::model::key::PlatformSettings::IosSettings(v.into()));
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `ExpressSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn express_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExpressKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::ExpressSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `ExpressSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_express_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::ExpressKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = std::option::Option::Some(
            crate::model::key::PlatformSettings::ExpressSettings(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Key {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Key"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Key {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __web_settings,
            __android_settings,
            __ios_settings,
            __express_settings,
            __labels,
            __create_time,
            __testing_options,
            __waf_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Key")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "webSettings" => Ok(__FieldTag::__web_settings),
                            "web_settings" => Ok(__FieldTag::__web_settings),
                            "androidSettings" => Ok(__FieldTag::__android_settings),
                            "android_settings" => Ok(__FieldTag::__android_settings),
                            "iosSettings" => Ok(__FieldTag::__ios_settings),
                            "ios_settings" => Ok(__FieldTag::__ios_settings),
                            "expressSettings" => Ok(__FieldTag::__express_settings),
                            "express_settings" => Ok(__FieldTag::__express_settings),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "testingOptions" => Ok(__FieldTag::__testing_options),
                            "testing_options" => Ok(__FieldTag::__testing_options),
                            "wafSettings" => Ok(__FieldTag::__waf_settings),
                            "waf_settings" => Ok(__FieldTag::__waf_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Key;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Key")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__web_settings => {
                            if !fields.insert(__FieldTag::__web_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_settings",
                                ));
                            }
                            if result.platform_settings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `platform_settings`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.Key.web_settings, latest field was webSettings",
                                ));
                            }
                            result.platform_settings = std::option::Option::Some(
                                crate::model::key::PlatformSettings::WebSettings(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WebKeySettings>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__android_settings => {
                            if !fields.insert(__FieldTag::__android_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for android_settings",
                                ));
                            }
                            if result.platform_settings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `platform_settings`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.Key.android_settings, latest field was androidSettings",
                                ));
                            }
                            result.platform_settings = std::option::Option::Some(
                                crate::model::key::PlatformSettings::AndroidSettings(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AndroidKeySettings>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ios_settings => {
                            if !fields.insert(__FieldTag::__ios_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ios_settings",
                                ));
                            }
                            if result.platform_settings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `platform_settings`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.Key.ios_settings, latest field was iosSettings",
                                ));
                            }
                            result.platform_settings = std::option::Option::Some(
                                crate::model::key::PlatformSettings::IosSettings(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IOSKeySettings>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__express_settings => {
                            if !fields.insert(__FieldTag::__express_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for express_settings",
                                ));
                            }
                            if result.platform_settings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `platform_settings`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.Key.express_settings, latest field was expressSettings",
                                ));
                            }
                            result.platform_settings = std::option::Option::Some(
                                crate::model::key::PlatformSettings::ExpressSettings(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExpressKeySettings>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__testing_options => {
                            if !fields.insert(__FieldTag::__testing_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for testing_options",
                                ));
                            }
                            result.testing_options = map
                                .next_value::<std::option::Option<crate::model::TestingOptions>>(
                                )?;
                        }
                        __FieldTag::__waf_settings => {
                            if !fields.insert(__FieldTag::__waf_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for waf_settings",
                                ));
                            }
                            result.waf_settings =
                                map.next_value::<std::option::Option<crate::model::WafSettings>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Key {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.web_settings() {
            state.serialize_entry("webSettings", value)?;
        }
        if let Some(value) = self.android_settings() {
            state.serialize_entry("androidSettings", value)?;
        }
        if let Some(value) = self.ios_settings() {
            state.serialize_entry("iosSettings", value)?;
        }
        if let Some(value) = self.express_settings() {
            state.serialize_entry("expressSettings", value)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.testing_options.is_some() {
            state.serialize_entry("testingOptions", &self.testing_options)?;
        }
        if self.waf_settings.is_some() {
            state.serialize_entry("wafSettings", &self.waf_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Key].
pub mod key {
    #[allow(unused_imports)]
    use super::*;

    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PlatformSettings {
        /// Settings for keys that can be used by websites.
        WebSettings(std::boxed::Box<crate::model::WebKeySettings>),
        /// Settings for keys that can be used by Android apps.
        AndroidSettings(std::boxed::Box<crate::model::AndroidKeySettings>),
        /// Settings for keys that can be used by iOS apps.
        IosSettings(std::boxed::Box<crate::model::IOSKeySettings>),
        /// Settings for keys that can be used by reCAPTCHA Express.
        ExpressSettings(std::boxed::Box<crate::model::ExpressKeySettings>),
    }
}

/// Options for user acceptance testing.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestingOptions {
    /// Optional. All assessments for this Key return this score. Must be between 0
    /// (likely not legitimate) and 1 (likely legitimate) inclusive.
    pub testing_score: f32,

    /// Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all
    /// challenge requests for this site return nocaptcha if NOCAPTCHA, or an
    /// unsolvable challenge if CHALLENGE.
    pub testing_challenge: crate::model::testing_options::TestingChallenge,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestingOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [testing_score][crate::model::TestingOptions::testing_score].
    pub fn set_testing_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.testing_score = v.into();
        self
    }

    /// Sets the value of [testing_challenge][crate::model::TestingOptions::testing_challenge].
    pub fn set_testing_challenge<
        T: std::convert::Into<crate::model::testing_options::TestingChallenge>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.testing_challenge = v.into();
        self
    }
}

impl wkt::message::Message for TestingOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TestingOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestingOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __testing_score,
            __testing_challenge,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestingOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testingScore" => Ok(__FieldTag::__testing_score),
                            "testing_score" => Ok(__FieldTag::__testing_score),
                            "testingChallenge" => Ok(__FieldTag::__testing_challenge),
                            "testing_challenge" => Ok(__FieldTag::__testing_challenge),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestingOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestingOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__testing_score => {
                            if !fields.insert(__FieldTag::__testing_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for testing_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.testing_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__testing_challenge => {
                            if !fields.insert(__FieldTag::__testing_challenge) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for testing_challenge",
                                ));
                            }
                            result.testing_challenge = map
                                .next_value::<std::option::Option<
                                    crate::model::testing_options::TestingChallenge,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TestingOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.testing_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("testingScore", &__With(&self.testing_score))?;
        }
        if !wkt::internal::is_default(&self.testing_challenge) {
            state.serialize_entry("testingChallenge", &self.testing_challenge)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TestingOptions].
pub mod testing_options {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the challenge option for challenge-based (CHECKBOX,
    /// INVISIBLE) testing keys.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TestingChallenge {
        /// Perform the normal risk analysis and return either nocaptcha or a
        /// challenge depending on risk and trust factors.
        Unspecified,
        /// Challenge requests for this key always return a nocaptcha, which
        /// does not require a solution.
        Nocaptcha,
        /// Challenge requests for this key always return an unsolvable
        /// challenge.
        UnsolvableChallenge,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TestingChallenge::value] or
        /// [TestingChallenge::name].
        UnknownValue(testing_challenge::UnknownValue),
    }

    #[doc(hidden)]
    pub mod testing_challenge {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TestingChallenge {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nocaptcha => std::option::Option::Some(1),
                Self::UnsolvableChallenge => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TESTING_CHALLENGE_UNSPECIFIED"),
                Self::Nocaptcha => std::option::Option::Some("NOCAPTCHA"),
                Self::UnsolvableChallenge => std::option::Option::Some("UNSOLVABLE_CHALLENGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TestingChallenge {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TestingChallenge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TestingChallenge {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nocaptcha,
                2 => Self::UnsolvableChallenge,
                _ => Self::UnknownValue(testing_challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TestingChallenge {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TESTING_CHALLENGE_UNSPECIFIED" => Self::Unspecified,
                "NOCAPTCHA" => Self::Nocaptcha,
                "UNSOLVABLE_CHALLENGE" => Self::UnsolvableChallenge,
                _ => Self::UnknownValue(testing_challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TestingChallenge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nocaptcha => serializer.serialize_i32(1),
                Self::UnsolvableChallenge => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TestingChallenge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestingChallenge>::new(
                ".google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge",
            ))
        }
    }
}

/// Settings specific to keys that can be used by websites.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WebKeySettings {
    /// Optional. If set to true, it means allowed_domains are not enforced.
    pub allow_all_domains: bool,

    /// Optional. Domains or subdomains of websites allowed to use the key. All
    /// subdomains of an allowed domain are automatically allowed. A valid domain
    /// requires a host and must not include any path, port, query or fragment.
    /// Examples: 'example.com' or 'subdomain.example.com'
    pub allowed_domains: std::vec::Vec<std::string::String>,

    /// Optional. If set to true, the key can be used on AMP (Accelerated Mobile
    /// Pages) websites. This is supported only for the SCORE integration type.
    pub allow_amp_traffic: bool,

    /// Required. Describes how this key is integrated with the website.
    pub integration_type: crate::model::web_key_settings::IntegrationType,

    /// Optional. Settings for the frequency and difficulty at which this key
    /// triggers captcha challenges. This should only be specified for
    /// IntegrationTypes CHECKBOX and INVISIBLE and SCORE_AND_CHALLENGE.
    pub challenge_security_preference: crate::model::web_key_settings::ChallengeSecurityPreference,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_domains][crate::model::WebKeySettings::allow_all_domains].
    pub fn set_allow_all_domains<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_domains = v.into();
        self
    }

    /// Sets the value of [allowed_domains][crate::model::WebKeySettings::allowed_domains].
    pub fn set_allowed_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_amp_traffic][crate::model::WebKeySettings::allow_amp_traffic].
    pub fn set_allow_amp_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_amp_traffic = v.into();
        self
    }

    /// Sets the value of [integration_type][crate::model::WebKeySettings::integration_type].
    pub fn set_integration_type<
        T: std::convert::Into<crate::model::web_key_settings::IntegrationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.integration_type = v.into();
        self
    }

    /// Sets the value of [challenge_security_preference][crate::model::WebKeySettings::challenge_security_preference].
    pub fn set_challenge_security_preference<
        T: std::convert::Into<crate::model::web_key_settings::ChallengeSecurityPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.challenge_security_preference = v.into();
        self
    }
}

impl wkt::message::Message for WebKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.WebKeySettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebKeySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_all_domains,
            __allowed_domains,
            __allow_amp_traffic,
            __integration_type,
            __challenge_security_preference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebKeySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowAllDomains" => Ok(__FieldTag::__allow_all_domains),
                            "allow_all_domains" => Ok(__FieldTag::__allow_all_domains),
                            "allowedDomains" => Ok(__FieldTag::__allowed_domains),
                            "allowed_domains" => Ok(__FieldTag::__allowed_domains),
                            "allowAmpTraffic" => Ok(__FieldTag::__allow_amp_traffic),
                            "allow_amp_traffic" => Ok(__FieldTag::__allow_amp_traffic),
                            "integrationType" => Ok(__FieldTag::__integration_type),
                            "integration_type" => Ok(__FieldTag::__integration_type),
                            "challengeSecurityPreference" => {
                                Ok(__FieldTag::__challenge_security_preference)
                            }
                            "challenge_security_preference" => {
                                Ok(__FieldTag::__challenge_security_preference)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebKeySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebKeySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_all_domains => {
                            if !fields.insert(__FieldTag::__allow_all_domains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_all_domains",
                                ));
                            }
                            result.allow_all_domains = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed_domains => {
                            if !fields.insert(__FieldTag::__allowed_domains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_domains",
                                ));
                            }
                            result.allowed_domains = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__allow_amp_traffic => {
                            if !fields.insert(__FieldTag::__allow_amp_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_amp_traffic",
                                ));
                            }
                            result.allow_amp_traffic = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integration_type => {
                            if !fields.insert(__FieldTag::__integration_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integration_type",
                                ));
                            }
                            result.integration_type = map
                                .next_value::<std::option::Option<
                                    crate::model::web_key_settings::IntegrationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__challenge_security_preference => {
                            if !fields.insert(__FieldTag::__challenge_security_preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for challenge_security_preference",
                                ));
                            }
                            result.challenge_security_preference = map
                                .next_value::<std::option::Option<
                                    crate::model::web_key_settings::ChallengeSecurityPreference,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WebKeySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.allow_all_domains) {
            state.serialize_entry("allowAllDomains", &self.allow_all_domains)?;
        }
        if !self.allowed_domains.is_empty() {
            state.serialize_entry("allowedDomains", &self.allowed_domains)?;
        }
        if !wkt::internal::is_default(&self.allow_amp_traffic) {
            state.serialize_entry("allowAmpTraffic", &self.allow_amp_traffic)?;
        }
        if !wkt::internal::is_default(&self.integration_type) {
            state.serialize_entry("integrationType", &self.integration_type)?;
        }
        if !wkt::internal::is_default(&self.challenge_security_preference) {
            state.serialize_entry(
                "challengeSecurityPreference",
                &self.challenge_security_preference,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WebKeySettings].
pub mod web_key_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the integration types for web keys.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IntegrationType {
        /// Default type that indicates this enum hasn't been specified. This is not
        /// a valid IntegrationType, one of the other types must be specified
        /// instead.
        Unspecified,
        /// Only used to produce scores. It doesn't display the "I'm not a robot"
        /// checkbox and never shows captcha challenges.
        Score,
        /// Displays the "I'm not a robot" checkbox and may show captcha challenges
        /// after it is checked.
        Checkbox,
        /// Doesn't display the "I'm not a robot" checkbox, but may show captcha
        /// challenges after risk analysis.
        Invisible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IntegrationType::value] or
        /// [IntegrationType::name].
        UnknownValue(integration_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod integration_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IntegrationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Score => std::option::Option::Some(1),
                Self::Checkbox => std::option::Option::Some(2),
                Self::Invisible => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INTEGRATION_TYPE_UNSPECIFIED"),
                Self::Score => std::option::Option::Some("SCORE"),
                Self::Checkbox => std::option::Option::Some("CHECKBOX"),
                Self::Invisible => std::option::Option::Some("INVISIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IntegrationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IntegrationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IntegrationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Score,
                2 => Self::Checkbox,
                3 => Self::Invisible,
                _ => Self::UnknownValue(integration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IntegrationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTEGRATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCORE" => Self::Score,
                "CHECKBOX" => Self::Checkbox,
                "INVISIBLE" => Self::Invisible,
                _ => Self::UnknownValue(integration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IntegrationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Score => serializer.serialize_i32(1),
                Self::Checkbox => serializer.serialize_i32(2),
                Self::Invisible => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IntegrationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntegrationType>::new(
                ".google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType",
            ))
        }
    }

    /// Enum that represents the possible challenge frequency and difficulty
    /// configurations for a web key.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ChallengeSecurityPreference {
        /// Default type that indicates this enum hasn't been specified.
        Unspecified,
        /// Key tends to show fewer and easier challenges.
        Usability,
        /// Key tends to show balanced (in amount and difficulty) challenges.
        Balance,
        /// Key tends to show more and harder challenges.
        Security,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ChallengeSecurityPreference::value] or
        /// [ChallengeSecurityPreference::name].
        UnknownValue(challenge_security_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod challenge_security_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ChallengeSecurityPreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Usability => std::option::Option::Some(1),
                Self::Balance => std::option::Option::Some(2),
                Self::Security => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED")
                }
                Self::Usability => std::option::Option::Some("USABILITY"),
                Self::Balance => std::option::Option::Some("BALANCE"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ChallengeSecurityPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ChallengeSecurityPreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ChallengeSecurityPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Usability,
                2 => Self::Balance,
                3 => Self::Security,
                _ => Self::UnknownValue(challenge_security_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ChallengeSecurityPreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "USABILITY" => Self::Usability,
                "BALANCE" => Self::Balance,
                "SECURITY" => Self::Security,
                _ => Self::UnknownValue(challenge_security_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ChallengeSecurityPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Usability => serializer.serialize_i32(1),
                Self::Balance => serializer.serialize_i32(2),
                Self::Security => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ChallengeSecurityPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChallengeSecurityPreference>::new(
                ".google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference"))
        }
    }
}

/// Settings specific to keys that can be used by Android apps.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AndroidKeySettings {
    /// Optional. If set to true, allowed_package_names are not enforced.
    pub allow_all_package_names: bool,

    /// Optional. Android package names of apps allowed to use the key.
    /// Example: 'com.companyname.appname'
    pub allowed_package_names: std::vec::Vec<std::string::String>,

    /// Optional. Set to true for keys that are used in an Android application that
    /// is available for download in app stores in addition to the Google Play
    /// Store.
    pub support_non_google_app_store_distribution: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AndroidKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_package_names][crate::model::AndroidKeySettings::allow_all_package_names].
    pub fn set_allow_all_package_names<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_package_names = v.into();
        self
    }

    /// Sets the value of [allowed_package_names][crate::model::AndroidKeySettings::allowed_package_names].
    pub fn set_allowed_package_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_package_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [support_non_google_app_store_distribution][crate::model::AndroidKeySettings::support_non_google_app_store_distribution].
    pub fn set_support_non_google_app_store_distribution<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.support_non_google_app_store_distribution = v.into();
        self
    }
}

impl wkt::message::Message for AndroidKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AndroidKeySettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AndroidKeySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_all_package_names,
            __allowed_package_names,
            __support_non_google_app_store_distribution,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AndroidKeySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowAllPackageNames" => Ok(__FieldTag::__allow_all_package_names),
                            "allow_all_package_names" => Ok(__FieldTag::__allow_all_package_names),
                            "allowedPackageNames" => Ok(__FieldTag::__allowed_package_names),
                            "allowed_package_names" => Ok(__FieldTag::__allowed_package_names),
                            "supportNonGoogleAppStoreDistribution" => {
                                Ok(__FieldTag::__support_non_google_app_store_distribution)
                            }
                            "support_non_google_app_store_distribution" => {
                                Ok(__FieldTag::__support_non_google_app_store_distribution)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AndroidKeySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AndroidKeySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_all_package_names => {
                            if !fields.insert(__FieldTag::__allow_all_package_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_all_package_names",
                                ));
                            }
                            result.allow_all_package_names = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed_package_names => {
                            if !fields.insert(__FieldTag::__allowed_package_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_package_names",
                                ));
                            }
                            result.allowed_package_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__support_non_google_app_store_distribution => {
                            if !fields
                                .insert(__FieldTag::__support_non_google_app_store_distribution)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_non_google_app_store_distribution",
                                ));
                            }
                            result.support_non_google_app_store_distribution = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AndroidKeySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.allow_all_package_names) {
            state.serialize_entry("allowAllPackageNames", &self.allow_all_package_names)?;
        }
        if !self.allowed_package_names.is_empty() {
            state.serialize_entry("allowedPackageNames", &self.allowed_package_names)?;
        }
        if !wkt::internal::is_default(&self.support_non_google_app_store_distribution) {
            state.serialize_entry(
                "supportNonGoogleAppStoreDistribution",
                &self.support_non_google_app_store_distribution,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings specific to keys that can be used by iOS apps.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IOSKeySettings {
    /// Optional. If set to true, allowed_bundle_ids are not enforced.
    pub allow_all_bundle_ids: bool,

    /// Optional. iOS bundle ids of apps allowed to use the key.
    /// Example: 'com.companyname.productname.appname'
    pub allowed_bundle_ids: std::vec::Vec<std::string::String>,

    /// Optional. Apple Developer account details for the app that is protected by
    /// the reCAPTCHA Key. reCAPTCHA leverages platform-specific checks like Apple
    /// App Attest and Apple DeviceCheck to protect your app from abuse. Providing
    /// these fields allows reCAPTCHA to get a better assessment of the integrity
    /// of your app.
    pub apple_developer_id: std::option::Option<crate::model::AppleDeveloperId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IOSKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_bundle_ids][crate::model::IOSKeySettings::allow_all_bundle_ids].
    pub fn set_allow_all_bundle_ids<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_bundle_ids = v.into();
        self
    }

    /// Sets the value of [allowed_bundle_ids][crate::model::IOSKeySettings::allowed_bundle_ids].
    pub fn set_allowed_bundle_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_bundle_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [apple_developer_id][crate::model::IOSKeySettings::apple_developer_id].
    pub fn set_apple_developer_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppleDeveloperId>,
    {
        self.apple_developer_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [apple_developer_id][crate::model::IOSKeySettings::apple_developer_id].
    pub fn set_or_clear_apple_developer_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppleDeveloperId>,
    {
        self.apple_developer_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IOSKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.IOSKeySettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IOSKeySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_all_bundle_ids,
            __allowed_bundle_ids,
            __apple_developer_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IOSKeySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowAllBundleIds" => Ok(__FieldTag::__allow_all_bundle_ids),
                            "allow_all_bundle_ids" => Ok(__FieldTag::__allow_all_bundle_ids),
                            "allowedBundleIds" => Ok(__FieldTag::__allowed_bundle_ids),
                            "allowed_bundle_ids" => Ok(__FieldTag::__allowed_bundle_ids),
                            "appleDeveloperId" => Ok(__FieldTag::__apple_developer_id),
                            "apple_developer_id" => Ok(__FieldTag::__apple_developer_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IOSKeySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IOSKeySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_all_bundle_ids => {
                            if !fields.insert(__FieldTag::__allow_all_bundle_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_all_bundle_ids",
                                ));
                            }
                            result.allow_all_bundle_ids = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed_bundle_ids => {
                            if !fields.insert(__FieldTag::__allowed_bundle_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_bundle_ids",
                                ));
                            }
                            result.allowed_bundle_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__apple_developer_id => {
                            if !fields.insert(__FieldTag::__apple_developer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apple_developer_id",
                                ));
                            }
                            result.apple_developer_id = map
                                .next_value::<std::option::Option<crate::model::AppleDeveloperId>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IOSKeySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.allow_all_bundle_ids) {
            state.serialize_entry("allowAllBundleIds", &self.allow_all_bundle_ids)?;
        }
        if !self.allowed_bundle_ids.is_empty() {
            state.serialize_entry("allowedBundleIds", &self.allowed_bundle_ids)?;
        }
        if self.apple_developer_id.is_some() {
            state.serialize_entry("appleDeveloperId", &self.apple_developer_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings specific to keys that can be used for reCAPTCHA Express.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExpressKeySettings {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpressKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExpressKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ExpressKeySettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExpressKeySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExpressKeySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExpressKeySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExpressKeySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExpressKeySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains fields that are required to perform Apple-specific integrity checks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppleDeveloperId {
    /// Required. Input only. A private key (downloaded as a text file with a .p8
    /// file extension) generated for your Apple Developer account. Ensure that
    /// Apple DeviceCheck is enabled for the private key.
    pub private_key: std::string::String,

    /// Required. The Apple developer key ID (10-character string).
    pub key_id: std::string::String,

    /// Required. The Apple team ID (10-character string) owning the provisioning
    /// profile used to build your application.
    pub team_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppleDeveloperId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::AppleDeveloperId::private_key].
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_id][crate::model::AppleDeveloperId::key_id].
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }

    /// Sets the value of [team_id][crate::model::AppleDeveloperId::team_id].
    pub fn set_team_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.team_id = v.into();
        self
    }
}

impl wkt::message::Message for AppleDeveloperId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AppleDeveloperId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppleDeveloperId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_key,
            __key_id,
            __team_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppleDeveloperId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateKey" => Ok(__FieldTag::__private_key),
                            "private_key" => Ok(__FieldTag::__private_key),
                            "keyId" => Ok(__FieldTag::__key_id),
                            "key_id" => Ok(__FieldTag::__key_id),
                            "teamId" => Ok(__FieldTag::__team_id),
                            "team_id" => Ok(__FieldTag::__team_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppleDeveloperId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppleDeveloperId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_key => {
                            if !fields.insert(__FieldTag::__private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key",
                                ));
                            }
                            result.private_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_id => {
                            if !fields.insert(__FieldTag::__key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_id",
                                ));
                            }
                            result.key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__team_id => {
                            if !fields.insert(__FieldTag::__team_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for team_id",
                                ));
                            }
                            result.team_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppleDeveloperId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_key.is_empty() {
            state.serialize_entry("privateKey", &self.private_key)?;
        }
        if !self.key_id.is_empty() {
            state.serialize_entry("keyId", &self.key_id)?;
        }
        if !self.team_id.is_empty() {
            state.serialize_entry("teamId", &self.team_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Score distribution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScoreDistribution {
    /// Map key is score value multiplied by 100. The scores are discrete values
    /// between [0, 1]. The maximum number of buckets is on order of a few dozen,
    /// but typically much lower (ie. 10).
    pub score_buckets: std::collections::HashMap<i32, i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScoreDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score_buckets][crate::model::ScoreDistribution::score_buckets].
    pub fn set_score_buckets<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.score_buckets = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ScoreDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ScoreDistribution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScoreDistribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score_buckets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScoreDistribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scoreBuckets" => Ok(__FieldTag::__score_buckets),
                            "score_buckets" => Ok(__FieldTag::__score_buckets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScoreDistribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScoreDistribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score_buckets => {
                            if !fields.insert(__FieldTag::__score_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score_buckets",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.score_buckets =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScoreDistribution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.score_buckets.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scoreBuckets", &__With(&self.score_buckets))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metrics related to scoring.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ScoreMetrics {
    /// Aggregated score metrics for all traffic.
    pub overall_metrics: std::option::Option<crate::model::ScoreDistribution>,

    /// Action-based metrics. The map key is the action name which specified by the
    /// site owners at time of the "execute" client-side call.
    pub action_metrics:
        std::collections::HashMap<std::string::String, crate::model::ScoreDistribution>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScoreMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overall_metrics][crate::model::ScoreMetrics::overall_metrics].
    pub fn set_overall_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScoreDistribution>,
    {
        self.overall_metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overall_metrics][crate::model::ScoreMetrics::overall_metrics].
    pub fn set_or_clear_overall_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScoreDistribution>,
    {
        self.overall_metrics = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_metrics][crate::model::ScoreMetrics::action_metrics].
    pub fn set_action_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ScoreDistribution>,
    {
        use std::iter::Iterator;
        self.action_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ScoreMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ScoreMetrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ScoreMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __overall_metrics,
            __action_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScoreMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "overallMetrics" => Ok(__FieldTag::__overall_metrics),
                            "overall_metrics" => Ok(__FieldTag::__overall_metrics),
                            "actionMetrics" => Ok(__FieldTag::__action_metrics),
                            "action_metrics" => Ok(__FieldTag::__action_metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ScoreMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScoreMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__overall_metrics => {
                            if !fields.insert(__FieldTag::__overall_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overall_metrics",
                                ));
                            }
                            result.overall_metrics = map
                                .next_value::<std::option::Option<crate::model::ScoreDistribution>>(
                                )?;
                        }
                        __FieldTag::__action_metrics => {
                            if !fields.insert(__FieldTag::__action_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_metrics",
                                ));
                            }
                            result.action_metrics = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ScoreDistribution,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ScoreMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.overall_metrics.is_some() {
            state.serialize_entry("overallMetrics", &self.overall_metrics)?;
        }
        if !self.action_metrics.is_empty() {
            state.serialize_entry("actionMetrics", &self.action_metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metrics related to challenges.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ChallengeMetrics {
    /// Count of reCAPTCHA checkboxes or badges rendered. This is mostly equivalent
    /// to a count of pageloads for pages that include reCAPTCHA.
    pub pageload_count: i64,

    /// Count of nocaptchas (successful verification without a challenge) issued.
    pub nocaptcha_count: i64,

    /// Count of submitted challenge solutions that were incorrect or otherwise
    /// deemed suspicious such that a subsequent challenge was triggered.
    pub failed_count: i64,

    /// Count of nocaptchas (successful verification without a challenge) plus
    /// submitted challenge solutions that were correct and resulted in
    /// verification.
    pub passed_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChallengeMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pageload_count][crate::model::ChallengeMetrics::pageload_count].
    pub fn set_pageload_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pageload_count = v.into();
        self
    }

    /// Sets the value of [nocaptcha_count][crate::model::ChallengeMetrics::nocaptcha_count].
    pub fn set_nocaptcha_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.nocaptcha_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::ChallengeMetrics::failed_count].
    pub fn set_failed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [passed_count][crate::model::ChallengeMetrics::passed_count].
    pub fn set_passed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_count = v.into();
        self
    }
}

impl wkt::message::Message for ChallengeMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ChallengeMetrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChallengeMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pageload_count,
            __nocaptcha_count,
            __failed_count,
            __passed_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChallengeMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageloadCount" => Ok(__FieldTag::__pageload_count),
                            "pageload_count" => Ok(__FieldTag::__pageload_count),
                            "nocaptchaCount" => Ok(__FieldTag::__nocaptcha_count),
                            "nocaptcha_count" => Ok(__FieldTag::__nocaptcha_count),
                            "failedCount" => Ok(__FieldTag::__failed_count),
                            "failed_count" => Ok(__FieldTag::__failed_count),
                            "passedCount" => Ok(__FieldTag::__passed_count),
                            "passed_count" => Ok(__FieldTag::__passed_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChallengeMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChallengeMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pageload_count => {
                            if !fields.insert(__FieldTag::__pageload_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pageload_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pageload_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nocaptcha_count => {
                            if !fields.insert(__FieldTag::__nocaptcha_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nocaptcha_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nocaptcha_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_count => {
                            if !fields.insert(__FieldTag::__failed_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__passed_count => {
                            if !fields.insert(__FieldTag::__passed_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passed_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.passed_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChallengeMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.pageload_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageloadCount", &__With(&self.pageload_count))?;
        }
        if !wkt::internal::is_default(&self.nocaptcha_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nocaptchaCount", &__With(&self.nocaptcha_count))?;
        }
        if !wkt::internal::is_default(&self.failed_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedCount", &__With(&self.failed_count))?;
        }
        if !wkt::internal::is_default(&self.passed_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("passedCount", &__With(&self.passed_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Policy config assessment.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyAssessment {
    /// Output only. If the processing of a policy config fails, an error is
    /// populated and the firewall_policy is left empty.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The policy that matched the request. If more than one policy
    /// may match, this is the first match. If no policy matches the incoming
    /// request, the policy field is left empty.
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallPolicyAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::FirewallPolicyAssessment::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::FirewallPolicyAssessment::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [firewall_policy][crate::model::FirewallPolicyAssessment::firewall_policy].
    pub fn set_firewall_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy][crate::model::FirewallPolicyAssessment::firewall_policy].
    pub fn set_or_clear_firewall_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FirewallPolicyAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FirewallPolicyAssessment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            __firewall_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallPolicyAssessment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            "firewallPolicy" => Ok(__FieldTag::__firewall_policy),
                            "firewall_policy" => Ok(__FieldTag::__firewall_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FirewallPolicyAssessment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallPolicyAssessment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__firewall_policy => {
                            if !fields.insert(__FieldTag::__firewall_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firewall_policy",
                                ));
                            }
                            result.firewall_policy = map
                                .next_value::<std::option::Option<crate::model::FirewallPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FirewallPolicyAssessment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.firewall_policy.is_some() {
            state.serialize_entry("firewallPolicy", &self.firewall_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An individual action. Each action represents what to do if a policy
/// matches.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallAction {
    pub firewall_action_oneof:
        std::option::Option<crate::model::firewall_action::FirewallActionOneof>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof].
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are mutually
    /// exclusive.
    pub fn set_firewall_action_oneof<
        T: std::convert::Into<std::option::Option<crate::model::firewall_action::FirewallActionOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = v.into();
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Allow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn allow(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::AllowAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Allow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Allow`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_allow<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::AllowAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Allow(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Block`, `None` if the field is not set or
    /// holds a different branch.
    pub fn block(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::BlockAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Block(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Block`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_block<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::BlockAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Block(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `IncludeRecaptchaScript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_recaptcha_script(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
    > {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `IncludeRecaptchaScript`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_include_recaptcha_script<
        T: std::convert::Into<
                std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Redirect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::RedirectAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Redirect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Redirect`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_redirect<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::RedirectAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Redirect(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Substitute`, `None` if the field is not set or
    /// holds a different branch.
    pub fn substitute(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::SubstituteAction>>
    {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Substitute(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Substitute`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_substitute<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::SubstituteAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Substitute(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `SetHeader`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_header(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::SetHeaderAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::SetHeader(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `SetHeader`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_set_header<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::SetHeaderAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::SetHeader(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FirewallAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FirewallAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow,
            __block,
            __include_recaptcha_script,
            __redirect,
            __substitute,
            __set_header,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allow" => Ok(__FieldTag::__allow),
                            "block" => Ok(__FieldTag::__block),
                            "includeRecaptchaScript" => Ok(__FieldTag::__include_recaptcha_script),
                            "include_recaptcha_script" => {
                                Ok(__FieldTag::__include_recaptcha_script)
                            }
                            "redirect" => Ok(__FieldTag::__redirect),
                            "substitute" => Ok(__FieldTag::__substitute),
                            "setHeader" => Ok(__FieldTag::__set_header),
                            "set_header" => Ok(__FieldTag::__set_header),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FirewallAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow => {
                            if !fields.insert(__FieldTag::__allow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow",
                                ));
                            }
                            if result.firewall_action_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `firewall_action_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.FirewallAction.allow, latest field was allow",
                                ));
                            }
                            result.firewall_action_oneof = std::option::Option::Some(
                                crate::model::firewall_action::FirewallActionOneof::Allow(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::firewall_action::AllowAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__block => {
                            if !fields.insert(__FieldTag::__block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for block",
                                ));
                            }
                            if result.firewall_action_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `firewall_action_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.FirewallAction.block, latest field was block",
                                ));
                            }
                            result.firewall_action_oneof = std::option::Option::Some(
                                crate::model::firewall_action::FirewallActionOneof::Block(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::firewall_action::BlockAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__include_recaptcha_script => {
                            if !fields.insert(__FieldTag::__include_recaptcha_script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_recaptcha_script",
                                ));
                            }
                            if result.firewall_action_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `firewall_action_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.FirewallAction.include_recaptcha_script, latest field was includeRecaptchaScript",
                                ));
                            }
                            result.firewall_action_oneof = std::option::Option::Some(
                                crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__redirect => {
                            if !fields.insert(__FieldTag::__redirect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect",
                                ));
                            }
                            if result.firewall_action_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `firewall_action_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.FirewallAction.redirect, latest field was redirect",
                                ));
                            }
                            result.firewall_action_oneof = std::option::Option::Some(
                                crate::model::firewall_action::FirewallActionOneof::Redirect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::firewall_action::RedirectAction,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__substitute => {
                            if !fields.insert(__FieldTag::__substitute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitute",
                                ));
                            }
                            if result.firewall_action_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `firewall_action_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.FirewallAction.substitute, latest field was substitute",
                                ));
                            }
                            result.firewall_action_oneof = std::option::Option::Some(
                                crate::model::firewall_action::FirewallActionOneof::Substitute(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::firewall_action::SubstituteAction,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__set_header => {
                            if !fields.insert(__FieldTag::__set_header) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_header",
                                ));
                            }
                            if result.firewall_action_oneof.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `firewall_action_oneof`, a oneof with full ID .google.cloud.recaptchaenterprise.v1.FirewallAction.set_header, latest field was setHeader",
                                ));
                            }
                            result.firewall_action_oneof = std::option::Option::Some(
                                crate::model::firewall_action::FirewallActionOneof::SetHeader(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::firewall_action::SetHeaderAction,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FirewallAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.allow() {
            state.serialize_entry("allow", value)?;
        }
        if let Some(value) = self.block() {
            state.serialize_entry("block", value)?;
        }
        if let Some(value) = self.include_recaptcha_script() {
            state.serialize_entry("includeRecaptchaScript", value)?;
        }
        if let Some(value) = self.redirect() {
            state.serialize_entry("redirect", value)?;
        }
        if let Some(value) = self.substitute() {
            state.serialize_entry("substitute", value)?;
        }
        if let Some(value) = self.set_header() {
            state.serialize_entry("setHeader", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FirewallAction].
pub mod firewall_action {
    #[allow(unused_imports)]
    use super::*;

    /// An allow action continues processing a request unimpeded.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowAction {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AllowAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AllowAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AllowAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AllowAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AllowAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AllowAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A block action serves an HTTP error code a prevents the request from
    /// hitting the backend.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BlockAction {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BlockAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BlockAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BlockAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BlockAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BlockAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BlockAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BlockAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// An include reCAPTCHA script action involves injecting reCAPTCHA JavaScript
    /// code into the HTML returned by the site backend. This reCAPTCHA
    /// script is tasked with collecting user signals on the requested web page,
    /// issuing tokens as a cookie within the site domain, and enabling their
    /// utilization in subsequent page requests.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IncludeRecaptchaScriptAction {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncludeRecaptchaScriptAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for IncludeRecaptchaScriptAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IncludeRecaptchaScriptAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IncludeRecaptchaScriptAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IncludeRecaptchaScriptAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IncludeRecaptchaScriptAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IncludeRecaptchaScriptAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A redirect action returns a 307 (temporary redirect) response, pointing
    /// the user to a reCAPTCHA interstitial page to attach a token.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RedirectAction {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for RedirectAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RedirectAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RedirectAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RedirectAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RedirectAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RedirectAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A substitute action transparently serves a different page than the one
    /// requested.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubstituteAction {
        /// Optional. The address to redirect to. The target is a relative path in
        /// the current host. Example: "/blog/404.html".
        pub path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubstituteAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::firewall_action::SubstituteAction::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }
    }

    impl wkt::message::Message for SubstituteAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SubstituteAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SubstituteAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "path" => Ok(__FieldTag::__path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SubstituteAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SubstituteAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SubstituteAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A set header action sets a header and forwards the request to the
    /// backend. This can be used to trigger custom protection implemented on the
    /// backend.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetHeaderAction {
        /// Optional. The header key to set in the request to the backend server.
        pub key: std::string::String,

        /// Optional. The header value to set in the request to the backend server.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SetHeaderAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::firewall_action::SetHeaderAction::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::firewall_action::SetHeaderAction::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for SetHeaderAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SetHeaderAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SetHeaderAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SetHeaderAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SetHeaderAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SetHeaderAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FirewallActionOneof {
        /// The user request did not match any policy and should be allowed
        /// access to the requested resource.
        Allow(std::boxed::Box<crate::model::firewall_action::AllowAction>),
        /// This action denies access to a given page. The user gets an HTTP
        /// error code.
        Block(std::boxed::Box<crate::model::firewall_action::BlockAction>),
        /// This action injects reCAPTCHA JavaScript code into the HTML page
        /// returned by the site backend.
        IncludeRecaptchaScript(
            std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
        ),
        /// This action redirects the request to a reCAPTCHA interstitial to
        /// attach a token.
        Redirect(std::boxed::Box<crate::model::firewall_action::RedirectAction>),
        /// This action transparently serves a different page to an offending
        /// user.
        Substitute(std::boxed::Box<crate::model::firewall_action::SubstituteAction>),
        /// This action sets a custom header but allow the request to continue
        /// to the customer backend.
        SetHeader(std::boxed::Box<crate::model::firewall_action::SetHeaderAction>),
    }
}

/// A FirewallPolicy represents a single matching pattern and resulting actions
/// to take.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicy {
    /// Identifier. The resource name for the FirewallPolicy in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub name: std::string::String,

    /// Optional. A description of what this policy aims to achieve, for
    /// convenience purposes. The description can at most include 256 UTF-8
    /// characters.
    pub description: std::string::String,

    /// Optional. The path for which this policy applies, specified as a glob
    /// pattern. For more information on glob, see the [manual
    /// page](https://man7.org/linux/man-pages/man7/glob.7.html).
    /// A path has a max length of 200 characters.
    pub path: std::string::String,

    /// Optional. A CEL (Common Expression Language) conditional expression that
    /// specifies if this policy applies to an incoming user request. If this
    /// condition evaluates to true and the requested path matched the path
    /// pattern, the associated actions should be executed by the caller. The
    /// condition string is checked for CEL syntax correctness on creation. For
    /// more information, see the [CEL spec](https://github.com/google/cel-spec)
    /// and its [language
    /// definition](https://github.com/google/cel-spec/blob/master/doc/langdef.md).
    /// A condition has a max length of 500 characters.
    pub condition: std::string::String,

    /// Optional. The actions that the caller should take regarding user access.
    /// There should be at most one terminal action. A terminal action is any
    /// action that forces a response, such as `AllowAction`,
    /// `BlockAction` or `SubstituteAction`.
    /// Zero or more non-terminal actions such as `SetHeader` might be
    /// specified. A single policy can contain up to 16 actions.
    pub actions: std::vec::Vec<crate::model::FirewallAction>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FirewallPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FirewallPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [path][crate::model::FirewallPolicy::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::FirewallPolicy::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::FirewallPolicy::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FirewallPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FirewallPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __path,
            __condition,
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FirewallPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "path" => Ok(__FieldTag::__path),
                            "condition" => Ok(__FieldTag::__condition),
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FirewallPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FirewallPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FirewallAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FirewallPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message to list memberships in a related account group.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupMembershipsRequest {
    /// Required. The resource name for the related account group in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of accounts to return. The service might
    /// return fewer than this value. If unspecified, at most 50 accounts are
    /// returned. The maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListRelatedAccountGroupMemberships` call.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroupMemberships` must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupMembershipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRelatedAccountGroupMembershipsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRelatedAccountGroupMembershipsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRelatedAccountGroupMembershipsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupMembershipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRelatedAccountGroupMembershipsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListRelatedAccountGroupMembershipsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRelatedAccountGroupMembershipsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRelatedAccountGroupMembershipsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRelatedAccountGroupMembershipsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response to a `ListRelatedAccountGroupMemberships` call.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupMembershipsResponse {
    /// The memberships listed by the query.
    pub related_account_group_memberships:
        std::vec::Vec<crate::model::RelatedAccountGroupMembership>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupMembershipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_account_group_memberships][crate::model::ListRelatedAccountGroupMembershipsResponse::related_account_group_memberships].
    pub fn set_related_account_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroupMembership>,
    {
        use std::iter::Iterator;
        self.related_account_group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRelatedAccountGroupMembershipsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupMembershipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRelatedAccountGroupMembershipsResponse {
    type PageItem = crate::model::RelatedAccountGroupMembership;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_group_memberships
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRelatedAccountGroupMembershipsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __related_account_group_memberships,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ListRelatedAccountGroupMembershipsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relatedAccountGroupMemberships" => {
                                Ok(__FieldTag::__related_account_group_memberships)
                            }
                            "related_account_group_memberships" => {
                                Ok(__FieldTag::__related_account_group_memberships)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRelatedAccountGroupMembershipsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRelatedAccountGroupMembershipsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__related_account_group_memberships => {
                            if !fields.insert(__FieldTag::__related_account_group_memberships) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_account_group_memberships",
                                ));
                            }
                            result.related_account_group_memberships = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelatedAccountGroupMembership>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRelatedAccountGroupMembershipsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.related_account_group_memberships.is_empty() {
            state.serialize_entry(
                "relatedAccountGroupMemberships",
                &self.related_account_group_memberships,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message to list related account groups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupsRequest {
    /// Required. The name of the project to list related account groups from, in
    /// the format `projects/{project}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListRelatedAccountGroups`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroups` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRelatedAccountGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRelatedAccountGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRelatedAccountGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRelatedAccountGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRelatedAccountGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRelatedAccountGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRelatedAccountGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRelatedAccountGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response to a `ListRelatedAccountGroups` call.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupsResponse {
    /// The groups of related accounts listed by the query.
    pub related_account_groups: std::vec::Vec<crate::model::RelatedAccountGroup>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_account_groups][crate::model::ListRelatedAccountGroupsResponse::related_account_groups].
    pub fn set_related_account_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroup>,
    {
        use std::iter::Iterator;
        self.related_account_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRelatedAccountGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRelatedAccountGroupsResponse {
    type PageItem = crate::model::RelatedAccountGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRelatedAccountGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __related_account_groups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRelatedAccountGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relatedAccountGroups" => Ok(__FieldTag::__related_account_groups),
                            "related_account_groups" => Ok(__FieldTag::__related_account_groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRelatedAccountGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRelatedAccountGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__related_account_groups => {
                            if !fields.insert(__FieldTag::__related_account_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_account_groups",
                                ));
                            }
                            result.related_account_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelatedAccountGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRelatedAccountGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.related_account_groups.is_empty() {
            state.serialize_entry("relatedAccountGroups", &self.related_account_groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message to search related account group memberships.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchRelatedAccountGroupMembershipsRequest {
    /// Required. The name of the project to search related account group
    /// memberships from. Specify the project name in the following format:
    /// `projects/{project}`.
    pub project: std::string::String,

    /// Optional. The unique stable account identifier used to search connections.
    /// The identifier should correspond to an `account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call. Either hashed_account_id
    /// or account_id must be set, but not both.
    pub account_id: std::string::String,

    /// Optional. Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier used to search connections. The
    /// identifier should correspond to a `hashed_account_id` provided in a
    /// previous `CreateAssessment` or `AnnotateAssessment` call. Either
    /// hashed_account_id or account_id must be set, but not both.
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `SearchRelatedAccountGroupMemberships` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `SearchRelatedAccountGroupMemberships` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRelatedAccountGroupMembershipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SearchRelatedAccountGroupMembershipsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::SearchRelatedAccountGroupMembershipsRequest::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::SearchRelatedAccountGroupMembershipsRequest::hashed_account_id].
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchRelatedAccountGroupMembershipsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchRelatedAccountGroupMembershipsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchRelatedAccountGroupMembershipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchRelatedAccountGroupMembershipsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __account_id,
            __hashed_account_id,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SearchRelatedAccountGroupMembershipsRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "accountId" => Ok(__FieldTag::__account_id),
                            "account_id" => Ok(__FieldTag::__account_id),
                            "hashedAccountId" => Ok(__FieldTag::__hashed_account_id),
                            "hashed_account_id" => Ok(__FieldTag::__hashed_account_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchRelatedAccountGroupMembershipsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchRelatedAccountGroupMembershipsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_id => {
                            if !fields.insert(__FieldTag::__account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_id",
                                ));
                            }
                            result.account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hashed_account_id => {
                            if !fields.insert(__FieldTag::__hashed_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hashed_account_id",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hashed_account_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchRelatedAccountGroupMembershipsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.account_id.is_empty() {
            state.serialize_entry("accountId", &self.account_id)?;
        }
        if !self.hashed_account_id.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hashedAccountId", &__With(&self.hashed_account_id))?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response to a `SearchRelatedAccountGroupMemberships` call.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchRelatedAccountGroupMembershipsResponse {
    /// The queried memberships.
    pub related_account_group_memberships:
        std::vec::Vec<crate::model::RelatedAccountGroupMembership>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRelatedAccountGroupMembershipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_account_group_memberships][crate::model::SearchRelatedAccountGroupMembershipsResponse::related_account_group_memberships].
    pub fn set_related_account_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroupMembership>,
    {
        use std::iter::Iterator;
        self.related_account_group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchRelatedAccountGroupMembershipsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchRelatedAccountGroupMembershipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchRelatedAccountGroupMembershipsResponse {
    type PageItem = crate::model::RelatedAccountGroupMembership;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_group_memberships
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchRelatedAccountGroupMembershipsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __related_account_group_memberships,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SearchRelatedAccountGroupMembershipsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relatedAccountGroupMemberships" => {
                                Ok(__FieldTag::__related_account_group_memberships)
                            }
                            "related_account_group_memberships" => {
                                Ok(__FieldTag::__related_account_group_memberships)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchRelatedAccountGroupMembershipsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchRelatedAccountGroupMembershipsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__related_account_group_memberships => {
                            if !fields.insert(__FieldTag::__related_account_group_memberships) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_account_group_memberships",
                                ));
                            }
                            result.related_account_group_memberships = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelatedAccountGroupMembership>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchRelatedAccountGroupMembershipsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.related_account_group_memberships.is_empty() {
            state.serialize_entry(
                "relatedAccountGroupMemberships",
                &self.related_account_group_memberships,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The AddIpOverride request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AddIpOverrideRequest {
    /// Required. The name of the key to which the IP override is added, in the
    /// format `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Required. IP override added to the key.
    pub ip_override_data: std::option::Option<crate::model::IpOverrideData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddIpOverrideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AddIpOverrideRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_override_data][crate::model::AddIpOverrideRequest::ip_override_data].
    pub fn set_ip_override_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_override_data][crate::model::AddIpOverrideRequest::ip_override_data].
    pub fn set_or_clear_ip_override_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AddIpOverrideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AddIpOverrideRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddIpOverrideRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ip_override_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddIpOverrideRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ipOverrideData" => Ok(__FieldTag::__ip_override_data),
                            "ip_override_data" => Ok(__FieldTag::__ip_override_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddIpOverrideRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddIpOverrideRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_override_data => {
                            if !fields.insert(__FieldTag::__ip_override_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_override_data",
                                ));
                            }
                            result.ip_override_data = map
                                .next_value::<std::option::Option<crate::model::IpOverrideData>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddIpOverrideRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.ip_override_data.is_some() {
            state.serialize_entry("ipOverrideData", &self.ip_override_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for AddIpOverride.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AddIpOverrideResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddIpOverrideResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddIpOverrideResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AddIpOverrideResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddIpOverrideResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddIpOverrideResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddIpOverrideResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddIpOverrideResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddIpOverrideResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The RemoveIpOverride request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveIpOverrideRequest {
    /// Required. The name of the key from which the IP override is removed, in the
    /// format `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Required. IP override to be removed from the key.
    pub ip_override_data: std::option::Option<crate::model::IpOverrideData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveIpOverrideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveIpOverrideRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_override_data][crate::model::RemoveIpOverrideRequest::ip_override_data].
    pub fn set_ip_override_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_override_data][crate::model::RemoveIpOverrideRequest::ip_override_data].
    pub fn set_or_clear_ip_override_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RemoveIpOverrideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RemoveIpOverrideRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveIpOverrideRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ip_override_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveIpOverrideRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ipOverrideData" => Ok(__FieldTag::__ip_override_data),
                            "ip_override_data" => Ok(__FieldTag::__ip_override_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveIpOverrideRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveIpOverrideRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_override_data => {
                            if !fields.insert(__FieldTag::__ip_override_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_override_data",
                                ));
                            }
                            result.ip_override_data = map
                                .next_value::<std::option::Option<crate::model::IpOverrideData>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveIpOverrideRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.ip_override_data.is_some() {
            state.serialize_entry("ipOverrideData", &self.ip_override_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for RemoveIpOverride.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveIpOverrideResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveIpOverrideResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveIpOverrideResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RemoveIpOverrideResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveIpOverrideResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveIpOverrideResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveIpOverrideResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveIpOverrideResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveIpOverrideResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The ListIpOverrides request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIpOverridesRequest {
    /// Required. The parent key for which the IP overrides are listed, in the
    /// format `projects/{project}/keys/{key}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of overrides to return. Default is 10. Max
    /// limit is 100. If the number of overrides is less than the page_size, all
    /// overrides are returned. If the page size is more than 100, it is coerced to
    /// 100.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous
    /// ListIpOverridesRequest, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIpOverridesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIpOverridesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIpOverridesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIpOverridesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIpOverridesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListIpOverridesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIpOverridesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIpOverridesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIpOverridesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIpOverridesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIpOverridesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for ListIpOverrides.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIpOverridesResponse {
    /// IP Overrides details.
    pub ip_overrides: std::vec::Vec<crate::model::IpOverrideData>,

    /// Token to retrieve the next page of results. If this field is empty, no keys
    /// remain in the results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIpOverridesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_overrides][crate::model::ListIpOverridesResponse::ip_overrides].
    pub fn set_ip_overrides<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpOverrideData>,
    {
        use std::iter::Iterator;
        self.ip_overrides = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIpOverridesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIpOverridesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListIpOverridesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIpOverridesResponse {
    type PageItem = crate::model::IpOverrideData;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ip_overrides
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIpOverridesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_overrides,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIpOverridesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipOverrides" => Ok(__FieldTag::__ip_overrides),
                            "ip_overrides" => Ok(__FieldTag::__ip_overrides),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIpOverridesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIpOverridesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_overrides => {
                            if !fields.insert(__FieldTag::__ip_overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_overrides",
                                ));
                            }
                            result.ip_overrides =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::IpOverrideData>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIpOverridesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_overrides.is_empty() {
            state.serialize_entry("ipOverrides", &self.ip_overrides)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A membership in a group of related accounts.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedAccountGroupMembership {
    /// Required. Identifier. The resource name for this membership in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}/memberships/{membership}`.
    pub name: std::string::String,

    /// The unique stable account identifier of the member. The identifier
    /// corresponds to an `account_id` provided in a previous `CreateAssessment` or
    /// `AnnotateAssessment` call.
    pub account_id: std::string::String,

    /// Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier of the member. The identifier
    /// corresponds to a `hashed_account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call.
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAccountGroupMembership {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RelatedAccountGroupMembership::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::RelatedAccountGroupMembership::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::RelatedAccountGroupMembership::hashed_account_id].
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAccountGroupMembership {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedAccountGroupMembership {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __account_id,
            __hashed_account_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedAccountGroupMembership")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "accountId" => Ok(__FieldTag::__account_id),
                            "account_id" => Ok(__FieldTag::__account_id),
                            "hashedAccountId" => Ok(__FieldTag::__hashed_account_id),
                            "hashed_account_id" => Ok(__FieldTag::__hashed_account_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedAccountGroupMembership;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedAccountGroupMembership")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_id => {
                            if !fields.insert(__FieldTag::__account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_id",
                                ));
                            }
                            result.account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hashed_account_id => {
                            if !fields.insert(__FieldTag::__hashed_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hashed_account_id",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hashed_account_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedAccountGroupMembership {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.account_id.is_empty() {
            state.serialize_entry("accountId", &self.account_id)?;
        }
        if !self.hashed_account_id.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hashedAccountId", &__With(&self.hashed_account_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A group of related accounts.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedAccountGroup {
    /// Required. Identifier. The resource name for the related account group in
    /// the format
    /// `projects/{project}/relatedaccountgroups/{related_account_group}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAccountGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RelatedAccountGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAccountGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RelatedAccountGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelatedAccountGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelatedAccountGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelatedAccountGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelatedAccountGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelatedAccountGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings specific to keys that can be used for WAF (Web Application
/// Firewall).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WafSettings {
    /// Required. The WAF service that uses this key.
    pub waf_service: crate::model::waf_settings::WafService,

    /// Required. The WAF feature for which this key is enabled.
    pub waf_feature: crate::model::waf_settings::WafFeature,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WafSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [waf_service][crate::model::WafSettings::waf_service].
    pub fn set_waf_service<T: std::convert::Into<crate::model::waf_settings::WafService>>(
        mut self,
        v: T,
    ) -> Self {
        self.waf_service = v.into();
        self
    }

    /// Sets the value of [waf_feature][crate::model::WafSettings::waf_feature].
    pub fn set_waf_feature<T: std::convert::Into<crate::model::waf_settings::WafFeature>>(
        mut self,
        v: T,
    ) -> Self {
        self.waf_feature = v.into();
        self
    }
}

impl wkt::message::Message for WafSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.WafSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WafSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __waf_service,
            __waf_feature,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WafSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "wafService" => Ok(__FieldTag::__waf_service),
                            "waf_service" => Ok(__FieldTag::__waf_service),
                            "wafFeature" => Ok(__FieldTag::__waf_feature),
                            "waf_feature" => Ok(__FieldTag::__waf_feature),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WafSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WafSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__waf_service => {
                            if !fields.insert(__FieldTag::__waf_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for waf_service",
                                ));
                            }
                            result.waf_service = map.next_value::<std::option::Option<crate::model::waf_settings::WafService>>()?.unwrap_or_default();
                        }
                        __FieldTag::__waf_feature => {
                            if !fields.insert(__FieldTag::__waf_feature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for waf_feature",
                                ));
                            }
                            result.waf_feature = map.next_value::<std::option::Option<crate::model::waf_settings::WafFeature>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WafSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.waf_service) {
            state.serialize_entry("wafService", &self.waf_service)?;
        }
        if !wkt::internal::is_default(&self.waf_feature) {
            state.serialize_entry("wafFeature", &self.waf_feature)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WafSettings].
pub mod waf_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Supported WAF features. For more information, see
    /// <https://cloud.google.com/recaptcha/docs/usecase#comparison_of_features>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WafFeature {
        /// Undefined feature.
        Unspecified,
        /// Redirects suspicious traffic to reCAPTCHA.
        ChallengePage,
        /// Use reCAPTCHA session-tokens to protect the whole user session on the
        /// site's domain.
        SessionToken,
        /// Use reCAPTCHA action-tokens to protect user actions.
        ActionToken,
        /// Use reCAPTCHA WAF express protection to protect any content other than
        /// web pages, like APIs and IoT devices.
        Express,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WafFeature::value] or
        /// [WafFeature::name].
        UnknownValue(waf_feature::UnknownValue),
    }

    #[doc(hidden)]
    pub mod waf_feature {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WafFeature {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ChallengePage => std::option::Option::Some(1),
                Self::SessionToken => std::option::Option::Some(2),
                Self::ActionToken => std::option::Option::Some(3),
                Self::Express => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WAF_FEATURE_UNSPECIFIED"),
                Self::ChallengePage => std::option::Option::Some("CHALLENGE_PAGE"),
                Self::SessionToken => std::option::Option::Some("SESSION_TOKEN"),
                Self::ActionToken => std::option::Option::Some("ACTION_TOKEN"),
                Self::Express => std::option::Option::Some("EXPRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WafFeature {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WafFeature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WafFeature {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ChallengePage,
                2 => Self::SessionToken,
                3 => Self::ActionToken,
                5 => Self::Express,
                _ => Self::UnknownValue(waf_feature::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WafFeature {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WAF_FEATURE_UNSPECIFIED" => Self::Unspecified,
                "CHALLENGE_PAGE" => Self::ChallengePage,
                "SESSION_TOKEN" => Self::SessionToken,
                "ACTION_TOKEN" => Self::ActionToken,
                "EXPRESS" => Self::Express,
                _ => Self::UnknownValue(waf_feature::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WafFeature {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ChallengePage => serializer.serialize_i32(1),
                Self::SessionToken => serializer.serialize_i32(2),
                Self::ActionToken => serializer.serialize_i32(3),
                Self::Express => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WafFeature {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WafFeature>::new(
                ".google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature",
            ))
        }
    }

    /// Web Application Firewalls supported by reCAPTCHA.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WafService {
        /// Undefined WAF
        Unspecified,
        /// Cloud Armor
        Ca,
        /// Fastly
        Fastly,
        /// Cloudflare
        Cloudflare,
        /// Akamai
        Akamai,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WafService::value] or
        /// [WafService::name].
        UnknownValue(waf_service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod waf_service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WafService {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ca => std::option::Option::Some(1),
                Self::Fastly => std::option::Option::Some(3),
                Self::Cloudflare => std::option::Option::Some(4),
                Self::Akamai => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WAF_SERVICE_UNSPECIFIED"),
                Self::Ca => std::option::Option::Some("CA"),
                Self::Fastly => std::option::Option::Some("FASTLY"),
                Self::Cloudflare => std::option::Option::Some("CLOUDFLARE"),
                Self::Akamai => std::option::Option::Some("AKAMAI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WafService {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WafService {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WafService {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ca,
                3 => Self::Fastly,
                4 => Self::Cloudflare,
                5 => Self::Akamai,
                _ => Self::UnknownValue(waf_service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WafService {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WAF_SERVICE_UNSPECIFIED" => Self::Unspecified,
                "CA" => Self::Ca,
                "FASTLY" => Self::Fastly,
                "CLOUDFLARE" => Self::Cloudflare,
                "AKAMAI" => Self::Akamai,
                _ => Self::UnknownValue(waf_service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WafService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ca => serializer.serialize_i32(1),
                Self::Fastly => serializer.serialize_i32(3),
                Self::Cloudflare => serializer.serialize_i32(4),
                Self::Akamai => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WafService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WafService>::new(
                ".google.cloud.recaptchaenterprise.v1.WafSettings.WafService",
            ))
        }
    }
}

/// The environment creating the assessment. This describes your environment
/// (the system invoking CreateAssessment), NOT the environment of your user.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AssessmentEnvironment {
    /// Optional. Identifies the client module initiating the CreateAssessment
    /// request. This can be the link to the client module's project. Examples
    /// include:
    ///
    /// - "github.com/GoogleCloudPlatform/recaptcha-enterprise-google-tag-manager"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-akamai"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-cloudflare"
    /// - "wordpress.org/plugins/recaptcha-something"
    pub client: std::string::String,

    /// Optional. The version of the client module. For example, "1.0.0".
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssessmentEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client][crate::model::AssessmentEnvironment::client].
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AssessmentEnvironment::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for AssessmentEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AssessmentEnvironment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssessmentEnvironment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __client,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssessmentEnvironment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "client" => Ok(__FieldTag::__client),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssessmentEnvironment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssessmentEnvironment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__client => {
                            if !fields.insert(__FieldTag::__client) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client",
                                ));
                            }
                            result.client = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssessmentEnvironment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.client.is_empty() {
            state.serialize_entry("client", &self.client)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about the IP or IP range override.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IpOverrideData {
    /// Required. The IP address to override (can be IPv4, IPv6 or CIDR).
    /// The IP override must be a valid IPv4 or IPv6 address, or a CIDR range.
    /// The IP override must be a public IP address.
    /// Example of IPv4: 168.192.5.6
    /// Example of IPv6: 2001:0000:130F:0000:0000:09C0:876A:130B
    /// Example of IPv4 with CIDR: 168.192.5.0/24
    /// Example of IPv6 with CIDR: 2001:0DB8:1234::/48
    pub ip: std::string::String,

    /// Required. Describes the type of IP override.
    pub override_type: crate::model::ip_override_data::OverrideType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpOverrideData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip][crate::model::IpOverrideData::ip].
    pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip = v.into();
        self
    }

    /// Sets the value of [override_type][crate::model::IpOverrideData::override_type].
    pub fn set_override_type<
        T: std::convert::Into<crate::model::ip_override_data::OverrideType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.override_type = v.into();
        self
    }
}

impl wkt::message::Message for IpOverrideData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.IpOverrideData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IpOverrideData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip,
            __override_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IpOverrideData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ip" => Ok(__FieldTag::__ip),
                            "overrideType" => Ok(__FieldTag::__override_type),
                            "override_type" => Ok(__FieldTag::__override_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IpOverrideData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IpOverrideData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip => {
                            if !fields.insert(__FieldTag::__ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip",
                                ));
                            }
                            result.ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_type => {
                            if !fields.insert(__FieldTag::__override_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_type",
                                ));
                            }
                            result.override_type =
                                map.next_value::<std::option::Option<
                                    crate::model::ip_override_data::OverrideType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IpOverrideData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip.is_empty() {
            state.serialize_entry("ip", &self.ip)?;
        }
        if !wkt::internal::is_default(&self.override_type) {
            state.serialize_entry("overrideType", &self.override_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [IpOverrideData].
pub mod ip_override_data {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the type of IP override.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OverrideType {
        /// Default override type that indicates this enum hasn't been specified.
        Unspecified,
        /// Allowlist the IP address; i.e. give a `risk_analysis.score` of 0.9 for
        /// all valid assessments.
        Allow,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OverrideType::value] or
        /// [OverrideType::name].
        UnknownValue(override_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod override_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OverrideType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OVERRIDE_TYPE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OverrideType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OverrideType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OverrideType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                _ => Self::UnknownValue(override_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OverrideType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OVERRIDE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                _ => Self::UnknownValue(override_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OverrideType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OverrideType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OverrideType>::new(
                ".google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType",
            ))
        }
    }
}
