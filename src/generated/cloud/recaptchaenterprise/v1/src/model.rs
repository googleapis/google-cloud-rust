// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// The create assessment request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAssessmentRequest {
    /// Required. The name of the project in which the assessment is created,
    /// in the format `projects/{project}`.
    pub parent: std::string::String,

    /// Required. The assessment details.
    pub assessment: std::option::Option<crate::model::Assessment>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssessmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssessmentRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateAssessmentRequest;
    /// let x = CreateAssessmentRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [assessment][crate::model::CreateAssessmentRequest::assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateAssessmentRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// let x = CreateAssessmentRequest::new().set_assessment(Assessment::default()/* use setters */);
    /// ```
    pub fn set_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Assessment>,
    {
        self.assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment][crate::model::CreateAssessmentRequest::assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateAssessmentRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// let x = CreateAssessmentRequest::new().set_or_clear_assessment(Some(Assessment::default()/* use setters */));
    /// let x = CreateAssessmentRequest::new().set_or_clear_assessment(None::<Assessment>);
    /// ```
    pub fn set_or_clear_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Assessment>,
    {
        self.assessment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAssessmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateAssessmentRequest"
    }
}

/// Describes an event in the lifecycle of a payment transaction.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransactionEvent {
    /// Optional. The type of this transaction event.
    pub event_type: crate::model::transaction_event::TransactionEventType,

    /// Optional. The reason or standardized code that corresponds with this
    /// transaction event, if one exists. For example, a CHARGEBACK event with code
    /// 6005.
    pub reason: std::string::String,

    /// Optional. The value that corresponds with this transaction event, if one
    /// exists. For example, a refund event where $5.00 was refunded. Currency is
    /// obtained from the original transaction data.
    pub value: f64,

    /// Optional. Timestamp when this transaction event occurred; otherwise assumed
    /// to be the time of the API call.
    pub event_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_type][crate::model::TransactionEvent::event_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_event::TransactionEventType;
    /// let x0 = TransactionEvent::new().set_event_type(TransactionEventType::MerchantApprove);
    /// let x1 = TransactionEvent::new().set_event_type(TransactionEventType::MerchantDeny);
    /// let x2 = TransactionEvent::new().set_event_type(TransactionEventType::ManualReview);
    /// ```
    pub fn set_event_type<
        T: std::convert::Into<crate::model::transaction_event::TransactionEventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::TransactionEvent::reason].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// let x = TransactionEvent::new().set_reason("example");
    /// ```
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TransactionEvent::value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// let x = TransactionEvent::new().set_value(42.0);
    /// ```
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::TransactionEvent::event_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// use wkt::Timestamp;
    /// let x = TransactionEvent::new().set_event_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::TransactionEvent::event_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// use wkt::Timestamp;
    /// let x = TransactionEvent::new().set_or_clear_event_time(Some(Timestamp::default()/* use setters */));
    /// let x = TransactionEvent::new().set_or_clear_event_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransactionEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionEvent"
    }
}

/// Defines additional types related to [TransactionEvent].
pub mod transaction_event {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents an event in the payment transaction lifecycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransactionEventType {
        /// Default, unspecified event type.
        Unspecified,
        /// Indicates that the transaction is approved by the merchant. The
        /// accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
        /// 'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantApprove,
        /// Indicates that the transaction is denied and concluded due to risks
        /// detected by the merchant. The accompanying reasons can include terms such
        /// as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantDeny,
        /// Indicates that the transaction is being evaluated by a human, due to
        /// suspicion or risk.
        ManualReview,
        /// Indicates that the authorization attempt with the card issuer succeeded.
        Authorization,
        /// Indicates that the authorization attempt with the card issuer failed.
        /// The accompanying reasons can include Visa's '54' indicating that the card
        /// is expired, or '82' indicating that the CVV is incorrect.
        AuthorizationDecline,
        /// Indicates that the transaction is completed because the funds were
        /// settled.
        PaymentCapture,
        /// Indicates that the transaction could not be completed because the funds
        /// were not settled.
        PaymentCaptureDecline,
        /// Indicates that the transaction has been canceled. Specify the reason
        /// for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
        Cancel,
        /// Indicates that the merchant has received a chargeback inquiry due to
        /// fraud for the transaction, requesting additional information before a
        /// fraud chargeback is officially issued and a formal chargeback
        /// notification is sent.
        ChargebackInquiry,
        /// Indicates that the merchant has received a chargeback alert due to fraud
        /// for the transaction. The process of resolving the dispute without
        /// involving the payment network is started.
        ChargebackAlert,
        /// Indicates that a fraud notification is issued for the transaction, sent
        /// by the payment instrument's issuing bank because the transaction appears
        /// to be fraudulent. We recommend including TC40 or SAFE data in the
        /// `reason` field for this event type. For partial chargebacks, we recommend
        /// that you include an amount in the `value` field.
        FraudNotification,
        /// Indicates that the merchant is informed by the payment network that the
        /// transaction has entered the chargeback process due to fraud. Reason code
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        Chargeback,
        /// Indicates that the transaction has entered the chargeback process due to
        /// fraud, and that the merchant has chosen to enter representment. Reason
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        ChargebackRepresentment,
        /// Indicates that the transaction has had a fraud chargeback which was
        /// illegitimate and was reversed as a result. For partial chargebacks, we
        /// recommend that you include an amount in the `value` field.
        ChargebackReverse,
        /// Indicates that the merchant has received a refund for a completed
        /// transaction. For partial refunds, we recommend that you include an amount
        /// in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
        /// exempt tax)
        RefundRequest,
        /// Indicates that the merchant has received a refund request for this
        /// transaction, but that they have declined it. For partial refunds, we
        /// recommend that you include an amount in the `value` field. Reason
        /// example: 'TAX_EXEMPT' (partial refund of exempt tax)
        RefundDecline,
        /// Indicates that the completed transaction was refunded by the merchant.
        /// For partial refunds, we recommend that you include an amount in the
        /// `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
        /// tax)
        Refund,
        /// Indicates that the completed transaction was refunded by the merchant,
        /// and that this refund was reversed. For partial refunds, we recommend that
        /// you include an amount in the `value` field.
        RefundReverse,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransactionEventType::value] or
        /// [TransactionEventType::name].
        UnknownValue(transaction_event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transaction_event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransactionEventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MerchantApprove => std::option::Option::Some(1),
                Self::MerchantDeny => std::option::Option::Some(2),
                Self::ManualReview => std::option::Option::Some(3),
                Self::Authorization => std::option::Option::Some(4),
                Self::AuthorizationDecline => std::option::Option::Some(5),
                Self::PaymentCapture => std::option::Option::Some(6),
                Self::PaymentCaptureDecline => std::option::Option::Some(7),
                Self::Cancel => std::option::Option::Some(8),
                Self::ChargebackInquiry => std::option::Option::Some(9),
                Self::ChargebackAlert => std::option::Option::Some(10),
                Self::FraudNotification => std::option::Option::Some(11),
                Self::Chargeback => std::option::Option::Some(12),
                Self::ChargebackRepresentment => std::option::Option::Some(13),
                Self::ChargebackReverse => std::option::Option::Some(14),
                Self::RefundRequest => std::option::Option::Some(15),
                Self::RefundDecline => std::option::Option::Some(16),
                Self::Refund => std::option::Option::Some(17),
                Self::RefundReverse => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSACTION_EVENT_TYPE_UNSPECIFIED")
                }
                Self::MerchantApprove => std::option::Option::Some("MERCHANT_APPROVE"),
                Self::MerchantDeny => std::option::Option::Some("MERCHANT_DENY"),
                Self::ManualReview => std::option::Option::Some("MANUAL_REVIEW"),
                Self::Authorization => std::option::Option::Some("AUTHORIZATION"),
                Self::AuthorizationDecline => std::option::Option::Some("AUTHORIZATION_DECLINE"),
                Self::PaymentCapture => std::option::Option::Some("PAYMENT_CAPTURE"),
                Self::PaymentCaptureDecline => std::option::Option::Some("PAYMENT_CAPTURE_DECLINE"),
                Self::Cancel => std::option::Option::Some("CANCEL"),
                Self::ChargebackInquiry => std::option::Option::Some("CHARGEBACK_INQUIRY"),
                Self::ChargebackAlert => std::option::Option::Some("CHARGEBACK_ALERT"),
                Self::FraudNotification => std::option::Option::Some("FRAUD_NOTIFICATION"),
                Self::Chargeback => std::option::Option::Some("CHARGEBACK"),
                Self::ChargebackRepresentment => {
                    std::option::Option::Some("CHARGEBACK_REPRESENTMENT")
                }
                Self::ChargebackReverse => std::option::Option::Some("CHARGEBACK_REVERSE"),
                Self::RefundRequest => std::option::Option::Some("REFUND_REQUEST"),
                Self::RefundDecline => std::option::Option::Some("REFUND_DECLINE"),
                Self::Refund => std::option::Option::Some("REFUND"),
                Self::RefundReverse => std::option::Option::Some("REFUND_REVERSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransactionEventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransactionEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransactionEventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MerchantApprove,
                2 => Self::MerchantDeny,
                3 => Self::ManualReview,
                4 => Self::Authorization,
                5 => Self::AuthorizationDecline,
                6 => Self::PaymentCapture,
                7 => Self::PaymentCaptureDecline,
                8 => Self::Cancel,
                9 => Self::ChargebackInquiry,
                10 => Self::ChargebackAlert,
                11 => Self::FraudNotification,
                12 => Self::Chargeback,
                13 => Self::ChargebackRepresentment,
                14 => Self::ChargebackReverse,
                15 => Self::RefundRequest,
                16 => Self::RefundDecline,
                17 => Self::Refund,
                18 => Self::RefundReverse,
                _ => Self::UnknownValue(transaction_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransactionEventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSACTION_EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MERCHANT_APPROVE" => Self::MerchantApprove,
                "MERCHANT_DENY" => Self::MerchantDeny,
                "MANUAL_REVIEW" => Self::ManualReview,
                "AUTHORIZATION" => Self::Authorization,
                "AUTHORIZATION_DECLINE" => Self::AuthorizationDecline,
                "PAYMENT_CAPTURE" => Self::PaymentCapture,
                "PAYMENT_CAPTURE_DECLINE" => Self::PaymentCaptureDecline,
                "CANCEL" => Self::Cancel,
                "CHARGEBACK_INQUIRY" => Self::ChargebackInquiry,
                "CHARGEBACK_ALERT" => Self::ChargebackAlert,
                "FRAUD_NOTIFICATION" => Self::FraudNotification,
                "CHARGEBACK" => Self::Chargeback,
                "CHARGEBACK_REPRESENTMENT" => Self::ChargebackRepresentment,
                "CHARGEBACK_REVERSE" => Self::ChargebackReverse,
                "REFUND_REQUEST" => Self::RefundRequest,
                "REFUND_DECLINE" => Self::RefundDecline,
                "REFUND" => Self::Refund,
                "REFUND_REVERSE" => Self::RefundReverse,
                _ => Self::UnknownValue(transaction_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransactionEventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MerchantApprove => serializer.serialize_i32(1),
                Self::MerchantDeny => serializer.serialize_i32(2),
                Self::ManualReview => serializer.serialize_i32(3),
                Self::Authorization => serializer.serialize_i32(4),
                Self::AuthorizationDecline => serializer.serialize_i32(5),
                Self::PaymentCapture => serializer.serialize_i32(6),
                Self::PaymentCaptureDecline => serializer.serialize_i32(7),
                Self::Cancel => serializer.serialize_i32(8),
                Self::ChargebackInquiry => serializer.serialize_i32(9),
                Self::ChargebackAlert => serializer.serialize_i32(10),
                Self::FraudNotification => serializer.serialize_i32(11),
                Self::Chargeback => serializer.serialize_i32(12),
                Self::ChargebackRepresentment => serializer.serialize_i32(13),
                Self::ChargebackReverse => serializer.serialize_i32(14),
                Self::RefundRequest => serializer.serialize_i32(15),
                Self::RefundDecline => serializer.serialize_i32(16),
                Self::Refund => serializer.serialize_i32(17),
                Self::RefundReverse => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransactionEventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransactionEventType>::new(
                ".google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType",
            ))
        }
    }
}

/// The request message to annotate an Assessment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateAssessmentRequest {
    /// Required. The resource name of the Assessment, in the format
    /// `projects/{project}/assessments/{assessment}`.
    pub name: std::string::String,

    /// Optional. The annotation that is assigned to the Event. This field can be
    /// left empty to provide reasons that apply to an event without concluding
    /// whether the event is legitimate or fraudulent.
    pub annotation: crate::model::annotate_assessment_request::Annotation,

    /// Optional. Reasons for the annotation that are assigned to the event.
    pub reasons: std::vec::Vec<crate::model::annotate_assessment_request::Reason>,

    /// Optional. A stable account identifier to apply to the assessment. This is
    /// an alternative to setting `account_id` in `CreateAssessment`, for example
    /// when a stable account identifier is not yet known in the initial request.
    pub account_id: std::string::String,

    /// Optional. A stable hashed account identifier to apply to the assessment.
    /// This is an alternative to setting `hashed_account_id` in
    /// `CreateAssessment`, for example when a stable account identifier is not yet
    /// known in the initial request.
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. If the assessment is part of a payment transaction, provide
    /// details on payment lifecycle events that occur in the transaction.
    pub transaction_event: std::option::Option<crate::model::TransactionEvent>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateAssessmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnnotateAssessmentRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// let x = AnnotateAssessmentRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [annotation][crate::model::AnnotateAssessmentRequest::annotation].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::annotate_assessment_request::Annotation;
    /// let x0 = AnnotateAssessmentRequest::new().set_annotation(Annotation::Legitimate);
    /// let x1 = AnnotateAssessmentRequest::new().set_annotation(Annotation::Fraudulent);
    /// ```
    pub fn set_annotation<
        T: std::convert::Into<crate::model::annotate_assessment_request::Annotation>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::AnnotateAssessmentRequest::reasons].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::annotate_assessment_request::Reason;
    /// let x = AnnotateAssessmentRequest::new().set_reasons([
    ///     Reason::Chargeback,
    ///     Reason::ChargebackFraud,
    ///     Reason::ChargebackDispute,
    /// ]);
    /// ```
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::annotate_assessment_request::Reason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [account_id][crate::model::AnnotateAssessmentRequest::account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// let x = AnnotateAssessmentRequest::new().set_account_id("example");
    /// ```
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::AnnotateAssessmentRequest::hashed_account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// let x = AnnotateAssessmentRequest::new().set_hashed_account_id(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [transaction_event][crate::model::AnnotateAssessmentRequest::transaction_event].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// let x = AnnotateAssessmentRequest::new().set_transaction_event(TransactionEvent::default()/* use setters */);
    /// ```
    pub fn set_transaction_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransactionEvent>,
    {
        self.transaction_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_event][crate::model::AnnotateAssessmentRequest::transaction_event].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AnnotateAssessmentRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::TransactionEvent;
    /// let x = AnnotateAssessmentRequest::new().set_or_clear_transaction_event(Some(TransactionEvent::default()/* use setters */));
    /// let x = AnnotateAssessmentRequest::new().set_or_clear_transaction_event(None::<TransactionEvent>);
    /// ```
    pub fn set_or_clear_transaction_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransactionEvent>,
    {
        self.transaction_event = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnnotateAssessmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest"
    }
}

/// Defines additional types related to [AnnotateAssessmentRequest].
pub mod annotate_assessment_request {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the types of annotations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Annotation {
        /// Default unspecified type.
        Unspecified,
        /// Provides information that the event turned out to be legitimate.
        Legitimate,
        /// Provides information that the event turned out to be fraudulent.
        Fraudulent,
        /// Provides information that the event was related to a login event in which
        /// the user typed the correct password. Deprecated, prefer indicating
        /// CORRECT_PASSWORD through the reasons field instead.
        #[deprecated]
        PasswordCorrect,
        /// Provides information that the event was related to a login event in which
        /// the user typed the incorrect password. Deprecated, prefer indicating
        /// INCORRECT_PASSWORD through the reasons field instead.
        #[deprecated]
        PasswordIncorrect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Annotation::value] or
        /// [Annotation::name].
        UnknownValue(annotation::UnknownValue),
    }

    #[doc(hidden)]
    pub mod annotation {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Annotation {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Legitimate => std::option::Option::Some(1),
                Self::Fraudulent => std::option::Option::Some(2),
                Self::PasswordCorrect => std::option::Option::Some(3),
                Self::PasswordIncorrect => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANNOTATION_UNSPECIFIED"),
                Self::Legitimate => std::option::Option::Some("LEGITIMATE"),
                Self::Fraudulent => std::option::Option::Some("FRAUDULENT"),
                Self::PasswordCorrect => std::option::Option::Some("PASSWORD_CORRECT"),
                Self::PasswordIncorrect => std::option::Option::Some("PASSWORD_INCORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Annotation {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Annotation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Annotation {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Legitimate,
                2 => Self::Fraudulent,
                3 => Self::PasswordCorrect,
                4 => Self::PasswordIncorrect,
                _ => Self::UnknownValue(annotation::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Annotation {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANNOTATION_UNSPECIFIED" => Self::Unspecified,
                "LEGITIMATE" => Self::Legitimate,
                "FRAUDULENT" => Self::Fraudulent,
                "PASSWORD_CORRECT" => Self::PasswordCorrect,
                "PASSWORD_INCORRECT" => Self::PasswordIncorrect,
                _ => Self::UnknownValue(annotation::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Annotation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Legitimate => serializer.serialize_i32(1),
                Self::Fraudulent => serializer.serialize_i32(2),
                Self::PasswordCorrect => serializer.serialize_i32(3),
                Self::PasswordIncorrect => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Annotation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Annotation>::new(
                ".google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation",
            ))
        }
    }

    /// Enum that represents potential reasons for annotating an assessment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reason {
        /// Unspecified reason. Do not use.
        Unspecified,
        /// Indicates that the transaction had a chargeback issued with no other
        /// details. When possible, specify the type by using CHARGEBACK_FRAUD or
        /// CHARGEBACK_DISPUTE instead.
        Chargeback,
        /// Indicates that the transaction had a chargeback issued related to an
        /// alleged unauthorized transaction from the cardholder's perspective (for
        /// example, the card number was stolen).
        ChargebackFraud,
        /// Indicates that the transaction had a chargeback issued related to the
        /// cardholder having provided their card details but allegedly not being
        /// satisfied with the purchase (for example, misrepresentation, attempted
        /// cancellation).
        ChargebackDispute,
        /// Indicates that the completed payment transaction was refunded by the
        /// seller.
        Refund,
        /// Indicates that the completed payment transaction was determined to be
        /// fraudulent by the seller, and was cancelled and refunded as a result.
        RefundFraud,
        /// Indicates that the payment transaction was accepted, and the user was
        /// charged.
        TransactionAccepted,
        /// Indicates that the payment transaction was declined, for example due to
        /// invalid card details.
        TransactionDeclined,
        /// Indicates the transaction associated with the assessment is suspected of
        /// being fraudulent based on the payment method, billing details, shipping
        /// address or other transaction information.
        PaymentHeuristics,
        /// Indicates that the user was served a 2FA challenge. An old assessment
        /// with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
        /// overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
        /// This is equivalent to `FAILED_TWO_FACTOR`.
        InitiatedTwoFactor,
        /// Indicates that the user passed a 2FA challenge.
        PassedTwoFactor,
        /// Indicates that the user failed a 2FA challenge.
        FailedTwoFactor,
        /// Indicates the user provided the correct password.
        CorrectPassword,
        /// Indicates the user provided an incorrect password.
        IncorrectPassword,
        /// Indicates that the user sent unwanted and abusive messages to other users
        /// of the platform, such as spam, scams, phishing, or social engineering.
        SocialSpam,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reason::value] or
        /// [Reason::name].
        UnknownValue(reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Chargeback => std::option::Option::Some(1),
                Self::ChargebackFraud => std::option::Option::Some(8),
                Self::ChargebackDispute => std::option::Option::Some(9),
                Self::Refund => std::option::Option::Some(10),
                Self::RefundFraud => std::option::Option::Some(11),
                Self::TransactionAccepted => std::option::Option::Some(12),
                Self::TransactionDeclined => std::option::Option::Some(13),
                Self::PaymentHeuristics => std::option::Option::Some(2),
                Self::InitiatedTwoFactor => std::option::Option::Some(7),
                Self::PassedTwoFactor => std::option::Option::Some(3),
                Self::FailedTwoFactor => std::option::Option::Some(4),
                Self::CorrectPassword => std::option::Option::Some(5),
                Self::IncorrectPassword => std::option::Option::Some(6),
                Self::SocialSpam => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                Self::Chargeback => std::option::Option::Some("CHARGEBACK"),
                Self::ChargebackFraud => std::option::Option::Some("CHARGEBACK_FRAUD"),
                Self::ChargebackDispute => std::option::Option::Some("CHARGEBACK_DISPUTE"),
                Self::Refund => std::option::Option::Some("REFUND"),
                Self::RefundFraud => std::option::Option::Some("REFUND_FRAUD"),
                Self::TransactionAccepted => std::option::Option::Some("TRANSACTION_ACCEPTED"),
                Self::TransactionDeclined => std::option::Option::Some("TRANSACTION_DECLINED"),
                Self::PaymentHeuristics => std::option::Option::Some("PAYMENT_HEURISTICS"),
                Self::InitiatedTwoFactor => std::option::Option::Some("INITIATED_TWO_FACTOR"),
                Self::PassedTwoFactor => std::option::Option::Some("PASSED_TWO_FACTOR"),
                Self::FailedTwoFactor => std::option::Option::Some("FAILED_TWO_FACTOR"),
                Self::CorrectPassword => std::option::Option::Some("CORRECT_PASSWORD"),
                Self::IncorrectPassword => std::option::Option::Some("INCORRECT_PASSWORD"),
                Self::SocialSpam => std::option::Option::Some("SOCIAL_SPAM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Chargeback,
                2 => Self::PaymentHeuristics,
                3 => Self::PassedTwoFactor,
                4 => Self::FailedTwoFactor,
                5 => Self::CorrectPassword,
                6 => Self::IncorrectPassword,
                7 => Self::InitiatedTwoFactor,
                8 => Self::ChargebackFraud,
                9 => Self::ChargebackDispute,
                10 => Self::Refund,
                11 => Self::RefundFraud,
                12 => Self::TransactionAccepted,
                13 => Self::TransactionDeclined,
                14 => Self::SocialSpam,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REASON_UNSPECIFIED" => Self::Unspecified,
                "CHARGEBACK" => Self::Chargeback,
                "CHARGEBACK_FRAUD" => Self::ChargebackFraud,
                "CHARGEBACK_DISPUTE" => Self::ChargebackDispute,
                "REFUND" => Self::Refund,
                "REFUND_FRAUD" => Self::RefundFraud,
                "TRANSACTION_ACCEPTED" => Self::TransactionAccepted,
                "TRANSACTION_DECLINED" => Self::TransactionDeclined,
                "PAYMENT_HEURISTICS" => Self::PaymentHeuristics,
                "INITIATED_TWO_FACTOR" => Self::InitiatedTwoFactor,
                "PASSED_TWO_FACTOR" => Self::PassedTwoFactor,
                "FAILED_TWO_FACTOR" => Self::FailedTwoFactor,
                "CORRECT_PASSWORD" => Self::CorrectPassword,
                "INCORRECT_PASSWORD" => Self::IncorrectPassword,
                "SOCIAL_SPAM" => Self::SocialSpam,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Chargeback => serializer.serialize_i32(1),
                Self::ChargebackFraud => serializer.serialize_i32(8),
                Self::ChargebackDispute => serializer.serialize_i32(9),
                Self::Refund => serializer.serialize_i32(10),
                Self::RefundFraud => serializer.serialize_i32(11),
                Self::TransactionAccepted => serializer.serialize_i32(12),
                Self::TransactionDeclined => serializer.serialize_i32(13),
                Self::PaymentHeuristics => serializer.serialize_i32(2),
                Self::InitiatedTwoFactor => serializer.serialize_i32(7),
                Self::PassedTwoFactor => serializer.serialize_i32(3),
                Self::FailedTwoFactor => serializer.serialize_i32(4),
                Self::CorrectPassword => serializer.serialize_i32(5),
                Self::IncorrectPassword => serializer.serialize_i32(6),
                Self::SocialSpam => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                ".google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason",
            ))
        }
    }
}

/// Empty response for AnnotateAssessment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateAssessmentResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateAssessmentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AnnotateAssessmentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AnnotateAssessmentResponse"
    }
}

/// Information about a verification endpoint that can be used for 2FA.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EndpointVerificationInfo {
    /// Output only. Token to provide to the client to trigger endpoint
    /// verification. It must be used within 15 minutes.
    pub request_token: std::string::String,

    /// Output only. Timestamp of the last successful verification for the
    /// endpoint, if any.
    pub last_verification_time: std::option::Option<wkt::Timestamp>,

    pub endpoint: std::option::Option<crate::model::endpoint_verification_info::Endpoint>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_token][crate::model::EndpointVerificationInfo::request_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// let x = EndpointVerificationInfo::new().set_request_token("example");
    /// ```
    pub fn set_request_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_token = v.into();
        self
    }

    /// Sets the value of [last_verification_time][crate::model::EndpointVerificationInfo::last_verification_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// use wkt::Timestamp;
    /// let x = EndpointVerificationInfo::new().set_last_verification_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_last_verification_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_verification_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_verification_time][crate::model::EndpointVerificationInfo::last_verification_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// use wkt::Timestamp;
    /// let x = EndpointVerificationInfo::new().set_or_clear_last_verification_time(Some(Timestamp::default()/* use setters */));
    /// let x = EndpointVerificationInfo::new().set_or_clear_last_verification_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_last_verification_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_verification_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint].
    ///
    /// Note that all the setters affecting `endpoint` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// use google_cloud_recaptchaenterprise_v1::model::endpoint_verification_info;
    /// let x = EndpointVerificationInfo::new().set_endpoint(Some(endpoint_verification_info::Endpoint::EmailAddress("example".to_string())));
    /// ```
    pub fn set_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::endpoint_verification_info::Endpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// The value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// if it holds a `EmailAddress`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email_address(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.endpoint.as_ref().and_then(|v| match v {
            crate::model::endpoint_verification_info::Endpoint::EmailAddress(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// to hold a `EmailAddress`.
    ///
    /// Note that all the setters affecting `endpoint` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// let x = EndpointVerificationInfo::new().set_email_address("example");
    /// assert!(x.email_address().is_some());
    /// assert!(x.phone_number().is_none());
    /// ```
    pub fn set_email_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = std::option::Option::Some(
            crate::model::endpoint_verification_info::Endpoint::EmailAddress(v.into()),
        );
        self
    }

    /// The value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// if it holds a `PhoneNumber`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.endpoint.as_ref().and_then(|v| match v {
            crate::model::endpoint_verification_info::Endpoint::PhoneNumber(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// to hold a `PhoneNumber`.
    ///
    /// Note that all the setters affecting `endpoint` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// let x = EndpointVerificationInfo::new().set_phone_number("example");
    /// assert!(x.phone_number().is_some());
    /// assert!(x.email_address().is_none());
    /// ```
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = std::option::Option::Some(
            crate::model::endpoint_verification_info::Endpoint::PhoneNumber(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EndpointVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo"
    }
}

/// Defines additional types related to [EndpointVerificationInfo].
pub mod endpoint_verification_info {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Endpoint {
        /// Email address for which to trigger a verification request.
        EmailAddress(std::string::String),
        /// Phone number for which to trigger a verification request. Should be given
        /// in E.164 format.
        PhoneNumber(std::string::String),
    }
}

/// Information about account verification, used for identity verification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AccountVerificationInfo {
    /// Optional. Endpoints that can be used for identity verification.
    pub endpoints: std::vec::Vec<crate::model::EndpointVerificationInfo>,

    /// Optional. Language code preference for the verification message, set as a
    /// IETF BCP 47 language code.
    pub language_code: std::string::String,

    /// Output only. Result of the latest account verification challenge.
    pub latest_verification_result: crate::model::account_verification_info::Result,

    /// Username of the account that is being verified. Deprecated. Customers
    /// should now provide the `account_id` field in `event.user_info`.
    #[deprecated]
    pub username: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoints][crate::model::AccountVerificationInfo::endpoints].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AccountVerificationInfo;
    /// use google_cloud_recaptchaenterprise_v1::model::EndpointVerificationInfo;
    /// let x = AccountVerificationInfo::new()
    ///     .set_endpoints([
    ///         EndpointVerificationInfo::default()/* use setters */,
    ///         EndpointVerificationInfo::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EndpointVerificationInfo>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::AccountVerificationInfo::language_code].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AccountVerificationInfo;
    /// let x = AccountVerificationInfo::new().set_language_code("example");
    /// ```
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [latest_verification_result][crate::model::AccountVerificationInfo::latest_verification_result].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AccountVerificationInfo;
    /// use google_cloud_recaptchaenterprise_v1::model::account_verification_info::Result;
    /// let x0 = AccountVerificationInfo::new().set_latest_verification_result(Result::SuccessUserVerified);
    /// let x1 = AccountVerificationInfo::new().set_latest_verification_result(Result::ErrorUserNotVerified);
    /// let x2 = AccountVerificationInfo::new().set_latest_verification_result(Result::ErrorSiteOnboardingIncomplete);
    /// ```
    pub fn set_latest_verification_result<
        T: std::convert::Into<crate::model::account_verification_info::Result>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_verification_result = v.into();
        self
    }

    /// Sets the value of [username][crate::model::AccountVerificationInfo::username].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AccountVerificationInfo;
    /// let x = AccountVerificationInfo::new().set_username("example");
    /// ```
    #[deprecated]
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for AccountVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AccountVerificationInfo"
    }
}

/// Defines additional types related to [AccountVerificationInfo].
pub mod account_verification_info {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the account verification as contained in the verdict token issued
    /// at the end of the verification flow.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// No information about the latest account verification.
        Unspecified,
        /// The user was successfully verified. This means the account verification
        /// challenge was successfully completed.
        SuccessUserVerified,
        /// The user failed the verification challenge.
        ErrorUserNotVerified,
        /// The site is not properly onboarded to use the account verification
        /// feature.
        ErrorSiteOnboardingIncomplete,
        /// The recipient is not allowed for account verification. This can occur
        /// during integration but should not occur in production.
        ErrorRecipientNotAllowed,
        /// The recipient has already been sent too many verification codes in a
        /// short amount of time.
        ErrorRecipientAbuseLimitExhausted,
        /// The verification flow could not be completed due to a critical internal
        /// error.
        ErrorCriticalInternal,
        /// The client has exceeded their two factor request quota for this period of
        /// time.
        ErrorCustomerQuotaExhausted,
        /// The request cannot be processed at the time because of an incident. This
        /// bypass can be restricted to a problematic destination email domain, a
        /// customer, or could affect the entire service.
        ErrorVerificationBypassed,
        /// The request parameters do not match with the token provided and cannot be
        /// processed.
        ErrorVerdictMismatch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SuccessUserVerified => std::option::Option::Some(1),
                Self::ErrorUserNotVerified => std::option::Option::Some(2),
                Self::ErrorSiteOnboardingIncomplete => std::option::Option::Some(3),
                Self::ErrorRecipientNotAllowed => std::option::Option::Some(4),
                Self::ErrorRecipientAbuseLimitExhausted => std::option::Option::Some(5),
                Self::ErrorCriticalInternal => std::option::Option::Some(6),
                Self::ErrorCustomerQuotaExhausted => std::option::Option::Some(7),
                Self::ErrorVerificationBypassed => std::option::Option::Some(8),
                Self::ErrorVerdictMismatch => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::SuccessUserVerified => std::option::Option::Some("SUCCESS_USER_VERIFIED"),
                Self::ErrorUserNotVerified => std::option::Option::Some("ERROR_USER_NOT_VERIFIED"),
                Self::ErrorSiteOnboardingIncomplete => {
                    std::option::Option::Some("ERROR_SITE_ONBOARDING_INCOMPLETE")
                }
                Self::ErrorRecipientNotAllowed => {
                    std::option::Option::Some("ERROR_RECIPIENT_NOT_ALLOWED")
                }
                Self::ErrorRecipientAbuseLimitExhausted => {
                    std::option::Option::Some("ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED")
                }
                Self::ErrorCriticalInternal => std::option::Option::Some("ERROR_CRITICAL_INTERNAL"),
                Self::ErrorCustomerQuotaExhausted => {
                    std::option::Option::Some("ERROR_CUSTOMER_QUOTA_EXHAUSTED")
                }
                Self::ErrorVerificationBypassed => {
                    std::option::Option::Some("ERROR_VERIFICATION_BYPASSED")
                }
                Self::ErrorVerdictMismatch => std::option::Option::Some("ERROR_VERDICT_MISMATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SuccessUserVerified,
                2 => Self::ErrorUserNotVerified,
                3 => Self::ErrorSiteOnboardingIncomplete,
                4 => Self::ErrorRecipientNotAllowed,
                5 => Self::ErrorRecipientAbuseLimitExhausted,
                6 => Self::ErrorCriticalInternal,
                7 => Self::ErrorCustomerQuotaExhausted,
                8 => Self::ErrorVerificationBypassed,
                9 => Self::ErrorVerdictMismatch,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS_USER_VERIFIED" => Self::SuccessUserVerified,
                "ERROR_USER_NOT_VERIFIED" => Self::ErrorUserNotVerified,
                "ERROR_SITE_ONBOARDING_INCOMPLETE" => Self::ErrorSiteOnboardingIncomplete,
                "ERROR_RECIPIENT_NOT_ALLOWED" => Self::ErrorRecipientNotAllowed,
                "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED" => Self::ErrorRecipientAbuseLimitExhausted,
                "ERROR_CRITICAL_INTERNAL" => Self::ErrorCriticalInternal,
                "ERROR_CUSTOMER_QUOTA_EXHAUSTED" => Self::ErrorCustomerQuotaExhausted,
                "ERROR_VERIFICATION_BYPASSED" => Self::ErrorVerificationBypassed,
                "ERROR_VERDICT_MISMATCH" => Self::ErrorVerdictMismatch,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SuccessUserVerified => serializer.serialize_i32(1),
                Self::ErrorUserNotVerified => serializer.serialize_i32(2),
                Self::ErrorSiteOnboardingIncomplete => serializer.serialize_i32(3),
                Self::ErrorRecipientNotAllowed => serializer.serialize_i32(4),
                Self::ErrorRecipientAbuseLimitExhausted => serializer.serialize_i32(5),
                Self::ErrorCriticalInternal => serializer.serialize_i32(6),
                Self::ErrorCustomerQuotaExhausted => serializer.serialize_i32(7),
                Self::ErrorVerificationBypassed => serializer.serialize_i32(8),
                Self::ErrorVerdictMismatch => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result",
            ))
        }
    }
}

/// Private password leak verification info.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivatePasswordLeakVerification {
    /// Required. Exactly 26-bit prefix of the SHA-256 hash of the canonicalized
    /// username. It is used to look up password leaks associated with that hash
    /// prefix.
    pub lookup_hash_prefix: ::bytes::Bytes,

    /// Optional. Encrypted Scrypt hash of the canonicalized username+password. It
    /// is re-encrypted by the server and returned through
    /// `reencrypted_user_credentials_hash`.
    pub encrypted_user_credentials_hash: ::bytes::Bytes,

    /// Output only. List of prefixes of the encrypted potential password leaks
    /// that matched the given parameters. They must be compared with the
    /// client-side decryption prefix of `reencrypted_user_credentials_hash`
    pub encrypted_leak_match_prefixes: std::vec::Vec<::bytes::Bytes>,

    /// Output only. Corresponds to the re-encryption of the
    /// `encrypted_user_credentials_hash` field. It is used to match potential
    /// password leaks within `encrypted_leak_match_prefixes`.
    pub reencrypted_user_credentials_hash: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePasswordLeakVerification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lookup_hash_prefix][crate::model::PrivatePasswordLeakVerification::lookup_hash_prefix].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::PrivatePasswordLeakVerification;
    /// let x = PrivatePasswordLeakVerification::new().set_lookup_hash_prefix(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_lookup_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.lookup_hash_prefix = v.into();
        self
    }

    /// Sets the value of [encrypted_user_credentials_hash][crate::model::PrivatePasswordLeakVerification::encrypted_user_credentials_hash].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::PrivatePasswordLeakVerification;
    /// let x = PrivatePasswordLeakVerification::new().set_encrypted_user_credentials_hash(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_encrypted_user_credentials_hash<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.encrypted_user_credentials_hash = v.into();
        self
    }

    /// Sets the value of [encrypted_leak_match_prefixes][crate::model::PrivatePasswordLeakVerification::encrypted_leak_match_prefixes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::PrivatePasswordLeakVerification;
    /// let b1 = bytes::Bytes::from_static(b"abc");
    /// let b2 = bytes::Bytes::from_static(b"xyz");
    /// let x = PrivatePasswordLeakVerification::new().set_encrypted_leak_match_prefixes([b1, b2]);
    /// ```
    pub fn set_encrypted_leak_match_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.encrypted_leak_match_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reencrypted_user_credentials_hash][crate::model::PrivatePasswordLeakVerification::reencrypted_user_credentials_hash].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::PrivatePasswordLeakVerification;
    /// let x = PrivatePasswordLeakVerification::new().set_reencrypted_user_credentials_hash(bytes::Bytes::from_static(b"example"));
    /// ```
    pub fn set_reencrypted_user_credentials_hash<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.reencrypted_user_credentials_hash = v.into();
        self
    }
}

impl wkt::message::Message for PrivatePasswordLeakVerification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification"
    }
}

/// A reCAPTCHA Enterprise assessment resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Assessment {
    /// Output only. Identifier. The resource name for the Assessment in the format
    /// `projects/{project}/assessments/{assessment}`.
    pub name: std::string::String,

    /// Optional. The event being assessed.
    pub event: std::option::Option<crate::model::Event>,

    /// Output only. The risk analysis result for the event being assessed.
    pub risk_analysis: std::option::Option<crate::model::RiskAnalysis>,

    /// Output only. Properties of the provided event token.
    pub token_properties: std::option::Option<crate::model::TokenProperties>,

    /// Optional. Account verification information for identity verification. The
    /// assessment event must include a token and site key to use this feature.
    pub account_verification: std::option::Option<crate::model::AccountVerificationInfo>,

    /// Output only. Assessment returned by account defender when an account
    /// identifier is provided.
    pub account_defender_assessment: std::option::Option<crate::model::AccountDefenderAssessment>,

    /// Optional. The private password leak verification field contains the
    /// parameters that are used to to check for leaks privately without sharing
    /// user credentials.
    pub private_password_leak_verification:
        std::option::Option<crate::model::PrivatePasswordLeakVerification>,

    /// Output only. Assessment returned when firewall policies belonging to the
    /// project are evaluated using the field firewall_policy_evaluation.
    pub firewall_policy_assessment: std::option::Option<crate::model::FirewallPolicyAssessment>,

    /// Output only. Assessment returned by Fraud Prevention when TransactionData
    /// is provided.
    pub fraud_prevention_assessment: std::option::Option<crate::model::FraudPreventionAssessment>,

    /// Output only. Fraud Signals specific to the users involved in a payment
    /// transaction.
    pub fraud_signals: std::option::Option<crate::model::FraudSignals>,

    /// Output only. Assessment returned when a site key, a token, and a phone
    /// number as `user_id` are provided. Account defender and SMS toll fraud
    /// protection need to be enabled.
    pub phone_fraud_assessment: std::option::Option<crate::model::PhoneFraudAssessment>,

    /// Optional. The environment creating the assessment. This describes your
    /// environment (the system invoking CreateAssessment), NOT the environment of
    /// your user.
    pub assessment_environment: std::option::Option<crate::model::AssessmentEnvironment>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Assessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Assessment::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// let x = Assessment::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event][crate::model::Assessment::event].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Assessment::new().set_event(Event::default()/* use setters */);
    /// ```
    pub fn set_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Event>,
    {
        self.event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event][crate::model::Assessment::event].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Assessment::new().set_or_clear_event(Some(Event::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_event(None::<Event>);
    /// ```
    pub fn set_or_clear_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Event>,
    {
        self.event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [risk_analysis][crate::model::Assessment::risk_analysis].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::RiskAnalysis;
    /// let x = Assessment::new().set_risk_analysis(RiskAnalysis::default()/* use setters */);
    /// ```
    pub fn set_risk_analysis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RiskAnalysis>,
    {
        self.risk_analysis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [risk_analysis][crate::model::Assessment::risk_analysis].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::RiskAnalysis;
    /// let x = Assessment::new().set_or_clear_risk_analysis(Some(RiskAnalysis::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_risk_analysis(None::<RiskAnalysis>);
    /// ```
    pub fn set_or_clear_risk_analysis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RiskAnalysis>,
    {
        self.risk_analysis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [token_properties][crate::model::Assessment::token_properties].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = Assessment::new().set_token_properties(TokenProperties::default()/* use setters */);
    /// ```
    pub fn set_token_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TokenProperties>,
    {
        self.token_properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [token_properties][crate::model::Assessment::token_properties].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = Assessment::new().set_or_clear_token_properties(Some(TokenProperties::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_token_properties(None::<TokenProperties>);
    /// ```
    pub fn set_or_clear_token_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TokenProperties>,
    {
        self.token_properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_verification][crate::model::Assessment::account_verification].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::AccountVerificationInfo;
    /// let x = Assessment::new().set_account_verification(AccountVerificationInfo::default()/* use setters */);
    /// ```
    pub fn set_account_verification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccountVerificationInfo>,
    {
        self.account_verification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_verification][crate::model::Assessment::account_verification].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::AccountVerificationInfo;
    /// let x = Assessment::new().set_or_clear_account_verification(Some(AccountVerificationInfo::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_account_verification(None::<AccountVerificationInfo>);
    /// ```
    pub fn set_or_clear_account_verification<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccountVerificationInfo>,
    {
        self.account_verification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_defender_assessment][crate::model::Assessment::account_defender_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::AccountDefenderAssessment;
    /// let x = Assessment::new().set_account_defender_assessment(AccountDefenderAssessment::default()/* use setters */);
    /// ```
    pub fn set_account_defender_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccountDefenderAssessment>,
    {
        self.account_defender_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_defender_assessment][crate::model::Assessment::account_defender_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::AccountDefenderAssessment;
    /// let x = Assessment::new().set_or_clear_account_defender_assessment(Some(AccountDefenderAssessment::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_account_defender_assessment(None::<AccountDefenderAssessment>);
    /// ```
    pub fn set_or_clear_account_defender_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccountDefenderAssessment>,
    {
        self.account_defender_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_password_leak_verification][crate::model::Assessment::private_password_leak_verification].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::PrivatePasswordLeakVerification;
    /// let x = Assessment::new().set_private_password_leak_verification(PrivatePasswordLeakVerification::default()/* use setters */);
    /// ```
    pub fn set_private_password_leak_verification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivatePasswordLeakVerification>,
    {
        self.private_password_leak_verification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_password_leak_verification][crate::model::Assessment::private_password_leak_verification].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::PrivatePasswordLeakVerification;
    /// let x = Assessment::new().set_or_clear_private_password_leak_verification(Some(PrivatePasswordLeakVerification::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_private_password_leak_verification(None::<PrivatePasswordLeakVerification>);
    /// ```
    pub fn set_or_clear_private_password_leak_verification<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::PrivatePasswordLeakVerification>,
    {
        self.private_password_leak_verification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [firewall_policy_assessment][crate::model::Assessment::firewall_policy_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicyAssessment;
    /// let x = Assessment::new().set_firewall_policy_assessment(FirewallPolicyAssessment::default()/* use setters */);
    /// ```
    pub fn set_firewall_policy_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyAssessment>,
    {
        self.firewall_policy_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy_assessment][crate::model::Assessment::firewall_policy_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicyAssessment;
    /// let x = Assessment::new().set_or_clear_firewall_policy_assessment(Some(FirewallPolicyAssessment::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_firewall_policy_assessment(None::<FirewallPolicyAssessment>);
    /// ```
    pub fn set_or_clear_firewall_policy_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyAssessment>,
    {
        self.firewall_policy_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fraud_prevention_assessment][crate::model::Assessment::fraud_prevention_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// let x = Assessment::new().set_fraud_prevention_assessment(FraudPreventionAssessment::default()/* use setters */);
    /// ```
    pub fn set_fraud_prevention_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FraudPreventionAssessment>,
    {
        self.fraud_prevention_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fraud_prevention_assessment][crate::model::Assessment::fraud_prevention_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// let x = Assessment::new().set_or_clear_fraud_prevention_assessment(Some(FraudPreventionAssessment::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_fraud_prevention_assessment(None::<FraudPreventionAssessment>);
    /// ```
    pub fn set_or_clear_fraud_prevention_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FraudPreventionAssessment>,
    {
        self.fraud_prevention_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fraud_signals][crate::model::Assessment::fraud_signals].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FraudSignals;
    /// let x = Assessment::new().set_fraud_signals(FraudSignals::default()/* use setters */);
    /// ```
    pub fn set_fraud_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FraudSignals>,
    {
        self.fraud_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fraud_signals][crate::model::Assessment::fraud_signals].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FraudSignals;
    /// let x = Assessment::new().set_or_clear_fraud_signals(Some(FraudSignals::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_fraud_signals(None::<FraudSignals>);
    /// ```
    pub fn set_or_clear_fraud_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FraudSignals>,
    {
        self.fraud_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [phone_fraud_assessment][crate::model::Assessment::phone_fraud_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::PhoneFraudAssessment;
    /// let x = Assessment::new().set_phone_fraud_assessment(PhoneFraudAssessment::default()/* use setters */);
    /// ```
    pub fn set_phone_fraud_assessment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhoneFraudAssessment>,
    {
        self.phone_fraud_assessment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phone_fraud_assessment][crate::model::Assessment::phone_fraud_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::PhoneFraudAssessment;
    /// let x = Assessment::new().set_or_clear_phone_fraud_assessment(Some(PhoneFraudAssessment::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_phone_fraud_assessment(None::<PhoneFraudAssessment>);
    /// ```
    pub fn set_or_clear_phone_fraud_assessment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhoneFraudAssessment>,
    {
        self.phone_fraud_assessment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assessment_environment][crate::model::Assessment::assessment_environment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::AssessmentEnvironment;
    /// let x = Assessment::new().set_assessment_environment(AssessmentEnvironment::default()/* use setters */);
    /// ```
    pub fn set_assessment_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssessmentEnvironment>,
    {
        self.assessment_environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assessment_environment][crate::model::Assessment::assessment_environment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Assessment;
    /// use google_cloud_recaptchaenterprise_v1::model::AssessmentEnvironment;
    /// let x = Assessment::new().set_or_clear_assessment_environment(Some(AssessmentEnvironment::default()/* use setters */));
    /// let x = Assessment::new().set_or_clear_assessment_environment(None::<AssessmentEnvironment>);
    /// ```
    pub fn set_or_clear_assessment_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssessmentEnvironment>,
    {
        self.assessment_environment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Assessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Assessment"
    }
}

/// The event being assessed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// Optional. The user response token provided by the reCAPTCHA Enterprise
    /// client-side integration on your site.
    pub token: std::string::String,

    /// Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
    /// site and generate the token.
    pub site_key: std::string::String,

    /// Optional. The user agent present in the request from the user's device
    /// related to this event.
    pub user_agent: std::string::String,

    /// Optional. The IP address in the request from the user's device related to
    /// this event.
    pub user_ip_address: std::string::String,

    /// Optional. The expected action for this type of event. This should be the
    /// same action provided at token generation time on client-side platforms
    /// already integrated with recaptcha enterprise.
    pub expected_action: std::string::String,

    /// Optional. Deprecated: use `user_info.account_id` instead.
    /// Unique stable hashed user identifier for the request. The identifier must
    /// be hashed using hmac-sha256 with stable secret.
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. Flag for a reCAPTCHA express request for an assessment without a
    /// token. If enabled, `site_key` must reference an Express site key.
    pub express: bool,

    /// Optional. The URI resource the user requested that triggered an assessment.
    pub requested_uri: std::string::String,

    /// Optional. Flag for running WAF token assessment.
    /// If enabled, the token must be specified, and have been created by a
    /// WAF-enabled key.
    pub waf_token_assessment: bool,

    /// Optional. JA3 fingerprint for SSL clients. To learn how to compute this
    /// fingerprint, please refer to <https://github.com/salesforce/ja3>.
    pub ja3: std::string::String,

    /// Optional. JA4 fingerprint for SSL clients. To learn how to compute this
    /// fingerprint, please refer to <https://github.com/FoxIO-LLC/ja4>.
    pub ja4: std::string::String,

    /// Optional. HTTP header information about the request.
    pub headers: std::vec::Vec<std::string::String>,

    /// Optional. Flag for enabling firewall policy config assessment.
    /// If this flag is enabled, the firewall policy is evaluated and a
    /// suggested firewall action is returned in the response.
    pub firewall_policy_evaluation: bool,

    /// Optional. Data describing a payment transaction to be assessed. Sending
    /// this data enables reCAPTCHA Enterprise Fraud Prevention and the
    /// FraudPreventionAssessment component in the response.
    pub transaction_data: std::option::Option<crate::model::TransactionData>,

    /// Optional. Information about the user that generates this event, when they
    /// can be identified. They are often identified through the use of an account
    /// for logged-in requests or login/registration requests, or by providing user
    /// identifiers for guest actions like checkout.
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// Optional. The Fraud Prevention setting for this assessment.
    pub fraud_prevention: crate::model::event::FraudPrevention,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::Event::token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_token("example");
    /// ```
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [site_key][crate::model::Event::site_key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_site_key("example");
    /// ```
    pub fn set_site_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site_key = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::Event::user_agent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_user_agent("example");
    /// ```
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [user_ip_address][crate::model::Event::user_ip_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_user_ip_address("example");
    /// ```
    pub fn set_user_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_ip_address = v.into();
        self
    }

    /// Sets the value of [expected_action][crate::model::Event::expected_action].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_expected_action("example");
    /// ```
    pub fn set_expected_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expected_action = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::Event::hashed_account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_hashed_account_id(bytes::Bytes::from_static(b"example"));
    /// ```
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [express][crate::model::Event::express].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_express(true);
    /// ```
    pub fn set_express<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.express = v.into();
        self
    }

    /// Sets the value of [requested_uri][crate::model::Event::requested_uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_requested_uri("example");
    /// ```
    pub fn set_requested_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.requested_uri = v.into();
        self
    }

    /// Sets the value of [waf_token_assessment][crate::model::Event::waf_token_assessment].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_waf_token_assessment(true);
    /// ```
    pub fn set_waf_token_assessment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.waf_token_assessment = v.into();
        self
    }

    /// Sets the value of [ja3][crate::model::Event::ja3].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_ja3("example");
    /// ```
    pub fn set_ja3<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ja3 = v.into();
        self
    }

    /// Sets the value of [ja4][crate::model::Event::ja4].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_ja4("example");
    /// ```
    pub fn set_ja4<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ja4 = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::Event::headers].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_headers(["a", "b", "c"]);
    /// ```
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [firewall_policy_evaluation][crate::model::Event::firewall_policy_evaluation].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// let x = Event::new().set_firewall_policy_evaluation(true);
    /// ```
    pub fn set_firewall_policy_evaluation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.firewall_policy_evaluation = v.into();
        self
    }

    /// Sets the value of [transaction_data][crate::model::Event::transaction_data].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = Event::new().set_transaction_data(TransactionData::default()/* use setters */);
    /// ```
    pub fn set_transaction_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransactionData>,
    {
        self.transaction_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_data][crate::model::Event::transaction_data].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = Event::new().set_or_clear_transaction_data(Some(TransactionData::default()/* use setters */));
    /// let x = Event::new().set_or_clear_transaction_data(None::<TransactionData>);
    /// ```
    pub fn set_or_clear_transaction_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransactionData>,
    {
        self.transaction_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_info][crate::model::Event::user_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// use google_cloud_recaptchaenterprise_v1::model::UserInfo;
    /// let x = Event::new().set_user_info(UserInfo::default()/* use setters */);
    /// ```
    pub fn set_user_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_info][crate::model::Event::user_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// use google_cloud_recaptchaenterprise_v1::model::UserInfo;
    /// let x = Event::new().set_or_clear_user_info(Some(UserInfo::default()/* use setters */));
    /// let x = Event::new().set_or_clear_user_info(None::<UserInfo>);
    /// ```
    pub fn set_or_clear_user_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fraud_prevention][crate::model::Event::fraud_prevention].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Event;
    /// use google_cloud_recaptchaenterprise_v1::model::event::FraudPrevention;
    /// let x0 = Event::new().set_fraud_prevention(FraudPrevention::Enabled);
    /// let x1 = Event::new().set_fraud_prevention(FraudPrevention::Disabled);
    /// ```
    pub fn set_fraud_prevention<T: std::convert::Into<crate::model::event::FraudPrevention>>(
        mut self,
        v: T,
    ) -> Self {
        self.fraud_prevention = v.into();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Event"
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Setting that controls Fraud Prevention assessments.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FraudPrevention {
        /// Default, unspecified setting. `fraud_prevention_assessment` is returned
        /// if `transaction_data` is present in `Event` and Fraud Prevention is
        /// enabled in the Google Cloud console.
        Unspecified,
        /// Enable Fraud Prevention for this assessment, if Fraud Prevention is
        /// enabled in the Google Cloud console.
        Enabled,
        /// Disable Fraud Prevention for this assessment, regardless of the Google
        /// Cloud console settings.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FraudPrevention::value] or
        /// [FraudPrevention::name].
        UnknownValue(fraud_prevention::UnknownValue),
    }

    #[doc(hidden)]
    pub mod fraud_prevention {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FraudPrevention {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FRAUD_PREVENTION_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FraudPrevention {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FraudPrevention {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FraudPrevention {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(fraud_prevention::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FraudPrevention {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FRAUD_PREVENTION_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(fraud_prevention::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FraudPrevention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FraudPrevention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FraudPrevention>::new(
                ".google.cloud.recaptchaenterprise.v1.Event.FraudPrevention",
            ))
        }
    }
}

/// Transaction data associated with a payment protected by reCAPTCHA Enterprise.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TransactionData {
    /// Unique identifier for the transaction. This custom identifier can be used
    /// to reference this transaction in the future, for example, labeling a refund
    /// or chargeback event. Two attempts at the same transaction should use the
    /// same transaction id.
    pub transaction_id: std::option::Option<std::string::String>,

    /// Optional. The payment method for the transaction. The allowed values are:
    ///
    /// * credit-card
    /// * debit-card
    /// * gift-card
    /// * processor-{name} (If a third-party is used, for example,
    ///   processor-paypal)
    /// * custom-{name} (If an alternative method is used, for example,
    ///   custom-crypto)
    pub payment_method: std::string::String,

    /// Optional. The Bank Identification Number - generally the first 6 or 8
    /// digits of the card.
    pub card_bin: std::string::String,

    /// Optional. The last four digits of the card.
    pub card_last_four: std::string::String,

    /// Optional. The currency code in ISO-4217 format.
    pub currency_code: std::string::String,

    /// Optional. The decimal value of the transaction in the specified currency.
    pub value: f64,

    /// Optional. The value of shipping in the specified currency. 0 for free or no
    /// shipping.
    pub shipping_value: f64,

    /// Optional. Destination address if this transaction involves shipping a
    /// physical item.
    pub shipping_address: std::option::Option<crate::model::transaction_data::Address>,

    /// Optional. Address associated with the payment method when applicable.
    pub billing_address: std::option::Option<crate::model::transaction_data::Address>,

    /// Optional. Information about the user paying/initiating the transaction.
    pub user: std::option::Option<crate::model::transaction_data::User>,

    /// Optional. Information about the user or users fulfilling the transaction.
    pub merchants: std::vec::Vec<crate::model::transaction_data::User>,

    /// Optional. Items purchased in this transaction.
    pub items: std::vec::Vec<crate::model::transaction_data::Item>,

    /// Optional. Information about the payment gateway's response to the
    /// transaction.
    pub gateway_info: std::option::Option<crate::model::transaction_data::GatewayInfo>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transaction_id][crate::model::TransactionData::transaction_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_transaction_id("example");
    /// ```
    pub fn set_transaction_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.transaction_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_id][crate::model::TransactionData::transaction_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_or_clear_transaction_id("example");
    /// let x = TransactionData::new().set_or_clear_transaction_id(Some("example"));
    /// let x = TransactionData::new().set_or_clear_transaction_id(None::<String>);
    /// ```
    pub fn set_or_clear_transaction_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.transaction_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payment_method][crate::model::TransactionData::payment_method].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_payment_method("example");
    /// ```
    pub fn set_payment_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payment_method = v.into();
        self
    }

    /// Sets the value of [card_bin][crate::model::TransactionData::card_bin].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_card_bin("example");
    /// ```
    pub fn set_card_bin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.card_bin = v.into();
        self
    }

    /// Sets the value of [card_last_four][crate::model::TransactionData::card_last_four].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_card_last_four("example");
    /// ```
    pub fn set_card_last_four<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.card_last_four = v.into();
        self
    }

    /// Sets the value of [currency_code][crate::model::TransactionData::currency_code].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_currency_code("example");
    /// ```
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TransactionData::value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_value(42.0);
    /// ```
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [shipping_value][crate::model::TransactionData::shipping_value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// let x = TransactionData::new().set_shipping_value(42.0);
    /// ```
    pub fn set_shipping_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.shipping_value = v.into();
        self
    }

    /// Sets the value of [shipping_address][crate::model::TransactionData::shipping_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
    /// let x = TransactionData::new().set_shipping_address(Address::default()/* use setters */);
    /// ```
    pub fn set_shipping_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.shipping_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shipping_address][crate::model::TransactionData::shipping_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
    /// let x = TransactionData::new().set_or_clear_shipping_address(Some(Address::default()/* use setters */));
    /// let x = TransactionData::new().set_or_clear_shipping_address(None::<Address>);
    /// ```
    pub fn set_or_clear_shipping_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.shipping_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [billing_address][crate::model::TransactionData::billing_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
    /// let x = TransactionData::new().set_billing_address(Address::default()/* use setters */);
    /// ```
    pub fn set_billing_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.billing_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [billing_address][crate::model::TransactionData::billing_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
    /// let x = TransactionData::new().set_or_clear_billing_address(Some(Address::default()/* use setters */));
    /// let x = TransactionData::new().set_or_clear_billing_address(None::<Address>);
    /// ```
    pub fn set_or_clear_billing_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::Address>,
    {
        self.billing_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::TransactionData::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
    /// let x = TransactionData::new().set_user(User::default()/* use setters */);
    /// ```
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::TransactionData::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
    /// let x = TransactionData::new().set_or_clear_user(Some(User::default()/* use setters */));
    /// let x = TransactionData::new().set_or_clear_user(None::<User>);
    /// ```
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [merchants][crate::model::TransactionData::merchants].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
    /// let x = TransactionData::new()
    ///     .set_merchants([
    ///         User::default()/* use setters */,
    ///         User::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_merchants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transaction_data::User>,
    {
        use std::iter::Iterator;
        self.merchants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [items][crate::model::TransactionData::items].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::Item;
    /// let x = TransactionData::new()
    ///     .set_items([
    ///         Item::default()/* use setters */,
    ///         Item::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transaction_data::Item>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gateway_info][crate::model::TransactionData::gateway_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::GatewayInfo;
    /// let x = TransactionData::new().set_gateway_info(GatewayInfo::default()/* use setters */);
    /// ```
    pub fn set_gateway_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::GatewayInfo>,
    {
        self.gateway_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gateway_info][crate::model::TransactionData::gateway_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TransactionData;
    /// use google_cloud_recaptchaenterprise_v1::model::transaction_data::GatewayInfo;
    /// let x = TransactionData::new().set_or_clear_gateway_info(Some(GatewayInfo::default()/* use setters */));
    /// let x = TransactionData::new().set_or_clear_gateway_info(None::<GatewayInfo>);
    /// ```
    pub fn set_or_clear_gateway_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::transaction_data::GatewayInfo>,
    {
        self.gateway_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransactionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData"
    }
}

/// Defines additional types related to [TransactionData].
pub mod transaction_data {
    #[allow(unused_imports)]
    use super::*;

    /// Structured address format for billing and shipping addresses.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Address {
        /// Optional. The recipient name, potentially including information such as
        /// "care of".
        pub recipient: std::string::String,

        /// Optional. The first lines of the address. The first line generally
        /// contains the street name and number, and further lines may include
        /// information such as an apartment number.
        pub address: std::vec::Vec<std::string::String>,

        /// Optional. The town/city of the address.
        pub locality: std::string::String,

        /// Optional. The state, province, or otherwise administrative area of the
        /// address.
        pub administrative_area: std::string::String,

        /// Optional. The CLDR country/region of the address.
        pub region_code: std::string::String,

        /// Optional. The postal or ZIP code of the address.
        pub postal_code: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Address {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recipient][crate::model::transaction_data::Address::recipient].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
        /// let x = Address::new().set_recipient("example");
        /// ```
        pub fn set_recipient<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.recipient = v.into();
            self
        }

        /// Sets the value of [address][crate::model::transaction_data::Address::address].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
        /// let x = Address::new().set_address(["a", "b", "c"]);
        /// ```
        pub fn set_address<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.address = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [locality][crate::model::transaction_data::Address::locality].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
        /// let x = Address::new().set_locality("example");
        /// ```
        pub fn set_locality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.locality = v.into();
            self
        }

        /// Sets the value of [administrative_area][crate::model::transaction_data::Address::administrative_area].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
        /// let x = Address::new().set_administrative_area("example");
        /// ```
        pub fn set_administrative_area<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.administrative_area = v.into();
            self
        }

        /// Sets the value of [region_code][crate::model::transaction_data::Address::region_code].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
        /// let x = Address::new().set_region_code("example");
        /// ```
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [postal_code][crate::model::transaction_data::Address::postal_code].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Address;
        /// let x = Address::new().set_postal_code("example");
        /// ```
        pub fn set_postal_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.postal_code = v.into();
            self
        }
    }

    impl wkt::message::Message for Address {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.Address"
        }
    }

    /// Details about a user's account involved in the transaction.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct User {
        /// Optional. Unique account identifier for this user. If using account
        /// defender, this should match the hashed_account_id field. Otherwise, a
        /// unique and persistent identifier for this account.
        pub account_id: std::string::String,

        /// Optional. The epoch milliseconds of the user's account creation.
        pub creation_ms: i64,

        /// Optional. The email address of the user.
        pub email: std::string::String,

        /// Optional. Whether the email has been verified to be accessible by the
        /// user (OTP or similar).
        pub email_verified: bool,

        /// Optional. The phone number of the user, with country code.
        pub phone_number: std::string::String,

        /// Optional. Whether the phone number has been verified to be accessible by
        /// the user (OTP or similar).
        pub phone_verified: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl User {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [account_id][crate::model::transaction_data::User::account_id].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
        /// let x = User::new().set_account_id("example");
        /// ```
        pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.account_id = v.into();
            self
        }

        /// Sets the value of [creation_ms][crate::model::transaction_data::User::creation_ms].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
        /// let x = User::new().set_creation_ms(42);
        /// ```
        pub fn set_creation_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.creation_ms = v.into();
            self
        }

        /// Sets the value of [email][crate::model::transaction_data::User::email].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
        /// let x = User::new().set_email("example");
        /// ```
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }

        /// Sets the value of [email_verified][crate::model::transaction_data::User::email_verified].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
        /// let x = User::new().set_email_verified(true);
        /// ```
        pub fn set_email_verified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.email_verified = v.into();
            self
        }

        /// Sets the value of [phone_number][crate::model::transaction_data::User::phone_number].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
        /// let x = User::new().set_phone_number("example");
        /// ```
        pub fn set_phone_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.phone_number = v.into();
            self
        }

        /// Sets the value of [phone_verified][crate::model::transaction_data::User::phone_verified].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::User;
        /// let x = User::new().set_phone_verified(true);
        /// ```
        pub fn set_phone_verified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.phone_verified = v.into();
            self
        }
    }

    impl wkt::message::Message for User {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.User"
        }
    }

    /// Line items being purchased in this transaction.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Item {
        /// Optional. The full name of the item.
        pub name: std::string::String,

        /// Optional. The value per item that the user is paying, in the transaction
        /// currency, after discounts.
        pub value: f64,

        /// Optional. The quantity of this item that is being purchased.
        pub quantity: i64,

        /// Optional. When a merchant is specified, its corresponding account_id.
        /// Necessary to populate marketplace-style transactions.
        pub merchant_account_id: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Item {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::transaction_data::Item::name].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Item;
        /// let x = Item::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::transaction_data::Item::value].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Item;
        /// let x = Item::new().set_value(42.0);
        /// ```
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [quantity][crate::model::transaction_data::Item::quantity].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Item;
        /// let x = Item::new().set_quantity(42);
        /// ```
        pub fn set_quantity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.quantity = v.into();
            self
        }

        /// Sets the value of [merchant_account_id][crate::model::transaction_data::Item::merchant_account_id].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::Item;
        /// let x = Item::new().set_merchant_account_id("example");
        /// ```
        pub fn set_merchant_account_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.merchant_account_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Item {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.Item"
        }
    }

    /// Details about the transaction from the gateway.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GatewayInfo {
        /// Optional. Name of the gateway service (for example, stripe, square,
        /// paypal).
        pub name: std::string::String,

        /// Optional. Gateway response code describing the state of the transaction.
        pub gateway_response_code: std::string::String,

        /// Optional. AVS response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        pub avs_response_code: std::string::String,

        /// Optional. CVV response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        pub cvv_response_code: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GatewayInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::transaction_data::GatewayInfo::name].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::GatewayInfo;
        /// let x = GatewayInfo::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [gateway_response_code][crate::model::transaction_data::GatewayInfo::gateway_response_code].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::GatewayInfo;
        /// let x = GatewayInfo::new().set_gateway_response_code("example");
        /// ```
        pub fn set_gateway_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gateway_response_code = v.into();
            self
        }

        /// Sets the value of [avs_response_code][crate::model::transaction_data::GatewayInfo::avs_response_code].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::GatewayInfo;
        /// let x = GatewayInfo::new().set_avs_response_code("example");
        /// ```
        pub fn set_avs_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.avs_response_code = v.into();
            self
        }

        /// Sets the value of [cvv_response_code][crate::model::transaction_data::GatewayInfo::cvv_response_code].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::transaction_data::GatewayInfo;
        /// let x = GatewayInfo::new().set_cvv_response_code("example");
        /// ```
        pub fn set_cvv_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cvv_response_code = v.into();
            self
        }
    }

    impl wkt::message::Message for GatewayInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo"
        }
    }
}

/// User information associated with a request protected by reCAPTCHA Enterprise.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserInfo {
    /// Optional. Creation time for this account associated with this user. Leave
    /// blank for non logged-in actions, guest checkout, or when there is no
    /// account associated with the current user.
    pub create_account_time: std::option::Option<wkt::Timestamp>,

    /// Optional. For logged-in requests or login/registration requests, the unique
    /// account identifier associated with this user. You can use the username if
    /// it is stable (meaning it is the same for every request associated with the
    /// same user), or any stable user ID of your choice. Leave blank for non
    /// logged-in actions or guest checkout.
    pub account_id: std::string::String,

    /// Optional. Identifiers associated with this user or request.
    pub user_ids: std::vec::Vec<crate::model::UserId>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_account_time][crate::model::UserInfo::create_account_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserInfo;
    /// use wkt::Timestamp;
    /// let x = UserInfo::new().set_create_account_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_account_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_account_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_account_time][crate::model::UserInfo::create_account_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserInfo;
    /// use wkt::Timestamp;
    /// let x = UserInfo::new().set_or_clear_create_account_time(Some(Timestamp::default()/* use setters */));
    /// let x = UserInfo::new().set_or_clear_create_account_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_account_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_account_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_id][crate::model::UserInfo::account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserInfo;
    /// let x = UserInfo::new().set_account_id("example");
    /// ```
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [user_ids][crate::model::UserInfo::user_ids].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserInfo;
    /// use google_cloud_recaptchaenterprise_v1::model::UserId;
    /// let x = UserInfo::new()
    ///     .set_user_ids([
    ///         UserId::default()/* use setters */,
    ///         UserId::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_user_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserId>,
    {
        use std::iter::Iterator;
        self.user_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UserInfo"
    }
}

/// An identifier associated with a user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserId {
    pub id_oneof: std::option::Option<crate::model::user_id::IdOneof>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof].
    ///
    /// Note that all the setters affecting `id_oneof` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserId;
    /// use google_cloud_recaptchaenterprise_v1::model::user_id;
    /// let x = UserId::new().set_id_oneof(Some(user_id::IdOneof::Email("example".to_string())));
    /// ```
    pub fn set_id_oneof<
        T: std::convert::Into<std::option::Option<crate::model::user_id::IdOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.id_oneof = v.into();
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `Email`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::Email(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `Email`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserId;
    /// let x = UserId::new().set_email("example");
    /// assert!(x.email().is_some());
    /// assert!(x.phone_number().is_none());
    /// assert!(x.username().is_none());
    /// ```
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof = std::option::Option::Some(crate::model::user_id::IdOneof::Email(v.into()));
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `PhoneNumber`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::PhoneNumber(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `PhoneNumber`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserId;
    /// let x = UserId::new().set_phone_number("example");
    /// assert!(x.phone_number().is_some());
    /// assert!(x.email().is_none());
    /// assert!(x.username().is_none());
    /// ```
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof =
            std::option::Option::Some(crate::model::user_id::IdOneof::PhoneNumber(v.into()));
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `Username`, `None` if the field is not set or
    /// holds a different branch.
    pub fn username(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::Username(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `Username`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UserId;
    /// let x = UserId::new().set_username("example");
    /// assert!(x.username().is_some());
    /// assert!(x.email().is_none());
    /// assert!(x.phone_number().is_none());
    /// ```
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof =
            std::option::Option::Some(crate::model::user_id::IdOneof::Username(v.into()));
        self
    }
}

impl wkt::message::Message for UserId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UserId"
    }
}

/// Defines additional types related to [UserId].
pub mod user_id {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IdOneof {
        /// Optional. An email address.
        Email(std::string::String),
        /// Optional. A phone number. Should use the E.164 format.
        PhoneNumber(std::string::String),
        /// Optional. A unique username, if different from all the other identifiers
        /// and `account_id` that are provided. Can be a unique login handle or
        /// display name for a user.
        Username(std::string::String),
    }
}

/// Risk analysis result for an event.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RiskAnalysis {
    /// Output only. Legitimate event score from 0.0 to 1.0.
    /// (1.0 means very likely legitimate traffic while 0.0 means very likely
    /// non-legitimate traffic).
    pub score: f32,

    /// Output only. Reasons contributing to the risk analysis verdict.
    pub reasons: std::vec::Vec<crate::model::risk_analysis::ClassificationReason>,

    /// Output only. Extended verdict reasons to be used for experimentation only.
    /// The set of possible reasons is subject to change.
    pub extended_verdict_reasons: std::vec::Vec<std::string::String>,

    /// Output only. Challenge information for SCORE_AND_CHALLENGE and INVISIBLE
    /// keys
    pub challenge: crate::model::risk_analysis::Challenge,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiskAnalysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::RiskAnalysis::score].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RiskAnalysis;
    /// let x = RiskAnalysis::new().set_score(42.0);
    /// ```
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::RiskAnalysis::reasons].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RiskAnalysis;
    /// use google_cloud_recaptchaenterprise_v1::model::risk_analysis::ClassificationReason;
    /// let x = RiskAnalysis::new().set_reasons([
    ///     ClassificationReason::Automation,
    ///     ClassificationReason::UnexpectedEnvironment,
    ///     ClassificationReason::TooMuchTraffic,
    /// ]);
    /// ```
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::risk_analysis::ClassificationReason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [extended_verdict_reasons][crate::model::RiskAnalysis::extended_verdict_reasons].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RiskAnalysis;
    /// let x = RiskAnalysis::new().set_extended_verdict_reasons(["a", "b", "c"]);
    /// ```
    pub fn set_extended_verdict_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.extended_verdict_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [challenge][crate::model::RiskAnalysis::challenge].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RiskAnalysis;
    /// use google_cloud_recaptchaenterprise_v1::model::risk_analysis::Challenge;
    /// let x0 = RiskAnalysis::new().set_challenge(Challenge::Nocaptcha);
    /// let x1 = RiskAnalysis::new().set_challenge(Challenge::Passed);
    /// let x2 = RiskAnalysis::new().set_challenge(Challenge::Failed);
    /// ```
    pub fn set_challenge<T: std::convert::Into<crate::model::risk_analysis::Challenge>>(
        mut self,
        v: T,
    ) -> Self {
        self.challenge = v.into();
        self
    }
}

impl wkt::message::Message for RiskAnalysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RiskAnalysis"
    }
}

/// Defines additional types related to [RiskAnalysis].
pub mod risk_analysis {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons contributing to the risk analysis verdict.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClassificationReason {
        /// Default unspecified type.
        Unspecified,
        /// Interactions matched the behavior of an automated agent.
        Automation,
        /// The event originated from an illegitimate environment.
        UnexpectedEnvironment,
        /// Traffic volume from the event source is higher than normal.
        TooMuchTraffic,
        /// Interactions with the site were significantly different than expected
        /// patterns.
        UnexpectedUsagePatterns,
        /// Too little traffic has been received from this site thus far to generate
        /// quality risk analysis.
        LowConfidenceScore,
        /// The request matches behavioral characteristics of a carding attack.
        SuspectedCarding,
        /// The request matches behavioral characteristics of chargebacks for fraud.
        SuspectedChargeback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClassificationReason::value] or
        /// [ClassificationReason::name].
        UnknownValue(classification_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod classification_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClassificationReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automation => std::option::Option::Some(1),
                Self::UnexpectedEnvironment => std::option::Option::Some(2),
                Self::TooMuchTraffic => std::option::Option::Some(3),
                Self::UnexpectedUsagePatterns => std::option::Option::Some(4),
                Self::LowConfidenceScore => std::option::Option::Some(5),
                Self::SuspectedCarding => std::option::Option::Some(6),
                Self::SuspectedChargeback => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLASSIFICATION_REASON_UNSPECIFIED"),
                Self::Automation => std::option::Option::Some("AUTOMATION"),
                Self::UnexpectedEnvironment => std::option::Option::Some("UNEXPECTED_ENVIRONMENT"),
                Self::TooMuchTraffic => std::option::Option::Some("TOO_MUCH_TRAFFIC"),
                Self::UnexpectedUsagePatterns => {
                    std::option::Option::Some("UNEXPECTED_USAGE_PATTERNS")
                }
                Self::LowConfidenceScore => std::option::Option::Some("LOW_CONFIDENCE_SCORE"),
                Self::SuspectedCarding => std::option::Option::Some("SUSPECTED_CARDING"),
                Self::SuspectedChargeback => std::option::Option::Some("SUSPECTED_CHARGEBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClassificationReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClassificationReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClassificationReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automation,
                2 => Self::UnexpectedEnvironment,
                3 => Self::TooMuchTraffic,
                4 => Self::UnexpectedUsagePatterns,
                5 => Self::LowConfidenceScore,
                6 => Self::SuspectedCarding,
                7 => Self::SuspectedChargeback,
                _ => Self::UnknownValue(classification_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClassificationReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLASSIFICATION_REASON_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATION" => Self::Automation,
                "UNEXPECTED_ENVIRONMENT" => Self::UnexpectedEnvironment,
                "TOO_MUCH_TRAFFIC" => Self::TooMuchTraffic,
                "UNEXPECTED_USAGE_PATTERNS" => Self::UnexpectedUsagePatterns,
                "LOW_CONFIDENCE_SCORE" => Self::LowConfidenceScore,
                "SUSPECTED_CARDING" => Self::SuspectedCarding,
                "SUSPECTED_CHARGEBACK" => Self::SuspectedChargeback,
                _ => Self::UnknownValue(classification_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClassificationReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automation => serializer.serialize_i32(1),
                Self::UnexpectedEnvironment => serializer.serialize_i32(2),
                Self::TooMuchTraffic => serializer.serialize_i32(3),
                Self::UnexpectedUsagePatterns => serializer.serialize_i32(4),
                Self::LowConfidenceScore => serializer.serialize_i32(5),
                Self::SuspectedCarding => serializer.serialize_i32(6),
                Self::SuspectedChargeback => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClassificationReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClassificationReason>::new(
                ".google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason",
            ))
        }
    }

    /// Challenge information for SCORE_AND_CHALLENGE and INVISIBLE keys
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Challenge {
        /// Default unspecified type.
        Unspecified,
        /// No challenge was presented for solving.
        Nocaptcha,
        /// A solution was submitted that was correct.
        Passed,
        /// A solution was submitted that was incorrect or otherwise
        /// deemed suspicious.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Challenge::value] or
        /// [Challenge::name].
        UnknownValue(challenge::UnknownValue),
    }

    #[doc(hidden)]
    pub mod challenge {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Challenge {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nocaptcha => std::option::Option::Some(1),
                Self::Passed => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHALLENGE_UNSPECIFIED"),
                Self::Nocaptcha => std::option::Option::Some("NOCAPTCHA"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Challenge {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Challenge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Challenge {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nocaptcha,
                2 => Self::Passed,
                3 => Self::Failed,
                _ => Self::UnknownValue(challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Challenge {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHALLENGE_UNSPECIFIED" => Self::Unspecified,
                "NOCAPTCHA" => Self::Nocaptcha,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Challenge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nocaptcha => serializer.serialize_i32(1),
                Self::Passed => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Challenge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Challenge>::new(
                ".google.cloud.recaptchaenterprise.v1.RiskAnalysis.Challenge",
            ))
        }
    }
}

/// Properties of the provided event token.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TokenProperties {
    /// Output only. Whether the provided user response token is valid. When valid
    /// = false, the reason could be specified in invalid_reason or it could also
    /// be due to a user failing to solve a challenge or a sitekey mismatch (i.e
    /// the sitekey used to generate the token was different than the one specified
    /// in the assessment).
    pub valid: bool,

    /// Output only. Reason associated with the response when valid = false.
    pub invalid_reason: crate::model::token_properties::InvalidReason,

    /// Output only. The timestamp corresponding to the generation of the token.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The hostname of the page on which the token was generated (Web
    /// keys only).
    pub hostname: std::string::String,

    /// Output only. The name of the Android package with which the token was
    /// generated (Android keys only).
    pub android_package_name: std::string::String,

    /// Output only. The ID of the iOS bundle with which the token was generated
    /// (iOS keys only).
    pub ios_bundle_id: std::string::String,

    /// Output only. Action name provided at token generation.
    pub action: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TokenProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [valid][crate::model::TokenProperties::valid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = TokenProperties::new().set_valid(true);
    /// ```
    pub fn set_valid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.valid = v.into();
        self
    }

    /// Sets the value of [invalid_reason][crate::model::TokenProperties::invalid_reason].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// use google_cloud_recaptchaenterprise_v1::model::token_properties::InvalidReason;
    /// let x0 = TokenProperties::new().set_invalid_reason(InvalidReason::UnknownInvalidReason);
    /// let x1 = TokenProperties::new().set_invalid_reason(InvalidReason::Malformed);
    /// let x2 = TokenProperties::new().set_invalid_reason(InvalidReason::Expired);
    /// ```
    pub fn set_invalid_reason<
        T: std::convert::Into<crate::model::token_properties::InvalidReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.invalid_reason = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TokenProperties::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// use wkt::Timestamp;
    /// let x = TokenProperties::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TokenProperties::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// use wkt::Timestamp;
    /// let x = TokenProperties::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = TokenProperties::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hostname][crate::model::TokenProperties::hostname].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = TokenProperties::new().set_hostname("example");
    /// ```
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [android_package_name][crate::model::TokenProperties::android_package_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = TokenProperties::new().set_android_package_name("example");
    /// ```
    pub fn set_android_package_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.android_package_name = v.into();
        self
    }

    /// Sets the value of [ios_bundle_id][crate::model::TokenProperties::ios_bundle_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = TokenProperties::new().set_ios_bundle_id("example");
    /// ```
    pub fn set_ios_bundle_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ios_bundle_id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::TokenProperties::action].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TokenProperties;
    /// let x = TokenProperties::new().set_action("example");
    /// ```
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }
}

impl wkt::message::Message for TokenProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TokenProperties"
    }
}

/// Defines additional types related to [TokenProperties].
pub mod token_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the types of invalid token reasons.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InvalidReason {
        /// Default unspecified type.
        Unspecified,
        /// If the failure reason was not accounted for.
        UnknownInvalidReason,
        /// The provided user verification token was malformed.
        Malformed,
        /// The user verification token had expired.
        Expired,
        /// The user verification had already been seen.
        Dupe,
        /// The user verification token was not present.
        Missing,
        /// A retriable error (such as network failure) occurred on the browser.
        /// Could easily be simulated by an attacker.
        BrowserError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InvalidReason::value] or
        /// [InvalidReason::name].
        UnknownValue(invalid_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod invalid_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InvalidReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownInvalidReason => std::option::Option::Some(1),
                Self::Malformed => std::option::Option::Some(2),
                Self::Expired => std::option::Option::Some(3),
                Self::Dupe => std::option::Option::Some(4),
                Self::Missing => std::option::Option::Some(5),
                Self::BrowserError => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INVALID_REASON_UNSPECIFIED"),
                Self::UnknownInvalidReason => std::option::Option::Some("UNKNOWN_INVALID_REASON"),
                Self::Malformed => std::option::Option::Some("MALFORMED"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::Dupe => std::option::Option::Some("DUPE"),
                Self::Missing => std::option::Option::Some("MISSING"),
                Self::BrowserError => std::option::Option::Some("BROWSER_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InvalidReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InvalidReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InvalidReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownInvalidReason,
                2 => Self::Malformed,
                3 => Self::Expired,
                4 => Self::Dupe,
                5 => Self::Missing,
                6 => Self::BrowserError,
                _ => Self::UnknownValue(invalid_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InvalidReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INVALID_REASON_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_INVALID_REASON" => Self::UnknownInvalidReason,
                "MALFORMED" => Self::Malformed,
                "EXPIRED" => Self::Expired,
                "DUPE" => Self::Dupe,
                "MISSING" => Self::Missing,
                "BROWSER_ERROR" => Self::BrowserError,
                _ => Self::UnknownValue(invalid_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InvalidReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownInvalidReason => serializer.serialize_i32(1),
                Self::Malformed => serializer.serialize_i32(2),
                Self::Expired => serializer.serialize_i32(3),
                Self::Dupe => serializer.serialize_i32(4),
                Self::Missing => serializer.serialize_i32(5),
                Self::BrowserError => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InvalidReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InvalidReason>::new(
                ".google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason",
            ))
        }
    }
}

/// Assessment for Fraud Prevention.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FraudPreventionAssessment {
    /// Output only. Probability of this transaction being fraudulent. Summarizes
    /// the combined risk of attack vectors below. Values are from 0.0 (lowest)
    /// to 1.0 (highest).
    pub transaction_risk: f32,

    /// Output only. Assessment of this transaction for risk of a stolen
    /// instrument.
    pub stolen_instrument_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,

    /// Output only. Assessment of this transaction for risk of being part of a
    /// card testing attack.
    pub card_testing_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::CardTestingVerdict>,

    /// Output only. Assessment of this transaction for behavioral trust.
    pub behavioral_trust_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FraudPreventionAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transaction_risk][crate::model::FraudPreventionAssessment::transaction_risk].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// let x = FraudPreventionAssessment::new().set_transaction_risk(42.0);
    /// ```
    pub fn set_transaction_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.transaction_risk = v.into();
        self
    }

    /// Sets the value of [stolen_instrument_verdict][crate::model::FraudPreventionAssessment::stolen_instrument_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::StolenInstrumentVerdict;
    /// let x = FraudPreventionAssessment::new().set_stolen_instrument_verdict(StolenInstrumentVerdict::default()/* use setters */);
    /// ```
    pub fn set_stolen_instrument_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,
    {
        self.stolen_instrument_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stolen_instrument_verdict][crate::model::FraudPreventionAssessment::stolen_instrument_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::StolenInstrumentVerdict;
    /// let x = FraudPreventionAssessment::new().set_or_clear_stolen_instrument_verdict(Some(StolenInstrumentVerdict::default()/* use setters */));
    /// let x = FraudPreventionAssessment::new().set_or_clear_stolen_instrument_verdict(None::<StolenInstrumentVerdict>);
    /// ```
    pub fn set_or_clear_stolen_instrument_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,
    {
        self.stolen_instrument_verdict = v.map(|x| x.into());
        self
    }

    /// Sets the value of [card_testing_verdict][crate::model::FraudPreventionAssessment::card_testing_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::CardTestingVerdict;
    /// let x = FraudPreventionAssessment::new().set_card_testing_verdict(CardTestingVerdict::default()/* use setters */);
    /// ```
    pub fn set_card_testing_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::CardTestingVerdict>,
    {
        self.card_testing_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [card_testing_verdict][crate::model::FraudPreventionAssessment::card_testing_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::CardTestingVerdict;
    /// let x = FraudPreventionAssessment::new().set_or_clear_card_testing_verdict(Some(CardTestingVerdict::default()/* use setters */));
    /// let x = FraudPreventionAssessment::new().set_or_clear_card_testing_verdict(None::<CardTestingVerdict>);
    /// ```
    pub fn set_or_clear_card_testing_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::CardTestingVerdict>,
    {
        self.card_testing_verdict = v.map(|x| x.into());
        self
    }

    /// Sets the value of [behavioral_trust_verdict][crate::model::FraudPreventionAssessment::behavioral_trust_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::BehavioralTrustVerdict;
    /// let x = FraudPreventionAssessment::new().set_behavioral_trust_verdict(BehavioralTrustVerdict::default()/* use setters */);
    /// ```
    pub fn set_behavioral_trust_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,
    {
        self.behavioral_trust_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [behavioral_trust_verdict][crate::model::FraudPreventionAssessment::behavioral_trust_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudPreventionAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::BehavioralTrustVerdict;
    /// let x = FraudPreventionAssessment::new().set_or_clear_behavioral_trust_verdict(Some(BehavioralTrustVerdict::default()/* use setters */));
    /// let x = FraudPreventionAssessment::new().set_or_clear_behavioral_trust_verdict(None::<BehavioralTrustVerdict>);
    /// ```
    pub fn set_or_clear_behavioral_trust_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,
    {
        self.behavioral_trust_verdict = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FraudPreventionAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment"
    }
}

/// Defines additional types related to [FraudPreventionAssessment].
pub mod fraud_prevention_assessment {
    #[allow(unused_imports)]
    use super::*;

    /// Information about stolen instrument fraud, where the user is not the
    /// legitimate owner of the instrument being used for the purchase.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StolenInstrumentVerdict {
        /// Output only. Probability of this transaction being executed with a stolen
        /// instrument. Values are from 0.0 (lowest) to 1.0 (highest).
        pub risk: f32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StolenInstrumentVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [risk][crate::model::fraud_prevention_assessment::StolenInstrumentVerdict::risk].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::StolenInstrumentVerdict;
        /// let x = StolenInstrumentVerdict::new().set_risk(42.0);
        /// ```
        pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.risk = v.into();
            self
        }
    }

    impl wkt::message::Message for StolenInstrumentVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict"
        }
    }

    /// Information about card testing fraud, where an adversary is testing
    /// fraudulently obtained cards or brute forcing their details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CardTestingVerdict {
        /// Output only. Probability of this transaction attempt being part of a card
        /// testing attack. Values are from 0.0 (lowest) to 1.0 (highest).
        pub risk: f32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CardTestingVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [risk][crate::model::fraud_prevention_assessment::CardTestingVerdict::risk].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::CardTestingVerdict;
        /// let x = CardTestingVerdict::new().set_risk(42.0);
        /// ```
        pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.risk = v.into();
            self
        }
    }

    impl wkt::message::Message for CardTestingVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict"
        }
    }

    /// Information about behavioral trust of the transaction.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BehavioralTrustVerdict {
        /// Output only. Probability of this transaction attempt being executed in a
        /// behaviorally trustworthy way. Values are from 0.0 (lowest) to 1.0
        /// (highest).
        pub trust: f32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BehavioralTrustVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trust][crate::model::fraud_prevention_assessment::BehavioralTrustVerdict::trust].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::fraud_prevention_assessment::BehavioralTrustVerdict;
        /// let x = BehavioralTrustVerdict::new().set_trust(42.0);
        /// ```
        pub fn set_trust<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.trust = v.into();
            self
        }
    }

    impl wkt::message::Message for BehavioralTrustVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict"
        }
    }
}

/// Fraud signals describing users and cards involved in the transaction.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FraudSignals {
    /// Output only. Signals describing the end user in this transaction.
    pub user_signals: std::option::Option<crate::model::fraud_signals::UserSignals>,

    /// Output only. Signals describing the payment card or cards used in this
    /// transaction.
    pub card_signals: std::option::Option<crate::model::fraud_signals::CardSignals>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FraudSignals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_signals][crate::model::FraudSignals::user_signals].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudSignals;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_signals::UserSignals;
    /// let x = FraudSignals::new().set_user_signals(UserSignals::default()/* use setters */);
    /// ```
    pub fn set_user_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::UserSignals>,
    {
        self.user_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_signals][crate::model::FraudSignals::user_signals].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudSignals;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_signals::UserSignals;
    /// let x = FraudSignals::new().set_or_clear_user_signals(Some(UserSignals::default()/* use setters */));
    /// let x = FraudSignals::new().set_or_clear_user_signals(None::<UserSignals>);
    /// ```
    pub fn set_or_clear_user_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::UserSignals>,
    {
        self.user_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [card_signals][crate::model::FraudSignals::card_signals].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudSignals;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_signals::CardSignals;
    /// let x = FraudSignals::new().set_card_signals(CardSignals::default()/* use setters */);
    /// ```
    pub fn set_card_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::CardSignals>,
    {
        self.card_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [card_signals][crate::model::FraudSignals::card_signals].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FraudSignals;
    /// use google_cloud_recaptchaenterprise_v1::model::fraud_signals::CardSignals;
    /// let x = FraudSignals::new().set_or_clear_card_signals(Some(CardSignals::default()/* use setters */));
    /// let x = FraudSignals::new().set_or_clear_card_signals(None::<CardSignals>);
    /// ```
    pub fn set_or_clear_card_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fraud_signals::CardSignals>,
    {
        self.card_signals = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FraudSignals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals"
    }
}

/// Defines additional types related to [FraudSignals].
pub mod fraud_signals {
    #[allow(unused_imports)]
    use super::*;

    /// Signals describing the user involved in this transaction.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserSignals {
        /// Output only. This user (based on email, phone, and other identifiers) has
        /// been seen on the internet for at least this number of days.
        pub active_days_lower_bound: i32,

        /// Output only. Likelihood (from 0.0 to 1.0) this user includes synthetic
        /// components in their identity, such as a randomly generated email address,
        /// temporary phone number, or fake shipping address.
        pub synthetic_risk: f32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [active_days_lower_bound][crate::model::fraud_signals::UserSignals::active_days_lower_bound].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::fraud_signals::UserSignals;
        /// let x = UserSignals::new().set_active_days_lower_bound(42);
        /// ```
        pub fn set_active_days_lower_bound<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.active_days_lower_bound = v.into();
            self
        }

        /// Sets the value of [synthetic_risk][crate::model::fraud_signals::UserSignals::synthetic_risk].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::fraud_signals::UserSignals;
        /// let x = UserSignals::new().set_synthetic_risk(42.0);
        /// ```
        pub fn set_synthetic_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.synthetic_risk = v.into();
            self
        }
    }

    impl wkt::message::Message for UserSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals"
        }
    }

    /// Signals describing the payment card used in this transaction.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CardSignals {
        /// Output only. The labels for the payment card in this transaction.
        pub card_labels: std::vec::Vec<crate::model::fraud_signals::card_signals::CardLabel>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CardSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [card_labels][crate::model::fraud_signals::CardSignals::card_labels].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::fraud_signals::CardSignals;
        /// use google_cloud_recaptchaenterprise_v1::model::fraud_signals::card_signals::CardLabel;
        /// let x = CardSignals::new().set_card_labels([
        ///     CardLabel::Prepaid,
        ///     CardLabel::Virtual,
        ///     CardLabel::UnexpectedLocation,
        /// ]);
        /// ```
        pub fn set_card_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::fraud_signals::card_signals::CardLabel>,
        {
            use std::iter::Iterator;
            self.card_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CardSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals"
        }
    }

    /// Defines additional types related to [CardSignals].
    pub mod card_signals {
        #[allow(unused_imports)]
        use super::*;

        /// Risk labels describing the card being assessed, such as its funding
        /// mechanism.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CardLabel {
            /// No label specified.
            Unspecified,
            /// This card has been detected as prepaid.
            Prepaid,
            /// This card has been detected as virtual, such as a card number generated
            /// for a single transaction or merchant.
            Virtual,
            /// This card has been detected as being used in an unexpected geographic
            /// location.
            UnexpectedLocation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [CardLabel::value] or
            /// [CardLabel::name].
            UnknownValue(card_label::UnknownValue),
        }

        #[doc(hidden)]
        pub mod card_label {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl CardLabel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Prepaid => std::option::Option::Some(1),
                    Self::Virtual => std::option::Option::Some(2),
                    Self::UnexpectedLocation => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CARD_LABEL_UNSPECIFIED"),
                    Self::Prepaid => std::option::Option::Some("PREPAID"),
                    Self::Virtual => std::option::Option::Some("VIRTUAL"),
                    Self::UnexpectedLocation => std::option::Option::Some("UNEXPECTED_LOCATION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for CardLabel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for CardLabel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for CardLabel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Prepaid,
                    2 => Self::Virtual,
                    3 => Self::UnexpectedLocation,
                    _ => Self::UnknownValue(card_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for CardLabel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CARD_LABEL_UNSPECIFIED" => Self::Unspecified,
                    "PREPAID" => Self::Prepaid,
                    "VIRTUAL" => Self::Virtual,
                    "UNEXPECTED_LOCATION" => Self::UnexpectedLocation,
                    _ => Self::UnknownValue(card_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for CardLabel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Prepaid => serializer.serialize_i32(1),
                    Self::Virtual => serializer.serialize_i32(2),
                    Self::UnexpectedLocation => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for CardLabel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<CardLabel>::new(
                    ".google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel",
                ))
            }
        }
    }
}

/// Information about SMS toll fraud.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SmsTollFraudVerdict {
    /// Output only. Probability of an SMS event being fraudulent.
    /// Values are from 0.0 (lowest) to 1.0 (highest).
    pub risk: f32,

    /// Output only. Reasons contributing to the SMS toll fraud verdict.
    pub reasons: std::vec::Vec<crate::model::sms_toll_fraud_verdict::SmsTollFraudReason>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmsTollFraudVerdict {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [risk][crate::model::SmsTollFraudVerdict::risk].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SmsTollFraudVerdict;
    /// let x = SmsTollFraudVerdict::new().set_risk(42.0);
    /// ```
    pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.risk = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::SmsTollFraudVerdict::reasons].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SmsTollFraudVerdict;
    /// use google_cloud_recaptchaenterprise_v1::model::sms_toll_fraud_verdict::SmsTollFraudReason;
    /// let x = SmsTollFraudVerdict::new().set_reasons([
    ///     SmsTollFraudReason::InvalidPhoneNumber,
    /// ]);
    /// ```
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sms_toll_fraud_verdict::SmsTollFraudReason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SmsTollFraudVerdict {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict"
    }
}

/// Defines additional types related to [SmsTollFraudVerdict].
pub mod sms_toll_fraud_verdict {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons contributing to the SMS toll fraud verdict.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SmsTollFraudReason {
        /// Default unspecified reason
        Unspecified,
        /// The provided phone number was invalid
        InvalidPhoneNumber,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SmsTollFraudReason::value] or
        /// [SmsTollFraudReason::name].
        UnknownValue(sms_toll_fraud_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sms_toll_fraud_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SmsTollFraudReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InvalidPhoneNumber => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SMS_TOLL_FRAUD_REASON_UNSPECIFIED"),
                Self::InvalidPhoneNumber => std::option::Option::Some("INVALID_PHONE_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SmsTollFraudReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SmsTollFraudReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SmsTollFraudReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InvalidPhoneNumber,
                _ => Self::UnknownValue(sms_toll_fraud_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SmsTollFraudReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SMS_TOLL_FRAUD_REASON_UNSPECIFIED" => Self::Unspecified,
                "INVALID_PHONE_NUMBER" => Self::InvalidPhoneNumber,
                _ => Self::UnknownValue(sms_toll_fraud_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SmsTollFraudReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InvalidPhoneNumber => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SmsTollFraudReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SmsTollFraudReason>::new(
                ".google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason",
            ))
        }
    }
}

/// Assessment for Phone Fraud
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhoneFraudAssessment {
    /// Output only. Assessment of this phone event for risk of SMS toll fraud.
    pub sms_toll_fraud_verdict: std::option::Option<crate::model::SmsTollFraudVerdict>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhoneFraudAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sms_toll_fraud_verdict][crate::model::PhoneFraudAssessment::sms_toll_fraud_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::PhoneFraudAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::SmsTollFraudVerdict;
    /// let x = PhoneFraudAssessment::new().set_sms_toll_fraud_verdict(SmsTollFraudVerdict::default()/* use setters */);
    /// ```
    pub fn set_sms_toll_fraud_verdict<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SmsTollFraudVerdict>,
    {
        self.sms_toll_fraud_verdict = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sms_toll_fraud_verdict][crate::model::PhoneFraudAssessment::sms_toll_fraud_verdict].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::PhoneFraudAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::SmsTollFraudVerdict;
    /// let x = PhoneFraudAssessment::new().set_or_clear_sms_toll_fraud_verdict(Some(SmsTollFraudVerdict::default()/* use setters */));
    /// let x = PhoneFraudAssessment::new().set_or_clear_sms_toll_fraud_verdict(None::<SmsTollFraudVerdict>);
    /// ```
    pub fn set_or_clear_sms_toll_fraud_verdict<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SmsTollFraudVerdict>,
    {
        self.sms_toll_fraud_verdict = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PhoneFraudAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment"
    }
}

/// Account defender risk assessment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AccountDefenderAssessment {
    /// Output only. Labels for this request.
    pub labels: std::vec::Vec<crate::model::account_defender_assessment::AccountDefenderLabel>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountDefenderAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::AccountDefenderAssessment::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AccountDefenderAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::account_defender_assessment::AccountDefenderLabel;
    /// let x = AccountDefenderAssessment::new().set_labels([
    ///     AccountDefenderLabel::ProfileMatch,
    ///     AccountDefenderLabel::SuspiciousLoginActivity,
    ///     AccountDefenderLabel::SuspiciousAccountCreation,
    /// ]);
    /// ```
    pub fn set_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::account_defender_assessment::AccountDefenderLabel>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccountDefenderAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment"
    }
}

/// Defines additional types related to [AccountDefenderAssessment].
pub mod account_defender_assessment {
    #[allow(unused_imports)]
    use super::*;

    /// Labels returned by account defender for this request.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccountDefenderLabel {
        /// Default unspecified type.
        Unspecified,
        /// The request matches a known good profile for the user.
        ProfileMatch,
        /// The request is potentially a suspicious login event and must be further
        /// verified either through multi-factor authentication or another system.
        SuspiciousLoginActivity,
        /// The request matched a profile that previously had suspicious account
        /// creation behavior. This can mean that this is a fake account.
        SuspiciousAccountCreation,
        /// The account in the request has a high number of related accounts. It does
        /// not necessarily imply that the account is bad but can require further
        /// investigation.
        RelatedAccountsNumberHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccountDefenderLabel::value] or
        /// [AccountDefenderLabel::name].
        UnknownValue(account_defender_label::UnknownValue),
    }

    #[doc(hidden)]
    pub mod account_defender_label {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccountDefenderLabel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ProfileMatch => std::option::Option::Some(1),
                Self::SuspiciousLoginActivity => std::option::Option::Some(2),
                Self::SuspiciousAccountCreation => std::option::Option::Some(3),
                Self::RelatedAccountsNumberHigh => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("ACCOUNT_DEFENDER_LABEL_UNSPECIFIED")
                }
                Self::ProfileMatch => std::option::Option::Some("PROFILE_MATCH"),
                Self::SuspiciousLoginActivity => {
                    std::option::Option::Some("SUSPICIOUS_LOGIN_ACTIVITY")
                }
                Self::SuspiciousAccountCreation => {
                    std::option::Option::Some("SUSPICIOUS_ACCOUNT_CREATION")
                }
                Self::RelatedAccountsNumberHigh => {
                    std::option::Option::Some("RELATED_ACCOUNTS_NUMBER_HIGH")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccountDefenderLabel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccountDefenderLabel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccountDefenderLabel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ProfileMatch,
                2 => Self::SuspiciousLoginActivity,
                3 => Self::SuspiciousAccountCreation,
                4 => Self::RelatedAccountsNumberHigh,
                _ => Self::UnknownValue(account_defender_label::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccountDefenderLabel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED" => Self::Unspecified,
                "PROFILE_MATCH" => Self::ProfileMatch,
                "SUSPICIOUS_LOGIN_ACTIVITY" => Self::SuspiciousLoginActivity,
                "SUSPICIOUS_ACCOUNT_CREATION" => Self::SuspiciousAccountCreation,
                "RELATED_ACCOUNTS_NUMBER_HIGH" => Self::RelatedAccountsNumberHigh,
                _ => Self::UnknownValue(account_defender_label::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccountDefenderLabel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ProfileMatch => serializer.serialize_i32(1),
                Self::SuspiciousLoginActivity => serializer.serialize_i32(2),
                Self::SuspiciousAccountCreation => serializer.serialize_i32(3),
                Self::RelatedAccountsNumberHigh => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccountDefenderLabel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccountDefenderLabel>::new(
                ".google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel"))
        }
    }
}

/// The create key request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKeyRequest {
    /// Required. The name of the project in which the key is created, in the
    /// format `projects/{project}`.
    pub parent: std::string::String,

    /// Required. Information to create a reCAPTCHA Enterprise key.
    pub key: std::option::Option<crate::model::Key>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateKeyRequest;
    /// let x = CreateKeyRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key][crate::model::CreateKeyRequest::key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateKeyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = CreateKeyRequest::new().set_key(Key::default()/* use setters */);
    /// ```
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::CreateKeyRequest::key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateKeyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = CreateKeyRequest::new().set_or_clear_key(Some(Key::default()/* use setters */));
    /// let x = CreateKeyRequest::new().set_or_clear_key(None::<Key>);
    /// ```
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateKeyRequest"
    }
}

/// The list keys request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeysRequest {
    /// Required. The name of the project that contains the keys that is
    /// listed, in the format `projects/{project}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of keys to return. Default is 10. Max limit is
    /// 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous.
    /// ListKeysRequest, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeysRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListKeysRequest;
    /// let x = ListKeysRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeysRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListKeysRequest;
    /// let x = ListKeysRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeysRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListKeysRequest;
    /// let x = ListKeysRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListKeysRequest"
    }
}

/// Response to request to list keys in a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKeysResponse {
    /// Key details.
    pub keys: std::vec::Vec<crate::model::Key>,

    /// Token to retrieve the next page of results. It is set to empty if no keys
    /// remain in results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::ListKeysResponse::keys].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListKeysResponse;
    /// use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = ListKeysResponse::new()
    ///     .set_keys([
    ///         Key::default()/* use setters */,
    ///         Key::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Key>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKeysResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListKeysResponse;
    /// let x = ListKeysResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKeysResponse {
    type PageItem = crate::model::Key;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The retrieve legacy secret key request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveLegacySecretKeyRequest {
    /// Required. The public key name linked to the requested secret key in the
    /// format `projects/{project}/keys/{key}`.
    pub key: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveLegacySecretKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::RetrieveLegacySecretKeyRequest::key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RetrieveLegacySecretKeyRequest;
    /// let x = RetrieveLegacySecretKeyRequest::new().set_key("example");
    /// ```
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveLegacySecretKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyRequest"
    }
}

/// The get key request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetKeyRequest {
    /// Required. The name of the requested key, in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::GetKeyRequest;
    /// let x = GetKeyRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetKeyRequest"
    }
}

/// The update key request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateKeyRequest {
    /// Required. The key to update.
    pub key: std::option::Option<crate::model::Key>,

    /// Optional. The mask to control which fields of the key get updated. If the
    /// mask is not present, all fields are updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::UpdateKeyRequest::key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateKeyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = UpdateKeyRequest::new().set_key(Key::default()/* use setters */);
    /// ```
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::UpdateKeyRequest::key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateKeyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = UpdateKeyRequest::new().set_or_clear_key(Some(Key::default()/* use setters */));
    /// let x = UpdateKeyRequest::new().set_or_clear_key(None::<Key>);
    /// ```
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Key>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateKeyRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateKeyRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateKeyRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateKeyRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateKeyRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateKeyRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateKeyRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UpdateKeyRequest"
    }
}

/// The delete key request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteKeyRequest {
    /// Required. The name of the key to be deleted, in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteKeyRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::DeleteKeyRequest;
    /// let x = DeleteKeyRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.DeleteKeyRequest"
    }
}

/// The create firewall policy request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFirewallPolicyRequest {
    /// Required. The name of the project this policy applies to, in the format
    /// `projects/{project}`.
    pub parent: std::string::String,

    /// Required. Information to create the policy.
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFirewallPolicyRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateFirewallPolicyRequest;
    /// let x = CreateFirewallPolicyRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [firewall_policy][crate::model::CreateFirewallPolicyRequest::firewall_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateFirewallPolicyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = CreateFirewallPolicyRequest::new().set_firewall_policy(FirewallPolicy::default()/* use setters */);
    /// ```
    pub fn set_firewall_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy][crate::model::CreateFirewallPolicyRequest::firewall_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::CreateFirewallPolicyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = CreateFirewallPolicyRequest::new().set_or_clear_firewall_policy(Some(FirewallPolicy::default()/* use setters */));
    /// let x = CreateFirewallPolicyRequest::new().set_or_clear_firewall_policy(None::<FirewallPolicy>);
    /// ```
    pub fn set_or_clear_firewall_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateFirewallPolicyRequest"
    }
}

/// The list firewall policies request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of policies to return. Default is 10. Max
    /// limit is 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous.
    /// ListFirewallPoliciesRequest, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFirewallPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFirewallPoliciesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListFirewallPoliciesRequest;
    /// let x = ListFirewallPoliciesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFirewallPoliciesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListFirewallPoliciesRequest;
    /// let x = ListFirewallPoliciesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFirewallPoliciesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListFirewallPoliciesRequest;
    /// let x = ListFirewallPoliciesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFirewallPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesRequest"
    }
}

/// Response to request to list firewall policies belonging to a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFirewallPoliciesResponse {
    /// Policy details.
    pub firewall_policies: std::vec::Vec<crate::model::FirewallPolicy>,

    /// Token to retrieve the next page of results. It is set to empty if no
    /// policies remain in results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFirewallPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policies][crate::model::ListFirewallPoliciesResponse::firewall_policies].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListFirewallPoliciesResponse;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = ListFirewallPoliciesResponse::new()
    ///     .set_firewall_policies([
    ///         FirewallPolicy::default()/* use setters */,
    ///         FirewallPolicy::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_firewall_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicy>,
    {
        use std::iter::Iterator;
        self.firewall_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFirewallPoliciesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListFirewallPoliciesResponse;
    /// let x = ListFirewallPoliciesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFirewallPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFirewallPoliciesResponse {
    type PageItem = crate::model::FirewallPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.firewall_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The get firewall policy request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFirewallPolicyRequest {
    /// Required. The name of the requested policy, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFirewallPolicyRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::GetFirewallPolicyRequest;
    /// let x = GetFirewallPolicyRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetFirewallPolicyRequest"
    }
}

/// The update firewall policy request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFirewallPolicyRequest {
    /// Required. The policy to update.
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    /// Optional. The mask to control which fields of the policy get updated. If
    /// the mask is not present, all fields are updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policy][crate::model::UpdateFirewallPolicyRequest::firewall_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateFirewallPolicyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = UpdateFirewallPolicyRequest::new().set_firewall_policy(FirewallPolicy::default()/* use setters */);
    /// ```
    pub fn set_firewall_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy][crate::model::UpdateFirewallPolicyRequest::firewall_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateFirewallPolicyRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = UpdateFirewallPolicyRequest::new().set_or_clear_firewall_policy(Some(FirewallPolicy::default()/* use setters */));
    /// let x = UpdateFirewallPolicyRequest::new().set_or_clear_firewall_policy(None::<FirewallPolicy>);
    /// ```
    pub fn set_or_clear_firewall_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFirewallPolicyRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateFirewallPolicyRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateFirewallPolicyRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFirewallPolicyRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::UpdateFirewallPolicyRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateFirewallPolicyRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateFirewallPolicyRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UpdateFirewallPolicyRequest"
    }
}

/// The delete firewall policy request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFirewallPolicyRequest {
    /// Required. The name of the policy to be deleted, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFirewallPolicyRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::DeleteFirewallPolicyRequest;
    /// let x = DeleteFirewallPolicyRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.DeleteFirewallPolicyRequest"
    }
}

/// The reorder firewall policies request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReorderFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    pub parent: std::string::String,

    /// Required. A list containing all policy names, in the new order. Each name
    /// is in the format `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub names: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReorderFirewallPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReorderFirewallPoliciesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ReorderFirewallPoliciesRequest;
    /// let x = ReorderFirewallPoliciesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::ReorderFirewallPoliciesRequest::names].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ReorderFirewallPoliciesRequest;
    /// let x = ReorderFirewallPoliciesRequest::new().set_names(["a", "b", "c"]);
    /// ```
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReorderFirewallPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesRequest"
    }
}

/// The reorder firewall policies response message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReorderFirewallPoliciesResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReorderFirewallPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReorderFirewallPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesResponse"
    }
}

/// The migrate key request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrateKeyRequest {
    /// Required. The name of the key to be migrated, in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Optional. If true, skips the billing check.
    /// A reCAPTCHA Enterprise key or migrated key behaves differently than a
    /// reCAPTCHA (non-Enterprise version) key when you reach a quota limit (see
    /// <https://cloud.google.com/recaptcha/quotas#quota_limit>). To avoid
    /// any disruption of your usage, we check that a billing account is present.
    /// If your usage of reCAPTCHA is under the free quota, you can safely skip the
    /// billing check and proceed with the migration. See
    /// <https://cloud.google.com/recaptcha/docs/billing-information>.
    pub skip_billing_check: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrateKeyRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::MigrateKeyRequest;
    /// let x = MigrateKeyRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_billing_check][crate::model::MigrateKeyRequest::skip_billing_check].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::MigrateKeyRequest;
    /// let x = MigrateKeyRequest::new().set_skip_billing_check(true);
    /// ```
    pub fn set_skip_billing_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_billing_check = v.into();
        self
    }
}

impl wkt::message::Message for MigrateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.MigrateKeyRequest"
    }
}

/// The get metrics request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMetricsRequest {
    /// Required. The name of the requested metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetricsRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::GetMetricsRequest;
    /// let x = GetMetricsRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetMetricsRequest"
    }
}

/// Metrics for a single Key.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Metrics {
    /// Output only. Identifier. The name of the metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    pub name: std::string::String,

    /// Inclusive start time aligned to a day in the America/Los_Angeles (Pacific)
    /// timezone.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. All Key types should have score-based data.
    pub score_metrics: std::vec::Vec<crate::model::ScoreMetrics>,

    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. Only challenge-based keys (CHECKBOX, INVISIBLE) have
    /// challenge-based data.
    pub challenge_metrics: std::vec::Vec<crate::model::ChallengeMetrics>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Metrics::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Metrics;
    /// let x = Metrics::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Metrics::start_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Metrics;
    /// use wkt::Timestamp;
    /// let x = Metrics::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Metrics::start_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Metrics;
    /// use wkt::Timestamp;
    /// let x = Metrics::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = Metrics::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [score_metrics][crate::model::Metrics::score_metrics].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Metrics;
    /// use google_cloud_recaptchaenterprise_v1::model::ScoreMetrics;
    /// let x = Metrics::new()
    ///     .set_score_metrics([
    ///         ScoreMetrics::default()/* use setters */,
    ///         ScoreMetrics::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_score_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScoreMetrics>,
    {
        use std::iter::Iterator;
        self.score_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [challenge_metrics][crate::model::Metrics::challenge_metrics].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Metrics;
    /// use google_cloud_recaptchaenterprise_v1::model::ChallengeMetrics;
    /// let x = Metrics::new()
    ///     .set_challenge_metrics([
    ///         ChallengeMetrics::default()/* use setters */,
    ///         ChallengeMetrics::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_challenge_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChallengeMetrics>,
    {
        use std::iter::Iterator;
        self.challenge_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Metrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Metrics"
    }
}

/// Secret key is used only in legacy reCAPTCHA. It must be used in a 3rd party
/// integration with legacy reCAPTCHA.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetrieveLegacySecretKeyResponse {
    /// The secret key (also known as shared secret) authorizes communication
    /// between your application backend and the reCAPTCHA Enterprise server to
    /// create an assessment.
    /// The secret key needs to be kept safe for security purposes.
    pub legacy_secret_key: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveLegacySecretKeyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [legacy_secret_key][crate::model::RetrieveLegacySecretKeyResponse::legacy_secret_key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RetrieveLegacySecretKeyResponse;
    /// let x = RetrieveLegacySecretKeyResponse::new().set_legacy_secret_key("example");
    /// ```
    pub fn set_legacy_secret_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_secret_key = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveLegacySecretKeyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyResponse"
    }
}

/// A key used to identify and configure applications (web and/or mobile) that
/// use reCAPTCHA Enterprise.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Key {
    /// Identifier. The resource name for the Key in the format
    /// `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Required. Human-readable display name of this key. Modifiable by user.
    pub display_name: std::string::String,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/recaptcha/docs/labels>).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The timestamp corresponding to the creation of this key.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Options for user acceptance testing.
    pub testing_options: std::option::Option<crate::model::TestingOptions>,

    /// Optional. Settings for WAF
    pub waf_settings: std::option::Option<crate::model::WafSettings>,

    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    pub platform_settings: std::option::Option<crate::model::key::PlatformSettings>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Key {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Key::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = Key::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Key::display_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = Key::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Key::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// let x = Key::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Key::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use wkt::Timestamp;
    /// let x = Key::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Key::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use wkt::Timestamp;
    /// let x = Key::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Key::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [testing_options][crate::model::Key::testing_options].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::TestingOptions;
    /// let x = Key::new().set_testing_options(TestingOptions::default()/* use setters */);
    /// ```
    pub fn set_testing_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestingOptions>,
    {
        self.testing_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [testing_options][crate::model::Key::testing_options].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::TestingOptions;
    /// let x = Key::new().set_or_clear_testing_options(Some(TestingOptions::default()/* use setters */));
    /// let x = Key::new().set_or_clear_testing_options(None::<TestingOptions>);
    /// ```
    pub fn set_or_clear_testing_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestingOptions>,
    {
        self.testing_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [waf_settings][crate::model::Key::waf_settings].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::WafSettings;
    /// let x = Key::new().set_waf_settings(WafSettings::default()/* use setters */);
    /// ```
    pub fn set_waf_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WafSettings>,
    {
        self.waf_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [waf_settings][crate::model::Key::waf_settings].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::WafSettings;
    /// let x = Key::new().set_or_clear_waf_settings(Some(WafSettings::default()/* use setters */));
    /// let x = Key::new().set_or_clear_waf_settings(None::<WafSettings>);
    /// ```
    pub fn set_or_clear_waf_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WafSettings>,
    {
        self.waf_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings].
    ///
    /// Note that all the setters affecting `platform_settings` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::key;
    /// use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// let x = Key::new().set_platform_settings(Some(key::PlatformSettings::WebSettings(WebKeySettings::default().into())));
    /// ```
    pub fn set_platform_settings<
        T: std::convert::Into<std::option::Option<crate::model::key::PlatformSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = v.into();
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `WebSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn web_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WebKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::WebSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `WebSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// let x = Key::new().set_web_settings(WebKeySettings::default()/* use setters */);
    /// assert!(x.web_settings().is_some());
    /// assert!(x.android_settings().is_none());
    /// assert!(x.ios_settings().is_none());
    /// assert!(x.express_settings().is_none());
    /// ```
    pub fn set_web_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::WebKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings =
            std::option::Option::Some(crate::model::key::PlatformSettings::WebSettings(v.into()));
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `AndroidSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn android_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AndroidKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::AndroidSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `AndroidSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::AndroidKeySettings;
    /// let x = Key::new().set_android_settings(AndroidKeySettings::default()/* use setters */);
    /// assert!(x.android_settings().is_some());
    /// assert!(x.web_settings().is_none());
    /// assert!(x.ios_settings().is_none());
    /// assert!(x.express_settings().is_none());
    /// ```
    pub fn set_android_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::AndroidKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = std::option::Option::Some(
            crate::model::key::PlatformSettings::AndroidSettings(v.into()),
        );
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `IosSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ios_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IOSKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::IosSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `IosSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::IOSKeySettings;
    /// let x = Key::new().set_ios_settings(IOSKeySettings::default()/* use setters */);
    /// assert!(x.ios_settings().is_some());
    /// assert!(x.web_settings().is_none());
    /// assert!(x.android_settings().is_none());
    /// assert!(x.express_settings().is_none());
    /// ```
    pub fn set_ios_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::IOSKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings =
            std::option::Option::Some(crate::model::key::PlatformSettings::IosSettings(v.into()));
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `ExpressSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn express_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExpressKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::ExpressSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `ExpressSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::Key;
    /// use google_cloud_recaptchaenterprise_v1::model::ExpressKeySettings;
    /// let x = Key::new().set_express_settings(ExpressKeySettings::default()/* use setters */);
    /// assert!(x.express_settings().is_some());
    /// assert!(x.web_settings().is_none());
    /// assert!(x.android_settings().is_none());
    /// assert!(x.ios_settings().is_none());
    /// ```
    pub fn set_express_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::ExpressKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = std::option::Option::Some(
            crate::model::key::PlatformSettings::ExpressSettings(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Key {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Key"
    }
}

/// Defines additional types related to [Key].
pub mod key {
    #[allow(unused_imports)]
    use super::*;

    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PlatformSettings {
        /// Settings for keys that can be used by websites.
        WebSettings(std::boxed::Box<crate::model::WebKeySettings>),
        /// Settings for keys that can be used by Android apps.
        AndroidSettings(std::boxed::Box<crate::model::AndroidKeySettings>),
        /// Settings for keys that can be used by iOS apps.
        IosSettings(std::boxed::Box<crate::model::IOSKeySettings>),
        /// Settings for keys that can be used by reCAPTCHA Express.
        ExpressSettings(std::boxed::Box<crate::model::ExpressKeySettings>),
    }
}

/// Options for user acceptance testing.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TestingOptions {
    /// Optional. All assessments for this Key return this score. Must be between 0
    /// (likely not legitimate) and 1 (likely legitimate) inclusive.
    pub testing_score: f32,

    /// Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all
    /// challenge requests for this site return nocaptcha if NOCAPTCHA, or an
    /// unsolvable challenge if CHALLENGE.
    pub testing_challenge: crate::model::testing_options::TestingChallenge,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestingOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [testing_score][crate::model::TestingOptions::testing_score].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TestingOptions;
    /// let x = TestingOptions::new().set_testing_score(42.0);
    /// ```
    pub fn set_testing_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.testing_score = v.into();
        self
    }

    /// Sets the value of [testing_challenge][crate::model::TestingOptions::testing_challenge].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::TestingOptions;
    /// use google_cloud_recaptchaenterprise_v1::model::testing_options::TestingChallenge;
    /// let x0 = TestingOptions::new().set_testing_challenge(TestingChallenge::Nocaptcha);
    /// let x1 = TestingOptions::new().set_testing_challenge(TestingChallenge::UnsolvableChallenge);
    /// ```
    pub fn set_testing_challenge<
        T: std::convert::Into<crate::model::testing_options::TestingChallenge>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.testing_challenge = v.into();
        self
    }
}

impl wkt::message::Message for TestingOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TestingOptions"
    }
}

/// Defines additional types related to [TestingOptions].
pub mod testing_options {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the challenge option for challenge-based (CHECKBOX,
    /// INVISIBLE) testing keys.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TestingChallenge {
        /// Perform the normal risk analysis and return either nocaptcha or a
        /// challenge depending on risk and trust factors.
        Unspecified,
        /// Challenge requests for this key always return a nocaptcha, which
        /// does not require a solution.
        Nocaptcha,
        /// Challenge requests for this key always return an unsolvable
        /// challenge.
        UnsolvableChallenge,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TestingChallenge::value] or
        /// [TestingChallenge::name].
        UnknownValue(testing_challenge::UnknownValue),
    }

    #[doc(hidden)]
    pub mod testing_challenge {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TestingChallenge {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nocaptcha => std::option::Option::Some(1),
                Self::UnsolvableChallenge => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TESTING_CHALLENGE_UNSPECIFIED"),
                Self::Nocaptcha => std::option::Option::Some("NOCAPTCHA"),
                Self::UnsolvableChallenge => std::option::Option::Some("UNSOLVABLE_CHALLENGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TestingChallenge {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TestingChallenge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TestingChallenge {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nocaptcha,
                2 => Self::UnsolvableChallenge,
                _ => Self::UnknownValue(testing_challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TestingChallenge {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TESTING_CHALLENGE_UNSPECIFIED" => Self::Unspecified,
                "NOCAPTCHA" => Self::Nocaptcha,
                "UNSOLVABLE_CHALLENGE" => Self::UnsolvableChallenge,
                _ => Self::UnknownValue(testing_challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TestingChallenge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nocaptcha => serializer.serialize_i32(1),
                Self::UnsolvableChallenge => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TestingChallenge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestingChallenge>::new(
                ".google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge",
            ))
        }
    }
}

/// Settings specific to keys that can be used by websites.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WebKeySettings {
    /// Optional. If set to true, it means allowed_domains are not enforced.
    pub allow_all_domains: bool,

    /// Optional. Domains or subdomains of websites allowed to use the key. All
    /// subdomains of an allowed domain are automatically allowed. A valid domain
    /// requires a host and must not include any path, port, query or fragment.
    /// Examples: 'example.com' or 'subdomain.example.com'
    pub allowed_domains: std::vec::Vec<std::string::String>,

    /// Optional. If set to true, the key can be used on AMP (Accelerated Mobile
    /// Pages) websites. This is supported only for the SCORE integration type.
    pub allow_amp_traffic: bool,

    /// Required. Describes how this key is integrated with the website.
    pub integration_type: crate::model::web_key_settings::IntegrationType,

    /// Optional. Settings for the frequency and difficulty at which this key
    /// triggers captcha challenges. This should only be specified for
    /// IntegrationTypes CHECKBOX and INVISIBLE and SCORE_AND_CHALLENGE.
    pub challenge_security_preference: crate::model::web_key_settings::ChallengeSecurityPreference,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_domains][crate::model::WebKeySettings::allow_all_domains].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// let x = WebKeySettings::new().set_allow_all_domains(true);
    /// ```
    pub fn set_allow_all_domains<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_domains = v.into();
        self
    }

    /// Sets the value of [allowed_domains][crate::model::WebKeySettings::allowed_domains].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// let x = WebKeySettings::new().set_allowed_domains(["a", "b", "c"]);
    /// ```
    pub fn set_allowed_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_amp_traffic][crate::model::WebKeySettings::allow_amp_traffic].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// let x = WebKeySettings::new().set_allow_amp_traffic(true);
    /// ```
    pub fn set_allow_amp_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_amp_traffic = v.into();
        self
    }

    /// Sets the value of [integration_type][crate::model::WebKeySettings::integration_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// use google_cloud_recaptchaenterprise_v1::model::web_key_settings::IntegrationType;
    /// let x0 = WebKeySettings::new().set_integration_type(IntegrationType::Score);
    /// let x1 = WebKeySettings::new().set_integration_type(IntegrationType::Checkbox);
    /// let x2 = WebKeySettings::new().set_integration_type(IntegrationType::Invisible);
    /// ```
    pub fn set_integration_type<
        T: std::convert::Into<crate::model::web_key_settings::IntegrationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.integration_type = v.into();
        self
    }

    /// Sets the value of [challenge_security_preference][crate::model::WebKeySettings::challenge_security_preference].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WebKeySettings;
    /// use google_cloud_recaptchaenterprise_v1::model::web_key_settings::ChallengeSecurityPreference;
    /// let x0 = WebKeySettings::new().set_challenge_security_preference(ChallengeSecurityPreference::Usability);
    /// let x1 = WebKeySettings::new().set_challenge_security_preference(ChallengeSecurityPreference::Balance);
    /// let x2 = WebKeySettings::new().set_challenge_security_preference(ChallengeSecurityPreference::Security);
    /// ```
    pub fn set_challenge_security_preference<
        T: std::convert::Into<crate::model::web_key_settings::ChallengeSecurityPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.challenge_security_preference = v.into();
        self
    }
}

impl wkt::message::Message for WebKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.WebKeySettings"
    }
}

/// Defines additional types related to [WebKeySettings].
pub mod web_key_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the integration types for web keys.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IntegrationType {
        /// Default type that indicates this enum hasn't been specified. This is not
        /// a valid IntegrationType, one of the other types must be specified
        /// instead.
        Unspecified,
        /// Only used to produce scores. It doesn't display the "I'm not a robot"
        /// checkbox and never shows captcha challenges.
        Score,
        /// Displays the "I'm not a robot" checkbox and may show captcha challenges
        /// after it is checked.
        Checkbox,
        /// Doesn't display the "I'm not a robot" checkbox, but may show captcha
        /// challenges after risk analysis.
        Invisible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IntegrationType::value] or
        /// [IntegrationType::name].
        UnknownValue(integration_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod integration_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IntegrationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Score => std::option::Option::Some(1),
                Self::Checkbox => std::option::Option::Some(2),
                Self::Invisible => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INTEGRATION_TYPE_UNSPECIFIED"),
                Self::Score => std::option::Option::Some("SCORE"),
                Self::Checkbox => std::option::Option::Some("CHECKBOX"),
                Self::Invisible => std::option::Option::Some("INVISIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IntegrationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IntegrationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IntegrationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Score,
                2 => Self::Checkbox,
                3 => Self::Invisible,
                _ => Self::UnknownValue(integration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IntegrationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTEGRATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCORE" => Self::Score,
                "CHECKBOX" => Self::Checkbox,
                "INVISIBLE" => Self::Invisible,
                _ => Self::UnknownValue(integration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IntegrationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Score => serializer.serialize_i32(1),
                Self::Checkbox => serializer.serialize_i32(2),
                Self::Invisible => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IntegrationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntegrationType>::new(
                ".google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType",
            ))
        }
    }

    /// Enum that represents the possible challenge frequency and difficulty
    /// configurations for a web key.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ChallengeSecurityPreference {
        /// Default type that indicates this enum hasn't been specified.
        Unspecified,
        /// Key tends to show fewer and easier challenges.
        Usability,
        /// Key tends to show balanced (in amount and difficulty) challenges.
        Balance,
        /// Key tends to show more and harder challenges.
        Security,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ChallengeSecurityPreference::value] or
        /// [ChallengeSecurityPreference::name].
        UnknownValue(challenge_security_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod challenge_security_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ChallengeSecurityPreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Usability => std::option::Option::Some(1),
                Self::Balance => std::option::Option::Some(2),
                Self::Security => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED")
                }
                Self::Usability => std::option::Option::Some("USABILITY"),
                Self::Balance => std::option::Option::Some("BALANCE"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ChallengeSecurityPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ChallengeSecurityPreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ChallengeSecurityPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Usability,
                2 => Self::Balance,
                3 => Self::Security,
                _ => Self::UnknownValue(challenge_security_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ChallengeSecurityPreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "USABILITY" => Self::Usability,
                "BALANCE" => Self::Balance,
                "SECURITY" => Self::Security,
                _ => Self::UnknownValue(challenge_security_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ChallengeSecurityPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Usability => serializer.serialize_i32(1),
                Self::Balance => serializer.serialize_i32(2),
                Self::Security => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ChallengeSecurityPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChallengeSecurityPreference>::new(
                ".google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference"))
        }
    }
}

/// Settings specific to keys that can be used by Android apps.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AndroidKeySettings {
    /// Optional. If set to true, allowed_package_names are not enforced.
    pub allow_all_package_names: bool,

    /// Optional. Android package names of apps allowed to use the key.
    /// Example: 'com.companyname.appname'
    pub allowed_package_names: std::vec::Vec<std::string::String>,

    /// Optional. Set to true for keys that are used in an Android application that
    /// is available for download in app stores in addition to the Google Play
    /// Store.
    pub support_non_google_app_store_distribution: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AndroidKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_package_names][crate::model::AndroidKeySettings::allow_all_package_names].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AndroidKeySettings;
    /// let x = AndroidKeySettings::new().set_allow_all_package_names(true);
    /// ```
    pub fn set_allow_all_package_names<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_package_names = v.into();
        self
    }

    /// Sets the value of [allowed_package_names][crate::model::AndroidKeySettings::allowed_package_names].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AndroidKeySettings;
    /// let x = AndroidKeySettings::new().set_allowed_package_names(["a", "b", "c"]);
    /// ```
    pub fn set_allowed_package_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_package_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [support_non_google_app_store_distribution][crate::model::AndroidKeySettings::support_non_google_app_store_distribution].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AndroidKeySettings;
    /// let x = AndroidKeySettings::new().set_support_non_google_app_store_distribution(true);
    /// ```
    pub fn set_support_non_google_app_store_distribution<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.support_non_google_app_store_distribution = v.into();
        self
    }
}

impl wkt::message::Message for AndroidKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AndroidKeySettings"
    }
}

/// Settings specific to keys that can be used by iOS apps.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IOSKeySettings {
    /// Optional. If set to true, allowed_bundle_ids are not enforced.
    pub allow_all_bundle_ids: bool,

    /// Optional. iOS bundle ids of apps allowed to use the key.
    /// Example: 'com.companyname.productname.appname'
    pub allowed_bundle_ids: std::vec::Vec<std::string::String>,

    /// Optional. Apple Developer account details for the app that is protected by
    /// the reCAPTCHA Key. reCAPTCHA leverages platform-specific checks like Apple
    /// App Attest and Apple DeviceCheck to protect your app from abuse. Providing
    /// these fields allows reCAPTCHA to get a better assessment of the integrity
    /// of your app.
    pub apple_developer_id: std::option::Option<crate::model::AppleDeveloperId>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IOSKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_bundle_ids][crate::model::IOSKeySettings::allow_all_bundle_ids].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::IOSKeySettings;
    /// let x = IOSKeySettings::new().set_allow_all_bundle_ids(true);
    /// ```
    pub fn set_allow_all_bundle_ids<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_bundle_ids = v.into();
        self
    }

    /// Sets the value of [allowed_bundle_ids][crate::model::IOSKeySettings::allowed_bundle_ids].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::IOSKeySettings;
    /// let x = IOSKeySettings::new().set_allowed_bundle_ids(["a", "b", "c"]);
    /// ```
    pub fn set_allowed_bundle_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_bundle_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [apple_developer_id][crate::model::IOSKeySettings::apple_developer_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::IOSKeySettings;
    /// use google_cloud_recaptchaenterprise_v1::model::AppleDeveloperId;
    /// let x = IOSKeySettings::new().set_apple_developer_id(AppleDeveloperId::default()/* use setters */);
    /// ```
    pub fn set_apple_developer_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppleDeveloperId>,
    {
        self.apple_developer_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [apple_developer_id][crate::model::IOSKeySettings::apple_developer_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::IOSKeySettings;
    /// use google_cloud_recaptchaenterprise_v1::model::AppleDeveloperId;
    /// let x = IOSKeySettings::new().set_or_clear_apple_developer_id(Some(AppleDeveloperId::default()/* use setters */));
    /// let x = IOSKeySettings::new().set_or_clear_apple_developer_id(None::<AppleDeveloperId>);
    /// ```
    pub fn set_or_clear_apple_developer_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppleDeveloperId>,
    {
        self.apple_developer_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IOSKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.IOSKeySettings"
    }
}

/// Settings specific to keys that can be used for reCAPTCHA Express.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExpressKeySettings {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpressKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExpressKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ExpressKeySettings"
    }
}

/// Contains fields that are required to perform Apple-specific integrity checks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppleDeveloperId {
    /// Required. Input only. A private key (downloaded as a text file with a .p8
    /// file extension) generated for your Apple Developer account. Ensure that
    /// Apple DeviceCheck is enabled for the private key.
    pub private_key: std::string::String,

    /// Required. The Apple developer key ID (10-character string).
    pub key_id: std::string::String,

    /// Required. The Apple team ID (10-character string) owning the provisioning
    /// profile used to build your application.
    pub team_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppleDeveloperId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::AppleDeveloperId::private_key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AppleDeveloperId;
    /// let x = AppleDeveloperId::new().set_private_key("example");
    /// ```
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_id][crate::model::AppleDeveloperId::key_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AppleDeveloperId;
    /// let x = AppleDeveloperId::new().set_key_id("example");
    /// ```
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }

    /// Sets the value of [team_id][crate::model::AppleDeveloperId::team_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AppleDeveloperId;
    /// let x = AppleDeveloperId::new().set_team_id("example");
    /// ```
    pub fn set_team_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.team_id = v.into();
        self
    }
}

impl wkt::message::Message for AppleDeveloperId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AppleDeveloperId"
    }
}

/// Score distribution.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScoreDistribution {
    /// Map key is score value multiplied by 100. The scores are discrete values
    /// between [0, 1]. The maximum number of buckets is on order of a few dozen,
    /// but typically much lower (ie. 10).
    pub score_buckets: std::collections::HashMap<i32, i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScoreDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score_buckets][crate::model::ScoreDistribution::score_buckets].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ScoreDistribution;
    /// let x = ScoreDistribution::new().set_score_buckets([
    ///     (0, 123),
    ///     (1, 456),
    /// ]);
    /// ```
    pub fn set_score_buckets<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.score_buckets = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ScoreDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ScoreDistribution"
    }
}

/// Metrics related to scoring.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ScoreMetrics {
    /// Aggregated score metrics for all traffic.
    pub overall_metrics: std::option::Option<crate::model::ScoreDistribution>,

    /// Action-based metrics. The map key is the action name which specified by the
    /// site owners at time of the "execute" client-side call.
    pub action_metrics:
        std::collections::HashMap<std::string::String, crate::model::ScoreDistribution>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScoreMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overall_metrics][crate::model::ScoreMetrics::overall_metrics].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ScoreMetrics;
    /// use google_cloud_recaptchaenterprise_v1::model::ScoreDistribution;
    /// let x = ScoreMetrics::new().set_overall_metrics(ScoreDistribution::default()/* use setters */);
    /// ```
    pub fn set_overall_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ScoreDistribution>,
    {
        self.overall_metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overall_metrics][crate::model::ScoreMetrics::overall_metrics].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ScoreMetrics;
    /// use google_cloud_recaptchaenterprise_v1::model::ScoreDistribution;
    /// let x = ScoreMetrics::new().set_or_clear_overall_metrics(Some(ScoreDistribution::default()/* use setters */));
    /// let x = ScoreMetrics::new().set_or_clear_overall_metrics(None::<ScoreDistribution>);
    /// ```
    pub fn set_or_clear_overall_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ScoreDistribution>,
    {
        self.overall_metrics = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_metrics][crate::model::ScoreMetrics::action_metrics].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ScoreMetrics;
    /// use google_cloud_recaptchaenterprise_v1::model::ScoreDistribution;
    /// let x = ScoreMetrics::new().set_action_metrics([
    ///     ("key0", ScoreDistribution::default()/* use setters */),
    ///     ("key1", ScoreDistribution::default()/* use (different) setters */),
    /// ]);
    /// ```
    pub fn set_action_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ScoreDistribution>,
    {
        use std::iter::Iterator;
        self.action_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ScoreMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ScoreMetrics"
    }
}

/// Metrics related to challenges.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ChallengeMetrics {
    /// Count of reCAPTCHA checkboxes or badges rendered. This is mostly equivalent
    /// to a count of pageloads for pages that include reCAPTCHA.
    pub pageload_count: i64,

    /// Count of nocaptchas (successful verification without a challenge) issued.
    pub nocaptcha_count: i64,

    /// Count of submitted challenge solutions that were incorrect or otherwise
    /// deemed suspicious such that a subsequent challenge was triggered.
    pub failed_count: i64,

    /// Count of nocaptchas (successful verification without a challenge) plus
    /// submitted challenge solutions that were correct and resulted in
    /// verification.
    pub passed_count: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChallengeMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pageload_count][crate::model::ChallengeMetrics::pageload_count].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ChallengeMetrics;
    /// let x = ChallengeMetrics::new().set_pageload_count(42);
    /// ```
    pub fn set_pageload_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pageload_count = v.into();
        self
    }

    /// Sets the value of [nocaptcha_count][crate::model::ChallengeMetrics::nocaptcha_count].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ChallengeMetrics;
    /// let x = ChallengeMetrics::new().set_nocaptcha_count(42);
    /// ```
    pub fn set_nocaptcha_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.nocaptcha_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::ChallengeMetrics::failed_count].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ChallengeMetrics;
    /// let x = ChallengeMetrics::new().set_failed_count(42);
    /// ```
    pub fn set_failed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [passed_count][crate::model::ChallengeMetrics::passed_count].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ChallengeMetrics;
    /// let x = ChallengeMetrics::new().set_passed_count(42);
    /// ```
    pub fn set_passed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_count = v.into();
        self
    }
}

impl wkt::message::Message for ChallengeMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ChallengeMetrics"
    }
}

/// Policy config assessment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyAssessment {
    /// Output only. If the processing of a policy config fails, an error is
    /// populated and the firewall_policy is left empty.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The policy that matched the request. If more than one policy
    /// may match, this is the first match. If no policy matches the incoming
    /// request, the policy field is left empty.
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallPolicyAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::FirewallPolicyAssessment::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicyAssessment;
    /// use rpc::model::Status;
    /// let x = FirewallPolicyAssessment::new().set_error(Status::default()/* use setters */);
    /// ```
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::FirewallPolicyAssessment::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicyAssessment;
    /// use rpc::model::Status;
    /// let x = FirewallPolicyAssessment::new().set_or_clear_error(Some(Status::default()/* use setters */));
    /// let x = FirewallPolicyAssessment::new().set_or_clear_error(None::<Status>);
    /// ```
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [firewall_policy][crate::model::FirewallPolicyAssessment::firewall_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicyAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = FirewallPolicyAssessment::new().set_firewall_policy(FirewallPolicy::default()/* use setters */);
    /// ```
    pub fn set_firewall_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [firewall_policy][crate::model::FirewallPolicyAssessment::firewall_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicyAssessment;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = FirewallPolicyAssessment::new().set_or_clear_firewall_policy(Some(FirewallPolicy::default()/* use setters */));
    /// let x = FirewallPolicyAssessment::new().set_or_clear_firewall_policy(None::<FirewallPolicy>);
    /// ```
    pub fn set_or_clear_firewall_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicy>,
    {
        self.firewall_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FirewallPolicyAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment"
    }
}

/// An individual action. Each action represents what to do if a policy
/// matches.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallAction {
    pub firewall_action_oneof:
        std::option::Option<crate::model::firewall_action::FirewallActionOneof>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof].
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::AllowAction;
    /// let x = FirewallAction::new().set_firewall_action_oneof(Some(firewall_action::FirewallActionOneof::Allow(AllowAction::default().into())));
    /// ```
    pub fn set_firewall_action_oneof<
        T: std::convert::Into<std::option::Option<crate::model::firewall_action::FirewallActionOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = v.into();
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Allow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn allow(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::AllowAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Allow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Allow`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::AllowAction;
    /// let x = FirewallAction::new().set_allow(AllowAction::default()/* use setters */);
    /// assert!(x.allow().is_some());
    /// assert!(x.block().is_none());
    /// assert!(x.include_recaptcha_script().is_none());
    /// assert!(x.redirect().is_none());
    /// assert!(x.substitute().is_none());
    /// assert!(x.set_header().is_none());
    /// ```
    pub fn set_allow<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::AllowAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Allow(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Block`, `None` if the field is not set or
    /// holds a different branch.
    pub fn block(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::BlockAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Block(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Block`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::BlockAction;
    /// let x = FirewallAction::new().set_block(BlockAction::default()/* use setters */);
    /// assert!(x.block().is_some());
    /// assert!(x.allow().is_none());
    /// assert!(x.include_recaptcha_script().is_none());
    /// assert!(x.redirect().is_none());
    /// assert!(x.substitute().is_none());
    /// assert!(x.set_header().is_none());
    /// ```
    pub fn set_block<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::BlockAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Block(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `IncludeRecaptchaScript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_recaptcha_script(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
    > {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `IncludeRecaptchaScript`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::IncludeRecaptchaScriptAction;
    /// let x = FirewallAction::new().set_include_recaptcha_script(IncludeRecaptchaScriptAction::default()/* use setters */);
    /// assert!(x.include_recaptcha_script().is_some());
    /// assert!(x.allow().is_none());
    /// assert!(x.block().is_none());
    /// assert!(x.redirect().is_none());
    /// assert!(x.substitute().is_none());
    /// assert!(x.set_header().is_none());
    /// ```
    pub fn set_include_recaptcha_script<
        T: std::convert::Into<
                std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Redirect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::RedirectAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Redirect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Redirect`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::RedirectAction;
    /// let x = FirewallAction::new().set_redirect(RedirectAction::default()/* use setters */);
    /// assert!(x.redirect().is_some());
    /// assert!(x.allow().is_none());
    /// assert!(x.block().is_none());
    /// assert!(x.include_recaptcha_script().is_none());
    /// assert!(x.substitute().is_none());
    /// assert!(x.set_header().is_none());
    /// ```
    pub fn set_redirect<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::RedirectAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Redirect(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Substitute`, `None` if the field is not set or
    /// holds a different branch.
    pub fn substitute(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::SubstituteAction>>
    {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Substitute(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Substitute`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::SubstituteAction;
    /// let x = FirewallAction::new().set_substitute(SubstituteAction::default()/* use setters */);
    /// assert!(x.substitute().is_some());
    /// assert!(x.allow().is_none());
    /// assert!(x.block().is_none());
    /// assert!(x.include_recaptcha_script().is_none());
    /// assert!(x.redirect().is_none());
    /// assert!(x.set_header().is_none());
    /// ```
    pub fn set_substitute<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::SubstituteAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Substitute(v.into()),
        );
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `SetHeader`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_header(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::SetHeaderAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::SetHeader(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `SetHeader`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// use google_cloud_recaptchaenterprise_v1::model::firewall_action::SetHeaderAction;
    /// let x = FirewallAction::new().set_set_header(SetHeaderAction::default()/* use setters */);
    /// assert!(x.set_header().is_some());
    /// assert!(x.allow().is_none());
    /// assert!(x.block().is_none());
    /// assert!(x.include_recaptcha_script().is_none());
    /// assert!(x.redirect().is_none());
    /// assert!(x.substitute().is_none());
    /// ```
    pub fn set_set_header<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::SetHeaderAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::SetHeader(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FirewallAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction"
    }
}

/// Defines additional types related to [FirewallAction].
pub mod firewall_action {
    #[allow(unused_imports)]
    use super::*;

    /// An allow action continues processing a request unimpeded.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AllowAction {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AllowAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction"
        }
    }

    /// A block action serves an HTTP error code a prevents the request from
    /// hitting the backend.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BlockAction {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BlockAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BlockAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction"
        }
    }

    /// An include reCAPTCHA script action involves injecting reCAPTCHA JavaScript
    /// code into the HTML returned by the site backend. This reCAPTCHA
    /// script is tasked with collecting user signals on the requested web page,
    /// issuing tokens as a cookie within the site domain, and enabling their
    /// utilization in subsequent page requests.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IncludeRecaptchaScriptAction {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncludeRecaptchaScriptAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for IncludeRecaptchaScriptAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction"
        }
    }

    /// A redirect action returns a 307 (temporary redirect) response, pointing
    /// the user to a reCAPTCHA interstitial page to attach a token.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RedirectAction {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for RedirectAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction"
        }
    }

    /// A substitute action transparently serves a different page than the one
    /// requested.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubstituteAction {
        /// Optional. The address to redirect to. The target is a relative path in
        /// the current host. Example: "/blog/404.html".
        pub path: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubstituteAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::firewall_action::SubstituteAction::path].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::firewall_action::SubstituteAction;
        /// let x = SubstituteAction::new().set_path("example");
        /// ```
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }
    }

    impl wkt::message::Message for SubstituteAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction"
        }
    }

    /// A set header action sets a header and forwards the request to the
    /// backend. This can be used to trigger custom protection implemented on the
    /// backend.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetHeaderAction {
        /// Optional. The header key to set in the request to the backend server.
        pub key: std::string::String,

        /// Optional. The header value to set in the request to the backend server.
        pub value: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SetHeaderAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::firewall_action::SetHeaderAction::key].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::firewall_action::SetHeaderAction;
        /// let x = SetHeaderAction::new().set_key("example");
        /// ```
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::firewall_action::SetHeaderAction::value].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_recaptchaenterprise_v1::model::firewall_action::SetHeaderAction;
        /// let x = SetHeaderAction::new().set_value("example");
        /// ```
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for SetHeaderAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction"
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FirewallActionOneof {
        /// The user request did not match any policy and should be allowed
        /// access to the requested resource.
        Allow(std::boxed::Box<crate::model::firewall_action::AllowAction>),
        /// This action denies access to a given page. The user gets an HTTP
        /// error code.
        Block(std::boxed::Box<crate::model::firewall_action::BlockAction>),
        /// This action injects reCAPTCHA JavaScript code into the HTML page
        /// returned by the site backend.
        IncludeRecaptchaScript(
            std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
        ),
        /// This action redirects the request to a reCAPTCHA interstitial to
        /// attach a token.
        Redirect(std::boxed::Box<crate::model::firewall_action::RedirectAction>),
        /// This action transparently serves a different page to an offending
        /// user.
        Substitute(std::boxed::Box<crate::model::firewall_action::SubstituteAction>),
        /// This action sets a custom header but allow the request to continue
        /// to the customer backend.
        SetHeader(std::boxed::Box<crate::model::firewall_action::SetHeaderAction>),
    }
}

/// A FirewallPolicy represents a single matching pattern and resulting actions
/// to take.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicy {
    /// Identifier. The resource name for the FirewallPolicy in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    pub name: std::string::String,

    /// Optional. A description of what this policy aims to achieve, for
    /// convenience purposes. The description can at most include 256 UTF-8
    /// characters.
    pub description: std::string::String,

    /// Optional. The path for which this policy applies, specified as a glob
    /// pattern. For more information on glob, see the [manual
    /// page](https://man7.org/linux/man-pages/man7/glob.7.html).
    /// A path has a max length of 200 characters.
    pub path: std::string::String,

    /// Optional. A CEL (Common Expression Language) conditional expression that
    /// specifies if this policy applies to an incoming user request. If this
    /// condition evaluates to true and the requested path matched the path
    /// pattern, the associated actions should be executed by the caller. The
    /// condition string is checked for CEL syntax correctness on creation. For
    /// more information, see the [CEL spec](https://github.com/google/cel-spec)
    /// and its [language
    /// definition](https://github.com/google/cel-spec/blob/master/doc/langdef.md).
    /// A condition has a max length of 500 characters.
    pub condition: std::string::String,

    /// Optional. The actions that the caller should take regarding user access.
    /// There should be at most one terminal action. A terminal action is any
    /// action that forces a response, such as `AllowAction`,
    /// `BlockAction` or `SubstituteAction`.
    /// Zero or more non-terminal actions such as `SetHeader` might be
    /// specified. A single policy can contain up to 16 actions.
    pub actions: std::vec::Vec<crate::model::FirewallAction>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FirewallPolicy::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = FirewallPolicy::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FirewallPolicy::description].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = FirewallPolicy::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [path][crate::model::FirewallPolicy::path].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = FirewallPolicy::new().set_path("example");
    /// ```
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::FirewallPolicy::condition].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// let x = FirewallPolicy::new().set_condition("example");
    /// ```
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::FirewallPolicy::actions].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::FirewallPolicy;
    /// use google_cloud_recaptchaenterprise_v1::model::FirewallAction;
    /// let x = FirewallPolicy::new()
    ///     .set_actions([
    ///         FirewallAction::default()/* use setters */,
    ///         FirewallAction::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FirewallPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallPolicy"
    }
}

/// The request message to list memberships in a related account group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupMembershipsRequest {
    /// Required. The resource name for the related account group in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of accounts to return. The service might
    /// return fewer than this value. If unspecified, at most 50 accounts are
    /// returned. The maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListRelatedAccountGroupMemberships` call.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroupMemberships` must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupMembershipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRelatedAccountGroupMembershipsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupMembershipsRequest;
    /// let x = ListRelatedAccountGroupMembershipsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRelatedAccountGroupMembershipsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupMembershipsRequest;
    /// let x = ListRelatedAccountGroupMembershipsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRelatedAccountGroupMembershipsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupMembershipsRequest;
    /// let x = ListRelatedAccountGroupMembershipsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupMembershipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsRequest"
    }
}

/// The response to a `ListRelatedAccountGroupMemberships` call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupMembershipsResponse {
    /// The memberships listed by the query.
    pub related_account_group_memberships:
        std::vec::Vec<crate::model::RelatedAccountGroupMembership>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupMembershipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_account_group_memberships][crate::model::ListRelatedAccountGroupMembershipsResponse::related_account_group_memberships].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupMembershipsResponse;
    /// use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroupMembership;
    /// let x = ListRelatedAccountGroupMembershipsResponse::new()
    ///     .set_related_account_group_memberships([
    ///         RelatedAccountGroupMembership::default()/* use setters */,
    ///         RelatedAccountGroupMembership::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_related_account_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroupMembership>,
    {
        use std::iter::Iterator;
        self.related_account_group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRelatedAccountGroupMembershipsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupMembershipsResponse;
    /// let x = ListRelatedAccountGroupMembershipsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupMembershipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRelatedAccountGroupMembershipsResponse {
    type PageItem = crate::model::RelatedAccountGroupMembership;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_group_memberships
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message to list related account groups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupsRequest {
    /// Required. The name of the project to list related account groups from, in
    /// the format `projects/{project}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListRelatedAccountGroups`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroups` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRelatedAccountGroupsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupsRequest;
    /// let x = ListRelatedAccountGroupsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRelatedAccountGroupsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupsRequest;
    /// let x = ListRelatedAccountGroupsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRelatedAccountGroupsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupsRequest;
    /// let x = ListRelatedAccountGroupsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest"
    }
}

/// The response to a `ListRelatedAccountGroups` call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRelatedAccountGroupsResponse {
    /// The groups of related accounts listed by the query.
    pub related_account_groups: std::vec::Vec<crate::model::RelatedAccountGroup>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_account_groups][crate::model::ListRelatedAccountGroupsResponse::related_account_groups].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupsResponse;
    /// use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroup;
    /// let x = ListRelatedAccountGroupsResponse::new()
    ///     .set_related_account_groups([
    ///         RelatedAccountGroup::default()/* use setters */,
    ///         RelatedAccountGroup::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_related_account_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroup>,
    {
        use std::iter::Iterator;
        self.related_account_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRelatedAccountGroupsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListRelatedAccountGroupsResponse;
    /// let x = ListRelatedAccountGroupsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRelatedAccountGroupsResponse {
    type PageItem = crate::model::RelatedAccountGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message to search related account group memberships.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchRelatedAccountGroupMembershipsRequest {
    /// Required. The name of the project to search related account group
    /// memberships from. Specify the project name in the following format:
    /// `projects/{project}`.
    pub project: std::string::String,

    /// Optional. The unique stable account identifier used to search connections.
    /// The identifier should correspond to an `account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call. Either hashed_account_id
    /// or account_id must be set, but not both.
    pub account_id: std::string::String,

    /// Optional. Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier used to search connections. The
    /// identifier should correspond to a `hashed_account_id` provided in a
    /// previous `CreateAssessment` or `AnnotateAssessment` call. Either
    /// hashed_account_id or account_id must be set, but not both.
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `SearchRelatedAccountGroupMemberships` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `SearchRelatedAccountGroupMemberships` must match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRelatedAccountGroupMembershipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SearchRelatedAccountGroupMembershipsRequest::project].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsRequest;
    /// let x = SearchRelatedAccountGroupMembershipsRequest::new().set_project("example");
    /// ```
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::SearchRelatedAccountGroupMembershipsRequest::account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsRequest;
    /// let x = SearchRelatedAccountGroupMembershipsRequest::new().set_account_id("example");
    /// ```
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::SearchRelatedAccountGroupMembershipsRequest::hashed_account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsRequest;
    /// let x = SearchRelatedAccountGroupMembershipsRequest::new().set_hashed_account_id(bytes::Bytes::from_static(b"example"));
    /// ```
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchRelatedAccountGroupMembershipsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsRequest;
    /// let x = SearchRelatedAccountGroupMembershipsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchRelatedAccountGroupMembershipsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsRequest;
    /// let x = SearchRelatedAccountGroupMembershipsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchRelatedAccountGroupMembershipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsRequest"
    }
}

/// The response to a `SearchRelatedAccountGroupMemberships` call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchRelatedAccountGroupMembershipsResponse {
    /// The queried memberships.
    pub related_account_group_memberships:
        std::vec::Vec<crate::model::RelatedAccountGroupMembership>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRelatedAccountGroupMembershipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_account_group_memberships][crate::model::SearchRelatedAccountGroupMembershipsResponse::related_account_group_memberships].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsResponse;
    /// use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroupMembership;
    /// let x = SearchRelatedAccountGroupMembershipsResponse::new()
    ///     .set_related_account_group_memberships([
    ///         RelatedAccountGroupMembership::default()/* use setters */,
    ///         RelatedAccountGroupMembership::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_related_account_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroupMembership>,
    {
        use std::iter::Iterator;
        self.related_account_group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchRelatedAccountGroupMembershipsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::SearchRelatedAccountGroupMembershipsResponse;
    /// let x = SearchRelatedAccountGroupMembershipsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchRelatedAccountGroupMembershipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchRelatedAccountGroupMembershipsResponse {
    type PageItem = crate::model::RelatedAccountGroupMembership;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_group_memberships
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The AddIpOverride request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddIpOverrideRequest {
    /// Required. The name of the key to which the IP override is added, in the
    /// format `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Required. IP override added to the key.
    pub ip_override_data: std::option::Option<crate::model::IpOverrideData>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddIpOverrideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AddIpOverrideRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AddIpOverrideRequest;
    /// let x = AddIpOverrideRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_override_data][crate::model::AddIpOverrideRequest::ip_override_data].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AddIpOverrideRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// let x = AddIpOverrideRequest::new().set_ip_override_data(IpOverrideData::default()/* use setters */);
    /// ```
    pub fn set_ip_override_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_override_data][crate::model::AddIpOverrideRequest::ip_override_data].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AddIpOverrideRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// let x = AddIpOverrideRequest::new().set_or_clear_ip_override_data(Some(IpOverrideData::default()/* use setters */));
    /// let x = AddIpOverrideRequest::new().set_or_clear_ip_override_data(None::<IpOverrideData>);
    /// ```
    pub fn set_or_clear_ip_override_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AddIpOverrideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AddIpOverrideRequest"
    }
}

/// Response for AddIpOverride.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddIpOverrideResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddIpOverrideResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddIpOverrideResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AddIpOverrideResponse"
    }
}

/// The RemoveIpOverride request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveIpOverrideRequest {
    /// Required. The name of the key from which the IP override is removed, in the
    /// format `projects/{project}/keys/{key}`.
    pub name: std::string::String,

    /// Required. IP override to be removed from the key.
    pub ip_override_data: std::option::Option<crate::model::IpOverrideData>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveIpOverrideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveIpOverrideRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RemoveIpOverrideRequest;
    /// let x = RemoveIpOverrideRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_override_data][crate::model::RemoveIpOverrideRequest::ip_override_data].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RemoveIpOverrideRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// let x = RemoveIpOverrideRequest::new().set_ip_override_data(IpOverrideData::default()/* use setters */);
    /// ```
    pub fn set_ip_override_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_override_data][crate::model::RemoveIpOverrideRequest::ip_override_data].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RemoveIpOverrideRequest;
    /// use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// let x = RemoveIpOverrideRequest::new().set_or_clear_ip_override_data(Some(IpOverrideData::default()/* use setters */));
    /// let x = RemoveIpOverrideRequest::new().set_or_clear_ip_override_data(None::<IpOverrideData>);
    /// ```
    pub fn set_or_clear_ip_override_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IpOverrideData>,
    {
        self.ip_override_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RemoveIpOverrideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RemoveIpOverrideRequest"
    }
}

/// Response for RemoveIpOverride.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveIpOverrideResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveIpOverrideResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveIpOverrideResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RemoveIpOverrideResponse"
    }
}

/// The ListIpOverrides request message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIpOverridesRequest {
    /// Required. The parent key for which the IP overrides are listed, in the
    /// format `projects/{project}/keys/{key}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of overrides to return. Default is 10. Max
    /// limit is 100. If the number of overrides is less than the page_size, all
    /// overrides are returned. If the page size is more than 100, it is coerced to
    /// 100.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous
    /// ListIpOverridesRequest, if any.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIpOverridesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIpOverridesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListIpOverridesRequest;
    /// let x = ListIpOverridesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIpOverridesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListIpOverridesRequest;
    /// let x = ListIpOverridesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIpOverridesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListIpOverridesRequest;
    /// let x = ListIpOverridesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIpOverridesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListIpOverridesRequest"
    }
}

/// Response for ListIpOverrides.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIpOverridesResponse {
    /// IP Overrides details.
    pub ip_overrides: std::vec::Vec<crate::model::IpOverrideData>,

    /// Token to retrieve the next page of results. If this field is empty, no keys
    /// remain in the results.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIpOverridesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_overrides][crate::model::ListIpOverridesResponse::ip_overrides].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListIpOverridesResponse;
    /// use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// let x = ListIpOverridesResponse::new()
    ///     .set_ip_overrides([
    ///         IpOverrideData::default()/* use setters */,
    ///         IpOverrideData::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_ip_overrides<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpOverrideData>,
    {
        use std::iter::Iterator;
        self.ip_overrides = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIpOverridesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::ListIpOverridesResponse;
    /// let x = ListIpOverridesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIpOverridesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListIpOverridesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIpOverridesResponse {
    type PageItem = crate::model::IpOverrideData;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ip_overrides
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A membership in a group of related accounts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedAccountGroupMembership {
    /// Required. Identifier. The resource name for this membership in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}/memberships/{membership}`.
    pub name: std::string::String,

    /// The unique stable account identifier of the member. The identifier
    /// corresponds to an `account_id` provided in a previous `CreateAssessment` or
    /// `AnnotateAssessment` call.
    pub account_id: std::string::String,

    /// Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier of the member. The identifier
    /// corresponds to a `hashed_account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call.
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAccountGroupMembership {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RelatedAccountGroupMembership::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroupMembership;
    /// let x = RelatedAccountGroupMembership::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::RelatedAccountGroupMembership::account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroupMembership;
    /// let x = RelatedAccountGroupMembership::new().set_account_id("example");
    /// ```
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::RelatedAccountGroupMembership::hashed_account_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroupMembership;
    /// let x = RelatedAccountGroupMembership::new().set_hashed_account_id(bytes::Bytes::from_static(b"example"));
    /// ```
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAccountGroupMembership {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership"
    }
}

/// A group of related accounts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RelatedAccountGroup {
    /// Required. Identifier. The resource name for the related account group in
    /// the format
    /// `projects/{project}/relatedaccountgroups/{related_account_group}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAccountGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RelatedAccountGroup::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::RelatedAccountGroup;
    /// let x = RelatedAccountGroup::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAccountGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RelatedAccountGroup"
    }
}

/// Settings specific to keys that can be used for WAF (Web Application
/// Firewall).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WafSettings {
    /// Required. The WAF service that uses this key.
    pub waf_service: crate::model::waf_settings::WafService,

    /// Required. The WAF feature for which this key is enabled.
    pub waf_feature: crate::model::waf_settings::WafFeature,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WafSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [waf_service][crate::model::WafSettings::waf_service].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WafSettings;
    /// use google_cloud_recaptchaenterprise_v1::model::waf_settings::WafService;
    /// let x0 = WafSettings::new().set_waf_service(WafService::Ca);
    /// let x1 = WafSettings::new().set_waf_service(WafService::Fastly);
    /// let x2 = WafSettings::new().set_waf_service(WafService::Cloudflare);
    /// ```
    pub fn set_waf_service<T: std::convert::Into<crate::model::waf_settings::WafService>>(
        mut self,
        v: T,
    ) -> Self {
        self.waf_service = v.into();
        self
    }

    /// Sets the value of [waf_feature][crate::model::WafSettings::waf_feature].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::WafSettings;
    /// use google_cloud_recaptchaenterprise_v1::model::waf_settings::WafFeature;
    /// let x0 = WafSettings::new().set_waf_feature(WafFeature::ChallengePage);
    /// let x1 = WafSettings::new().set_waf_feature(WafFeature::SessionToken);
    /// let x2 = WafSettings::new().set_waf_feature(WafFeature::ActionToken);
    /// ```
    pub fn set_waf_feature<T: std::convert::Into<crate::model::waf_settings::WafFeature>>(
        mut self,
        v: T,
    ) -> Self {
        self.waf_feature = v.into();
        self
    }
}

impl wkt::message::Message for WafSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.WafSettings"
    }
}

/// Defines additional types related to [WafSettings].
pub mod waf_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Supported WAF features. For more information, see
    /// <https://cloud.google.com/recaptcha/docs/usecase#comparison_of_features>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WafFeature {
        /// Undefined feature.
        Unspecified,
        /// Redirects suspicious traffic to reCAPTCHA.
        ChallengePage,
        /// Use reCAPTCHA session-tokens to protect the whole user session on the
        /// site's domain.
        SessionToken,
        /// Use reCAPTCHA action-tokens to protect user actions.
        ActionToken,
        /// Use reCAPTCHA WAF express protection to protect any content other than
        /// web pages, like APIs and IoT devices.
        Express,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WafFeature::value] or
        /// [WafFeature::name].
        UnknownValue(waf_feature::UnknownValue),
    }

    #[doc(hidden)]
    pub mod waf_feature {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WafFeature {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ChallengePage => std::option::Option::Some(1),
                Self::SessionToken => std::option::Option::Some(2),
                Self::ActionToken => std::option::Option::Some(3),
                Self::Express => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WAF_FEATURE_UNSPECIFIED"),
                Self::ChallengePage => std::option::Option::Some("CHALLENGE_PAGE"),
                Self::SessionToken => std::option::Option::Some("SESSION_TOKEN"),
                Self::ActionToken => std::option::Option::Some("ACTION_TOKEN"),
                Self::Express => std::option::Option::Some("EXPRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WafFeature {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WafFeature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WafFeature {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ChallengePage,
                2 => Self::SessionToken,
                3 => Self::ActionToken,
                5 => Self::Express,
                _ => Self::UnknownValue(waf_feature::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WafFeature {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WAF_FEATURE_UNSPECIFIED" => Self::Unspecified,
                "CHALLENGE_PAGE" => Self::ChallengePage,
                "SESSION_TOKEN" => Self::SessionToken,
                "ACTION_TOKEN" => Self::ActionToken,
                "EXPRESS" => Self::Express,
                _ => Self::UnknownValue(waf_feature::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WafFeature {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ChallengePage => serializer.serialize_i32(1),
                Self::SessionToken => serializer.serialize_i32(2),
                Self::ActionToken => serializer.serialize_i32(3),
                Self::Express => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WafFeature {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WafFeature>::new(
                ".google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature",
            ))
        }
    }

    /// Web Application Firewalls supported by reCAPTCHA.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WafService {
        /// Undefined WAF
        Unspecified,
        /// Cloud Armor
        Ca,
        /// Fastly
        Fastly,
        /// Cloudflare
        Cloudflare,
        /// Akamai
        Akamai,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WafService::value] or
        /// [WafService::name].
        UnknownValue(waf_service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod waf_service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WafService {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ca => std::option::Option::Some(1),
                Self::Fastly => std::option::Option::Some(3),
                Self::Cloudflare => std::option::Option::Some(4),
                Self::Akamai => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WAF_SERVICE_UNSPECIFIED"),
                Self::Ca => std::option::Option::Some("CA"),
                Self::Fastly => std::option::Option::Some("FASTLY"),
                Self::Cloudflare => std::option::Option::Some("CLOUDFLARE"),
                Self::Akamai => std::option::Option::Some("AKAMAI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WafService {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WafService {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WafService {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ca,
                3 => Self::Fastly,
                4 => Self::Cloudflare,
                5 => Self::Akamai,
                _ => Self::UnknownValue(waf_service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WafService {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WAF_SERVICE_UNSPECIFIED" => Self::Unspecified,
                "CA" => Self::Ca,
                "FASTLY" => Self::Fastly,
                "CLOUDFLARE" => Self::Cloudflare,
                "AKAMAI" => Self::Akamai,
                _ => Self::UnknownValue(waf_service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WafService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ca => serializer.serialize_i32(1),
                Self::Fastly => serializer.serialize_i32(3),
                Self::Cloudflare => serializer.serialize_i32(4),
                Self::Akamai => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WafService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WafService>::new(
                ".google.cloud.recaptchaenterprise.v1.WafSettings.WafService",
            ))
        }
    }
}

/// The environment creating the assessment. This describes your environment
/// (the system invoking CreateAssessment), NOT the environment of your user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssessmentEnvironment {
    /// Optional. Identifies the client module initiating the CreateAssessment
    /// request. This can be the link to the client module's project. Examples
    /// include:
    ///
    /// - "github.com/GoogleCloudPlatform/recaptcha-enterprise-google-tag-manager"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-akamai"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-cloudflare"
    /// - "wordpress.org/plugins/recaptcha-something"
    pub client: std::string::String,

    /// Optional. The version of the client module. For example, "1.0.0".
    pub version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssessmentEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client][crate::model::AssessmentEnvironment::client].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AssessmentEnvironment;
    /// let x = AssessmentEnvironment::new().set_client("example");
    /// ```
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AssessmentEnvironment::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::AssessmentEnvironment;
    /// let x = AssessmentEnvironment::new().set_version("example");
    /// ```
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for AssessmentEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AssessmentEnvironment"
    }
}

/// Information about the IP or IP range override.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IpOverrideData {
    /// Required. The IP address to override (can be IPv4, IPv6 or CIDR).
    /// The IP override must be a valid IPv4 or IPv6 address, or a CIDR range.
    /// The IP override must be a public IP address.
    /// Example of IPv4: 168.192.5.6
    /// Example of IPv6: 2001:0000:130F:0000:0000:09C0:876A:130B
    /// Example of IPv4 with CIDR: 168.192.5.0/24
    /// Example of IPv6 with CIDR: 2001:0DB8:1234::/48
    pub ip: std::string::String,

    /// Required. Describes the type of IP override.
    pub override_type: crate::model::ip_override_data::OverrideType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpOverrideData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip][crate::model::IpOverrideData::ip].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// let x = IpOverrideData::new().set_ip("example");
    /// ```
    pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip = v.into();
        self
    }

    /// Sets the value of [override_type][crate::model::IpOverrideData::override_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_recaptchaenterprise_v1::model::IpOverrideData;
    /// use google_cloud_recaptchaenterprise_v1::model::ip_override_data::OverrideType;
    /// let x0 = IpOverrideData::new().set_override_type(OverrideType::Allow);
    /// ```
    pub fn set_override_type<
        T: std::convert::Into<crate::model::ip_override_data::OverrideType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.override_type = v.into();
        self
    }
}

impl wkt::message::Message for IpOverrideData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.IpOverrideData"
    }
}

/// Defines additional types related to [IpOverrideData].
pub mod ip_override_data {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the type of IP override.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OverrideType {
        /// Default override type that indicates this enum hasn't been specified.
        Unspecified,
        /// Allowlist the IP address; i.e. give a `risk_analysis.score` of 0.9 for
        /// all valid assessments.
        Allow,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OverrideType::value] or
        /// [OverrideType::name].
        UnknownValue(override_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod override_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OverrideType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OVERRIDE_TYPE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OverrideType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OverrideType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OverrideType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                _ => Self::UnknownValue(override_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OverrideType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OVERRIDE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                _ => Self::UnknownValue(override_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OverrideType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OverrideType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OverrideType>::new(
                ".google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType",
            ))
        }
    }
}
