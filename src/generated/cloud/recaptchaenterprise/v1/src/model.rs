// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The create assessment request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAssessmentRequest {
    /// Required. The name of the project in which the assessment is created,
    /// in the format `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The assessment details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assessment: std::option::Option<crate::model::Assessment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssessmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssessmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [assessment][crate::model::CreateAssessmentRequest::assessment].
    pub fn set_assessment<T: std::convert::Into<std::option::Option<crate::model::Assessment>>>(
        mut self,
        v: T,
    ) -> Self {
        self.assessment = v.into();
        self
    }
}

impl wkt::message::Message for CreateAssessmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateAssessmentRequest"
    }
}

/// Describes an event in the lifecycle of a payment transaction.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransactionEvent {
    /// Optional. The type of this transaction event.
    pub event_type: crate::model::transaction_event::TransactionEventType,

    /// Optional. The reason or standardized code that corresponds with this
    /// transaction event, if one exists. For example, a CHARGEBACK event with code
    /// 6005.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,

    /// Optional. The value that corresponds with this transaction event, if one
    /// exists. For example, a refund event where $5.00 was refunded. Currency is
    /// obtained from the original transaction data.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub value: f64,

    /// Optional. Timestamp when this transaction event occurred; otherwise assumed
    /// to be the time of the API call.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_type][crate::model::TransactionEvent::event_type].
    pub fn set_event_type<
        T: std::convert::Into<crate::model::transaction_event::TransactionEventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::TransactionEvent::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TransactionEvent::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::TransactionEvent::event_time].
    pub fn set_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_time = v.into();
        self
    }
}

impl wkt::message::Message for TransactionEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionEvent"
    }
}

/// Defines additional types related to [TransactionEvent].
pub mod transaction_event {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents an event in the payment transaction lifecycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransactionEventType {
        /// Default, unspecified event type.
        Unspecified,
        /// Indicates that the transaction is approved by the merchant. The
        /// accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
        /// 'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantApprove,
        /// Indicates that the transaction is denied and concluded due to risks
        /// detected by the merchant. The accompanying reasons can include terms such
        /// as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantDeny,
        /// Indicates that the transaction is being evaluated by a human, due to
        /// suspicion or risk.
        ManualReview,
        /// Indicates that the authorization attempt with the card issuer succeeded.
        Authorization,
        /// Indicates that the authorization attempt with the card issuer failed.
        /// The accompanying reasons can include Visa's '54' indicating that the card
        /// is expired, or '82' indicating that the CVV is incorrect.
        AuthorizationDecline,
        /// Indicates that the transaction is completed because the funds were
        /// settled.
        PaymentCapture,
        /// Indicates that the transaction could not be completed because the funds
        /// were not settled.
        PaymentCaptureDecline,
        /// Indicates that the transaction has been canceled. Specify the reason
        /// for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
        Cancel,
        /// Indicates that the merchant has received a chargeback inquiry due to
        /// fraud for the transaction, requesting additional information before a
        /// fraud chargeback is officially issued and a formal chargeback
        /// notification is sent.
        ChargebackInquiry,
        /// Indicates that the merchant has received a chargeback alert due to fraud
        /// for the transaction. The process of resolving the dispute without
        /// involving the payment network is started.
        ChargebackAlert,
        /// Indicates that a fraud notification is issued for the transaction, sent
        /// by the payment instrument's issuing bank because the transaction appears
        /// to be fraudulent. We recommend including TC40 or SAFE data in the
        /// `reason` field for this event type. For partial chargebacks, we recommend
        /// that you include an amount in the `value` field.
        FraudNotification,
        /// Indicates that the merchant is informed by the payment network that the
        /// transaction has entered the chargeback process due to fraud. Reason code
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        Chargeback,
        /// Indicates that the transaction has entered the chargeback process due to
        /// fraud, and that the merchant has chosen to enter representment. Reason
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        ChargebackRepresentment,
        /// Indicates that the transaction has had a fraud chargeback which was
        /// illegitimate and was reversed as a result. For partial chargebacks, we
        /// recommend that you include an amount in the `value` field.
        ChargebackReverse,
        /// Indicates that the merchant has received a refund for a completed
        /// transaction. For partial refunds, we recommend that you include an amount
        /// in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
        /// exempt tax)
        RefundRequest,
        /// Indicates that the merchant has received a refund request for this
        /// transaction, but that they have declined it. For partial refunds, we
        /// recommend that you include an amount in the `value` field. Reason
        /// example: 'TAX_EXEMPT' (partial refund of exempt tax)
        RefundDecline,
        /// Indicates that the completed transaction was refunded by the merchant.
        /// For partial refunds, we recommend that you include an amount in the
        /// `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
        /// tax)
        Refund,
        /// Indicates that the completed transaction was refunded by the merchant,
        /// and that this refund was reversed. For partial refunds, we recommend that
        /// you include an amount in the `value` field.
        RefundReverse,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransactionEventType::value] or
        /// [TransactionEventType::name].
        UnknownValue(transaction_event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transaction_event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransactionEventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MerchantApprove => std::option::Option::Some(1),
                Self::MerchantDeny => std::option::Option::Some(2),
                Self::ManualReview => std::option::Option::Some(3),
                Self::Authorization => std::option::Option::Some(4),
                Self::AuthorizationDecline => std::option::Option::Some(5),
                Self::PaymentCapture => std::option::Option::Some(6),
                Self::PaymentCaptureDecline => std::option::Option::Some(7),
                Self::Cancel => std::option::Option::Some(8),
                Self::ChargebackInquiry => std::option::Option::Some(9),
                Self::ChargebackAlert => std::option::Option::Some(10),
                Self::FraudNotification => std::option::Option::Some(11),
                Self::Chargeback => std::option::Option::Some(12),
                Self::ChargebackRepresentment => std::option::Option::Some(13),
                Self::ChargebackReverse => std::option::Option::Some(14),
                Self::RefundRequest => std::option::Option::Some(15),
                Self::RefundDecline => std::option::Option::Some(16),
                Self::Refund => std::option::Option::Some(17),
                Self::RefundReverse => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSACTION_EVENT_TYPE_UNSPECIFIED")
                }
                Self::MerchantApprove => std::option::Option::Some("MERCHANT_APPROVE"),
                Self::MerchantDeny => std::option::Option::Some("MERCHANT_DENY"),
                Self::ManualReview => std::option::Option::Some("MANUAL_REVIEW"),
                Self::Authorization => std::option::Option::Some("AUTHORIZATION"),
                Self::AuthorizationDecline => std::option::Option::Some("AUTHORIZATION_DECLINE"),
                Self::PaymentCapture => std::option::Option::Some("PAYMENT_CAPTURE"),
                Self::PaymentCaptureDecline => std::option::Option::Some("PAYMENT_CAPTURE_DECLINE"),
                Self::Cancel => std::option::Option::Some("CANCEL"),
                Self::ChargebackInquiry => std::option::Option::Some("CHARGEBACK_INQUIRY"),
                Self::ChargebackAlert => std::option::Option::Some("CHARGEBACK_ALERT"),
                Self::FraudNotification => std::option::Option::Some("FRAUD_NOTIFICATION"),
                Self::Chargeback => std::option::Option::Some("CHARGEBACK"),
                Self::ChargebackRepresentment => {
                    std::option::Option::Some("CHARGEBACK_REPRESENTMENT")
                }
                Self::ChargebackReverse => std::option::Option::Some("CHARGEBACK_REVERSE"),
                Self::RefundRequest => std::option::Option::Some("REFUND_REQUEST"),
                Self::RefundDecline => std::option::Option::Some("REFUND_DECLINE"),
                Self::Refund => std::option::Option::Some("REFUND"),
                Self::RefundReverse => std::option::Option::Some("REFUND_REVERSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransactionEventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransactionEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransactionEventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MerchantApprove,
                2 => Self::MerchantDeny,
                3 => Self::ManualReview,
                4 => Self::Authorization,
                5 => Self::AuthorizationDecline,
                6 => Self::PaymentCapture,
                7 => Self::PaymentCaptureDecline,
                8 => Self::Cancel,
                9 => Self::ChargebackInquiry,
                10 => Self::ChargebackAlert,
                11 => Self::FraudNotification,
                12 => Self::Chargeback,
                13 => Self::ChargebackRepresentment,
                14 => Self::ChargebackReverse,
                15 => Self::RefundRequest,
                16 => Self::RefundDecline,
                17 => Self::Refund,
                18 => Self::RefundReverse,
                _ => Self::UnknownValue(transaction_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransactionEventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSACTION_EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MERCHANT_APPROVE" => Self::MerchantApprove,
                "MERCHANT_DENY" => Self::MerchantDeny,
                "MANUAL_REVIEW" => Self::ManualReview,
                "AUTHORIZATION" => Self::Authorization,
                "AUTHORIZATION_DECLINE" => Self::AuthorizationDecline,
                "PAYMENT_CAPTURE" => Self::PaymentCapture,
                "PAYMENT_CAPTURE_DECLINE" => Self::PaymentCaptureDecline,
                "CANCEL" => Self::Cancel,
                "CHARGEBACK_INQUIRY" => Self::ChargebackInquiry,
                "CHARGEBACK_ALERT" => Self::ChargebackAlert,
                "FRAUD_NOTIFICATION" => Self::FraudNotification,
                "CHARGEBACK" => Self::Chargeback,
                "CHARGEBACK_REPRESENTMENT" => Self::ChargebackRepresentment,
                "CHARGEBACK_REVERSE" => Self::ChargebackReverse,
                "REFUND_REQUEST" => Self::RefundRequest,
                "REFUND_DECLINE" => Self::RefundDecline,
                "REFUND" => Self::Refund,
                "REFUND_REVERSE" => Self::RefundReverse,
                _ => Self::UnknownValue(transaction_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransactionEventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MerchantApprove => serializer.serialize_i32(1),
                Self::MerchantDeny => serializer.serialize_i32(2),
                Self::ManualReview => serializer.serialize_i32(3),
                Self::Authorization => serializer.serialize_i32(4),
                Self::AuthorizationDecline => serializer.serialize_i32(5),
                Self::PaymentCapture => serializer.serialize_i32(6),
                Self::PaymentCaptureDecline => serializer.serialize_i32(7),
                Self::Cancel => serializer.serialize_i32(8),
                Self::ChargebackInquiry => serializer.serialize_i32(9),
                Self::ChargebackAlert => serializer.serialize_i32(10),
                Self::FraudNotification => serializer.serialize_i32(11),
                Self::Chargeback => serializer.serialize_i32(12),
                Self::ChargebackRepresentment => serializer.serialize_i32(13),
                Self::ChargebackReverse => serializer.serialize_i32(14),
                Self::RefundRequest => serializer.serialize_i32(15),
                Self::RefundDecline => serializer.serialize_i32(16),
                Self::Refund => serializer.serialize_i32(17),
                Self::RefundReverse => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransactionEventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransactionEventType>::new(
                ".google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType",
            ))
        }
    }
}

/// The request message to annotate an Assessment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateAssessmentRequest {
    /// Required. The resource name of the Assessment, in the format
    /// `projects/{project}/assessments/{assessment}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The annotation that is assigned to the Event. This field can be
    /// left empty to provide reasons that apply to an event without concluding
    /// whether the event is legitimate or fraudulent.
    pub annotation: crate::model::annotate_assessment_request::Annotation,

    /// Optional. Reasons for the annotation that are assigned to the event.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reasons: std::vec::Vec<crate::model::annotate_assessment_request::Reason>,

    /// Optional. A stable account identifier to apply to the assessment. This is
    /// an alternative to setting `account_id` in `CreateAssessment`, for example
    /// when a stable account identifier is not yet known in the initial request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id: std::string::String,

    /// Optional. A stable hashed account identifier to apply to the assessment.
    /// This is an alternative to setting `hashed_account_id` in
    /// `CreateAssessment`, for example when a stable account identifier is not yet
    /// known in the initial request.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. If the assessment is part of a payment transaction, provide
    /// details on payment lifecycle events that occur in the transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_event: std::option::Option<crate::model::TransactionEvent>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateAssessmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnnotateAssessmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [annotation][crate::model::AnnotateAssessmentRequest::annotation].
    pub fn set_annotation<
        T: std::convert::Into<crate::model::annotate_assessment_request::Annotation>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::AnnotateAssessmentRequest::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::AnnotateAssessmentRequest::hashed_account_id].
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [transaction_event][crate::model::AnnotateAssessmentRequest::transaction_event].
    pub fn set_transaction_event<
        T: std::convert::Into<std::option::Option<crate::model::TransactionEvent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transaction_event = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::AnnotateAssessmentRequest::reasons].
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::annotate_assessment_request::Reason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateAssessmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest"
    }
}

/// Defines additional types related to [AnnotateAssessmentRequest].
pub mod annotate_assessment_request {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the types of annotations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Annotation {
        /// Default unspecified type.
        Unspecified,
        /// Provides information that the event turned out to be legitimate.
        Legitimate,
        /// Provides information that the event turned out to be fraudulent.
        Fraudulent,
        /// Provides information that the event was related to a login event in which
        /// the user typed the correct password. Deprecated, prefer indicating
        /// CORRECT_PASSWORD through the reasons field instead.
        #[deprecated]
        PasswordCorrect,
        /// Provides information that the event was related to a login event in which
        /// the user typed the incorrect password. Deprecated, prefer indicating
        /// INCORRECT_PASSWORD through the reasons field instead.
        #[deprecated]
        PasswordIncorrect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Annotation::value] or
        /// [Annotation::name].
        UnknownValue(annotation::UnknownValue),
    }

    #[doc(hidden)]
    pub mod annotation {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Annotation {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Legitimate => std::option::Option::Some(1),
                Self::Fraudulent => std::option::Option::Some(2),
                Self::PasswordCorrect => std::option::Option::Some(3),
                Self::PasswordIncorrect => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANNOTATION_UNSPECIFIED"),
                Self::Legitimate => std::option::Option::Some("LEGITIMATE"),
                Self::Fraudulent => std::option::Option::Some("FRAUDULENT"),
                Self::PasswordCorrect => std::option::Option::Some("PASSWORD_CORRECT"),
                Self::PasswordIncorrect => std::option::Option::Some("PASSWORD_INCORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Annotation {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Annotation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Annotation {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Legitimate,
                2 => Self::Fraudulent,
                3 => Self::PasswordCorrect,
                4 => Self::PasswordIncorrect,
                _ => Self::UnknownValue(annotation::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Annotation {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANNOTATION_UNSPECIFIED" => Self::Unspecified,
                "LEGITIMATE" => Self::Legitimate,
                "FRAUDULENT" => Self::Fraudulent,
                "PASSWORD_CORRECT" => Self::PasswordCorrect,
                "PASSWORD_INCORRECT" => Self::PasswordIncorrect,
                _ => Self::UnknownValue(annotation::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Annotation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Legitimate => serializer.serialize_i32(1),
                Self::Fraudulent => serializer.serialize_i32(2),
                Self::PasswordCorrect => serializer.serialize_i32(3),
                Self::PasswordIncorrect => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Annotation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Annotation>::new(
                ".google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation",
            ))
        }
    }

    /// Enum that represents potential reasons for annotating an assessment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reason {
        /// Unspecified reason. Do not use.
        Unspecified,
        /// Indicates that the transaction had a chargeback issued with no other
        /// details. When possible, specify the type by using CHARGEBACK_FRAUD or
        /// CHARGEBACK_DISPUTE instead.
        Chargeback,
        /// Indicates that the transaction had a chargeback issued related to an
        /// alleged unauthorized transaction from the cardholder's perspective (for
        /// example, the card number was stolen).
        ChargebackFraud,
        /// Indicates that the transaction had a chargeback issued related to the
        /// cardholder having provided their card details but allegedly not being
        /// satisfied with the purchase (for example, misrepresentation, attempted
        /// cancellation).
        ChargebackDispute,
        /// Indicates that the completed payment transaction was refunded by the
        /// seller.
        Refund,
        /// Indicates that the completed payment transaction was determined to be
        /// fraudulent by the seller, and was cancelled and refunded as a result.
        RefundFraud,
        /// Indicates that the payment transaction was accepted, and the user was
        /// charged.
        TransactionAccepted,
        /// Indicates that the payment transaction was declined, for example due to
        /// invalid card details.
        TransactionDeclined,
        /// Indicates the transaction associated with the assessment is suspected of
        /// being fraudulent based on the payment method, billing details, shipping
        /// address or other transaction information.
        PaymentHeuristics,
        /// Indicates that the user was served a 2FA challenge. An old assessment
        /// with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
        /// overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
        /// This is equivalent to `FAILED_TWO_FACTOR`.
        InitiatedTwoFactor,
        /// Indicates that the user passed a 2FA challenge.
        PassedTwoFactor,
        /// Indicates that the user failed a 2FA challenge.
        FailedTwoFactor,
        /// Indicates the user provided the correct password.
        CorrectPassword,
        /// Indicates the user provided an incorrect password.
        IncorrectPassword,
        /// Indicates that the user sent unwanted and abusive messages to other users
        /// of the platform, such as spam, scams, phishing, or social engineering.
        SocialSpam,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reason::value] or
        /// [Reason::name].
        UnknownValue(reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Chargeback => std::option::Option::Some(1),
                Self::ChargebackFraud => std::option::Option::Some(8),
                Self::ChargebackDispute => std::option::Option::Some(9),
                Self::Refund => std::option::Option::Some(10),
                Self::RefundFraud => std::option::Option::Some(11),
                Self::TransactionAccepted => std::option::Option::Some(12),
                Self::TransactionDeclined => std::option::Option::Some(13),
                Self::PaymentHeuristics => std::option::Option::Some(2),
                Self::InitiatedTwoFactor => std::option::Option::Some(7),
                Self::PassedTwoFactor => std::option::Option::Some(3),
                Self::FailedTwoFactor => std::option::Option::Some(4),
                Self::CorrectPassword => std::option::Option::Some(5),
                Self::IncorrectPassword => std::option::Option::Some(6),
                Self::SocialSpam => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                Self::Chargeback => std::option::Option::Some("CHARGEBACK"),
                Self::ChargebackFraud => std::option::Option::Some("CHARGEBACK_FRAUD"),
                Self::ChargebackDispute => std::option::Option::Some("CHARGEBACK_DISPUTE"),
                Self::Refund => std::option::Option::Some("REFUND"),
                Self::RefundFraud => std::option::Option::Some("REFUND_FRAUD"),
                Self::TransactionAccepted => std::option::Option::Some("TRANSACTION_ACCEPTED"),
                Self::TransactionDeclined => std::option::Option::Some("TRANSACTION_DECLINED"),
                Self::PaymentHeuristics => std::option::Option::Some("PAYMENT_HEURISTICS"),
                Self::InitiatedTwoFactor => std::option::Option::Some("INITIATED_TWO_FACTOR"),
                Self::PassedTwoFactor => std::option::Option::Some("PASSED_TWO_FACTOR"),
                Self::FailedTwoFactor => std::option::Option::Some("FAILED_TWO_FACTOR"),
                Self::CorrectPassword => std::option::Option::Some("CORRECT_PASSWORD"),
                Self::IncorrectPassword => std::option::Option::Some("INCORRECT_PASSWORD"),
                Self::SocialSpam => std::option::Option::Some("SOCIAL_SPAM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Chargeback,
                2 => Self::PaymentHeuristics,
                3 => Self::PassedTwoFactor,
                4 => Self::FailedTwoFactor,
                5 => Self::CorrectPassword,
                6 => Self::IncorrectPassword,
                7 => Self::InitiatedTwoFactor,
                8 => Self::ChargebackFraud,
                9 => Self::ChargebackDispute,
                10 => Self::Refund,
                11 => Self::RefundFraud,
                12 => Self::TransactionAccepted,
                13 => Self::TransactionDeclined,
                14 => Self::SocialSpam,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REASON_UNSPECIFIED" => Self::Unspecified,
                "CHARGEBACK" => Self::Chargeback,
                "CHARGEBACK_FRAUD" => Self::ChargebackFraud,
                "CHARGEBACK_DISPUTE" => Self::ChargebackDispute,
                "REFUND" => Self::Refund,
                "REFUND_FRAUD" => Self::RefundFraud,
                "TRANSACTION_ACCEPTED" => Self::TransactionAccepted,
                "TRANSACTION_DECLINED" => Self::TransactionDeclined,
                "PAYMENT_HEURISTICS" => Self::PaymentHeuristics,
                "INITIATED_TWO_FACTOR" => Self::InitiatedTwoFactor,
                "PASSED_TWO_FACTOR" => Self::PassedTwoFactor,
                "FAILED_TWO_FACTOR" => Self::FailedTwoFactor,
                "CORRECT_PASSWORD" => Self::CorrectPassword,
                "INCORRECT_PASSWORD" => Self::IncorrectPassword,
                "SOCIAL_SPAM" => Self::SocialSpam,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Chargeback => serializer.serialize_i32(1),
                Self::ChargebackFraud => serializer.serialize_i32(8),
                Self::ChargebackDispute => serializer.serialize_i32(9),
                Self::Refund => serializer.serialize_i32(10),
                Self::RefundFraud => serializer.serialize_i32(11),
                Self::TransactionAccepted => serializer.serialize_i32(12),
                Self::TransactionDeclined => serializer.serialize_i32(13),
                Self::PaymentHeuristics => serializer.serialize_i32(2),
                Self::InitiatedTwoFactor => serializer.serialize_i32(7),
                Self::PassedTwoFactor => serializer.serialize_i32(3),
                Self::FailedTwoFactor => serializer.serialize_i32(4),
                Self::CorrectPassword => serializer.serialize_i32(5),
                Self::IncorrectPassword => serializer.serialize_i32(6),
                Self::SocialSpam => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                ".google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason",
            ))
        }
    }
}

/// Empty response for AnnotateAssessment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateAssessmentResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateAssessmentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AnnotateAssessmentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AnnotateAssessmentResponse"
    }
}

/// Information about a verification endpoint that can be used for 2FA.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EndpointVerificationInfo {
    /// Output only. Token to provide to the client to trigger endpoint
    /// verification. It must be used within 15 minutes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_token: std::string::String,

    /// Output only. Timestamp of the last successful verification for the
    /// endpoint, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_verification_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint: std::option::Option<crate::model::endpoint_verification_info::Endpoint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_token][crate::model::EndpointVerificationInfo::request_token].
    pub fn set_request_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_token = v.into();
        self
    }

    /// Sets the value of [last_verification_time][crate::model::EndpointVerificationInfo::last_verification_time].
    pub fn set_last_verification_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_verification_time = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint].
    ///
    /// Note that all the setters affecting `endpoint` are mutually
    /// exclusive.
    pub fn set_endpoint<
        T: std::convert::Into<std::option::Option<crate::model::endpoint_verification_info::Endpoint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint = v.into();
        self
    }

    /// The value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// if it holds a `EmailAddress`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email_address(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.endpoint.as_ref().and_then(|v| match v {
            crate::model::endpoint_verification_info::Endpoint::EmailAddress(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// if it holds a `PhoneNumber`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.endpoint.as_ref().and_then(|v| match v {
            crate::model::endpoint_verification_info::Endpoint::PhoneNumber(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// to hold a `EmailAddress`.
    ///
    /// Note that all the setters affecting `endpoint` are
    /// mutually exclusive.
    pub fn set_email_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = std::option::Option::Some(
            crate::model::endpoint_verification_info::Endpoint::EmailAddress(v.into()),
        );
        self
    }

    /// Sets the value of [endpoint][crate::model::EndpointVerificationInfo::endpoint]
    /// to hold a `PhoneNumber`.
    ///
    /// Note that all the setters affecting `endpoint` are
    /// mutually exclusive.
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = std::option::Option::Some(
            crate::model::endpoint_verification_info::Endpoint::PhoneNumber(v.into()),
        );
        self
    }
}

impl wkt::message::Message for EndpointVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo"
    }
}

/// Defines additional types related to [EndpointVerificationInfo].
pub mod endpoint_verification_info {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Endpoint {
        /// Email address for which to trigger a verification request.
        EmailAddress(std::string::String),
        /// Phone number for which to trigger a verification request. Should be given
        /// in E.164 format.
        PhoneNumber(std::string::String),
    }
}

/// Information about account verification, used for identity verification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccountVerificationInfo {
    /// Optional. Endpoints that can be used for identity verification.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub endpoints: std::vec::Vec<crate::model::EndpointVerificationInfo>,

    /// Optional. Language code preference for the verification message, set as a
    /// IETF BCP 47 language code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Output only. Result of the latest account verification challenge.
    pub latest_verification_result: crate::model::account_verification_info::Result,

    /// Username of the account that is being verified. Deprecated. Customers
    /// should now provide the `account_id` field in `event.user_info`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::AccountVerificationInfo::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [latest_verification_result][crate::model::AccountVerificationInfo::latest_verification_result].
    pub fn set_latest_verification_result<
        T: std::convert::Into<crate::model::account_verification_info::Result>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_verification_result = v.into();
        self
    }

    /// Sets the value of [username][crate::model::AccountVerificationInfo::username].
    #[deprecated]
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::AccountVerificationInfo::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EndpointVerificationInfo>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccountVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AccountVerificationInfo"
    }
}

/// Defines additional types related to [AccountVerificationInfo].
pub mod account_verification_info {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the account verification as contained in the verdict token issued
    /// at the end of the verification flow.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// No information about the latest account verification.
        Unspecified,
        /// The user was successfully verified. This means the account verification
        /// challenge was successfully completed.
        SuccessUserVerified,
        /// The user failed the verification challenge.
        ErrorUserNotVerified,
        /// The site is not properly onboarded to use the account verification
        /// feature.
        ErrorSiteOnboardingIncomplete,
        /// The recipient is not allowed for account verification. This can occur
        /// during integration but should not occur in production.
        ErrorRecipientNotAllowed,
        /// The recipient has already been sent too many verification codes in a
        /// short amount of time.
        ErrorRecipientAbuseLimitExhausted,
        /// The verification flow could not be completed due to a critical internal
        /// error.
        ErrorCriticalInternal,
        /// The client has exceeded their two factor request quota for this period of
        /// time.
        ErrorCustomerQuotaExhausted,
        /// The request cannot be processed at the time because of an incident. This
        /// bypass can be restricted to a problematic destination email domain, a
        /// customer, or could affect the entire service.
        ErrorVerificationBypassed,
        /// The request parameters do not match with the token provided and cannot be
        /// processed.
        ErrorVerdictMismatch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SuccessUserVerified => std::option::Option::Some(1),
                Self::ErrorUserNotVerified => std::option::Option::Some(2),
                Self::ErrorSiteOnboardingIncomplete => std::option::Option::Some(3),
                Self::ErrorRecipientNotAllowed => std::option::Option::Some(4),
                Self::ErrorRecipientAbuseLimitExhausted => std::option::Option::Some(5),
                Self::ErrorCriticalInternal => std::option::Option::Some(6),
                Self::ErrorCustomerQuotaExhausted => std::option::Option::Some(7),
                Self::ErrorVerificationBypassed => std::option::Option::Some(8),
                Self::ErrorVerdictMismatch => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::SuccessUserVerified => std::option::Option::Some("SUCCESS_USER_VERIFIED"),
                Self::ErrorUserNotVerified => std::option::Option::Some("ERROR_USER_NOT_VERIFIED"),
                Self::ErrorSiteOnboardingIncomplete => {
                    std::option::Option::Some("ERROR_SITE_ONBOARDING_INCOMPLETE")
                }
                Self::ErrorRecipientNotAllowed => {
                    std::option::Option::Some("ERROR_RECIPIENT_NOT_ALLOWED")
                }
                Self::ErrorRecipientAbuseLimitExhausted => {
                    std::option::Option::Some("ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED")
                }
                Self::ErrorCriticalInternal => std::option::Option::Some("ERROR_CRITICAL_INTERNAL"),
                Self::ErrorCustomerQuotaExhausted => {
                    std::option::Option::Some("ERROR_CUSTOMER_QUOTA_EXHAUSTED")
                }
                Self::ErrorVerificationBypassed => {
                    std::option::Option::Some("ERROR_VERIFICATION_BYPASSED")
                }
                Self::ErrorVerdictMismatch => std::option::Option::Some("ERROR_VERDICT_MISMATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SuccessUserVerified,
                2 => Self::ErrorUserNotVerified,
                3 => Self::ErrorSiteOnboardingIncomplete,
                4 => Self::ErrorRecipientNotAllowed,
                5 => Self::ErrorRecipientAbuseLimitExhausted,
                6 => Self::ErrorCriticalInternal,
                7 => Self::ErrorCustomerQuotaExhausted,
                8 => Self::ErrorVerificationBypassed,
                9 => Self::ErrorVerdictMismatch,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "SUCCESS_USER_VERIFIED" => Self::SuccessUserVerified,
                "ERROR_USER_NOT_VERIFIED" => Self::ErrorUserNotVerified,
                "ERROR_SITE_ONBOARDING_INCOMPLETE" => Self::ErrorSiteOnboardingIncomplete,
                "ERROR_RECIPIENT_NOT_ALLOWED" => Self::ErrorRecipientNotAllowed,
                "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED" => Self::ErrorRecipientAbuseLimitExhausted,
                "ERROR_CRITICAL_INTERNAL" => Self::ErrorCriticalInternal,
                "ERROR_CUSTOMER_QUOTA_EXHAUSTED" => Self::ErrorCustomerQuotaExhausted,
                "ERROR_VERIFICATION_BYPASSED" => Self::ErrorVerificationBypassed,
                "ERROR_VERDICT_MISMATCH" => Self::ErrorVerdictMismatch,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SuccessUserVerified => serializer.serialize_i32(1),
                Self::ErrorUserNotVerified => serializer.serialize_i32(2),
                Self::ErrorSiteOnboardingIncomplete => serializer.serialize_i32(3),
                Self::ErrorRecipientNotAllowed => serializer.serialize_i32(4),
                Self::ErrorRecipientAbuseLimitExhausted => serializer.serialize_i32(5),
                Self::ErrorCriticalInternal => serializer.serialize_i32(6),
                Self::ErrorCustomerQuotaExhausted => serializer.serialize_i32(7),
                Self::ErrorVerificationBypassed => serializer.serialize_i32(8),
                Self::ErrorVerdictMismatch => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result",
            ))
        }
    }
}

/// Private password leak verification info.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivatePasswordLeakVerification {
    /// Required. Exactly 26-bit prefix of the SHA-256 hash of the canonicalized
    /// username. It is used to look up password leaks associated with that hash
    /// prefix.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub lookup_hash_prefix: ::bytes::Bytes,

    /// Optional. Encrypted Scrypt hash of the canonicalized username+password. It
    /// is re-encrypted by the server and returned through
    /// `reencrypted_user_credentials_hash`.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub encrypted_user_credentials_hash: ::bytes::Bytes,

    /// Output only. List of prefixes of the encrypted potential password leaks
    /// that matched the given parameters. They must be compared with the
    /// client-side decryption prefix of `reencrypted_user_credentials_hash`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub encrypted_leak_match_prefixes: std::vec::Vec<::bytes::Bytes>,

    /// Output only. Corresponds to the re-encryption of the
    /// `encrypted_user_credentials_hash` field. It is used to match potential
    /// password leaks within `encrypted_leak_match_prefixes`.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub reencrypted_user_credentials_hash: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePasswordLeakVerification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lookup_hash_prefix][crate::model::PrivatePasswordLeakVerification::lookup_hash_prefix].
    pub fn set_lookup_hash_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.lookup_hash_prefix = v.into();
        self
    }

    /// Sets the value of [encrypted_user_credentials_hash][crate::model::PrivatePasswordLeakVerification::encrypted_user_credentials_hash].
    pub fn set_encrypted_user_credentials_hash<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.encrypted_user_credentials_hash = v.into();
        self
    }

    /// Sets the value of [reencrypted_user_credentials_hash][crate::model::PrivatePasswordLeakVerification::reencrypted_user_credentials_hash].
    pub fn set_reencrypted_user_credentials_hash<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.reencrypted_user_credentials_hash = v.into();
        self
    }

    /// Sets the value of [encrypted_leak_match_prefixes][crate::model::PrivatePasswordLeakVerification::encrypted_leak_match_prefixes].
    pub fn set_encrypted_leak_match_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.encrypted_leak_match_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PrivatePasswordLeakVerification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification"
    }
}

/// A reCAPTCHA Enterprise assessment resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Assessment {
    /// Output only. Identifier. The resource name for the Assessment in the format
    /// `projects/{project}/assessments/{assessment}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The event being assessed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event: std::option::Option<crate::model::Event>,

    /// Output only. The risk analysis result for the event being assessed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub risk_analysis: std::option::Option<crate::model::RiskAnalysis>,

    /// Output only. Properties of the provided event token.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub token_properties: std::option::Option<crate::model::TokenProperties>,

    /// Optional. Account verification information for identity verification. The
    /// assessment event must include a token and site key to use this feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub account_verification: std::option::Option<crate::model::AccountVerificationInfo>,

    /// Output only. Assessment returned by account defender when an account
    /// identifier is provided.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub account_defender_assessment: std::option::Option<crate::model::AccountDefenderAssessment>,

    /// Optional. The private password leak verification field contains the
    /// parameters that are used to to check for leaks privately without sharing
    /// user credentials.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_password_leak_verification:
        std::option::Option<crate::model::PrivatePasswordLeakVerification>,

    /// Output only. Assessment returned when firewall policies belonging to the
    /// project are evaluated using the field firewall_policy_evaluation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub firewall_policy_assessment: std::option::Option<crate::model::FirewallPolicyAssessment>,

    /// Output only. Assessment returned by Fraud Prevention when TransactionData
    /// is provided.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fraud_prevention_assessment: std::option::Option<crate::model::FraudPreventionAssessment>,

    /// Output only. Fraud Signals specific to the users involved in a payment
    /// transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fraud_signals: std::option::Option<crate::model::FraudSignals>,

    /// Output only. Assessment returned when a site key, a token, and a phone
    /// number as `user_id` are provided. Account defender and SMS toll fraud
    /// protection need to be enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub phone_fraud_assessment: std::option::Option<crate::model::PhoneFraudAssessment>,

    /// Optional. The environment creating the assessment. This describes your
    /// environment (the system invoking CreateAssessment), NOT the environment of
    /// your user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assessment_environment: std::option::Option<crate::model::AssessmentEnvironment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Assessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Assessment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event][crate::model::Assessment::event].
    pub fn set_event<T: std::convert::Into<std::option::Option<crate::model::Event>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }

    /// Sets the value of [risk_analysis][crate::model::Assessment::risk_analysis].
    pub fn set_risk_analysis<
        T: std::convert::Into<std::option::Option<crate::model::RiskAnalysis>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.risk_analysis = v.into();
        self
    }

    /// Sets the value of [token_properties][crate::model::Assessment::token_properties].
    pub fn set_token_properties<
        T: std::convert::Into<std::option::Option<crate::model::TokenProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_properties = v.into();
        self
    }

    /// Sets the value of [account_verification][crate::model::Assessment::account_verification].
    pub fn set_account_verification<
        T: std::convert::Into<std::option::Option<crate::model::AccountVerificationInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.account_verification = v.into();
        self
    }

    /// Sets the value of [account_defender_assessment][crate::model::Assessment::account_defender_assessment].
    pub fn set_account_defender_assessment<
        T: std::convert::Into<std::option::Option<crate::model::AccountDefenderAssessment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.account_defender_assessment = v.into();
        self
    }

    /// Sets the value of [private_password_leak_verification][crate::model::Assessment::private_password_leak_verification].
    pub fn set_private_password_leak_verification<
        T: std::convert::Into<std::option::Option<crate::model::PrivatePasswordLeakVerification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_password_leak_verification = v.into();
        self
    }

    /// Sets the value of [firewall_policy_assessment][crate::model::Assessment::firewall_policy_assessment].
    pub fn set_firewall_policy_assessment<
        T: std::convert::Into<std::option::Option<crate::model::FirewallPolicyAssessment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_policy_assessment = v.into();
        self
    }

    /// Sets the value of [fraud_prevention_assessment][crate::model::Assessment::fraud_prevention_assessment].
    pub fn set_fraud_prevention_assessment<
        T: std::convert::Into<std::option::Option<crate::model::FraudPreventionAssessment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.fraud_prevention_assessment = v.into();
        self
    }

    /// Sets the value of [fraud_signals][crate::model::Assessment::fraud_signals].
    pub fn set_fraud_signals<
        T: std::convert::Into<std::option::Option<crate::model::FraudSignals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.fraud_signals = v.into();
        self
    }

    /// Sets the value of [phone_fraud_assessment][crate::model::Assessment::phone_fraud_assessment].
    pub fn set_phone_fraud_assessment<
        T: std::convert::Into<std::option::Option<crate::model::PhoneFraudAssessment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.phone_fraud_assessment = v.into();
        self
    }

    /// Sets the value of [assessment_environment][crate::model::Assessment::assessment_environment].
    pub fn set_assessment_environment<
        T: std::convert::Into<std::option::Option<crate::model::AssessmentEnvironment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assessment_environment = v.into();
        self
    }
}

impl wkt::message::Message for Assessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Assessment"
    }
}

/// The event being assessed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Optional. The user response token provided by the reCAPTCHA Enterprise
    /// client-side integration on your site.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token: std::string::String,

    /// Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
    /// site and generate the token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site_key: std::string::String,

    /// Optional. The user agent present in the request from the user's device
    /// related to this event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_agent: std::string::String,

    /// Optional. The IP address in the request from the user's device related to
    /// this event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_ip_address: std::string::String,

    /// Optional. The expected action for this type of event. This should be the
    /// same action provided at token generation time on client-side platforms
    /// already integrated with recaptcha enterprise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub expected_action: std::string::String,

    /// Optional. Deprecated: use `user_info.account_id` instead.
    /// Unique stable hashed user identifier for the request. The identifier must
    /// be hashed using hmac-sha256 with stable secret.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. Flag for a reCAPTCHA express request for an assessment without a
    /// token. If enabled, `site_key` must reference an Express site key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub express: bool,

    /// Optional. The URI resource the user requested that triggered an assessment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub requested_uri: std::string::String,

    /// Optional. Flag for running WAF token assessment.
    /// If enabled, the token must be specified, and have been created by a
    /// WAF-enabled key.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub waf_token_assessment: bool,

    /// Optional. JA3 fingerprint for SSL clients. To learn how to compute this
    /// fingerprint, please refer to <https://github.com/salesforce/ja3>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ja3: std::string::String,

    /// Optional. JA4 fingerprint for SSL clients. To learn how to compute this
    /// fingerprint, please refer to <https://github.com/FoxIO-LLC/ja4>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ja4: std::string::String,

    /// Optional. HTTP header information about the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub headers: std::vec::Vec<std::string::String>,

    /// Optional. Flag for enabling firewall policy config assessment.
    /// If this flag is enabled, the firewall policy is evaluated and a
    /// suggested firewall action is returned in the response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub firewall_policy_evaluation: bool,

    /// Optional. Data describing a payment transaction to be assessed. Sending
    /// this data enables reCAPTCHA Enterprise Fraud Prevention and the
    /// FraudPreventionAssessment component in the response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_data: std::option::Option<crate::model::TransactionData>,

    /// Optional. Information about the user that generates this event, when they
    /// can be identified. They are often identified through the use of an account
    /// for logged-in requests or login/registration requests, or by providing user
    /// identifiers for guest actions like checkout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// Optional. The Fraud Prevention setting for this assessment.
    pub fraud_prevention: crate::model::event::FraudPrevention,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::Event::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [site_key][crate::model::Event::site_key].
    pub fn set_site_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site_key = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::Event::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [user_ip_address][crate::model::Event::user_ip_address].
    pub fn set_user_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_ip_address = v.into();
        self
    }

    /// Sets the value of [expected_action][crate::model::Event::expected_action].
    pub fn set_expected_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expected_action = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::Event::hashed_account_id].
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [express][crate::model::Event::express].
    pub fn set_express<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.express = v.into();
        self
    }

    /// Sets the value of [requested_uri][crate::model::Event::requested_uri].
    pub fn set_requested_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.requested_uri = v.into();
        self
    }

    /// Sets the value of [waf_token_assessment][crate::model::Event::waf_token_assessment].
    pub fn set_waf_token_assessment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.waf_token_assessment = v.into();
        self
    }

    /// Sets the value of [ja3][crate::model::Event::ja3].
    pub fn set_ja3<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ja3 = v.into();
        self
    }

    /// Sets the value of [ja4][crate::model::Event::ja4].
    pub fn set_ja4<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ja4 = v.into();
        self
    }

    /// Sets the value of [firewall_policy_evaluation][crate::model::Event::firewall_policy_evaluation].
    pub fn set_firewall_policy_evaluation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.firewall_policy_evaluation = v.into();
        self
    }

    /// Sets the value of [transaction_data][crate::model::Event::transaction_data].
    pub fn set_transaction_data<
        T: std::convert::Into<std::option::Option<crate::model::TransactionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transaction_data = v.into();
        self
    }

    /// Sets the value of [user_info][crate::model::Event::user_info].
    pub fn set_user_info<T: std::convert::Into<std::option::Option<crate::model::UserInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_info = v.into();
        self
    }

    /// Sets the value of [fraud_prevention][crate::model::Event::fraud_prevention].
    pub fn set_fraud_prevention<T: std::convert::Into<crate::model::event::FraudPrevention>>(
        mut self,
        v: T,
    ) -> Self {
        self.fraud_prevention = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::Event::headers].
    pub fn set_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Event"
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Setting that controls Fraud Prevention assessments.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FraudPrevention {
        /// Default, unspecified setting. `fraud_prevention_assessment` is returned
        /// if `transaction_data` is present in `Event` and Fraud Prevention is
        /// enabled in the Google Cloud console.
        Unspecified,
        /// Enable Fraud Prevention for this assessment, if Fraud Prevention is
        /// enabled in the Google Cloud console.
        Enabled,
        /// Disable Fraud Prevention for this assessment, regardless of the Google
        /// Cloud console settings.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FraudPrevention::value] or
        /// [FraudPrevention::name].
        UnknownValue(fraud_prevention::UnknownValue),
    }

    #[doc(hidden)]
    pub mod fraud_prevention {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FraudPrevention {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FRAUD_PREVENTION_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FraudPrevention {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FraudPrevention {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FraudPrevention {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                _ => Self::UnknownValue(fraud_prevention::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FraudPrevention {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FRAUD_PREVENTION_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(fraud_prevention::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FraudPrevention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FraudPrevention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FraudPrevention>::new(
                ".google.cloud.recaptchaenterprise.v1.Event.FraudPrevention",
            ))
        }
    }
}

/// Transaction data associated with a payment protected by reCAPTCHA Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransactionData {
    /// Unique identifier for the transaction. This custom identifier can be used
    /// to reference this transaction in the future, for example, labeling a refund
    /// or chargeback event. Two attempts at the same transaction should use the
    /// same transaction id.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_id: std::option::Option<std::string::String>,

    /// Optional. The payment method for the transaction. The allowed values are:
    ///
    /// * credit-card
    /// * debit-card
    /// * gift-card
    /// * processor-{name} (If a third-party is used, for example,
    ///   processor-paypal)
    /// * custom-{name} (If an alternative method is used, for example,
    ///   custom-crypto)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub payment_method: std::string::String,

    /// Optional. The Bank Identification Number - generally the first 6 or 8
    /// digits of the card.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub card_bin: std::string::String,

    /// Optional. The last four digits of the card.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub card_last_four: std::string::String,

    /// Optional. The currency code in ISO-4217 format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub currency_code: std::string::String,

    /// Optional. The decimal value of the transaction in the specified currency.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub value: f64,

    /// Optional. The value of shipping in the specified currency. 0 for free or no
    /// shipping.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub shipping_value: f64,

    /// Optional. Destination address if this transaction involves shipping a
    /// physical item.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shipping_address: std::option::Option<crate::model::transaction_data::Address>,

    /// Optional. Address associated with the payment method when applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub billing_address: std::option::Option<crate::model::transaction_data::Address>,

    /// Optional. Information about the user paying/initiating the transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user: std::option::Option<crate::model::transaction_data::User>,

    /// Optional. Information about the user or users fulfilling the transaction.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub merchants: std::vec::Vec<crate::model::transaction_data::User>,

    /// Optional. Items purchased in this transaction.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::transaction_data::Item>,

    /// Optional. Information about the payment gateway's response to the
    /// transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gateway_info: std::option::Option<crate::model::transaction_data::GatewayInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transaction_id][crate::model::TransactionData::transaction_id].
    pub fn set_transaction_id<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.transaction_id = v.into();
        self
    }

    /// Sets the value of [payment_method][crate::model::TransactionData::payment_method].
    pub fn set_payment_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payment_method = v.into();
        self
    }

    /// Sets the value of [card_bin][crate::model::TransactionData::card_bin].
    pub fn set_card_bin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.card_bin = v.into();
        self
    }

    /// Sets the value of [card_last_four][crate::model::TransactionData::card_last_four].
    pub fn set_card_last_four<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.card_last_four = v.into();
        self
    }

    /// Sets the value of [currency_code][crate::model::TransactionData::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }

    /// Sets the value of [value][crate::model::TransactionData::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [shipping_value][crate::model::TransactionData::shipping_value].
    pub fn set_shipping_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.shipping_value = v.into();
        self
    }

    /// Sets the value of [shipping_address][crate::model::TransactionData::shipping_address].
    pub fn set_shipping_address<
        T: std::convert::Into<std::option::Option<crate::model::transaction_data::Address>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shipping_address = v.into();
        self
    }

    /// Sets the value of [billing_address][crate::model::TransactionData::billing_address].
    pub fn set_billing_address<
        T: std::convert::Into<std::option::Option<crate::model::transaction_data::Address>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.billing_address = v.into();
        self
    }

    /// Sets the value of [user][crate::model::TransactionData::user].
    pub fn set_user<
        T: std::convert::Into<std::option::Option<crate::model::transaction_data::User>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [gateway_info][crate::model::TransactionData::gateway_info].
    pub fn set_gateway_info<
        T: std::convert::Into<std::option::Option<crate::model::transaction_data::GatewayInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gateway_info = v.into();
        self
    }

    /// Sets the value of [merchants][crate::model::TransactionData::merchants].
    pub fn set_merchants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transaction_data::User>,
    {
        use std::iter::Iterator;
        self.merchants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [items][crate::model::TransactionData::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transaction_data::Item>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TransactionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData"
    }
}

/// Defines additional types related to [TransactionData].
pub mod transaction_data {
    #[allow(unused_imports)]
    use super::*;

    /// Structured address format for billing and shipping addresses.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Address {
        /// Optional. The recipient name, potentially including information such as
        /// "care of".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub recipient: std::string::String,

        /// Optional. The first lines of the address. The first line generally
        /// contains the street name and number, and further lines may include
        /// information such as an apartment number.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub address: std::vec::Vec<std::string::String>,

        /// Optional. The town/city of the address.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub locality: std::string::String,

        /// Optional. The state, province, or otherwise administrative area of the
        /// address.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub administrative_area: std::string::String,

        /// Optional. The CLDR country/region of the address.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub region_code: std::string::String,

        /// Optional. The postal or ZIP code of the address.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub postal_code: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Address {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recipient][crate::model::transaction_data::Address::recipient].
        pub fn set_recipient<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.recipient = v.into();
            self
        }

        /// Sets the value of [locality][crate::model::transaction_data::Address::locality].
        pub fn set_locality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.locality = v.into();
            self
        }

        /// Sets the value of [administrative_area][crate::model::transaction_data::Address::administrative_area].
        pub fn set_administrative_area<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.administrative_area = v.into();
            self
        }

        /// Sets the value of [region_code][crate::model::transaction_data::Address::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }

        /// Sets the value of [postal_code][crate::model::transaction_data::Address::postal_code].
        pub fn set_postal_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.postal_code = v.into();
            self
        }

        /// Sets the value of [address][crate::model::transaction_data::Address::address].
        pub fn set_address<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.address = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Address {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.Address"
        }
    }

    /// Details about a user's account involved in the transaction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct User {
        /// Optional. Unique account identifier for this user. If using account
        /// defender, this should match the hashed_account_id field. Otherwise, a
        /// unique and persistent identifier for this account.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub account_id: std::string::String,

        /// Optional. The epoch milliseconds of the user's account creation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub creation_ms: i64,

        /// Optional. The email address of the user.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub email: std::string::String,

        /// Optional. Whether the email has been verified to be accessible by the
        /// user (OTP or similar).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub email_verified: bool,

        /// Optional. The phone number of the user, with country code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub phone_number: std::string::String,

        /// Optional. Whether the phone number has been verified to be accessible by
        /// the user (OTP or similar).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub phone_verified: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl User {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [account_id][crate::model::transaction_data::User::account_id].
        pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.account_id = v.into();
            self
        }

        /// Sets the value of [creation_ms][crate::model::transaction_data::User::creation_ms].
        pub fn set_creation_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.creation_ms = v.into();
            self
        }

        /// Sets the value of [email][crate::model::transaction_data::User::email].
        pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.email = v.into();
            self
        }

        /// Sets the value of [email_verified][crate::model::transaction_data::User::email_verified].
        pub fn set_email_verified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.email_verified = v.into();
            self
        }

        /// Sets the value of [phone_number][crate::model::transaction_data::User::phone_number].
        pub fn set_phone_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.phone_number = v.into();
            self
        }

        /// Sets the value of [phone_verified][crate::model::transaction_data::User::phone_verified].
        pub fn set_phone_verified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.phone_verified = v.into();
            self
        }
    }

    impl wkt::message::Message for User {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.User"
        }
    }

    /// Line items being purchased in this transaction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Item {
        /// Optional. The full name of the item.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. The value per item that the user is paying, in the transaction
        /// currency, after discounts.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub value: f64,

        /// Optional. The quantity of this item that is being purchased.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub quantity: i64,

        /// Optional. When a merchant is specified, its corresponding account_id.
        /// Necessary to populate marketplace-style transactions.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub merchant_account_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Item {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::transaction_data::Item::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::transaction_data::Item::value].
        pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [quantity][crate::model::transaction_data::Item::quantity].
        pub fn set_quantity<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.quantity = v.into();
            self
        }

        /// Sets the value of [merchant_account_id][crate::model::transaction_data::Item::merchant_account_id].
        pub fn set_merchant_account_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.merchant_account_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Item {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.Item"
        }
    }

    /// Details about the transaction from the gateway.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GatewayInfo {
        /// Optional. Name of the gateway service (for example, stripe, square,
        /// paypal).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. Gateway response code describing the state of the transaction.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub gateway_response_code: std::string::String,

        /// Optional. AVS response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub avs_response_code: std::string::String,

        /// Optional. CVV response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cvv_response_code: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GatewayInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::transaction_data::GatewayInfo::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [gateway_response_code][crate::model::transaction_data::GatewayInfo::gateway_response_code].
        pub fn set_gateway_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gateway_response_code = v.into();
            self
        }

        /// Sets the value of [avs_response_code][crate::model::transaction_data::GatewayInfo::avs_response_code].
        pub fn set_avs_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.avs_response_code = v.into();
            self
        }

        /// Sets the value of [cvv_response_code][crate::model::transaction_data::GatewayInfo::cvv_response_code].
        pub fn set_cvv_response_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cvv_response_code = v.into();
            self
        }
    }

    impl wkt::message::Message for GatewayInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo"
        }
    }
}

/// User information associated with a request protected by reCAPTCHA Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserInfo {
    /// Optional. Creation time for this account associated with this user. Leave
    /// blank for non logged-in actions, guest checkout, or when there is no
    /// account associated with the current user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_account_time: std::option::Option<wkt::Timestamp>,

    /// Optional. For logged-in requests or login/registration requests, the unique
    /// account identifier associated with this user. You can use the username if
    /// it is stable (meaning it is the same for every request associated with the
    /// same user), or any stable user ID of your choice. Leave blank for non
    /// logged-in actions or guest checkout.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id: std::string::String,

    /// Optional. Identifiers associated with this user or request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub user_ids: std::vec::Vec<crate::model::UserId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_account_time][crate::model::UserInfo::create_account_time].
    pub fn set_create_account_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_account_time = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::UserInfo::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [user_ids][crate::model::UserInfo::user_ids].
    pub fn set_user_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserId>,
    {
        use std::iter::Iterator;
        self.user_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UserInfo"
    }
}

/// An identifier associated with a user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserId {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub id_oneof: std::option::Option<crate::model::user_id::IdOneof>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof].
    ///
    /// Note that all the setters affecting `id_oneof` are mutually
    /// exclusive.
    pub fn set_id_oneof<
        T: std::convert::Into<std::option::Option<crate::model::user_id::IdOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.id_oneof = v.into();
        self
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `Email`, `None` if the field is not set or
    /// holds a different branch.
    pub fn email(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::Email(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `PhoneNumber`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::PhoneNumber(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [id_oneof][crate::model::UserId::id_oneof]
    /// if it holds a `Username`, `None` if the field is not set or
    /// holds a different branch.
    pub fn username(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.id_oneof.as_ref().and_then(|v| match v {
            crate::model::user_id::IdOneof::Username(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `Email`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof = std::option::Option::Some(crate::model::user_id::IdOneof::Email(v.into()));
        self
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `PhoneNumber`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof =
            std::option::Option::Some(crate::model::user_id::IdOneof::PhoneNumber(v.into()));
        self
    }

    /// Sets the value of [id_oneof][crate::model::UserId::id_oneof]
    /// to hold a `Username`.
    ///
    /// Note that all the setters affecting `id_oneof` are
    /// mutually exclusive.
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_oneof =
            std::option::Option::Some(crate::model::user_id::IdOneof::Username(v.into()));
        self
    }
}

impl wkt::message::Message for UserId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UserId"
    }
}

/// Defines additional types related to [UserId].
pub mod user_id {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum IdOneof {
        /// Optional. An email address.
        Email(std::string::String),
        /// Optional. A phone number. Should use the E.164 format.
        PhoneNumber(std::string::String),
        /// Optional. A unique username, if different from all the other identifiers
        /// and `account_id` that are provided. Can be a unique login handle or
        /// display name for a user.
        Username(std::string::String),
    }
}

/// Risk analysis result for an event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RiskAnalysis {
    /// Output only. Legitimate event score from 0.0 to 1.0.
    /// (1.0 means very likely legitimate traffic while 0.0 means very likely
    /// non-legitimate traffic).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub score: f32,

    /// Output only. Reasons contributing to the risk analysis verdict.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reasons: std::vec::Vec<crate::model::risk_analysis::ClassificationReason>,

    /// Output only. Extended verdict reasons to be used for experimentation only.
    /// The set of possible reasons is subject to change.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub extended_verdict_reasons: std::vec::Vec<std::string::String>,

    /// Output only. Challenge information for SCORE_AND_CHALLENGE and INVISIBLE
    /// keys
    pub challenge: crate::model::risk_analysis::Challenge,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RiskAnalysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::RiskAnalysis::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [challenge][crate::model::RiskAnalysis::challenge].
    pub fn set_challenge<T: std::convert::Into<crate::model::risk_analysis::Challenge>>(
        mut self,
        v: T,
    ) -> Self {
        self.challenge = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::RiskAnalysis::reasons].
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::risk_analysis::ClassificationReason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [extended_verdict_reasons][crate::model::RiskAnalysis::extended_verdict_reasons].
    pub fn set_extended_verdict_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.extended_verdict_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RiskAnalysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RiskAnalysis"
    }
}

/// Defines additional types related to [RiskAnalysis].
pub mod risk_analysis {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons contributing to the risk analysis verdict.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClassificationReason {
        /// Default unspecified type.
        Unspecified,
        /// Interactions matched the behavior of an automated agent.
        Automation,
        /// The event originated from an illegitimate environment.
        UnexpectedEnvironment,
        /// Traffic volume from the event source is higher than normal.
        TooMuchTraffic,
        /// Interactions with the site were significantly different than expected
        /// patterns.
        UnexpectedUsagePatterns,
        /// Too little traffic has been received from this site thus far to generate
        /// quality risk analysis.
        LowConfidenceScore,
        /// The request matches behavioral characteristics of a carding attack.
        SuspectedCarding,
        /// The request matches behavioral characteristics of chargebacks for fraud.
        SuspectedChargeback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClassificationReason::value] or
        /// [ClassificationReason::name].
        UnknownValue(classification_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod classification_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClassificationReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automation => std::option::Option::Some(1),
                Self::UnexpectedEnvironment => std::option::Option::Some(2),
                Self::TooMuchTraffic => std::option::Option::Some(3),
                Self::UnexpectedUsagePatterns => std::option::Option::Some(4),
                Self::LowConfidenceScore => std::option::Option::Some(5),
                Self::SuspectedCarding => std::option::Option::Some(6),
                Self::SuspectedChargeback => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLASSIFICATION_REASON_UNSPECIFIED"),
                Self::Automation => std::option::Option::Some("AUTOMATION"),
                Self::UnexpectedEnvironment => std::option::Option::Some("UNEXPECTED_ENVIRONMENT"),
                Self::TooMuchTraffic => std::option::Option::Some("TOO_MUCH_TRAFFIC"),
                Self::UnexpectedUsagePatterns => {
                    std::option::Option::Some("UNEXPECTED_USAGE_PATTERNS")
                }
                Self::LowConfidenceScore => std::option::Option::Some("LOW_CONFIDENCE_SCORE"),
                Self::SuspectedCarding => std::option::Option::Some("SUSPECTED_CARDING"),
                Self::SuspectedChargeback => std::option::Option::Some("SUSPECTED_CHARGEBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClassificationReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClassificationReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClassificationReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automation,
                2 => Self::UnexpectedEnvironment,
                3 => Self::TooMuchTraffic,
                4 => Self::UnexpectedUsagePatterns,
                5 => Self::LowConfidenceScore,
                6 => Self::SuspectedCarding,
                7 => Self::SuspectedChargeback,
                _ => Self::UnknownValue(classification_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClassificationReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLASSIFICATION_REASON_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATION" => Self::Automation,
                "UNEXPECTED_ENVIRONMENT" => Self::UnexpectedEnvironment,
                "TOO_MUCH_TRAFFIC" => Self::TooMuchTraffic,
                "UNEXPECTED_USAGE_PATTERNS" => Self::UnexpectedUsagePatterns,
                "LOW_CONFIDENCE_SCORE" => Self::LowConfidenceScore,
                "SUSPECTED_CARDING" => Self::SuspectedCarding,
                "SUSPECTED_CHARGEBACK" => Self::SuspectedChargeback,
                _ => Self::UnknownValue(classification_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClassificationReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automation => serializer.serialize_i32(1),
                Self::UnexpectedEnvironment => serializer.serialize_i32(2),
                Self::TooMuchTraffic => serializer.serialize_i32(3),
                Self::UnexpectedUsagePatterns => serializer.serialize_i32(4),
                Self::LowConfidenceScore => serializer.serialize_i32(5),
                Self::SuspectedCarding => serializer.serialize_i32(6),
                Self::SuspectedChargeback => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClassificationReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClassificationReason>::new(
                ".google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason",
            ))
        }
    }

    /// Challenge information for SCORE_AND_CHALLENGE and INVISIBLE keys
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Challenge {
        /// Default unspecified type.
        Unspecified,
        /// No challenge was presented for solving.
        Nocaptcha,
        /// A solution was submitted that was correct.
        Passed,
        /// A solution was submitted that was incorrect or otherwise
        /// deemed suspicious.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Challenge::value] or
        /// [Challenge::name].
        UnknownValue(challenge::UnknownValue),
    }

    #[doc(hidden)]
    pub mod challenge {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Challenge {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nocaptcha => std::option::Option::Some(1),
                Self::Passed => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHALLENGE_UNSPECIFIED"),
                Self::Nocaptcha => std::option::Option::Some("NOCAPTCHA"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Challenge {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Challenge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Challenge {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nocaptcha,
                2 => Self::Passed,
                3 => Self::Failed,
                _ => Self::UnknownValue(challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Challenge {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHALLENGE_UNSPECIFIED" => Self::Unspecified,
                "NOCAPTCHA" => Self::Nocaptcha,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Challenge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nocaptcha => serializer.serialize_i32(1),
                Self::Passed => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Challenge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Challenge>::new(
                ".google.cloud.recaptchaenterprise.v1.RiskAnalysis.Challenge",
            ))
        }
    }
}

/// Properties of the provided event token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TokenProperties {
    /// Output only. Whether the provided user response token is valid. When valid
    /// = false, the reason could be specified in invalid_reason or it could also
    /// be due to a user failing to solve a challenge or a sitekey mismatch (i.e
    /// the sitekey used to generate the token was different than the one specified
    /// in the assessment).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub valid: bool,

    /// Output only. Reason associated with the response when valid = false.
    pub invalid_reason: crate::model::token_properties::InvalidReason,

    /// Output only. The timestamp corresponding to the generation of the token.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The hostname of the page on which the token was generated (Web
    /// keys only).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Output only. The name of the Android package with which the token was
    /// generated (Android keys only).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub android_package_name: std::string::String,

    /// Output only. The ID of the iOS bundle with which the token was generated
    /// (iOS keys only).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ios_bundle_id: std::string::String,

    /// Output only. Action name provided at token generation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TokenProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [valid][crate::model::TokenProperties::valid].
    pub fn set_valid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.valid = v.into();
        self
    }

    /// Sets the value of [invalid_reason][crate::model::TokenProperties::invalid_reason].
    pub fn set_invalid_reason<
        T: std::convert::Into<crate::model::token_properties::InvalidReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.invalid_reason = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TokenProperties::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::TokenProperties::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [android_package_name][crate::model::TokenProperties::android_package_name].
    pub fn set_android_package_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.android_package_name = v.into();
        self
    }

    /// Sets the value of [ios_bundle_id][crate::model::TokenProperties::ios_bundle_id].
    pub fn set_ios_bundle_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ios_bundle_id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::TokenProperties::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }
}

impl wkt::message::Message for TokenProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TokenProperties"
    }
}

/// Defines additional types related to [TokenProperties].
pub mod token_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the types of invalid token reasons.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InvalidReason {
        /// Default unspecified type.
        Unspecified,
        /// If the failure reason was not accounted for.
        UnknownInvalidReason,
        /// The provided user verification token was malformed.
        Malformed,
        /// The user verification token had expired.
        Expired,
        /// The user verification had already been seen.
        Dupe,
        /// The user verification token was not present.
        Missing,
        /// A retriable error (such as network failure) occurred on the browser.
        /// Could easily be simulated by an attacker.
        BrowserError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InvalidReason::value] or
        /// [InvalidReason::name].
        UnknownValue(invalid_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod invalid_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InvalidReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownInvalidReason => std::option::Option::Some(1),
                Self::Malformed => std::option::Option::Some(2),
                Self::Expired => std::option::Option::Some(3),
                Self::Dupe => std::option::Option::Some(4),
                Self::Missing => std::option::Option::Some(5),
                Self::BrowserError => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INVALID_REASON_UNSPECIFIED"),
                Self::UnknownInvalidReason => std::option::Option::Some("UNKNOWN_INVALID_REASON"),
                Self::Malformed => std::option::Option::Some("MALFORMED"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::Dupe => std::option::Option::Some("DUPE"),
                Self::Missing => std::option::Option::Some("MISSING"),
                Self::BrowserError => std::option::Option::Some("BROWSER_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InvalidReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InvalidReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InvalidReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownInvalidReason,
                2 => Self::Malformed,
                3 => Self::Expired,
                4 => Self::Dupe,
                5 => Self::Missing,
                6 => Self::BrowserError,
                _ => Self::UnknownValue(invalid_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InvalidReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INVALID_REASON_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_INVALID_REASON" => Self::UnknownInvalidReason,
                "MALFORMED" => Self::Malformed,
                "EXPIRED" => Self::Expired,
                "DUPE" => Self::Dupe,
                "MISSING" => Self::Missing,
                "BROWSER_ERROR" => Self::BrowserError,
                _ => Self::UnknownValue(invalid_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InvalidReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownInvalidReason => serializer.serialize_i32(1),
                Self::Malformed => serializer.serialize_i32(2),
                Self::Expired => serializer.serialize_i32(3),
                Self::Dupe => serializer.serialize_i32(4),
                Self::Missing => serializer.serialize_i32(5),
                Self::BrowserError => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InvalidReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InvalidReason>::new(
                ".google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason",
            ))
        }
    }
}

/// Assessment for Fraud Prevention.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FraudPreventionAssessment {
    /// Output only. Probability of this transaction being fraudulent. Summarizes
    /// the combined risk of attack vectors below. Values are from 0.0 (lowest)
    /// to 1.0 (highest).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub transaction_risk: f32,

    /// Output only. Assessment of this transaction for risk of a stolen
    /// instrument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stolen_instrument_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::StolenInstrumentVerdict>,

    /// Output only. Assessment of this transaction for risk of being part of a
    /// card testing attack.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub card_testing_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::CardTestingVerdict>,

    /// Output only. Assessment of this transaction for behavioral trust.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub behavioral_trust_verdict:
        std::option::Option<crate::model::fraud_prevention_assessment::BehavioralTrustVerdict>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FraudPreventionAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transaction_risk][crate::model::FraudPreventionAssessment::transaction_risk].
    pub fn set_transaction_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.transaction_risk = v.into();
        self
    }

    /// Sets the value of [stolen_instrument_verdict][crate::model::FraudPreventionAssessment::stolen_instrument_verdict].
    pub fn set_stolen_instrument_verdict<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::fraud_prevention_assessment::StolenInstrumentVerdict,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stolen_instrument_verdict = v.into();
        self
    }

    /// Sets the value of [card_testing_verdict][crate::model::FraudPreventionAssessment::card_testing_verdict].
    pub fn set_card_testing_verdict<
        T: std::convert::Into<
                std::option::Option<crate::model::fraud_prevention_assessment::CardTestingVerdict>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.card_testing_verdict = v.into();
        self
    }

    /// Sets the value of [behavioral_trust_verdict][crate::model::FraudPreventionAssessment::behavioral_trust_verdict].
    pub fn set_behavioral_trust_verdict<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::fraud_prevention_assessment::BehavioralTrustVerdict,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.behavioral_trust_verdict = v.into();
        self
    }
}

impl wkt::message::Message for FraudPreventionAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment"
    }
}

/// Defines additional types related to [FraudPreventionAssessment].
pub mod fraud_prevention_assessment {
    #[allow(unused_imports)]
    use super::*;

    /// Information about stolen instrument fraud, where the user is not the
    /// legitimate owner of the instrument being used for the purchase.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StolenInstrumentVerdict {
        /// Output only. Probability of this transaction being executed with a stolen
        /// instrument. Values are from 0.0 (lowest) to 1.0 (highest).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub risk: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StolenInstrumentVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [risk][crate::model::fraud_prevention_assessment::StolenInstrumentVerdict::risk].
        pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.risk = v.into();
            self
        }
    }

    impl wkt::message::Message for StolenInstrumentVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict"
        }
    }

    /// Information about card testing fraud, where an adversary is testing
    /// fraudulently obtained cards or brute forcing their details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CardTestingVerdict {
        /// Output only. Probability of this transaction attempt being part of a card
        /// testing attack. Values are from 0.0 (lowest) to 1.0 (highest).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub risk: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CardTestingVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [risk][crate::model::fraud_prevention_assessment::CardTestingVerdict::risk].
        pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.risk = v.into();
            self
        }
    }

    impl wkt::message::Message for CardTestingVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict"
        }
    }

    /// Information about behavioral trust of the transaction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BehavioralTrustVerdict {
        /// Output only. Probability of this transaction attempt being executed in a
        /// behaviorally trustworthy way. Values are from 0.0 (lowest) to 1.0
        /// (highest).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub trust: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BehavioralTrustVerdict {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trust][crate::model::fraud_prevention_assessment::BehavioralTrustVerdict::trust].
        pub fn set_trust<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.trust = v.into();
            self
        }
    }

    impl wkt::message::Message for BehavioralTrustVerdict {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict"
        }
    }
}

/// Fraud signals describing users and cards involved in the transaction.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FraudSignals {
    /// Output only. Signals describing the end user in this transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_signals: std::option::Option<crate::model::fraud_signals::UserSignals>,

    /// Output only. Signals describing the payment card or cards used in this
    /// transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub card_signals: std::option::Option<crate::model::fraud_signals::CardSignals>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FraudSignals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_signals][crate::model::FraudSignals::user_signals].
    pub fn set_user_signals<
        T: std::convert::Into<std::option::Option<crate::model::fraud_signals::UserSignals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_signals = v.into();
        self
    }

    /// Sets the value of [card_signals][crate::model::FraudSignals::card_signals].
    pub fn set_card_signals<
        T: std::convert::Into<std::option::Option<crate::model::fraud_signals::CardSignals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.card_signals = v.into();
        self
    }
}

impl wkt::message::Message for FraudSignals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals"
    }
}

/// Defines additional types related to [FraudSignals].
pub mod fraud_signals {
    #[allow(unused_imports)]
    use super::*;

    /// Signals describing the user involved in this transaction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UserSignals {
        /// Output only. This user (based on email, phone, and other identifiers) has
        /// been seen on the internet for at least this number of days.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub active_days_lower_bound: i32,

        /// Output only. Likelihood (from 0.0 to 1.0) this user includes synthetic
        /// components in their identity, such as a randomly generated email address,
        /// temporary phone number, or fake shipping address.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub synthetic_risk: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [active_days_lower_bound][crate::model::fraud_signals::UserSignals::active_days_lower_bound].
        pub fn set_active_days_lower_bound<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.active_days_lower_bound = v.into();
            self
        }

        /// Sets the value of [synthetic_risk][crate::model::fraud_signals::UserSignals::synthetic_risk].
        pub fn set_synthetic_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.synthetic_risk = v.into();
            self
        }
    }

    impl wkt::message::Message for UserSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals"
        }
    }

    /// Signals describing the payment card used in this transaction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CardSignals {
        /// Output only. The labels for the payment card in this transaction.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub card_labels: std::vec::Vec<crate::model::fraud_signals::card_signals::CardLabel>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CardSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [card_labels][crate::model::fraud_signals::CardSignals::card_labels].
        pub fn set_card_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::fraud_signals::card_signals::CardLabel>,
        {
            use std::iter::Iterator;
            self.card_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CardSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals"
        }
    }

    /// Defines additional types related to [CardSignals].
    pub mod card_signals {
        #[allow(unused_imports)]
        use super::*;

        /// Risk labels describing the card being assessed, such as its funding
        /// mechanism.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CardLabel {
            /// No label specified.
            Unspecified,
            /// This card has been detected as prepaid.
            Prepaid,
            /// This card has been detected as virtual, such as a card number generated
            /// for a single transaction or merchant.
            Virtual,
            /// This card has been detected as being used in an unexpected geographic
            /// location.
            UnexpectedLocation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [CardLabel::value] or
            /// [CardLabel::name].
            UnknownValue(card_label::UnknownValue),
        }

        #[doc(hidden)]
        pub mod card_label {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl CardLabel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Prepaid => std::option::Option::Some(1),
                    Self::Virtual => std::option::Option::Some(2),
                    Self::UnexpectedLocation => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CARD_LABEL_UNSPECIFIED"),
                    Self::Prepaid => std::option::Option::Some("PREPAID"),
                    Self::Virtual => std::option::Option::Some("VIRTUAL"),
                    Self::UnexpectedLocation => std::option::Option::Some("UNEXPECTED_LOCATION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for CardLabel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for CardLabel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for CardLabel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Prepaid,
                    2 => Self::Virtual,
                    3 => Self::UnexpectedLocation,
                    _ => Self::UnknownValue(card_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for CardLabel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CARD_LABEL_UNSPECIFIED" => Self::Unspecified,
                    "PREPAID" => Self::Prepaid,
                    "VIRTUAL" => Self::Virtual,
                    "UNEXPECTED_LOCATION" => Self::UnexpectedLocation,
                    _ => Self::UnknownValue(card_label::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for CardLabel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Prepaid => serializer.serialize_i32(1),
                    Self::Virtual => serializer.serialize_i32(2),
                    Self::UnexpectedLocation => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for CardLabel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<CardLabel>::new(
                    ".google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel",
                ))
            }
        }
    }
}

/// Information about SMS toll fraud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SmsTollFraudVerdict {
    /// Output only. Probability of an SMS event being fraudulent.
    /// Values are from 0.0 (lowest) to 1.0 (highest).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub risk: f32,

    /// Output only. Reasons contributing to the SMS toll fraud verdict.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reasons: std::vec::Vec<crate::model::sms_toll_fraud_verdict::SmsTollFraudReason>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmsTollFraudVerdict {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [risk][crate::model::SmsTollFraudVerdict::risk].
    pub fn set_risk<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.risk = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::SmsTollFraudVerdict::reasons].
    pub fn set_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sms_toll_fraud_verdict::SmsTollFraudReason>,
    {
        use std::iter::Iterator;
        self.reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SmsTollFraudVerdict {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict"
    }
}

/// Defines additional types related to [SmsTollFraudVerdict].
pub mod sms_toll_fraud_verdict {
    #[allow(unused_imports)]
    use super::*;

    /// Reasons contributing to the SMS toll fraud verdict.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SmsTollFraudReason {
        /// Default unspecified reason
        Unspecified,
        /// The provided phone number was invalid
        InvalidPhoneNumber,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SmsTollFraudReason::value] or
        /// [SmsTollFraudReason::name].
        UnknownValue(sms_toll_fraud_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sms_toll_fraud_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SmsTollFraudReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InvalidPhoneNumber => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SMS_TOLL_FRAUD_REASON_UNSPECIFIED"),
                Self::InvalidPhoneNumber => std::option::Option::Some("INVALID_PHONE_NUMBER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SmsTollFraudReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SmsTollFraudReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SmsTollFraudReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InvalidPhoneNumber,
                _ => Self::UnknownValue(sms_toll_fraud_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SmsTollFraudReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SMS_TOLL_FRAUD_REASON_UNSPECIFIED" => Self::Unspecified,
                "INVALID_PHONE_NUMBER" => Self::InvalidPhoneNumber,
                _ => Self::UnknownValue(sms_toll_fraud_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SmsTollFraudReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InvalidPhoneNumber => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SmsTollFraudReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SmsTollFraudReason>::new(
                ".google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason",
            ))
        }
    }
}

/// Assessment for Phone Fraud
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhoneFraudAssessment {
    /// Output only. Assessment of this phone event for risk of SMS toll fraud.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sms_toll_fraud_verdict: std::option::Option<crate::model::SmsTollFraudVerdict>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhoneFraudAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sms_toll_fraud_verdict][crate::model::PhoneFraudAssessment::sms_toll_fraud_verdict].
    pub fn set_sms_toll_fraud_verdict<
        T: std::convert::Into<std::option::Option<crate::model::SmsTollFraudVerdict>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sms_toll_fraud_verdict = v.into();
        self
    }
}

impl wkt::message::Message for PhoneFraudAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment"
    }
}

/// Account defender risk assessment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccountDefenderAssessment {
    /// Output only. Labels for this request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub labels: std::vec::Vec<crate::model::account_defender_assessment::AccountDefenderLabel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountDefenderAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::AccountDefenderAssessment::labels].
    pub fn set_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::account_defender_assessment::AccountDefenderLabel>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccountDefenderAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment"
    }
}

/// Defines additional types related to [AccountDefenderAssessment].
pub mod account_defender_assessment {
    #[allow(unused_imports)]
    use super::*;

    /// Labels returned by account defender for this request.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccountDefenderLabel {
        /// Default unspecified type.
        Unspecified,
        /// The request matches a known good profile for the user.
        ProfileMatch,
        /// The request is potentially a suspicious login event and must be further
        /// verified either through multi-factor authentication or another system.
        SuspiciousLoginActivity,
        /// The request matched a profile that previously had suspicious account
        /// creation behavior. This can mean that this is a fake account.
        SuspiciousAccountCreation,
        /// The account in the request has a high number of related accounts. It does
        /// not necessarily imply that the account is bad but can require further
        /// investigation.
        RelatedAccountsNumberHigh,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccountDefenderLabel::value] or
        /// [AccountDefenderLabel::name].
        UnknownValue(account_defender_label::UnknownValue),
    }

    #[doc(hidden)]
    pub mod account_defender_label {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccountDefenderLabel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ProfileMatch => std::option::Option::Some(1),
                Self::SuspiciousLoginActivity => std::option::Option::Some(2),
                Self::SuspiciousAccountCreation => std::option::Option::Some(3),
                Self::RelatedAccountsNumberHigh => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("ACCOUNT_DEFENDER_LABEL_UNSPECIFIED")
                }
                Self::ProfileMatch => std::option::Option::Some("PROFILE_MATCH"),
                Self::SuspiciousLoginActivity => {
                    std::option::Option::Some("SUSPICIOUS_LOGIN_ACTIVITY")
                }
                Self::SuspiciousAccountCreation => {
                    std::option::Option::Some("SUSPICIOUS_ACCOUNT_CREATION")
                }
                Self::RelatedAccountsNumberHigh => {
                    std::option::Option::Some("RELATED_ACCOUNTS_NUMBER_HIGH")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccountDefenderLabel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccountDefenderLabel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccountDefenderLabel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ProfileMatch,
                2 => Self::SuspiciousLoginActivity,
                3 => Self::SuspiciousAccountCreation,
                4 => Self::RelatedAccountsNumberHigh,
                _ => Self::UnknownValue(account_defender_label::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccountDefenderLabel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED" => Self::Unspecified,
                "PROFILE_MATCH" => Self::ProfileMatch,
                "SUSPICIOUS_LOGIN_ACTIVITY" => Self::SuspiciousLoginActivity,
                "SUSPICIOUS_ACCOUNT_CREATION" => Self::SuspiciousAccountCreation,
                "RELATED_ACCOUNTS_NUMBER_HIGH" => Self::RelatedAccountsNumberHigh,
                _ => Self::UnknownValue(account_defender_label::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccountDefenderLabel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ProfileMatch => serializer.serialize_i32(1),
                Self::SuspiciousLoginActivity => serializer.serialize_i32(2),
                Self::SuspiciousAccountCreation => serializer.serialize_i32(3),
                Self::RelatedAccountsNumberHigh => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccountDefenderLabel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccountDefenderLabel>::new(
                ".google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel"))
        }
    }
}

/// The create key request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateKeyRequest {
    /// Required. The name of the project in which the key is created, in the
    /// format `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Information to create a reCAPTCHA Enterprise key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key: std::option::Option<crate::model::Key>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [key][crate::model::CreateKeyRequest::key].
    pub fn set_key<T: std::convert::Into<std::option::Option<crate::model::Key>>>(
        mut self,
        v: T,
    ) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for CreateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateKeyRequest"
    }
}

/// The list keys request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKeysRequest {
    /// Required. The name of the project that contains the keys that is
    /// listed, in the format `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of keys to return. Default is 10. Max limit is
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous.
    /// ListKeysRequest, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListKeysRequest"
    }
}

/// Response to request to list keys in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListKeysResponse {
    /// Key details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub keys: std::vec::Vec<crate::model::Key>,

    /// Token to retrieve the next page of results. It is set to empty if no keys
    /// remain in results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [keys][crate::model::ListKeysResponse::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Key>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKeysResponse {
    type PageItem = crate::model::Key;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The retrieve legacy secret key request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveLegacySecretKeyRequest {
    /// Required. The public key name linked to the requested secret key in the
    /// format `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveLegacySecretKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::RetrieveLegacySecretKeyRequest::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveLegacySecretKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyRequest"
    }
}

/// The get key request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetKeyRequest {
    /// Required. The name of the requested key, in the format
    /// `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetKeyRequest"
    }
}

/// The update key request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateKeyRequest {
    /// Required. The key to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub key: std::option::Option<crate::model::Key>,

    /// Optional. The mask to control which fields of the key get updated. If the
    /// mask is not present, all fields are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::UpdateKeyRequest::key].
    pub fn set_key<T: std::convert::Into<std::option::Option<crate::model::Key>>>(
        mut self,
        v: T,
    ) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateKeyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UpdateKeyRequest"
    }
}

/// The delete key request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteKeyRequest {
    /// Required. The name of the key to be deleted, in the format
    /// `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.DeleteKeyRequest"
    }
}

/// The create firewall policy request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFirewallPolicyRequest {
    /// Required. The name of the project this policy applies to, in the format
    /// `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Information to create the policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFirewallPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [firewall_policy][crate::model::CreateFirewallPolicyRequest::firewall_policy].
    pub fn set_firewall_policy<
        T: std::convert::Into<std::option::Option<crate::model::FirewallPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_policy = v.into();
        self
    }
}

impl wkt::message::Message for CreateFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.CreateFirewallPolicyRequest"
    }
}

/// The list firewall policies request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of policies to return. Default is 10. Max
    /// limit is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous.
    /// ListFirewallPoliciesRequest, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFirewallPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFirewallPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFirewallPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFirewallPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFirewallPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesRequest"
    }
}

/// Response to request to list firewall policies belonging to a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFirewallPoliciesResponse {
    /// Policy details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub firewall_policies: std::vec::Vec<crate::model::FirewallPolicy>,

    /// Token to retrieve the next page of results. It is set to empty if no
    /// policies remain in results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFirewallPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListFirewallPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [firewall_policies][crate::model::ListFirewallPoliciesResponse::firewall_policies].
    pub fn set_firewall_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicy>,
    {
        use std::iter::Iterator;
        self.firewall_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListFirewallPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFirewallPoliciesResponse {
    type PageItem = crate::model::FirewallPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.firewall_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The get firewall policy request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFirewallPolicyRequest {
    /// Required. The name of the requested policy, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFirewallPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetFirewallPolicyRequest"
    }
}

/// The update firewall policy request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFirewallPolicyRequest {
    /// Required. The policy to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    /// Optional. The mask to control which fields of the policy get updated. If
    /// the mask is not present, all fields are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policy][crate::model::UpdateFirewallPolicyRequest::firewall_policy].
    pub fn set_firewall_policy<
        T: std::convert::Into<std::option::Option<crate::model::FirewallPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_policy = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFirewallPolicyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.UpdateFirewallPolicyRequest"
    }
}

/// The delete firewall policy request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFirewallPolicyRequest {
    /// Required. The name of the policy to be deleted, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFirewallPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFirewallPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFirewallPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.DeleteFirewallPolicyRequest"
    }
}

/// The reorder firewall policies request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReorderFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A list containing all policy names, in the new order. Each name
    /// is in the format `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReorderFirewallPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ReorderFirewallPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::ReorderFirewallPoliciesRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReorderFirewallPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesRequest"
    }
}

/// The reorder firewall policies response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReorderFirewallPoliciesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReorderFirewallPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ReorderFirewallPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesResponse"
    }
}

/// The migrate key request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrateKeyRequest {
    /// Required. The name of the key to be migrated, in the format
    /// `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If true, skips the billing check.
    /// A reCAPTCHA Enterprise key or migrated key behaves differently than a
    /// reCAPTCHA (non-Enterprise version) key when you reach a quota limit (see
    /// <https://cloud.google.com/recaptcha/quotas#quota_limit>). To avoid
    /// any disruption of your usage, we check that a billing account is present.
    /// If your usage of reCAPTCHA is under the free quota, you can safely skip the
    /// billing check and proceed with the migration. See
    /// <https://cloud.google.com/recaptcha/docs/billing-information>.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_billing_check: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrateKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrateKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_billing_check][crate::model::MigrateKeyRequest::skip_billing_check].
    pub fn set_skip_billing_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_billing_check = v.into();
        self
    }
}

impl wkt::message::Message for MigrateKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.MigrateKeyRequest"
    }
}

/// The get metrics request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetricsRequest {
    /// Required. The name of the requested metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetricsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.GetMetricsRequest"
    }
}

/// Metrics for a single Key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Metrics {
    /// Output only. Identifier. The name of the metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Inclusive start time aligned to a day in the America/Los_Angeles (Pacific)
    /// timezone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. All Key types should have score-based data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub score_metrics: std::vec::Vec<crate::model::ScoreMetrics>,

    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. Only challenge-based keys (CHECKBOX, INVISIBLE) have
    /// challenge-based data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub challenge_metrics: std::vec::Vec<crate::model::ChallengeMetrics>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Metrics::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Metrics::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [score_metrics][crate::model::Metrics::score_metrics].
    pub fn set_score_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ScoreMetrics>,
    {
        use std::iter::Iterator;
        self.score_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [challenge_metrics][crate::model::Metrics::challenge_metrics].
    pub fn set_challenge_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChallengeMetrics>,
    {
        use std::iter::Iterator;
        self.challenge_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Metrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Metrics"
    }
}

/// Secret key is used only in legacy reCAPTCHA. It must be used in a 3rd party
/// integration with legacy reCAPTCHA.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetrieveLegacySecretKeyResponse {
    /// The secret key (also known as shared secret) authorizes communication
    /// between your application backend and the reCAPTCHA Enterprise server to
    /// create an assessment.
    /// The secret key needs to be kept safe for security purposes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub legacy_secret_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetrieveLegacySecretKeyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [legacy_secret_key][crate::model::RetrieveLegacySecretKeyResponse::legacy_secret_key].
    pub fn set_legacy_secret_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_secret_key = v.into();
        self
    }
}

impl wkt::message::Message for RetrieveLegacySecretKeyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyResponse"
    }
}

/// A key used to identify and configure applications (web and/or mobile) that
/// use reCAPTCHA Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Key {
    /// Identifier. The resource name for the Key in the format
    /// `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Human-readable display name of this key. Modifiable by user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/recaptcha/docs/labels>).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The timestamp corresponding to the creation of this key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Options for user acceptance testing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub testing_options: std::option::Option<crate::model::TestingOptions>,

    /// Optional. Settings for WAF
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub waf_settings: std::option::Option<crate::model::WafSettings>,

    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub platform_settings: std::option::Option<crate::model::key::PlatformSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Key {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Key::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Key::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Key::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [testing_options][crate::model::Key::testing_options].
    pub fn set_testing_options<
        T: std::convert::Into<std::option::Option<crate::model::TestingOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.testing_options = v.into();
        self
    }

    /// Sets the value of [waf_settings][crate::model::Key::waf_settings].
    pub fn set_waf_settings<
        T: std::convert::Into<std::option::Option<crate::model::WafSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.waf_settings = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Key::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings].
    ///
    /// Note that all the setters affecting `platform_settings` are mutually
    /// exclusive.
    pub fn set_platform_settings<
        T: std::convert::Into<std::option::Option<crate::model::key::PlatformSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = v.into();
        self
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `WebSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn web_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WebKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::WebSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `AndroidSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn android_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AndroidKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::AndroidSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `IosSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ios_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IOSKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::IosSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [platform_settings][crate::model::Key::platform_settings]
    /// if it holds a `ExpressSettings`, `None` if the field is not set or
    /// holds a different branch.
    pub fn express_settings(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExpressKeySettings>> {
        #[allow(unreachable_patterns)]
        self.platform_settings.as_ref().and_then(|v| match v {
            crate::model::key::PlatformSettings::ExpressSettings(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `WebSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_web_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::WebKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings =
            std::option::Option::Some(crate::model::key::PlatformSettings::WebSettings(v.into()));
        self
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `AndroidSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_android_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::AndroidKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = std::option::Option::Some(
            crate::model::key::PlatformSettings::AndroidSettings(v.into()),
        );
        self
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `IosSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_ios_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::IOSKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings =
            std::option::Option::Some(crate::model::key::PlatformSettings::IosSettings(v.into()));
        self
    }

    /// Sets the value of [platform_settings][crate::model::Key::platform_settings]
    /// to hold a `ExpressSettings`.
    ///
    /// Note that all the setters affecting `platform_settings` are
    /// mutually exclusive.
    pub fn set_express_settings<
        T: std::convert::Into<std::boxed::Box<crate::model::ExpressKeySettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_settings = std::option::Option::Some(
            crate::model::key::PlatformSettings::ExpressSettings(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Key {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.Key"
    }
}

/// Defines additional types related to [Key].
pub mod key {
    #[allow(unused_imports)]
    use super::*;

    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PlatformSettings {
        /// Settings for keys that can be used by websites.
        WebSettings(std::boxed::Box<crate::model::WebKeySettings>),
        /// Settings for keys that can be used by Android apps.
        AndroidSettings(std::boxed::Box<crate::model::AndroidKeySettings>),
        /// Settings for keys that can be used by iOS apps.
        IosSettings(std::boxed::Box<crate::model::IOSKeySettings>),
        /// Settings for keys that can be used by reCAPTCHA Express.
        ExpressSettings(std::boxed::Box<crate::model::ExpressKeySettings>),
    }
}

/// Options for user acceptance testing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TestingOptions {
    /// Optional. All assessments for this Key return this score. Must be between 0
    /// (likely not legitimate) and 1 (likely legitimate) inclusive.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub testing_score: f32,

    /// Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all
    /// challenge requests for this site return nocaptcha if NOCAPTCHA, or an
    /// unsolvable challenge if CHALLENGE.
    pub testing_challenge: crate::model::testing_options::TestingChallenge,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestingOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [testing_score][crate::model::TestingOptions::testing_score].
    pub fn set_testing_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.testing_score = v.into();
        self
    }

    /// Sets the value of [testing_challenge][crate::model::TestingOptions::testing_challenge].
    pub fn set_testing_challenge<
        T: std::convert::Into<crate::model::testing_options::TestingChallenge>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.testing_challenge = v.into();
        self
    }
}

impl wkt::message::Message for TestingOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.TestingOptions"
    }
}

/// Defines additional types related to [TestingOptions].
pub mod testing_options {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the challenge option for challenge-based (CHECKBOX,
    /// INVISIBLE) testing keys.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TestingChallenge {
        /// Perform the normal risk analysis and return either nocaptcha or a
        /// challenge depending on risk and trust factors.
        Unspecified,
        /// Challenge requests for this key always return a nocaptcha, which
        /// does not require a solution.
        Nocaptcha,
        /// Challenge requests for this key always return an unsolvable
        /// challenge.
        UnsolvableChallenge,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TestingChallenge::value] or
        /// [TestingChallenge::name].
        UnknownValue(testing_challenge::UnknownValue),
    }

    #[doc(hidden)]
    pub mod testing_challenge {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TestingChallenge {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Nocaptcha => std::option::Option::Some(1),
                Self::UnsolvableChallenge => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TESTING_CHALLENGE_UNSPECIFIED"),
                Self::Nocaptcha => std::option::Option::Some("NOCAPTCHA"),
                Self::UnsolvableChallenge => std::option::Option::Some("UNSOLVABLE_CHALLENGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TestingChallenge {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TestingChallenge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TestingChallenge {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Nocaptcha,
                2 => Self::UnsolvableChallenge,
                _ => Self::UnknownValue(testing_challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TestingChallenge {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TESTING_CHALLENGE_UNSPECIFIED" => Self::Unspecified,
                "NOCAPTCHA" => Self::Nocaptcha,
                "UNSOLVABLE_CHALLENGE" => Self::UnsolvableChallenge,
                _ => Self::UnknownValue(testing_challenge::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TestingChallenge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Nocaptcha => serializer.serialize_i32(1),
                Self::UnsolvableChallenge => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TestingChallenge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestingChallenge>::new(
                ".google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge",
            ))
        }
    }
}

/// Settings specific to keys that can be used by websites.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebKeySettings {
    /// Optional. If set to true, it means allowed_domains are not enforced.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_all_domains: bool,

    /// Optional. Domains or subdomains of websites allowed to use the key. All
    /// subdomains of an allowed domain are automatically allowed. A valid domain
    /// requires a host and must not include any path, port, query or fragment.
    /// Examples: 'example.com' or 'subdomain.example.com'
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_domains: std::vec::Vec<std::string::String>,

    /// Optional. If set to true, the key can be used on AMP (Accelerated Mobile
    /// Pages) websites. This is supported only for the SCORE integration type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_amp_traffic: bool,

    /// Required. Describes how this key is integrated with the website.
    pub integration_type: crate::model::web_key_settings::IntegrationType,

    /// Optional. Settings for the frequency and difficulty at which this key
    /// triggers captcha challenges. This should only be specified for
    /// IntegrationTypes CHECKBOX and INVISIBLE and SCORE_AND_CHALLENGE.
    pub challenge_security_preference: crate::model::web_key_settings::ChallengeSecurityPreference,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_domains][crate::model::WebKeySettings::allow_all_domains].
    pub fn set_allow_all_domains<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_domains = v.into();
        self
    }

    /// Sets the value of [allow_amp_traffic][crate::model::WebKeySettings::allow_amp_traffic].
    pub fn set_allow_amp_traffic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_amp_traffic = v.into();
        self
    }

    /// Sets the value of [integration_type][crate::model::WebKeySettings::integration_type].
    pub fn set_integration_type<
        T: std::convert::Into<crate::model::web_key_settings::IntegrationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.integration_type = v.into();
        self
    }

    /// Sets the value of [challenge_security_preference][crate::model::WebKeySettings::challenge_security_preference].
    pub fn set_challenge_security_preference<
        T: std::convert::Into<crate::model::web_key_settings::ChallengeSecurityPreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.challenge_security_preference = v.into();
        self
    }

    /// Sets the value of [allowed_domains][crate::model::WebKeySettings::allowed_domains].
    pub fn set_allowed_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_domains = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WebKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.WebKeySettings"
    }
}

/// Defines additional types related to [WebKeySettings].
pub mod web_key_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the integration types for web keys.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IntegrationType {
        /// Default type that indicates this enum hasn't been specified. This is not
        /// a valid IntegrationType, one of the other types must be specified
        /// instead.
        Unspecified,
        /// Only used to produce scores. It doesn't display the "I'm not a robot"
        /// checkbox and never shows captcha challenges.
        Score,
        /// Displays the "I'm not a robot" checkbox and may show captcha challenges
        /// after it is checked.
        Checkbox,
        /// Doesn't display the "I'm not a robot" checkbox, but may show captcha
        /// challenges after risk analysis.
        Invisible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IntegrationType::value] or
        /// [IntegrationType::name].
        UnknownValue(integration_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod integration_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IntegrationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Score => std::option::Option::Some(1),
                Self::Checkbox => std::option::Option::Some(2),
                Self::Invisible => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INTEGRATION_TYPE_UNSPECIFIED"),
                Self::Score => std::option::Option::Some("SCORE"),
                Self::Checkbox => std::option::Option::Some("CHECKBOX"),
                Self::Invisible => std::option::Option::Some("INVISIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IntegrationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IntegrationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IntegrationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Score,
                2 => Self::Checkbox,
                3 => Self::Invisible,
                _ => Self::UnknownValue(integration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IntegrationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTEGRATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCORE" => Self::Score,
                "CHECKBOX" => Self::Checkbox,
                "INVISIBLE" => Self::Invisible,
                _ => Self::UnknownValue(integration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IntegrationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Score => serializer.serialize_i32(1),
                Self::Checkbox => serializer.serialize_i32(2),
                Self::Invisible => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IntegrationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntegrationType>::new(
                ".google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType",
            ))
        }
    }

    /// Enum that represents the possible challenge frequency and difficulty
    /// configurations for a web key.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ChallengeSecurityPreference {
        /// Default type that indicates this enum hasn't been specified.
        Unspecified,
        /// Key tends to show fewer and easier challenges.
        Usability,
        /// Key tends to show balanced (in amount and difficulty) challenges.
        Balance,
        /// Key tends to show more and harder challenges.
        Security,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ChallengeSecurityPreference::value] or
        /// [ChallengeSecurityPreference::name].
        UnknownValue(challenge_security_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod challenge_security_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ChallengeSecurityPreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Usability => std::option::Option::Some(1),
                Self::Balance => std::option::Option::Some(2),
                Self::Security => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED")
                }
                Self::Usability => std::option::Option::Some("USABILITY"),
                Self::Balance => std::option::Option::Some("BALANCE"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ChallengeSecurityPreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ChallengeSecurityPreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ChallengeSecurityPreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Usability,
                2 => Self::Balance,
                3 => Self::Security,
                _ => Self::UnknownValue(challenge_security_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ChallengeSecurityPreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "USABILITY" => Self::Usability,
                "BALANCE" => Self::Balance,
                "SECURITY" => Self::Security,
                _ => Self::UnknownValue(challenge_security_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ChallengeSecurityPreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Usability => serializer.serialize_i32(1),
                Self::Balance => serializer.serialize_i32(2),
                Self::Security => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ChallengeSecurityPreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ChallengeSecurityPreference>::new(
                ".google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference"))
        }
    }
}

/// Settings specific to keys that can be used by Android apps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AndroidKeySettings {
    /// Optional. If set to true, allowed_package_names are not enforced.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_all_package_names: bool,

    /// Optional. Android package names of apps allowed to use the key.
    /// Example: 'com.companyname.appname'
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_package_names: std::vec::Vec<std::string::String>,

    /// Optional. Set to true for keys that are used in an Android application that
    /// is available for download in app stores in addition to the Google Play
    /// Store.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub support_non_google_app_store_distribution: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AndroidKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_package_names][crate::model::AndroidKeySettings::allow_all_package_names].
    pub fn set_allow_all_package_names<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_package_names = v.into();
        self
    }

    /// Sets the value of [support_non_google_app_store_distribution][crate::model::AndroidKeySettings::support_non_google_app_store_distribution].
    pub fn set_support_non_google_app_store_distribution<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.support_non_google_app_store_distribution = v.into();
        self
    }

    /// Sets the value of [allowed_package_names][crate::model::AndroidKeySettings::allowed_package_names].
    pub fn set_allowed_package_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_package_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AndroidKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AndroidKeySettings"
    }
}

/// Settings specific to keys that can be used by iOS apps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IOSKeySettings {
    /// Optional. If set to true, allowed_bundle_ids are not enforced.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_all_bundle_ids: bool,

    /// Optional. iOS bundle ids of apps allowed to use the key.
    /// Example: 'com.companyname.productname.appname'
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_bundle_ids: std::vec::Vec<std::string::String>,

    /// Optional. Apple Developer account details for the app that is protected by
    /// the reCAPTCHA Key. reCAPTCHA leverages platform-specific checks like Apple
    /// App Attest and Apple DeviceCheck to protect your app from abuse. Providing
    /// these fields allows reCAPTCHA to get a better assessment of the integrity
    /// of your app.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub apple_developer_id: std::option::Option<crate::model::AppleDeveloperId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IOSKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_all_bundle_ids][crate::model::IOSKeySettings::allow_all_bundle_ids].
    pub fn set_allow_all_bundle_ids<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_all_bundle_ids = v.into();
        self
    }

    /// Sets the value of [apple_developer_id][crate::model::IOSKeySettings::apple_developer_id].
    pub fn set_apple_developer_id<
        T: std::convert::Into<std::option::Option<crate::model::AppleDeveloperId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.apple_developer_id = v.into();
        self
    }

    /// Sets the value of [allowed_bundle_ids][crate::model::IOSKeySettings::allowed_bundle_ids].
    pub fn set_allowed_bundle_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_bundle_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IOSKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.IOSKeySettings"
    }
}

/// Settings specific to keys that can be used for reCAPTCHA Express.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExpressKeySettings {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpressKeySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExpressKeySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ExpressKeySettings"
    }
}

/// Contains fields that are required to perform Apple-specific integrity checks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppleDeveloperId {
    /// Required. Input only. A private key (downloaded as a text file with a .p8
    /// file extension) generated for your Apple Developer account. Ensure that
    /// Apple DeviceCheck is enabled for the private key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_key: std::string::String,

    /// Required. The Apple developer key ID (10-character string).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_id: std::string::String,

    /// Required. The Apple team ID (10-character string) owning the provisioning
    /// profile used to build your application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub team_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppleDeveloperId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::AppleDeveloperId::private_key].
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_id][crate::model::AppleDeveloperId::key_id].
    pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_id = v.into();
        self
    }

    /// Sets the value of [team_id][crate::model::AppleDeveloperId::team_id].
    pub fn set_team_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.team_id = v.into();
        self
    }
}

impl wkt::message::Message for AppleDeveloperId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AppleDeveloperId"
    }
}

/// Score distribution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScoreDistribution {
    /// Map key is score value multiplied by 100. The scores are discrete values
    /// between [0, 1]. The maximum number of buckets is on order of a few dozen,
    /// but typically much lower (ie. 10).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, serde_with::DisplayFromStr>")]
    pub score_buckets: std::collections::HashMap<i32, i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScoreDistribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score_buckets][crate::model::ScoreDistribution::score_buckets].
    pub fn set_score_buckets<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.score_buckets = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ScoreDistribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ScoreDistribution"
    }
}

/// Metrics related to scoring.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScoreMetrics {
    /// Aggregated score metrics for all traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overall_metrics: std::option::Option<crate::model::ScoreDistribution>,

    /// Action-based metrics. The map key is the action name which specified by the
    /// site owners at time of the "execute" client-side call.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub action_metrics:
        std::collections::HashMap<std::string::String, crate::model::ScoreDistribution>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScoreMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overall_metrics][crate::model::ScoreMetrics::overall_metrics].
    pub fn set_overall_metrics<
        T: std::convert::Into<std::option::Option<crate::model::ScoreDistribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overall_metrics = v.into();
        self
    }

    /// Sets the value of [action_metrics][crate::model::ScoreMetrics::action_metrics].
    pub fn set_action_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ScoreDistribution>,
    {
        use std::iter::Iterator;
        self.action_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ScoreMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ScoreMetrics"
    }
}

/// Metrics related to challenges.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChallengeMetrics {
    /// Count of reCAPTCHA checkboxes or badges rendered. This is mostly equivalent
    /// to a count of pageloads for pages that include reCAPTCHA.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pageload_count: i64,

    /// Count of nocaptchas (successful verification without a challenge) issued.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub nocaptcha_count: i64,

    /// Count of submitted challenge solutions that were incorrect or otherwise
    /// deemed suspicious such that a subsequent challenge was triggered.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_count: i64,

    /// Count of nocaptchas (successful verification without a challenge) plus
    /// submitted challenge solutions that were correct and resulted in
    /// verification.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub passed_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChallengeMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pageload_count][crate::model::ChallengeMetrics::pageload_count].
    pub fn set_pageload_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pageload_count = v.into();
        self
    }

    /// Sets the value of [nocaptcha_count][crate::model::ChallengeMetrics::nocaptcha_count].
    pub fn set_nocaptcha_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.nocaptcha_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::ChallengeMetrics::failed_count].
    pub fn set_failed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [passed_count][crate::model::ChallengeMetrics::passed_count].
    pub fn set_passed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_count = v.into();
        self
    }
}

impl wkt::message::Message for ChallengeMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ChallengeMetrics"
    }
}

/// Policy config assessment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirewallPolicyAssessment {
    /// Output only. If the processing of a policy config fails, an error is
    /// populated and the firewall_policy is left empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The policy that matched the request. If more than one policy
    /// may match, this is the first match. If no policy matches the incoming
    /// request, the policy field is left empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallPolicyAssessment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::FirewallPolicyAssessment::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [firewall_policy][crate::model::FirewallPolicyAssessment::firewall_policy].
    pub fn set_firewall_policy<
        T: std::convert::Into<std::option::Option<crate::model::FirewallPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_policy = v.into();
        self
    }
}

impl wkt::message::Message for FirewallPolicyAssessment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment"
    }
}

/// An individual action. Each action represents what to do if a policy
/// matches.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirewallAction {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub firewall_action_oneof:
        std::option::Option<crate::model::firewall_action::FirewallActionOneof>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof].
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are mutually
    /// exclusive.
    pub fn set_firewall_action_oneof<
        T: std::convert::Into<std::option::Option<crate::model::firewall_action::FirewallActionOneof>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = v.into();
        self
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Allow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn allow(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::AllowAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Allow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Block`, `None` if the field is not set or
    /// holds a different branch.
    pub fn block(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::BlockAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Block(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `IncludeRecaptchaScript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_recaptcha_script(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
    > {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Redirect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::RedirectAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Redirect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `Substitute`, `None` if the field is not set or
    /// holds a different branch.
    pub fn substitute(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::SubstituteAction>>
    {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::Substitute(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// if it holds a `SetHeader`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_header(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::firewall_action::SetHeaderAction>> {
        #[allow(unreachable_patterns)]
        self.firewall_action_oneof.as_ref().and_then(|v| match v {
            crate::model::firewall_action::FirewallActionOneof::SetHeader(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Allow`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_allow<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::AllowAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Allow(v.into()),
        );
        self
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Block`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_block<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::BlockAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Block(v.into()),
        );
        self
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `IncludeRecaptchaScript`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_include_recaptcha_script<
        T: std::convert::Into<
                std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::IncludeRecaptchaScript(v.into()),
        );
        self
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Redirect`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_redirect<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::RedirectAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Redirect(v.into()),
        );
        self
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `Substitute`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_substitute<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::SubstituteAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::Substitute(v.into()),
        );
        self
    }

    /// Sets the value of [firewall_action_oneof][crate::model::FirewallAction::firewall_action_oneof]
    /// to hold a `SetHeader`.
    ///
    /// Note that all the setters affecting `firewall_action_oneof` are
    /// mutually exclusive.
    pub fn set_set_header<
        T: std::convert::Into<std::boxed::Box<crate::model::firewall_action::SetHeaderAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.firewall_action_oneof = std::option::Option::Some(
            crate::model::firewall_action::FirewallActionOneof::SetHeader(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FirewallAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction"
    }
}

/// Defines additional types related to [FirewallAction].
pub mod firewall_action {
    #[allow(unused_imports)]
    use super::*;

    /// An allow action continues processing a request unimpeded.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AllowAction {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AllowAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for AllowAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction"
        }
    }

    /// A block action serves an HTTP error code a prevents the request from
    /// hitting the backend.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BlockAction {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BlockAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BlockAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction"
        }
    }

    /// An include reCAPTCHA script action involves injecting reCAPTCHA JavaScript
    /// code into the HTML returned by the site backend. This reCAPTCHA
    /// script is tasked with collecting user signals on the requested web page,
    /// issuing tokens as a cookie within the site domain, and enabling their
    /// utilization in subsequent page requests.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IncludeRecaptchaScriptAction {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncludeRecaptchaScriptAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for IncludeRecaptchaScriptAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction"
        }
    }

    /// A redirect action returns a 307 (temporary redirect) response, pointing
    /// the user to a reCAPTCHA interstitial page to attach a token.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RedirectAction {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for RedirectAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction"
        }
    }

    /// A substitute action transparently serves a different page than the one
    /// requested.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SubstituteAction {
        /// Optional. The address to redirect to. The target is a relative path in
        /// the current host. Example: "/blog/404.html".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubstituteAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::firewall_action::SubstituteAction::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }
    }

    impl wkt::message::Message for SubstituteAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction"
        }
    }

    /// A set header action sets a header and forwards the request to the
    /// backend. This can be used to trigger custom protection implemented on the
    /// backend.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SetHeaderAction {
        /// Optional. The header key to set in the request to the backend server.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// Optional. The header value to set in the request to the backend server.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SetHeaderAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::firewall_action::SetHeaderAction::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::firewall_action::SetHeaderAction::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for SetHeaderAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FirewallActionOneof {
        /// The user request did not match any policy and should be allowed
        /// access to the requested resource.
        Allow(std::boxed::Box<crate::model::firewall_action::AllowAction>),
        /// This action denies access to a given page. The user gets an HTTP
        /// error code.
        Block(std::boxed::Box<crate::model::firewall_action::BlockAction>),
        /// This action injects reCAPTCHA JavaScript code into the HTML page
        /// returned by the site backend.
        IncludeRecaptchaScript(
            std::boxed::Box<crate::model::firewall_action::IncludeRecaptchaScriptAction>,
        ),
        /// This action redirects the request to a reCAPTCHA interstitial to
        /// attach a token.
        Redirect(std::boxed::Box<crate::model::firewall_action::RedirectAction>),
        /// This action transparently serves a different page to an offending
        /// user.
        Substitute(std::boxed::Box<crate::model::firewall_action::SubstituteAction>),
        /// This action sets a custom header but allow the request to continue
        /// to the customer backend.
        SetHeader(std::boxed::Box<crate::model::firewall_action::SetHeaderAction>),
    }
}

/// A FirewallPolicy represents a single matching pattern and resulting actions
/// to take.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirewallPolicy {
    /// Identifier. The resource name for the FirewallPolicy in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A description of what this policy aims to achieve, for
    /// convenience purposes. The description can at most include 256 UTF-8
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. The path for which this policy applies, specified as a glob
    /// pattern. For more information on glob, see the [manual
    /// page](https://man7.org/linux/man-pages/man7/glob.7.html).
    /// A path has a max length of 200 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Optional. A CEL (Common Expression Language) conditional expression that
    /// specifies if this policy applies to an incoming user request. If this
    /// condition evaluates to true and the requested path matched the path
    /// pattern, the associated actions should be executed by the caller. The
    /// condition string is checked for CEL syntax correctness on creation. For
    /// more information, see the [CEL spec](https://github.com/google/cel-spec)
    /// and its [language
    /// definition](https://github.com/google/cel-spec/blob/master/doc/langdef.md).
    /// A condition has a max length of 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub condition: std::string::String,

    /// Optional. The actions that the caller should take regarding user access.
    /// There should be at most one terminal action. A terminal action is any
    /// action that forces a response, such as `AllowAction`,
    /// `BlockAction` or `SubstituteAction`.
    /// Zero or more non-terminal actions such as `SetHeader` might be
    /// specified. A single policy can contain up to 16 actions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::FirewallAction>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirewallPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FirewallPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::FirewallPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [path][crate::model::FirewallPolicy::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::FirewallPolicy::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [actions][crate::model::FirewallPolicy::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallAction>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FirewallPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.FirewallPolicy"
    }
}

/// The request message to list memberships in a related account group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRelatedAccountGroupMembershipsRequest {
    /// Required. The resource name for the related account group in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of accounts to return. The service might
    /// return fewer than this value. If unspecified, at most 50 accounts are
    /// returned. The maximum value is 1000; values above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListRelatedAccountGroupMemberships` call.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroupMemberships` must match the call that provided the
    /// page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupMembershipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRelatedAccountGroupMembershipsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRelatedAccountGroupMembershipsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRelatedAccountGroupMembershipsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupMembershipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsRequest"
    }
}

/// The response to a `ListRelatedAccountGroupMemberships` call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRelatedAccountGroupMembershipsResponse {
    /// The memberships listed by the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_account_group_memberships:
        std::vec::Vec<crate::model::RelatedAccountGroupMembership>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupMembershipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRelatedAccountGroupMembershipsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [related_account_group_memberships][crate::model::ListRelatedAccountGroupMembershipsResponse::related_account_group_memberships].
    pub fn set_related_account_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroupMembership>,
    {
        use std::iter::Iterator;
        self.related_account_group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupMembershipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRelatedAccountGroupMembershipsResponse {
    type PageItem = crate::model::RelatedAccountGroupMembership;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_group_memberships
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message to list related account groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRelatedAccountGroupsRequest {
    /// Required. The name of the project to list related account groups from, in
    /// the format `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListRelatedAccountGroups`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroups` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRelatedAccountGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRelatedAccountGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRelatedAccountGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest"
    }
}

/// The response to a `ListRelatedAccountGroups` call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRelatedAccountGroupsResponse {
    /// The groups of related accounts listed by the query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_account_groups: std::vec::Vec<crate::model::RelatedAccountGroup>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRelatedAccountGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRelatedAccountGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [related_account_groups][crate::model::ListRelatedAccountGroupsResponse::related_account_groups].
    pub fn set_related_account_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroup>,
    {
        use std::iter::Iterator;
        self.related_account_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRelatedAccountGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRelatedAccountGroupsResponse {
    type PageItem = crate::model::RelatedAccountGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message to search related account group memberships.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchRelatedAccountGroupMembershipsRequest {
    /// Required. The name of the project to search related account group
    /// memberships from. Specify the project name in the following format:
    /// `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Optional. The unique stable account identifier used to search connections.
    /// The identifier should correspond to an `account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call. Either hashed_account_id
    /// or account_id must be set, but not both.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id: std::string::String,

    /// Optional. Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier used to search connections. The
    /// identifier should correspond to a `hashed_account_id` provided in a
    /// previous `CreateAssessment` or `AnnotateAssessment` call. Either
    /// hashed_account_id or account_id must be set, but not both.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `SearchRelatedAccountGroupMemberships` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `SearchRelatedAccountGroupMemberships` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRelatedAccountGroupMembershipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SearchRelatedAccountGroupMembershipsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::SearchRelatedAccountGroupMembershipsRequest::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::SearchRelatedAccountGroupMembershipsRequest::hashed_account_id].
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchRelatedAccountGroupMembershipsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchRelatedAccountGroupMembershipsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchRelatedAccountGroupMembershipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsRequest"
    }
}

/// The response to a `SearchRelatedAccountGroupMemberships` call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchRelatedAccountGroupMembershipsResponse {
    /// The queried memberships.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_account_group_memberships:
        std::vec::Vec<crate::model::RelatedAccountGroupMembership>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRelatedAccountGroupMembershipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchRelatedAccountGroupMembershipsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [related_account_group_memberships][crate::model::SearchRelatedAccountGroupMembershipsResponse::related_account_group_memberships].
    pub fn set_related_account_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RelatedAccountGroupMembership>,
    {
        use std::iter::Iterator;
        self.related_account_group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchRelatedAccountGroupMembershipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchRelatedAccountGroupMembershipsResponse {
    type PageItem = crate::model::RelatedAccountGroupMembership;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.related_account_group_memberships
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The AddIpOverride request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddIpOverrideRequest {
    /// Required. The name of the key to which the IP override is added, in the
    /// format `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. IP override added to the key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_override_data: std::option::Option<crate::model::IpOverrideData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddIpOverrideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AddIpOverrideRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_override_data][crate::model::AddIpOverrideRequest::ip_override_data].
    pub fn set_ip_override_data<
        T: std::convert::Into<std::option::Option<crate::model::IpOverrideData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ip_override_data = v.into();
        self
    }
}

impl wkt::message::Message for AddIpOverrideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AddIpOverrideRequest"
    }
}

/// Response for AddIpOverride.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddIpOverrideResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddIpOverrideResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddIpOverrideResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AddIpOverrideResponse"
    }
}

/// The RemoveIpOverride request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveIpOverrideRequest {
    /// Required. The name of the key from which the IP override is removed, in the
    /// format `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. IP override to be removed from the key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_override_data: std::option::Option<crate::model::IpOverrideData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveIpOverrideRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveIpOverrideRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_override_data][crate::model::RemoveIpOverrideRequest::ip_override_data].
    pub fn set_ip_override_data<
        T: std::convert::Into<std::option::Option<crate::model::IpOverrideData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ip_override_data = v.into();
        self
    }
}

impl wkt::message::Message for RemoveIpOverrideRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RemoveIpOverrideRequest"
    }
}

/// Response for RemoveIpOverride.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveIpOverrideResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveIpOverrideResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveIpOverrideResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RemoveIpOverrideResponse"
    }
}

/// The ListIpOverrides request message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIpOverridesRequest {
    /// Required. The parent key for which the IP overrides are listed, in the
    /// format `projects/{project}/keys/{key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of overrides to return. Default is 10. Max
    /// limit is 100. If the number of overrides is less than the page_size, all
    /// overrides are returned. If the page size is more than 100, it is coerced to
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous
    /// ListIpOverridesRequest, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIpOverridesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIpOverridesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIpOverridesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIpOverridesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListIpOverridesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListIpOverridesRequest"
    }
}

/// Response for ListIpOverrides.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIpOverridesResponse {
    /// IP Overrides details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_overrides: std::vec::Vec<crate::model::IpOverrideData>,

    /// Token to retrieve the next page of results. If this field is empty, no keys
    /// remain in the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIpOverridesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListIpOverridesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [ip_overrides][crate::model::ListIpOverridesResponse::ip_overrides].
    pub fn set_ip_overrides<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpOverrideData>,
    {
        use std::iter::Iterator;
        self.ip_overrides = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIpOverridesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.ListIpOverridesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIpOverridesResponse {
    type PageItem = crate::model::IpOverrideData;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ip_overrides
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A membership in a group of related accounts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RelatedAccountGroupMembership {
    /// Required. Identifier. The resource name for this membership in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}/memberships/{membership}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The unique stable account identifier of the member. The identifier
    /// corresponds to an `account_id` provided in a previous `CreateAssessment` or
    /// `AnnotateAssessment` call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub account_id: std::string::String,

    /// Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier of the member. The identifier
    /// corresponds to a `hashed_account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[deprecated]
    pub hashed_account_id: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAccountGroupMembership {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RelatedAccountGroupMembership::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [account_id][crate::model::RelatedAccountGroupMembership::account_id].
    pub fn set_account_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_id = v.into();
        self
    }

    /// Sets the value of [hashed_account_id][crate::model::RelatedAccountGroupMembership::hashed_account_id].
    #[deprecated]
    pub fn set_hashed_account_id<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.hashed_account_id = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAccountGroupMembership {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership"
    }
}

/// A group of related accounts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RelatedAccountGroup {
    /// Required. Identifier. The resource name for the related account group in
    /// the format
    /// `projects/{project}/relatedaccountgroups/{related_account_group}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelatedAccountGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RelatedAccountGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RelatedAccountGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.RelatedAccountGroup"
    }
}

/// Settings specific to keys that can be used for WAF (Web Application
/// Firewall).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WafSettings {
    /// Required. The WAF service that uses this key.
    pub waf_service: crate::model::waf_settings::WafService,

    /// Required. The WAF feature for which this key is enabled.
    pub waf_feature: crate::model::waf_settings::WafFeature,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WafSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [waf_service][crate::model::WafSettings::waf_service].
    pub fn set_waf_service<T: std::convert::Into<crate::model::waf_settings::WafService>>(
        mut self,
        v: T,
    ) -> Self {
        self.waf_service = v.into();
        self
    }

    /// Sets the value of [waf_feature][crate::model::WafSettings::waf_feature].
    pub fn set_waf_feature<T: std::convert::Into<crate::model::waf_settings::WafFeature>>(
        mut self,
        v: T,
    ) -> Self {
        self.waf_feature = v.into();
        self
    }
}

impl wkt::message::Message for WafSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.WafSettings"
    }
}

/// Defines additional types related to [WafSettings].
pub mod waf_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Supported WAF features. For more information, see
    /// <https://cloud.google.com/recaptcha/docs/usecase#comparison_of_features>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WafFeature {
        /// Undefined feature.
        Unspecified,
        /// Redirects suspicious traffic to reCAPTCHA.
        ChallengePage,
        /// Use reCAPTCHA session-tokens to protect the whole user session on the
        /// site's domain.
        SessionToken,
        /// Use reCAPTCHA action-tokens to protect user actions.
        ActionToken,
        /// Use reCAPTCHA WAF express protection to protect any content other than
        /// web pages, like APIs and IoT devices.
        Express,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WafFeature::value] or
        /// [WafFeature::name].
        UnknownValue(waf_feature::UnknownValue),
    }

    #[doc(hidden)]
    pub mod waf_feature {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WafFeature {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ChallengePage => std::option::Option::Some(1),
                Self::SessionToken => std::option::Option::Some(2),
                Self::ActionToken => std::option::Option::Some(3),
                Self::Express => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WAF_FEATURE_UNSPECIFIED"),
                Self::ChallengePage => std::option::Option::Some("CHALLENGE_PAGE"),
                Self::SessionToken => std::option::Option::Some("SESSION_TOKEN"),
                Self::ActionToken => std::option::Option::Some("ACTION_TOKEN"),
                Self::Express => std::option::Option::Some("EXPRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WafFeature {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WafFeature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WafFeature {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ChallengePage,
                2 => Self::SessionToken,
                3 => Self::ActionToken,
                5 => Self::Express,
                _ => Self::UnknownValue(waf_feature::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WafFeature {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WAF_FEATURE_UNSPECIFIED" => Self::Unspecified,
                "CHALLENGE_PAGE" => Self::ChallengePage,
                "SESSION_TOKEN" => Self::SessionToken,
                "ACTION_TOKEN" => Self::ActionToken,
                "EXPRESS" => Self::Express,
                _ => Self::UnknownValue(waf_feature::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WafFeature {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ChallengePage => serializer.serialize_i32(1),
                Self::SessionToken => serializer.serialize_i32(2),
                Self::ActionToken => serializer.serialize_i32(3),
                Self::Express => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WafFeature {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WafFeature>::new(
                ".google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature",
            ))
        }
    }

    /// Web Application Firewalls supported by reCAPTCHA.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WafService {
        /// Undefined WAF
        Unspecified,
        /// Cloud Armor
        Ca,
        /// Fastly
        Fastly,
        /// Cloudflare
        Cloudflare,
        /// Akamai
        Akamai,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WafService::value] or
        /// [WafService::name].
        UnknownValue(waf_service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod waf_service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WafService {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ca => std::option::Option::Some(1),
                Self::Fastly => std::option::Option::Some(3),
                Self::Cloudflare => std::option::Option::Some(4),
                Self::Akamai => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WAF_SERVICE_UNSPECIFIED"),
                Self::Ca => std::option::Option::Some("CA"),
                Self::Fastly => std::option::Option::Some("FASTLY"),
                Self::Cloudflare => std::option::Option::Some("CLOUDFLARE"),
                Self::Akamai => std::option::Option::Some("AKAMAI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WafService {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WafService {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WafService {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ca,
                3 => Self::Fastly,
                4 => Self::Cloudflare,
                5 => Self::Akamai,
                _ => Self::UnknownValue(waf_service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WafService {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WAF_SERVICE_UNSPECIFIED" => Self::Unspecified,
                "CA" => Self::Ca,
                "FASTLY" => Self::Fastly,
                "CLOUDFLARE" => Self::Cloudflare,
                "AKAMAI" => Self::Akamai,
                _ => Self::UnknownValue(waf_service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WafService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ca => serializer.serialize_i32(1),
                Self::Fastly => serializer.serialize_i32(3),
                Self::Cloudflare => serializer.serialize_i32(4),
                Self::Akamai => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WafService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WafService>::new(
                ".google.cloud.recaptchaenterprise.v1.WafSettings.WafService",
            ))
        }
    }
}

/// The environment creating the assessment. This describes your environment
/// (the system invoking CreateAssessment), NOT the environment of your user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssessmentEnvironment {
    /// Optional. Identifies the client module initiating the CreateAssessment
    /// request. This can be the link to the client module's project. Examples
    /// include:
    ///
    /// - "github.com/GoogleCloudPlatform/recaptcha-enterprise-google-tag-manager"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-akamai"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-cloudflare"
    /// - "wordpress.org/plugins/recaptcha-something"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client: std::string::String,

    /// Optional. The version of the client module. For example, "1.0.0".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssessmentEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client][crate::model::AssessmentEnvironment::client].
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AssessmentEnvironment::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for AssessmentEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.AssessmentEnvironment"
    }
}

/// Information about the IP or IP range override.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IpOverrideData {
    /// Required. The IP address to override (can be IPv4, IPv6 or CIDR).
    /// The IP override must be a valid IPv4 or IPv6 address, or a CIDR range.
    /// The IP override must be a public IP address.
    /// Example of IPv4: 168.192.5.6
    /// Example of IPv6: 2001:0000:130F:0000:0000:09C0:876A:130B
    /// Example of IPv4 with CIDR: 168.192.5.0/24
    /// Example of IPv6 with CIDR: 2001:0DB8:1234::/48
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip: std::string::String,

    /// Required. Describes the type of IP override.
    pub override_type: crate::model::ip_override_data::OverrideType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpOverrideData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip][crate::model::IpOverrideData::ip].
    pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip = v.into();
        self
    }

    /// Sets the value of [override_type][crate::model::IpOverrideData::override_type].
    pub fn set_override_type<
        T: std::convert::Into<crate::model::ip_override_data::OverrideType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.override_type = v.into();
        self
    }
}

impl wkt::message::Message for IpOverrideData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recaptchaenterprise.v1.IpOverrideData"
    }
}

/// Defines additional types related to [IpOverrideData].
pub mod ip_override_data {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that represents the type of IP override.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OverrideType {
        /// Default override type that indicates this enum hasn't been specified.
        Unspecified,
        /// Allowlist the IP address; i.e. give a `risk_analysis.score` of 0.9 for
        /// all valid assessments.
        Allow,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OverrideType::value] or
        /// [OverrideType::name].
        UnknownValue(override_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod override_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OverrideType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OVERRIDE_TYPE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OverrideType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OverrideType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OverrideType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                _ => Self::UnknownValue(override_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OverrideType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OVERRIDE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW" => Self::Allow,
                _ => Self::UnknownValue(override_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OverrideType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OverrideType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OverrideType>::new(
                ".google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType",
            ))
        }
    }
}
