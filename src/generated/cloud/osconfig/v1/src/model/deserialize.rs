// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Inventory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __os_info,
            __items,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Inventory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "osInfo" => Ok(__FieldTag::__os_info),
                            "os_info" => Ok(__FieldTag::__os_info),
                            "items" => Ok(__FieldTag::__items),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Inventory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Inventory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_info => {
                            if !fields.insert(__FieldTag::__os_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_info",
                                ));
                            }
                            result.os_info = map
                                .next_value::<std::option::Option<crate::model::inventory::OsInfo>>(
                                )?;
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::inventory::Item,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::OsInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __long_name,
            __short_name,
            __version,
            __architecture,
            __kernel_version,
            __kernel_release,
            __osconfig_agent_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OsInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "longName" => Ok(__FieldTag::__long_name),
                            "long_name" => Ok(__FieldTag::__long_name),
                            "shortName" => Ok(__FieldTag::__short_name),
                            "short_name" => Ok(__FieldTag::__short_name),
                            "version" => Ok(__FieldTag::__version),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "kernelVersion" => Ok(__FieldTag::__kernel_version),
                            "kernel_version" => Ok(__FieldTag::__kernel_version),
                            "kernelRelease" => Ok(__FieldTag::__kernel_release),
                            "kernel_release" => Ok(__FieldTag::__kernel_release),
                            "osconfigAgentVersion" => Ok(__FieldTag::__osconfig_agent_version),
                            "osconfig_agent_version" => Ok(__FieldTag::__osconfig_agent_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::OsInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OsInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__long_name => {
                            if !fields.insert(__FieldTag::__long_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_name",
                                ));
                            }
                            result.long_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__short_name => {
                            if !fields.insert(__FieldTag::__short_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_name",
                                ));
                            }
                            result.short_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kernel_version => {
                            if !fields.insert(__FieldTag::__kernel_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kernel_version",
                                ));
                            }
                            result.kernel_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kernel_release => {
                            if !fields.insert(__FieldTag::__kernel_release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kernel_release",
                                ));
                            }
                            result.kernel_release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__osconfig_agent_version => {
                            if !fields.insert(__FieldTag::__osconfig_agent_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for osconfig_agent_version",
                                ));
                            }
                            result.osconfig_agent_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::Item {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __origin_type,
            __create_time,
            __update_time,
            __type,
            __installed_package,
            __available_package,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Item")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "originType" => Ok(__FieldTag::__origin_type),
                            "origin_type" => Ok(__FieldTag::__origin_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "type" => Ok(__FieldTag::__type),
                            "installedPackage" => Ok(__FieldTag::__installed_package),
                            "installed_package" => Ok(__FieldTag::__installed_package),
                            "availablePackage" => Ok(__FieldTag::__available_package),
                            "available_package" => Ok(__FieldTag::__available_package),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::Item;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Item")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__origin_type => {
                            if !fields.insert(__FieldTag::__origin_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for origin_type",
                                ));
                            }
                            result.origin_type = map.next_value::<std::option::Option<crate::model::inventory::item::OriginType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::inventory::item::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__installed_package => {
                            if !fields.insert(__FieldTag::__installed_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installed_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.Item.installed_package, latest field was installedPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::item::Details::InstalledPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::SoftwarePackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__available_package => {
                            if !fields.insert(__FieldTag::__available_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.Item.available_package, latest field was availablePackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::item::Details::AvailablePackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::SoftwarePackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::SoftwarePackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __yum_package,
            __apt_package,
            __zypper_package,
            __googet_package,
            __zypper_patch,
            __wua_package,
            __qfe_package,
            __cos_package,
            __windows_application,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoftwarePackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "yumPackage" => Ok(__FieldTag::__yum_package),
                            "yum_package" => Ok(__FieldTag::__yum_package),
                            "aptPackage" => Ok(__FieldTag::__apt_package),
                            "apt_package" => Ok(__FieldTag::__apt_package),
                            "zypperPackage" => Ok(__FieldTag::__zypper_package),
                            "zypper_package" => Ok(__FieldTag::__zypper_package),
                            "googetPackage" => Ok(__FieldTag::__googet_package),
                            "googet_package" => Ok(__FieldTag::__googet_package),
                            "zypperPatch" => Ok(__FieldTag::__zypper_patch),
                            "zypper_patch" => Ok(__FieldTag::__zypper_patch),
                            "wuaPackage" => Ok(__FieldTag::__wua_package),
                            "wua_package" => Ok(__FieldTag::__wua_package),
                            "qfePackage" => Ok(__FieldTag::__qfe_package),
                            "qfe_package" => Ok(__FieldTag::__qfe_package),
                            "cosPackage" => Ok(__FieldTag::__cos_package),
                            "cos_package" => Ok(__FieldTag::__cos_package),
                            "windowsApplication" => Ok(__FieldTag::__windows_application),
                            "windows_application" => Ok(__FieldTag::__windows_application),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::SoftwarePackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoftwarePackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__yum_package => {
                            if !fields.insert(__FieldTag::__yum_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yum_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.yum_package, latest field was yumPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::YumPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::VersionedPackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__apt_package => {
                            if !fields.insert(__FieldTag::__apt_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apt_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.apt_package, latest field was aptPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::AptPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::VersionedPackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__zypper_package => {
                            if !fields.insert(__FieldTag::__zypper_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zypper_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.zypper_package, latest field was zypperPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::ZypperPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::VersionedPackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__googet_package => {
                            if !fields.insert(__FieldTag::__googet_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for googet_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.googet_package, latest field was googetPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::GoogetPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::VersionedPackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__zypper_patch => {
                            if !fields.insert(__FieldTag::__zypper_patch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zypper_patch",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.zypper_patch, latest field was zypperPatch",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::ZypperPatch(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::ZypperPatch>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__wua_package => {
                            if !fields.insert(__FieldTag::__wua_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wua_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.wua_package, latest field was wuaPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::WuaPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::inventory::WindowsUpdatePackage,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__qfe_package => {
                            if !fields.insert(__FieldTag::__qfe_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qfe_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.qfe_package, latest field was qfePackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::QfePackage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__cos_package => {
                            if !fields.insert(__FieldTag::__cos_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cos_package",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.cos_package, latest field was cosPackage",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::CosPackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::inventory::VersionedPackage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__windows_application => {
                            if !fields.insert(__FieldTag::__windows_application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_application",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.windows_application, latest field was windowsApplication",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::inventory::software_package::Details::WindowsApplication(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::inventory::WindowsApplication>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::VersionedPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package_name,
            __architecture,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VersionedPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "packageName" => Ok(__FieldTag::__package_name),
                            "package_name" => Ok(__FieldTag::__package_name),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::VersionedPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VersionedPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package_name => {
                            if !fields.insert(__FieldTag::__package_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_name",
                                ));
                            }
                            result.package_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::ZypperPatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_name,
            __category,
            __severity,
            __summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZypperPatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchName" => Ok(__FieldTag::__patch_name),
                            "patch_name" => Ok(__FieldTag::__patch_name),
                            "category" => Ok(__FieldTag::__category),
                            "severity" => Ok(__FieldTag::__severity),
                            "summary" => Ok(__FieldTag::__summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::ZypperPatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZypperPatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_name => {
                            if !fields.insert(__FieldTag::__patch_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_name",
                                ));
                            }
                            result.patch_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::WindowsUpdatePackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __description,
            __categories,
            __kb_article_ids,
            __support_url,
            __more_info_urls,
            __update_id,
            __revision_number,
            __last_deployment_change_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsUpdatePackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "categories" => Ok(__FieldTag::__categories),
                            "kbArticleIds" => Ok(__FieldTag::__kb_article_ids),
                            "kb_article_ids" => Ok(__FieldTag::__kb_article_ids),
                            "supportUrl" => Ok(__FieldTag::__support_url),
                            "support_url" => Ok(__FieldTag::__support_url),
                            "moreInfoUrls" => Ok(__FieldTag::__more_info_urls),
                            "more_info_urls" => Ok(__FieldTag::__more_info_urls),
                            "updateId" => Ok(__FieldTag::__update_id),
                            "update_id" => Ok(__FieldTag::__update_id),
                            "revisionNumber" => Ok(__FieldTag::__revision_number),
                            "revision_number" => Ok(__FieldTag::__revision_number),
                            "lastDeploymentChangeTime" => {
                                Ok(__FieldTag::__last_deployment_change_time)
                            }
                            "last_deployment_change_time" => {
                                Ok(__FieldTag::__last_deployment_change_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::WindowsUpdatePackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsUpdatePackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::inventory::windows_update_package::WindowsUpdateCategory>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kb_article_ids => {
                            if !fields.insert(__FieldTag::__kb_article_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kb_article_ids",
                                ));
                            }
                            result.kb_article_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__support_url => {
                            if !fields.insert(__FieldTag::__support_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_url",
                                ));
                            }
                            result.support_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__more_info_urls => {
                            if !fields.insert(__FieldTag::__more_info_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for more_info_urls",
                                ));
                            }
                            result.more_info_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_id => {
                            if !fields.insert(__FieldTag::__update_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_id",
                                ));
                            }
                            result.update_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_number => {
                            if !fields.insert(__FieldTag::__revision_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.revision_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_deployment_change_time => {
                            if !fields.insert(__FieldTag::__last_deployment_change_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_deployment_change_time",
                                ));
                            }
                            result.last_deployment_change_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::inventory::windows_update_package::WindowsUpdateCategory
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsUpdateCategory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::windows_update_package::WindowsUpdateCategory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsUpdateCategory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::WindowsQuickFixEngineeringPackage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __caption,
            __description,
            __hot_fix_id,
            __install_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsQuickFixEngineeringPackage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caption" => Ok(__FieldTag::__caption),
                            "description" => Ok(__FieldTag::__description),
                            "hotFixId" => Ok(__FieldTag::__hot_fix_id),
                            "hot_fix_id" => Ok(__FieldTag::__hot_fix_id),
                            "installTime" => Ok(__FieldTag::__install_time),
                            "install_time" => Ok(__FieldTag::__install_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::WindowsQuickFixEngineeringPackage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsQuickFixEngineeringPackage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__caption => {
                            if !fields.insert(__FieldTag::__caption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for caption",
                                ));
                            }
                            result.caption = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hot_fix_id => {
                            if !fields.insert(__FieldTag::__hot_fix_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_fix_id",
                                ));
                            }
                            result.hot_fix_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__install_time => {
                            if !fields.insert(__FieldTag::__install_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for install_time",
                                ));
                            }
                            result.install_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::inventory::WindowsApplication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __display_version,
            __publisher,
            __install_date,
            __help_link,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsApplication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "displayVersion" => Ok(__FieldTag::__display_version),
                            "display_version" => Ok(__FieldTag::__display_version),
                            "publisher" => Ok(__FieldTag::__publisher),
                            "installDate" => Ok(__FieldTag::__install_date),
                            "install_date" => Ok(__FieldTag::__install_date),
                            "helpLink" => Ok(__FieldTag::__help_link),
                            "help_link" => Ok(__FieldTag::__help_link),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::inventory::WindowsApplication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsApplication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_version => {
                            if !fields.insert(__FieldTag::__display_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_version",
                                ));
                            }
                            result.display_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publisher => {
                            if !fields.insert(__FieldTag::__publisher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publisher",
                                ));
                            }
                            result.publisher = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__install_date => {
                            if !fields.insert(__FieldTag::__install_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for install_date",
                                ));
                            }
                            result.install_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__help_link => {
                            if !fields.insert(__FieldTag::__help_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for help_link",
                                ));
                            }
                            result.help_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetInventoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInventoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetInventoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInventoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::InventoryView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListInventoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInventoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListInventoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInventoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::InventoryView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListInventoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inventories,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInventoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inventories" => Ok(__FieldTag::__inventories),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListInventoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInventoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inventories => {
                            if !fields.insert(__FieldTag::__inventories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventories",
                                ));
                            }
                            result.inventories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Inventory>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OSPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __description,
            __mode,
            __resource_groups,
            __allow_no_resource_group_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "description" => Ok(__FieldTag::__description),
                            "mode" => Ok(__FieldTag::__mode),
                            "resourceGroups" => Ok(__FieldTag::__resource_groups),
                            "resource_groups" => Ok(__FieldTag::__resource_groups),
                            "allowNoResourceGroupMatch" => {
                                Ok(__FieldTag::__allow_no_resource_group_match)
                            }
                            "allow_no_resource_group_match" => {
                                Ok(__FieldTag::__allow_no_resource_group_match)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OSPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<crate::model::os_policy::Mode>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_groups => {
                            if !fields.insert(__FieldTag::__resource_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_groups",
                                ));
                            }
                            result.resource_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::os_policy::ResourceGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_no_resource_group_match => {
                            if !fields.insert(__FieldTag::__allow_no_resource_group_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_no_resource_group_match",
                                ));
                            }
                            result.allow_no_resource_group_match = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::InventoryFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_short_name,
            __os_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InventoryFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osShortName" => Ok(__FieldTag::__os_short_name),
                            "os_short_name" => Ok(__FieldTag::__os_short_name),
                            "osVersion" => Ok(__FieldTag::__os_version),
                            "os_version" => Ok(__FieldTag::__os_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::InventoryFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InventoryFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_short_name => {
                            if !fields.insert(__FieldTag::__os_short_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_short_name",
                                ));
                            }
                            result.os_short_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_version => {
                            if !fields.insert(__FieldTag::__os_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_version",
                                ));
                            }
                            result.os_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::Resource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __pkg,
            __repository,
            __exec,
            __file,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Resource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "pkg" => Ok(__FieldTag::__pkg),
                            "repository" => Ok(__FieldTag::__repository),
                            "exec" => Ok(__FieldTag::__exec),
                            "file" => Ok(__FieldTag::__file),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::Resource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Resource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pkg => {
                            if !fields.insert(__FieldTag::__pkg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pkg",
                                ));
                            }
                            if result.resource_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.pkg, latest field was pkg",
                                ));
                            }
                            result.resource_type = std::option::Option::Some(
                                crate::model::os_policy::resource::ResourceType::Pkg(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::os_policy::resource::PackageResource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            if result.resource_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.repository, latest field was repository",
                                ));
                            }
                            result.resource_type = std::option::Option::Some(
                                crate::model::os_policy::resource::ResourceType::Repository(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::os_policy::resource::RepositoryResource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__exec => {
                            if !fields.insert(__FieldTag::__exec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exec",
                                ));
                            }
                            if result.resource_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.exec, latest field was exec",
                                ));
                            }
                            result.resource_type = std::option::Option::Some(
                                crate::model::os_policy::resource::ResourceType::Exec(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::os_policy::resource::ExecResource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            if result.resource_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.file, latest field was file",
                                ));
                            }
                            result.resource_type = std::option::Option::Some(
                                crate::model::os_policy::resource::ResourceType::File(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::os_policy::resource::FileResource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::File {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __remote,
            __gcs,
            __local_path,
            __allow_insecure,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for File")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "remote" => Ok(__FieldTag::__remote),
                            "gcs" => Ok(__FieldTag::__gcs),
                            "localPath" => Ok(__FieldTag::__local_path),
                            "local_path" => Ok(__FieldTag::__local_path),
                            "allowInsecure" => Ok(__FieldTag::__allow_insecure),
                            "allow_insecure" => Ok(__FieldTag::__allow_insecure),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::File;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct File")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__remote => {
                            if !fields.insert(__FieldTag::__remote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.File.remote, latest field was remote",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::os_policy::resource::file::Type::Remote(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::os_policy::resource::file::Remote,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs => {
                            if !fields.insert(__FieldTag::__gcs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.File.gcs, latest field was gcs",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::os_policy::resource::file::Type::Gcs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::os_policy::resource::file::Gcs,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__local_path => {
                            if !fields.insert(__FieldTag::__local_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_path",
                                ));
                            }
                            if result.r#type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `r#type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.File.local_path, latest field was localPath",
                                ));
                            }
                            result.r#type = std::option::Option::Some(
                                crate::model::os_policy::resource::file::Type::LocalPath(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__allow_insecure => {
                            if !fields.insert(__FieldTag::__allow_insecure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_insecure",
                                ));
                            }
                            result.allow_insecure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::file::Remote {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __sha256_checksum,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Remote")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "sha256Checksum" => Ok(__FieldTag::__sha256_checksum),
                            "sha256_checksum" => Ok(__FieldTag::__sha256_checksum),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::file::Remote;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Remote")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sha256_checksum => {
                            if !fields.insert(__FieldTag::__sha256_checksum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha256_checksum",
                                ));
                            }
                            result.sha256_checksum = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::file::Gcs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Gcs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::file::Gcs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Gcs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::PackageResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __desired_state,
            __apt,
            __deb,
            __yum,
            __zypper,
            __rpm,
            __googet,
            __msi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "desiredState" => Ok(__FieldTag::__desired_state),
                            "desired_state" => Ok(__FieldTag::__desired_state),
                            "apt" => Ok(__FieldTag::__apt),
                            "deb" => Ok(__FieldTag::__deb),
                            "yum" => Ok(__FieldTag::__yum),
                            "zypper" => Ok(__FieldTag::__zypper),
                            "rpm" => Ok(__FieldTag::__rpm),
                            "googet" => Ok(__FieldTag::__googet),
                            "msi" => Ok(__FieldTag::__msi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::PackageResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__desired_state => {
                            if !fields.insert(__FieldTag::__desired_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_state",
                                ));
                            }
                            result.desired_state = map.next_value::<std::option::Option<crate::model::os_policy::resource::package_resource::DesiredState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__apt => {
                            if !fields.insert(__FieldTag::__apt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apt",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.apt, latest field was apt",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Apt(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__deb => {
                            if !fields.insert(__FieldTag::__deb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deb",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.deb, latest field was deb",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Deb(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__yum => {
                            if !fields.insert(__FieldTag::__yum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yum",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.yum, latest field was yum",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Yum(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__zypper => {
                            if !fields.insert(__FieldTag::__zypper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zypper",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.zypper, latest field was zypper",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Zypper(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Zypper>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__rpm => {
                            if !fields.insert(__FieldTag::__rpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rpm",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.rpm, latest field was rpm",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Rpm(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__googet => {
                            if !fields.insert(__FieldTag::__googet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for googet",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.googet, latest field was googet",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Googet(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::GooGet>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__msi => {
                            if !fields.insert(__FieldTag::__msi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for msi",
                                ));
                            }
                            if result.system_package.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.msi, latest field was msi",
                                ));
                            }
                            result.system_package = std::option::Option::Some(
                                crate::model::os_policy::resource::package_resource::SystemPackage::Msi(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::Deb {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __pull_deps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Deb")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "pullDeps" => Ok(__FieldTag::__pull_deps),
                            "pull_deps" => Ok(__FieldTag::__pull_deps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::Deb;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Deb")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::os_policy::resource::File>>()?
                                ;
                        }
                        __FieldTag::__pull_deps => {
                            if !fields.insert(__FieldTag::__pull_deps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_deps",
                                ));
                            }
                            result.pull_deps = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::Apt {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Apt")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::Apt;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Apt")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::Rpm {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __pull_deps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rpm")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "pullDeps" => Ok(__FieldTag::__pull_deps),
                            "pull_deps" => Ok(__FieldTag::__pull_deps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::Rpm;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rpm")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::os_policy::resource::File>>()?
                                ;
                        }
                        __FieldTag::__pull_deps => {
                            if !fields.insert(__FieldTag::__pull_deps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pull_deps",
                                ));
                            }
                            result.pull_deps = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::Yum {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Yum")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::Yum;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Yum")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::Zypper {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Zypper")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::Zypper;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Zypper")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::GooGet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GooGet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::GooGet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GooGet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::package_resource::Msi {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Msi")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::package_resource::Msi;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Msi")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::os_policy::resource::File>>()?
                                ;
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::RepositoryResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __apt,
            __yum,
            __zypper,
            __goo,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepositoryResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "apt" => Ok(__FieldTag::__apt),
                            "yum" => Ok(__FieldTag::__yum),
                            "zypper" => Ok(__FieldTag::__zypper),
                            "goo" => Ok(__FieldTag::__goo),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::RepositoryResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepositoryResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__apt => {
                            if !fields.insert(__FieldTag::__apt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apt",
                                ));
                            }
                            if result.repository.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.apt, latest field was apt",
                                ));
                            }
                            result.repository = std::option::Option::Some(
                                crate::model::os_policy::resource::repository_resource::Repository::Apt(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::AptRepository>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__yum => {
                            if !fields.insert(__FieldTag::__yum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yum",
                                ));
                            }
                            if result.repository.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.yum, latest field was yum",
                                ));
                            }
                            result.repository = std::option::Option::Some(
                                crate::model::os_policy::resource::repository_resource::Repository::Yum(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::YumRepository>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__zypper => {
                            if !fields.insert(__FieldTag::__zypper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zypper",
                                ));
                            }
                            if result.repository.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.zypper, latest field was zypper",
                                ));
                            }
                            result.repository = std::option::Option::Some(
                                crate::model::os_policy::resource::repository_resource::Repository::Zypper(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::ZypperRepository>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__goo => {
                            if !fields.insert(__FieldTag::__goo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for goo",
                                ));
                            }
                            if result.repository.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.goo, latest field was goo",
                                ));
                            }
                            result.repository = std::option::Option::Some(
                                crate::model::os_policy::resource::repository_resource::Repository::Goo(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::GooRepository>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::os_policy::resource::repository_resource::AptRepository
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __archive_type,
            __uri,
            __distribution,
            __components,
            __gpg_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AptRepository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "archiveType" => Ok(__FieldTag::__archive_type),
                            "archive_type" => Ok(__FieldTag::__archive_type),
                            "uri" => Ok(__FieldTag::__uri),
                            "distribution" => Ok(__FieldTag::__distribution),
                            "components" => Ok(__FieldTag::__components),
                            "gpgKey" => Ok(__FieldTag::__gpg_key),
                            "gpg_key" => Ok(__FieldTag::__gpg_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::repository_resource::AptRepository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AptRepository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__archive_type => {
                            if !fields.insert(__FieldTag::__archive_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_type",
                                ));
                            }
                            result.archive_type = map.next_value::<std::option::Option<crate::model::os_policy::resource::repository_resource::apt_repository::ArchiveType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distribution => {
                            if !fields.insert(__FieldTag::__distribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution",
                                ));
                            }
                            result.distribution = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__components => {
                            if !fields.insert(__FieldTag::__components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for components",
                                ));
                            }
                            result.components = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gpg_key => {
                            if !fields.insert(__FieldTag::__gpg_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpg_key",
                                ));
                            }
                            result.gpg_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::os_policy::resource::repository_resource::YumRepository
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            __base_url,
            __gpg_keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for YumRepository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "baseUrl" => Ok(__FieldTag::__base_url),
                            "base_url" => Ok(__FieldTag::__base_url),
                            "gpgKeys" => Ok(__FieldTag::__gpg_keys),
                            "gpg_keys" => Ok(__FieldTag::__gpg_keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::repository_resource::YumRepository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct YumRepository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_url => {
                            if !fields.insert(__FieldTag::__base_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_url",
                                ));
                            }
                            result.base_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpg_keys => {
                            if !fields.insert(__FieldTag::__gpg_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpg_keys",
                                ));
                            }
                            result.gpg_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::os_policy::resource::repository_resource::ZypperRepository
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            __base_url,
            __gpg_keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZypperRepository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "baseUrl" => Ok(__FieldTag::__base_url),
                            "base_url" => Ok(__FieldTag::__base_url),
                            "gpgKeys" => Ok(__FieldTag::__gpg_keys),
                            "gpg_keys" => Ok(__FieldTag::__gpg_keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::repository_resource::ZypperRepository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZypperRepository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_url => {
                            if !fields.insert(__FieldTag::__base_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_url",
                                ));
                            }
                            result.base_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpg_keys => {
                            if !fields.insert(__FieldTag::__gpg_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpg_keys",
                                ));
                            }
                            result.gpg_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::os_policy::resource::repository_resource::GooRepository
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GooRepository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "url" => Ok(__FieldTag::__url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::repository_resource::GooRepository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GooRepository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::ExecResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __validate,
            __enforce,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "validate" => Ok(__FieldTag::__validate),
                            "enforce" => Ok(__FieldTag::__enforce),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::ExecResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__validate => {
                            if !fields.insert(__FieldTag::__validate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate",
                                ));
                            }
                            result.validate = map.next_value::<std::option::Option<
                                crate::model::os_policy::resource::exec_resource::Exec,
                            >>()?;
                        }
                        __FieldTag::__enforce => {
                            if !fields.insert(__FieldTag::__enforce) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enforce",
                                ));
                            }
                            result.enforce = map.next_value::<std::option::Option<
                                crate::model::os_policy::resource::exec_resource::Exec,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::exec_resource::Exec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file,
            __script,
            __args,
            __interpreter,
            __output_file_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Exec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "file" => Ok(__FieldTag::__file),
                            "script" => Ok(__FieldTag::__script),
                            "args" => Ok(__FieldTag::__args),
                            "interpreter" => Ok(__FieldTag::__interpreter),
                            "outputFilePath" => Ok(__FieldTag::__output_file_path),
                            "output_file_path" => Ok(__FieldTag::__output_file_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::exec_resource::Exec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Exec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.file, latest field was file",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::os_policy::resource::exec_resource::exec::Source::File(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::File>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.script, latest field was script",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::os_policy::resource::exec_resource::exec::Source::Script(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__interpreter => {
                            if !fields.insert(__FieldTag::__interpreter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interpreter",
                                ));
                            }
                            result.interpreter = map.next_value::<std::option::Option<crate::model::os_policy::resource::exec_resource::exec::Interpreter>>()?.unwrap_or_default();
                        }
                        __FieldTag::__output_file_path => {
                            if !fields.insert(__FieldTag::__output_file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_file_path",
                                ));
                            }
                            result.output_file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::resource::FileResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file,
            __content,
            __path,
            __state,
            __permissions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "file" => Ok(__FieldTag::__file),
                            "content" => Ok(__FieldTag::__content),
                            "path" => Ok(__FieldTag::__path),
                            "state" => Ok(__FieldTag::__state),
                            "permissions" => Ok(__FieldTag::__permissions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::resource::FileResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.file, latest field was file",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::os_policy::resource::file_resource::Source::File(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::os_policy::resource::File>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.content, latest field was content",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::os_policy::resource::file_resource::Source::Content(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::os_policy::resource::file_resource::DesiredState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permissions => {
                            if !fields.insert(__FieldTag::__permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permissions",
                                ));
                            }
                            result.permissions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy::ResourceGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inventory_filters,
            __resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inventoryFilters" => Ok(__FieldTag::__inventory_filters),
                            "inventory_filters" => Ok(__FieldTag::__inventory_filters),
                            "resources" => Ok(__FieldTag::__resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy::ResourceGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inventory_filters => {
                            if !fields.insert(__FieldTag::__inventory_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventory_filters",
                                ));
                            }
                            result.inventory_filters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::os_policy::InventoryFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::os_policy::Resource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOSPolicyAssignmentReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOSPolicyAssignmentReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOSPolicyAssignmentReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOSPolicyAssignmentReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOSPolicyAssignmentReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __filter,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSPolicyAssignmentReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOSPolicyAssignmentReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOSPolicyAssignmentReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignment_reports,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListOSPolicyAssignmentReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignmentReports" => {
                                Ok(__FieldTag::__os_policy_assignment_reports)
                            }
                            "os_policy_assignment_reports" => {
                                Ok(__FieldTag::__os_policy_assignment_reports)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOSPolicyAssignmentReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignment_reports => {
                            if !fields.insert(__FieldTag::__os_policy_assignment_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment_reports",
                                ));
                            }
                            result.os_policy_assignment_reports = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OSPolicyAssignmentReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OSPolicyAssignmentReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance,
            __os_policy_assignment,
            __os_policy_compliances,
            __update_time,
            __last_run_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyAssignmentReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instance" => Ok(__FieldTag::__instance),
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "osPolicyCompliances" => Ok(__FieldTag::__os_policy_compliances),
                            "os_policy_compliances" => Ok(__FieldTag::__os_policy_compliances),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastRunId" => Ok(__FieldTag::__last_run_id),
                            "last_run_id" => Ok(__FieldTag::__last_run_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OSPolicyAssignmentReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyAssignmentReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_compliances => {
                            if !fields.insert(__FieldTag::__os_policy_compliances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_compliances",
                                ));
                            }
                            result.os_policy_compliances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment_report::OSPolicyCompliance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_run_id => {
                            if !fields.insert(__FieldTag::__last_run_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_run_id",
                                ));
                            }
                            result.last_run_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment_report::OSPolicyCompliance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_id,
            __compliance_state,
            __compliance_state_reason,
            __os_policy_resource_compliances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyCompliance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyId" => Ok(__FieldTag::__os_policy_id),
                            "os_policy_id" => Ok(__FieldTag::__os_policy_id),
                            "complianceState" => Ok(__FieldTag::__compliance_state),
                            "compliance_state" => Ok(__FieldTag::__compliance_state),
                            "complianceStateReason" => Ok(__FieldTag::__compliance_state_reason),
                            "compliance_state_reason" => Ok(__FieldTag::__compliance_state_reason),
                            "osPolicyResourceCompliances" => {
                                Ok(__FieldTag::__os_policy_resource_compliances)
                            }
                            "os_policy_resource_compliances" => {
                                Ok(__FieldTag::__os_policy_resource_compliances)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment_report::OSPolicyCompliance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyCompliance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_id => {
                            if !fields.insert(__FieldTag::__os_policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_id",
                                ));
                            }
                            result.os_policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compliance_state => {
                            if !fields.insert(__FieldTag::__compliance_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_state",
                                ));
                            }
                            result.compliance_state = map.next_value::<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::ComplianceState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compliance_state_reason => {
                            if !fields.insert(__FieldTag::__compliance_state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_state_reason",
                                ));
                            }
                            result.compliance_state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_resource_compliances => {
                            if !fields.insert(__FieldTag::__os_policy_resource_compliances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_resource_compliances",
                                ));
                            }
                            result.os_policy_resource_compliances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_resource_id,
            __config_steps,
            __compliance_state,
            __compliance_state_reason,
            __exec_resource_output,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyResourceCompliance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyResourceId" => Ok(__FieldTag::__os_policy_resource_id),
                            "os_policy_resource_id" => Ok(__FieldTag::__os_policy_resource_id),
                            "configSteps" => Ok(__FieldTag::__config_steps),
                            "config_steps" => Ok(__FieldTag::__config_steps),
                            "complianceState" => Ok(__FieldTag::__compliance_state),
                            "compliance_state" => Ok(__FieldTag::__compliance_state),
                            "complianceStateReason" => Ok(__FieldTag::__compliance_state_reason),
                            "compliance_state_reason" => Ok(__FieldTag::__compliance_state_reason),
                            "execResourceOutput" => Ok(__FieldTag::__exec_resource_output),
                            "exec_resource_output" => Ok(__FieldTag::__exec_resource_output),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyResourceCompliance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_resource_id => {
                            if !fields.insert(__FieldTag::__os_policy_resource_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_resource_id",
                                ));
                            }
                            result.os_policy_resource_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_steps => {
                            if !fields.insert(__FieldTag::__config_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_steps",
                                ));
                            }
                            result.config_steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compliance_state => {
                            if !fields.insert(__FieldTag::__compliance_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_state",
                                ));
                            }
                            result.compliance_state = map.next_value::<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ComplianceState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compliance_state_reason => {
                            if !fields.insert(__FieldTag::__compliance_state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_state_reason",
                                ));
                            }
                            result.compliance_state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exec_resource_output => {
                            if !fields.insert(__FieldTag::__exec_resource_output) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exec_resource_output",
                                ));
                            }
                            if result.output.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.exec_resource_output, latest field was execResourceOutput",
                                ));
                            }
                            result.output = std::option::Option::Some(
                                crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output::ExecResourceOutput(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __error_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyResourceConfigStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyResourceConfigStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::os_policy_resource_config_step::Type>>()?.unwrap_or_default();
                        },
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for error_message"));
                            }
                            result.error_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enforcement_output,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecResourceOutput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enforcementOutput" => Ok(__FieldTag::__enforcement_output),
                            "enforcement_output" => Ok(__FieldTag::__enforcement_output),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecResourceOutput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enforcement_output => {
                            if !fields.insert(__FieldTag::__enforcement_output) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enforcement_output"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.enforcement_output = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OSPolicyAssignment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __os_policies,
            __instance_filter,
            __rollout,
            __revision_id,
            __revision_create_time,
            __etag,
            __rollout_state,
            __baseline,
            __deleted,
            __reconciling,
            __uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyAssignment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "osPolicies" => Ok(__FieldTag::__os_policies),
                            "os_policies" => Ok(__FieldTag::__os_policies),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "revisionCreateTime" => Ok(__FieldTag::__revision_create_time),
                            "revision_create_time" => Ok(__FieldTag::__revision_create_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "rolloutState" => Ok(__FieldTag::__rollout_state),
                            "rollout_state" => Ok(__FieldTag::__rollout_state),
                            "baseline" => Ok(__FieldTag::__baseline),
                            "deleted" => Ok(__FieldTag::__deleted),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "uid" => Ok(__FieldTag::__uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OSPolicyAssignment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyAssignment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policies => {
                            if !fields.insert(__FieldTag::__os_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policies",
                                ));
                            }
                            result.os_policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OSPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<
                                crate::model::os_policy_assignment::InstanceFilter,
                            >>()?;
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout =
                                map.next_value::<std::option::Option<
                                    crate::model::os_policy_assignment::Rollout,
                                >>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_create_time => {
                            if !fields.insert(__FieldTag::__revision_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_create_time",
                                ));
                            }
                            result.revision_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_state => {
                            if !fields.insert(__FieldTag::__rollout_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_state",
                                ));
                            }
                            result.rollout_state = map
                                .next_value::<std::option::Option<
                                    crate::model::os_policy_assignment::RolloutState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__baseline => {
                            if !fields.insert(__FieldTag::__baseline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for baseline",
                                ));
                            }
                            result.baseline = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment::LabelSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LabelSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment::LabelSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LabelSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment::InstanceFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all,
            __inclusion_labels,
            __exclusion_labels,
            __inventories,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "all" => Ok(__FieldTag::__all),
                            "inclusionLabels" => Ok(__FieldTag::__inclusion_labels),
                            "inclusion_labels" => Ok(__FieldTag::__inclusion_labels),
                            "exclusionLabels" => Ok(__FieldTag::__exclusion_labels),
                            "exclusion_labels" => Ok(__FieldTag::__exclusion_labels),
                            "inventories" => Ok(__FieldTag::__inventories),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment::InstanceFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all => {
                            if !fields.insert(__FieldTag::__all) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all",
                                ));
                            }
                            result.all = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inclusion_labels => {
                            if !fields.insert(__FieldTag::__inclusion_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inclusion_labels",
                                ));
                            }
                            result.inclusion_labels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exclusion_labels => {
                            if !fields.insert(__FieldTag::__exclusion_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusion_labels",
                                ));
                            }
                            result.exclusion_labels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inventories => {
                            if !fields.insert(__FieldTag::__inventories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventories",
                                ));
                            }
                            result.inventories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment::instance_filter::Inventory>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment::instance_filter::Inventory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_short_name,
            __os_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Inventory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osShortName" => Ok(__FieldTag::__os_short_name),
                            "os_short_name" => Ok(__FieldTag::__os_short_name),
                            "osVersion" => Ok(__FieldTag::__os_version),
                            "os_version" => Ok(__FieldTag::__os_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment::instance_filter::Inventory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Inventory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_short_name => {
                            if !fields.insert(__FieldTag::__os_short_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_short_name",
                                ));
                            }
                            result.os_short_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_version => {
                            if !fields.insert(__FieldTag::__os_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_version",
                                ));
                            }
                            result.os_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::os_policy_assignment::Rollout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disruption_budget,
            __min_wait_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rollout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disruptionBudget" => Ok(__FieldTag::__disruption_budget),
                            "disruption_budget" => Ok(__FieldTag::__disruption_budget),
                            "minWaitDuration" => Ok(__FieldTag::__min_wait_duration),
                            "min_wait_duration" => Ok(__FieldTag::__min_wait_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::os_policy_assignment::Rollout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rollout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disruption_budget => {
                            if !fields.insert(__FieldTag::__disruption_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disruption_budget",
                                ));
                            }
                            result.disruption_budget = map
                                .next_value::<std::option::Option<crate::model::FixedOrPercent>>(
                                )?;
                        }
                        __FieldTag::__min_wait_duration => {
                            if !fields.insert(__FieldTag::__min_wait_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_wait_duration",
                                ));
                            }
                            result.min_wait_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OSPolicyAssignmentOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignment,
            __api_method,
            __rollout_state,
            __rollout_start_time,
            __rollout_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyAssignmentOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "apiMethod" => Ok(__FieldTag::__api_method),
                            "api_method" => Ok(__FieldTag::__api_method),
                            "rolloutState" => Ok(__FieldTag::__rollout_state),
                            "rollout_state" => Ok(__FieldTag::__rollout_state),
                            "rolloutStartTime" => Ok(__FieldTag::__rollout_start_time),
                            "rollout_start_time" => Ok(__FieldTag::__rollout_start_time),
                            "rolloutUpdateTime" => Ok(__FieldTag::__rollout_update_time),
                            "rollout_update_time" => Ok(__FieldTag::__rollout_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OSPolicyAssignmentOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyAssignmentOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_method => {
                            if !fields.insert(__FieldTag::__api_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_method",
                                ));
                            }
                            result.api_method = map.next_value::<std::option::Option<crate::model::os_policy_assignment_operation_metadata::APIMethod>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rollout_state => {
                            if !fields.insert(__FieldTag::__rollout_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_state",
                                ));
                            }
                            result.rollout_state = map.next_value::<std::option::Option<crate::model::os_policy_assignment_operation_metadata::RolloutState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rollout_start_time => {
                            if !fields.insert(__FieldTag::__rollout_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_start_time",
                                ));
                            }
                            result.rollout_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rollout_update_time => {
                            if !fields.insert(__FieldTag::__rollout_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_update_time",
                                ));
                            }
                            result.rollout_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __os_policy_assignment,
            __os_policy_assignment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "osPolicyAssignmentId" => Ok(__FieldTag::__os_policy_assignment_id),
                            "os_policy_assignment_id" => Ok(__FieldTag::__os_policy_assignment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map.next_value::<std::option::Option<crate::model::OSPolicyAssignment>>()?
                                ;
                        }
                        __FieldTag::__os_policy_assignment_id => {
                            if !fields.insert(__FieldTag::__os_policy_assignment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment_id",
                                ));
                            }
                            result.os_policy_assignment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map.next_value::<std::option::Option<crate::model::OSPolicyAssignment>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOSPolicyAssignmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSPolicyAssignmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOSPolicyAssignmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOSPolicyAssignmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSPolicyAssignmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignments" => Ok(__FieldTag::__os_policy_assignments),
                            "os_policy_assignments" => Ok(__FieldTag::__os_policy_assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOSPolicyAssignmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignments => {
                            if !fields.insert(__FieldTag::__os_policy_assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignments",
                                ));
                            }
                            result.os_policy_assignments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OSPolicyAssignment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOSPolicyAssignmentRevisionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListOSPolicyAssignmentRevisionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOSPolicyAssignmentRevisionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentRevisionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOSPolicyAssignmentRevisionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListOSPolicyAssignmentRevisionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignments" => Ok(__FieldTag::__os_policy_assignments),
                            "os_policy_assignments" => Ok(__FieldTag::__os_policy_assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOSPolicyAssignmentRevisionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentRevisionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignments => {
                            if !fields.insert(__FieldTag::__os_policy_assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignments",
                                ));
                            }
                            result.os_policy_assignments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OSPolicyAssignment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FixedOrPercent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fixed,
            __percent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FixedOrPercent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fixed" => Ok(__FieldTag::__fixed),
                            "percent" => Ok(__FieldTag::__percent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FixedOrPercent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FixedOrPercent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fixed => {
                            if !fields.insert(__FieldTag::__fixed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.osconfig.v1.FixedOrPercent.fixed, latest field was fixed",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::fixed_or_percent::Mode::Fixed(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.osconfig.v1.FixedOrPercent.percent, latest field was percent",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::fixed_or_percent::Mode::Percent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __instance_filter,
            __patch_config,
            __duration,
            __one_time_schedule,
            __recurring_schedule,
            __create_time,
            __update_time,
            __last_execute_time,
            __rollout,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "patchConfig" => Ok(__FieldTag::__patch_config),
                            "patch_config" => Ok(__FieldTag::__patch_config),
                            "duration" => Ok(__FieldTag::__duration),
                            "oneTimeSchedule" => Ok(__FieldTag::__one_time_schedule),
                            "one_time_schedule" => Ok(__FieldTag::__one_time_schedule),
                            "recurringSchedule" => Ok(__FieldTag::__recurring_schedule),
                            "recurring_schedule" => Ok(__FieldTag::__recurring_schedule),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastExecuteTime" => Ok(__FieldTag::__last_execute_time),
                            "last_execute_time" => Ok(__FieldTag::__last_execute_time),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<crate::model::PatchInstanceFilter>>()?
                                ;
                        }
                        __FieldTag::__patch_config => {
                            if !fields.insert(__FieldTag::__patch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_config",
                                ));
                            }
                            result.patch_config =
                                map.next_value::<std::option::Option<crate::model::PatchConfig>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__one_time_schedule => {
                            if !fields.insert(__FieldTag::__one_time_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for one_time_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.osconfig.v1.PatchDeployment.one_time_schedule, latest field was oneTimeSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::patch_deployment::Schedule::OneTimeSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OneTimeSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__recurring_schedule => {
                            if !fields.insert(__FieldTag::__recurring_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurring_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.osconfig.v1.PatchDeployment.recurring_schedule, latest field was recurringSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::patch_deployment::Schedule::RecurringSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RecurringSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_execute_time => {
                            if !fields.insert(__FieldTag::__last_execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execute_time",
                                ));
                            }
                            result.last_execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<crate::model::PatchRollout>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::patch_deployment::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OneTimeSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execute_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OneTimeSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executeTime" => Ok(__FieldTag::__execute_time),
                            "execute_time" => Ok(__FieldTag::__execute_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OneTimeSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OneTimeSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execute_time => {
                            if !fields.insert(__FieldTag::__execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execute_time",
                                ));
                            }
                            result.execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RecurringSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_zone,
            __start_time,
            __end_time,
            __time_of_day,
            __frequency,
            __weekly,
            __monthly,
            __last_execute_time,
            __next_execute_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecurringSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "timeOfDay" => Ok(__FieldTag::__time_of_day),
                            "time_of_day" => Ok(__FieldTag::__time_of_day),
                            "frequency" => Ok(__FieldTag::__frequency),
                            "weekly" => Ok(__FieldTag::__weekly),
                            "monthly" => Ok(__FieldTag::__monthly),
                            "lastExecuteTime" => Ok(__FieldTag::__last_execute_time),
                            "last_execute_time" => Ok(__FieldTag::__last_execute_time),
                            "nextExecuteTime" => Ok(__FieldTag::__next_execute_time),
                            "next_execute_time" => Ok(__FieldTag::__next_execute_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RecurringSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecurringSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<gtype::model::TimeZone>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__time_of_day => {
                            if !fields.insert(__FieldTag::__time_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_of_day",
                                ));
                            }
                            result.time_of_day =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            result.frequency =
                                map.next_value::<std::option::Option<
                                    crate::model::recurring_schedule::Frequency,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__weekly => {
                            if !fields.insert(__FieldTag::__weekly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly",
                                ));
                            }
                            if result.schedule_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule_config`, a oneof with full ID .google.cloud.osconfig.v1.RecurringSchedule.weekly, latest field was weekly",
                                ));
                            }
                            result.schedule_config = std::option::Option::Some(
                                crate::model::recurring_schedule::ScheduleConfig::Weekly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WeeklySchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__monthly => {
                            if !fields.insert(__FieldTag::__monthly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly",
                                ));
                            }
                            if result.schedule_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule_config`, a oneof with full ID .google.cloud.osconfig.v1.RecurringSchedule.monthly, latest field was monthly",
                                ));
                            }
                            result.schedule_config = std::option::Option::Some(
                                crate::model::recurring_schedule::ScheduleConfig::Monthly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MonthlySchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__last_execute_time => {
                            if !fields.insert(__FieldTag::__last_execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execute_time",
                                ));
                            }
                            result.last_execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_execute_time => {
                            if !fields.insert(__FieldTag::__next_execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_execute_time",
                                ));
                            }
                            result.next_execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WeeklySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __day_of_week,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeeklySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WeeklySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeeklySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MonthlySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __week_day_of_month,
            __month_day,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonthlySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weekDayOfMonth" => Ok(__FieldTag::__week_day_of_month),
                            "week_day_of_month" => Ok(__FieldTag::__week_day_of_month),
                            "monthDay" => Ok(__FieldTag::__month_day),
                            "month_day" => Ok(__FieldTag::__month_day),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MonthlySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonthlySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__week_day_of_month => {
                            if !fields.insert(__FieldTag::__week_day_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for week_day_of_month",
                                ));
                            }
                            if result.day_of_month.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `day_of_month`, a oneof with full ID .google.cloud.osconfig.v1.MonthlySchedule.week_day_of_month, latest field was weekDayOfMonth",
                                ));
                            }
                            result.day_of_month = std::option::Option::Some(
                                crate::model::monthly_schedule::DayOfMonth::WeekDayOfMonth(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WeekDayOfMonth>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__month_day => {
                            if !fields.insert(__FieldTag::__month_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for month_day",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.day_of_month.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `day_of_month`, a oneof with full ID .google.cloud.osconfig.v1.MonthlySchedule.month_day, latest field was monthDay",
                                ));
                            }
                            result.day_of_month = std::option::Option::Some(
                                crate::model::monthly_schedule::DayOfMonth::MonthDay(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WeekDayOfMonth {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __week_ordinal,
            __day_of_week,
            __day_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeekDayOfMonth")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weekOrdinal" => Ok(__FieldTag::__week_ordinal),
                            "week_ordinal" => Ok(__FieldTag::__week_ordinal),
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            "dayOffset" => Ok(__FieldTag::__day_offset),
                            "day_offset" => Ok(__FieldTag::__day_offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WeekDayOfMonth;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeekDayOfMonth")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__week_ordinal => {
                            if !fields.insert(__FieldTag::__week_ordinal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for week_ordinal",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.week_ordinal = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__day_offset => {
                            if !fields.insert(__FieldTag::__day_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.day_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreatePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __patch_deployment_id,
            __patch_deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "patchDeploymentId" => Ok(__FieldTag::__patch_deployment_id),
                            "patch_deployment_id" => Ok(__FieldTag::__patch_deployment_id),
                            "patchDeployment" => Ok(__FieldTag::__patch_deployment),
                            "patch_deployment" => Ok(__FieldTag::__patch_deployment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreatePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__patch_deployment_id => {
                            if !fields.insert(__FieldTag::__patch_deployment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment_id",
                                ));
                            }
                            result.patch_deployment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__patch_deployment => {
                            if !fields.insert(__FieldTag::__patch_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment",
                                ));
                            }
                            result.patch_deployment = map
                                .next_value::<std::option::Option<crate::model::PatchDeployment>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetPatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetPatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListPatchDeploymentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchDeploymentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListPatchDeploymentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchDeploymentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListPatchDeploymentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_deployments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchDeploymentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchDeployments" => Ok(__FieldTag::__patch_deployments),
                            "patch_deployments" => Ok(__FieldTag::__patch_deployments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListPatchDeploymentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchDeploymentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_deployments => {
                            if !fields.insert(__FieldTag::__patch_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployments",
                                ));
                            }
                            result.patch_deployments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PatchDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeletePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeletePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdatePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_deployment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchDeployment" => Ok(__FieldTag::__patch_deployment),
                            "patch_deployment" => Ok(__FieldTag::__patch_deployment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdatePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_deployment => {
                            if !fields.insert(__FieldTag::__patch_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment",
                                ));
                            }
                            result.patch_deployment = map
                                .next_value::<std::option::Option<crate::model::PatchDeployment>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PausePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PausePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PausePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PausePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResumePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResumePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExecutePatchJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __description,
            __instance_filter,
            __patch_config,
            __duration,
            __dry_run,
            __display_name,
            __rollout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutePatchJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "description" => Ok(__FieldTag::__description),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "patchConfig" => Ok(__FieldTag::__patch_config),
                            "patch_config" => Ok(__FieldTag::__patch_config),
                            "duration" => Ok(__FieldTag::__duration),
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "rollout" => Ok(__FieldTag::__rollout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExecutePatchJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutePatchJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<crate::model::PatchInstanceFilter>>()?
                                ;
                        }
                        __FieldTag::__patch_config => {
                            if !fields.insert(__FieldTag::__patch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_config",
                                ));
                            }
                            result.patch_config =
                                map.next_value::<std::option::Option<crate::model::PatchConfig>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<crate::model::PatchRollout>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetPatchJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPatchJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetPatchJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPatchJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListPatchJobInstanceDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobInstanceDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListPatchJobInstanceDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobInstanceDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListPatchJobInstanceDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_job_instance_details,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobInstanceDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchJobInstanceDetails" => {
                                Ok(__FieldTag::__patch_job_instance_details)
                            }
                            "patch_job_instance_details" => {
                                Ok(__FieldTag::__patch_job_instance_details)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListPatchJobInstanceDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobInstanceDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_job_instance_details => {
                            if !fields.insert(__FieldTag::__patch_job_instance_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_job_instance_details",
                                ));
                            }
                            result.patch_job_instance_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PatchJobInstanceDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchJobInstanceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance_system_id,
            __state,
            __failure_reason,
            __attempt_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchJobInstanceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instanceSystemId" => Ok(__FieldTag::__instance_system_id),
                            "instance_system_id" => Ok(__FieldTag::__instance_system_id),
                            "state" => Ok(__FieldTag::__state),
                            "failureReason" => Ok(__FieldTag::__failure_reason),
                            "failure_reason" => Ok(__FieldTag::__failure_reason),
                            "attemptCount" => Ok(__FieldTag::__attempt_count),
                            "attempt_count" => Ok(__FieldTag::__attempt_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchJobInstanceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchJobInstanceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_system_id => {
                            if !fields.insert(__FieldTag::__instance_system_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_system_id",
                                ));
                            }
                            result.instance_system_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::instance::PatchState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failure_reason => {
                            if !fields.insert(__FieldTag::__failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_reason",
                                ));
                            }
                            result.failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attempt_count => {
                            if !fields.insert(__FieldTag::__attempt_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempt_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attempt_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListPatchJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListPatchJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListPatchJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchJobs" => Ok(__FieldTag::__patch_jobs),
                            "patch_jobs" => Ok(__FieldTag::__patch_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListPatchJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_jobs => {
                            if !fields.insert(__FieldTag::__patch_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_jobs",
                                ));
                            }
                            result.patch_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PatchJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            __state,
            __instance_filter,
            __patch_config,
            __duration,
            __instance_details_summary,
            __dry_run,
            __error_message,
            __percent_complete,
            __patch_deployment,
            __rollout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "patchConfig" => Ok(__FieldTag::__patch_config),
                            "patch_config" => Ok(__FieldTag::__patch_config),
                            "duration" => Ok(__FieldTag::__duration),
                            "instanceDetailsSummary" => Ok(__FieldTag::__instance_details_summary),
                            "instance_details_summary" => {
                                Ok(__FieldTag::__instance_details_summary)
                            }
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "percentComplete" => Ok(__FieldTag::__percent_complete),
                            "percent_complete" => Ok(__FieldTag::__percent_complete),
                            "patchDeployment" => Ok(__FieldTag::__patch_deployment),
                            "patch_deployment" => Ok(__FieldTag::__patch_deployment),
                            "rollout" => Ok(__FieldTag::__rollout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::patch_job::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<crate::model::PatchInstanceFilter>>()?
                                ;
                        }
                        __FieldTag::__patch_config => {
                            if !fields.insert(__FieldTag::__patch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_config",
                                ));
                            }
                            result.patch_config =
                                map.next_value::<std::option::Option<crate::model::PatchConfig>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__instance_details_summary => {
                            if !fields.insert(__FieldTag::__instance_details_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_details_summary",
                                ));
                            }
                            result.instance_details_summary = map
                                .next_value::<std::option::Option<
                                    crate::model::patch_job::InstanceDetailsSummary,
                                >>()?;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__percent_complete => {
                            if !fields.insert(__FieldTag::__percent_complete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent_complete",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent_complete =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__patch_deployment => {
                            if !fields.insert(__FieldTag::__patch_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment",
                                ));
                            }
                            result.patch_deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<crate::model::PatchRollout>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::patch_job::InstanceDetailsSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pending_instance_count,
            __inactive_instance_count,
            __notified_instance_count,
            __started_instance_count,
            __downloading_patches_instance_count,
            __applying_patches_instance_count,
            __rebooting_instance_count,
            __succeeded_instance_count,
            __succeeded_reboot_required_instance_count,
            __failed_instance_count,
            __acked_instance_count,
            __timed_out_instance_count,
            __pre_patch_step_instance_count,
            __post_patch_step_instance_count,
            __no_agent_detected_instance_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceDetailsSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pendingInstanceCount" => Ok(__FieldTag::__pending_instance_count),
                            "pending_instance_count" => Ok(__FieldTag::__pending_instance_count),
                            "inactiveInstanceCount" => Ok(__FieldTag::__inactive_instance_count),
                            "inactive_instance_count" => Ok(__FieldTag::__inactive_instance_count),
                            "notifiedInstanceCount" => Ok(__FieldTag::__notified_instance_count),
                            "notified_instance_count" => Ok(__FieldTag::__notified_instance_count),
                            "startedInstanceCount" => Ok(__FieldTag::__started_instance_count),
                            "started_instance_count" => Ok(__FieldTag::__started_instance_count),
                            "downloadingPatchesInstanceCount" => {
                                Ok(__FieldTag::__downloading_patches_instance_count)
                            }
                            "downloading_patches_instance_count" => {
                                Ok(__FieldTag::__downloading_patches_instance_count)
                            }
                            "applyingPatchesInstanceCount" => {
                                Ok(__FieldTag::__applying_patches_instance_count)
                            }
                            "applying_patches_instance_count" => {
                                Ok(__FieldTag::__applying_patches_instance_count)
                            }
                            "rebootingInstanceCount" => Ok(__FieldTag::__rebooting_instance_count),
                            "rebooting_instance_count" => {
                                Ok(__FieldTag::__rebooting_instance_count)
                            }
                            "succeededInstanceCount" => Ok(__FieldTag::__succeeded_instance_count),
                            "succeeded_instance_count" => {
                                Ok(__FieldTag::__succeeded_instance_count)
                            }
                            "succeededRebootRequiredInstanceCount" => {
                                Ok(__FieldTag::__succeeded_reboot_required_instance_count)
                            }
                            "succeeded_reboot_required_instance_count" => {
                                Ok(__FieldTag::__succeeded_reboot_required_instance_count)
                            }
                            "failedInstanceCount" => Ok(__FieldTag::__failed_instance_count),
                            "failed_instance_count" => Ok(__FieldTag::__failed_instance_count),
                            "ackedInstanceCount" => Ok(__FieldTag::__acked_instance_count),
                            "acked_instance_count" => Ok(__FieldTag::__acked_instance_count),
                            "timedOutInstanceCount" => Ok(__FieldTag::__timed_out_instance_count),
                            "timed_out_instance_count" => {
                                Ok(__FieldTag::__timed_out_instance_count)
                            }
                            "prePatchStepInstanceCount" => {
                                Ok(__FieldTag::__pre_patch_step_instance_count)
                            }
                            "pre_patch_step_instance_count" => {
                                Ok(__FieldTag::__pre_patch_step_instance_count)
                            }
                            "postPatchStepInstanceCount" => {
                                Ok(__FieldTag::__post_patch_step_instance_count)
                            }
                            "post_patch_step_instance_count" => {
                                Ok(__FieldTag::__post_patch_step_instance_count)
                            }
                            "noAgentDetectedInstanceCount" => {
                                Ok(__FieldTag::__no_agent_detected_instance_count)
                            }
                            "no_agent_detected_instance_count" => {
                                Ok(__FieldTag::__no_agent_detected_instance_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::patch_job::InstanceDetailsSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceDetailsSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pending_instance_count => {
                            if !fields.insert(__FieldTag::__pending_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pending_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__inactive_instance_count => {
                            if !fields.insert(__FieldTag::__inactive_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inactive_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.inactive_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__notified_instance_count => {
                            if !fields.insert(__FieldTag::__notified_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notified_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.notified_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__started_instance_count => {
                            if !fields.insert(__FieldTag::__started_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for started_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.started_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__downloading_patches_instance_count => {
                            if !fields.insert(__FieldTag::__downloading_patches_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for downloading_patches_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.downloading_patches_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__applying_patches_instance_count => {
                            if !fields.insert(__FieldTag::__applying_patches_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applying_patches_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.applying_patches_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rebooting_instance_count => {
                            if !fields.insert(__FieldTag::__rebooting_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rebooting_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rebooting_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__succeeded_instance_count => {
                            if !fields.insert(__FieldTag::__succeeded_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for succeeded_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.succeeded_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__succeeded_reboot_required_instance_count => {
                            if !fields
                                .insert(__FieldTag::__succeeded_reboot_required_instance_count)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for succeeded_reboot_required_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.succeeded_reboot_required_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_instance_count => {
                            if !fields.insert(__FieldTag::__failed_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__acked_instance_count => {
                            if !fields.insert(__FieldTag::__acked_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acked_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.acked_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__timed_out_instance_count => {
                            if !fields.insert(__FieldTag::__timed_out_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timed_out_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.timed_out_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pre_patch_step_instance_count => {
                            if !fields.insert(__FieldTag::__pre_patch_step_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pre_patch_step_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pre_patch_step_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__post_patch_step_instance_count => {
                            if !fields.insert(__FieldTag::__post_patch_step_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_patch_step_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.post_patch_step_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__no_agent_detected_instance_count => {
                            if !fields.insert(__FieldTag::__no_agent_detected_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_agent_detected_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.no_agent_detected_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reboot_config,
            __apt,
            __yum,
            __goo,
            __zypper,
            __windows_update,
            __pre_step,
            __post_step,
            __mig_instances_allowed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rebootConfig" => Ok(__FieldTag::__reboot_config),
                            "reboot_config" => Ok(__FieldTag::__reboot_config),
                            "apt" => Ok(__FieldTag::__apt),
                            "yum" => Ok(__FieldTag::__yum),
                            "goo" => Ok(__FieldTag::__goo),
                            "zypper" => Ok(__FieldTag::__zypper),
                            "windowsUpdate" => Ok(__FieldTag::__windows_update),
                            "windows_update" => Ok(__FieldTag::__windows_update),
                            "preStep" => Ok(__FieldTag::__pre_step),
                            "pre_step" => Ok(__FieldTag::__pre_step),
                            "postStep" => Ok(__FieldTag::__post_step),
                            "post_step" => Ok(__FieldTag::__post_step),
                            "migInstancesAllowed" => Ok(__FieldTag::__mig_instances_allowed),
                            "mig_instances_allowed" => Ok(__FieldTag::__mig_instances_allowed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reboot_config => {
                            if !fields.insert(__FieldTag::__reboot_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reboot_config",
                                ));
                            }
                            result.reboot_config = map.next_value::<std::option::Option<crate::model::patch_config::RebootConfig>>()?.unwrap_or_default();
                        }
                        __FieldTag::__apt => {
                            if !fields.insert(__FieldTag::__apt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apt",
                                ));
                            }
                            result.apt =
                                map.next_value::<std::option::Option<crate::model::AptSettings>>()?;
                        }
                        __FieldTag::__yum => {
                            if !fields.insert(__FieldTag::__yum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yum",
                                ));
                            }
                            result.yum =
                                map.next_value::<std::option::Option<crate::model::YumSettings>>()?;
                        }
                        __FieldTag::__goo => {
                            if !fields.insert(__FieldTag::__goo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for goo",
                                ));
                            }
                            result.goo =
                                map.next_value::<std::option::Option<crate::model::GooSettings>>()?;
                        }
                        __FieldTag::__zypper => {
                            if !fields.insert(__FieldTag::__zypper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zypper",
                                ));
                            }
                            result.zypper = map
                                .next_value::<std::option::Option<crate::model::ZypperSettings>>(
                                )?;
                        }
                        __FieldTag::__windows_update => {
                            if !fields.insert(__FieldTag::__windows_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_update",
                                ));
                            }
                            result.windows_update = map.next_value::<std::option::Option<crate::model::WindowsUpdateSettings>>()?
                                ;
                        }
                        __FieldTag::__pre_step => {
                            if !fields.insert(__FieldTag::__pre_step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pre_step",
                                ));
                            }
                            result.pre_step =
                                map.next_value::<std::option::Option<crate::model::ExecStep>>()?;
                        }
                        __FieldTag::__post_step => {
                            if !fields.insert(__FieldTag::__post_step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_step",
                                ));
                            }
                            result.post_step =
                                map.next_value::<std::option::Option<crate::model::ExecStep>>()?;
                        }
                        __FieldTag::__mig_instances_allowed => {
                            if !fields.insert(__FieldTag::__mig_instances_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mig_instances_allowed",
                                ));
                            }
                            result.mig_instances_allowed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CancelPatchJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelPatchJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CancelPatchJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelPatchJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AptSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __excludes,
            __exclusive_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AptSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePackages" => Ok(__FieldTag::__exclusive_packages),
                            "exclusive_packages" => Ok(__FieldTag::__exclusive_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AptSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AptSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::apt_settings::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_packages => {
                            if !fields.insert(__FieldTag::__exclusive_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_packages",
                                ));
                            }
                            result.exclusive_packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::YumSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __security,
            __minimal,
            __excludes,
            __exclusive_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for YumSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "security" => Ok(__FieldTag::__security),
                            "minimal" => Ok(__FieldTag::__minimal),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePackages" => Ok(__FieldTag::__exclusive_packages),
                            "exclusive_packages" => Ok(__FieldTag::__exclusive_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::YumSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct YumSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__security => {
                            if !fields.insert(__FieldTag::__security) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security",
                                ));
                            }
                            result.security = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimal => {
                            if !fields.insert(__FieldTag::__minimal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimal",
                                ));
                            }
                            result.minimal = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_packages => {
                            if !fields.insert(__FieldTag::__exclusive_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_packages",
                                ));
                            }
                            result.exclusive_packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GooSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GooSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GooSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GooSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ZypperSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __with_optional,
            __with_update,
            __categories,
            __severities,
            __excludes,
            __exclusive_patches,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZypperSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "withOptional" => Ok(__FieldTag::__with_optional),
                            "with_optional" => Ok(__FieldTag::__with_optional),
                            "withUpdate" => Ok(__FieldTag::__with_update),
                            "with_update" => Ok(__FieldTag::__with_update),
                            "categories" => Ok(__FieldTag::__categories),
                            "severities" => Ok(__FieldTag::__severities),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePatches" => Ok(__FieldTag::__exclusive_patches),
                            "exclusive_patches" => Ok(__FieldTag::__exclusive_patches),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ZypperSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZypperSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__with_optional => {
                            if !fields.insert(__FieldTag::__with_optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for with_optional",
                                ));
                            }
                            result.with_optional = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__with_update => {
                            if !fields.insert(__FieldTag::__with_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for with_update",
                                ));
                            }
                            result.with_update = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severities => {
                            if !fields.insert(__FieldTag::__severities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severities",
                                ));
                            }
                            result.severities = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_patches => {
                            if !fields.insert(__FieldTag::__exclusive_patches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_patches",
                                ));
                            }
                            result.exclusive_patches = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WindowsUpdateSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __classifications,
            __excludes,
            __exclusive_patches,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsUpdateSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "classifications" => Ok(__FieldTag::__classifications),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePatches" => Ok(__FieldTag::__exclusive_patches),
                            "exclusive_patches" => Ok(__FieldTag::__exclusive_patches),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WindowsUpdateSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsUpdateSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__classifications => {
                            if !fields.insert(__FieldTag::__classifications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classifications",
                                ));
                            }
                            result.classifications = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::windows_update_settings::Classification,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_patches => {
                            if !fields.insert(__FieldTag::__exclusive_patches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_patches",
                                ));
                            }
                            result.exclusive_patches = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExecStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __linux_exec_step_config,
            __windows_exec_step_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linuxExecStepConfig" => Ok(__FieldTag::__linux_exec_step_config),
                            "linux_exec_step_config" => Ok(__FieldTag::__linux_exec_step_config),
                            "windowsExecStepConfig" => Ok(__FieldTag::__windows_exec_step_config),
                            "windows_exec_step_config" => {
                                Ok(__FieldTag::__windows_exec_step_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExecStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__linux_exec_step_config => {
                            if !fields.insert(__FieldTag::__linux_exec_step_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_exec_step_config",
                                ));
                            }
                            result.linux_exec_step_config = map
                                .next_value::<std::option::Option<crate::model::ExecStepConfig>>(
                                )?;
                        }
                        __FieldTag::__windows_exec_step_config => {
                            if !fields.insert(__FieldTag::__windows_exec_step_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_exec_step_config",
                                ));
                            }
                            result.windows_exec_step_config = map
                                .next_value::<std::option::Option<crate::model::ExecStepConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExecStepConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_path,
            __gcs_object,
            __allowed_success_codes,
            __interpreter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecStepConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localPath" => Ok(__FieldTag::__local_path),
                            "local_path" => Ok(__FieldTag::__local_path),
                            "gcsObject" => Ok(__FieldTag::__gcs_object),
                            "gcs_object" => Ok(__FieldTag::__gcs_object),
                            "allowedSuccessCodes" => Ok(__FieldTag::__allowed_success_codes),
                            "allowed_success_codes" => Ok(__FieldTag::__allowed_success_codes),
                            "interpreter" => Ok(__FieldTag::__interpreter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExecStepConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecStepConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_path => {
                            if !fields.insert(__FieldTag::__local_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_path",
                                ));
                            }
                            if result.executable.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `executable`, a oneof with full ID .google.cloud.osconfig.v1.ExecStepConfig.local_path, latest field was localPath",
                                ));
                            }
                            result.executable = std::option::Option::Some(
                                crate::model::exec_step_config::Executable::LocalPath(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_object => {
                            if !fields.insert(__FieldTag::__gcs_object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_object",
                                ));
                            }
                            if result.executable.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `executable`, a oneof with full ID .google.cloud.osconfig.v1.ExecStepConfig.gcs_object, latest field was gcsObject",
                                ));
                            }
                            result.executable = std::option::Option::Some(
                                crate::model::exec_step_config::Executable::GcsObject(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsObject>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__allowed_success_codes => {
                            if !fields.insert(__FieldTag::__allowed_success_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_success_codes",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allowed_success_codes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__interpreter => {
                            if !fields.insert(__FieldTag::__interpreter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interpreter",
                                ));
                            }
                            result.interpreter =
                                map.next_value::<std::option::Option<
                                    crate::model::exec_step_config::Interpreter,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsObject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsObject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generationNumber" => Ok(__FieldTag::__generation_number),
                            "generation_number" => Ok(__FieldTag::__generation_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsObject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsObject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation_number => {
                            if !fields.insert(__FieldTag::__generation_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_number",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchInstanceFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all,
            __group_labels,
            __zones,
            __instances,
            __instance_name_prefixes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchInstanceFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "all" => Ok(__FieldTag::__all),
                            "groupLabels" => Ok(__FieldTag::__group_labels),
                            "group_labels" => Ok(__FieldTag::__group_labels),
                            "zones" => Ok(__FieldTag::__zones),
                            "instances" => Ok(__FieldTag::__instances),
                            "instanceNamePrefixes" => Ok(__FieldTag::__instance_name_prefixes),
                            "instance_name_prefixes" => Ok(__FieldTag::__instance_name_prefixes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchInstanceFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchInstanceFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all => {
                            if !fields.insert(__FieldTag::__all) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all",
                                ));
                            }
                            result.all = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_labels => {
                            if !fields.insert(__FieldTag::__group_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_labels",
                                ));
                            }
                            result.group_labels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::patch_instance_filter::GroupLabel>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zones => {
                            if !fields.insert(__FieldTag::__zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zones",
                                ));
                            }
                            result.zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_name_prefixes => {
                            if !fields.insert(__FieldTag::__instance_name_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_name_prefixes",
                                ));
                            }
                            result.instance_name_prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::patch_instance_filter::GroupLabel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GroupLabel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::patch_instance_filter::GroupLabel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GroupLabel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchRollout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __disruption_budget,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchRollout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "disruptionBudget" => Ok(__FieldTag::__disruption_budget),
                            "disruption_budget" => Ok(__FieldTag::__disruption_budget),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchRollout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchRollout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::patch_rollout::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disruption_budget => {
                            if !fields.insert(__FieldTag::__disruption_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disruption_budget",
                                ));
                            }
                            result.disruption_budget = map
                                .next_value::<std::option::Option<crate::model::FixedOrPercent>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VulnerabilityReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __vulnerabilities,
            __update_time,
            __highest_upgradable_cve_severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "vulnerabilities" => Ok(__FieldTag::__vulnerabilities),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "highestUpgradableCveSeverity" => {
                                Ok(__FieldTag::__highest_upgradable_cve_severity)
                            }
                            "highest_upgradable_cve_severity" => {
                                Ok(__FieldTag::__highest_upgradable_cve_severity)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VulnerabilityReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vulnerabilities => {
                            if !fields.insert(__FieldTag::__vulnerabilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerabilities",
                                ));
                            }
                            result.vulnerabilities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::vulnerability_report::Vulnerability,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__highest_upgradable_cve_severity => {
                            if !fields.insert(__FieldTag::__highest_upgradable_cve_severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for highest_upgradable_cve_severity",
                                ));
                            }
                            result.highest_upgradable_cve_severity = map
                                .next_value::<std::option::Option<
                                    crate::model::vulnerability_report::VulnerabilitySeverityLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_report::Vulnerability {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            __installed_inventory_item_ids,
            __available_inventory_item_ids,
            __create_time,
            __update_time,
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Vulnerability")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            "installedInventoryItemIds" => {
                                Ok(__FieldTag::__installed_inventory_item_ids)
                            }
                            "installed_inventory_item_ids" => {
                                Ok(__FieldTag::__installed_inventory_item_ids)
                            }
                            "availableInventoryItemIds" => {
                                Ok(__FieldTag::__available_inventory_item_ids)
                            }
                            "available_inventory_item_ids" => {
                                Ok(__FieldTag::__available_inventory_item_ids)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_report::Vulnerability;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Vulnerability")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map.next_value::<std::option::Option<
                                crate::model::vulnerability_report::vulnerability::Details,
                            >>()?;
                        }
                        __FieldTag::__installed_inventory_item_ids => {
                            if !fields.insert(__FieldTag::__installed_inventory_item_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installed_inventory_item_ids",
                                ));
                            }
                            result.installed_inventory_item_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__available_inventory_item_ids => {
                            if !fields.insert(__FieldTag::__available_inventory_item_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_inventory_item_ids",
                                ));
                            }
                            result.available_inventory_item_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::vulnerability_report::vulnerability::Item,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_report::vulnerability::Details {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cve,
            __cvss_v2_score,
            __cvss_v3,
            __severity,
            __description,
            __references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Details")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cve" => Ok(__FieldTag::__cve),
                            "cvssV2Score" => Ok(__FieldTag::__cvss_v2_score),
                            "cvss_v2_score" => Ok(__FieldTag::__cvss_v2_score),
                            "cvssV3" => Ok(__FieldTag::__cvss_v3),
                            "cvss_v3" => Ok(__FieldTag::__cvss_v3),
                            "severity" => Ok(__FieldTag::__severity),
                            "description" => Ok(__FieldTag::__description),
                            "references" => Ok(__FieldTag::__references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_report::vulnerability::Details;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Details")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cve => {
                            if !fields.insert(__FieldTag::__cve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve",
                                ));
                            }
                            result.cve = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cvss_v2_score => {
                            if !fields.insert(__FieldTag::__cvss_v2_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v2_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cvss_v2_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cvss_v3 => {
                            if !fields.insert(__FieldTag::__cvss_v3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvss_v3",
                                ));
                            }
                            result.cvss_v3 =
                                map.next_value::<std::option::Option<crate::model::CVSSv3>>()?;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_report::vulnerability::details::Reference>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::vulnerability_report::vulnerability::details::Reference
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Reference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_report::vulnerability::details::Reference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Reference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vulnerability_report::vulnerability::Item {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __installed_inventory_item_id,
            __available_inventory_item_id,
            __fixed_cpe_uri,
            __upstream_fix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Item")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "installedInventoryItemId" => {
                                Ok(__FieldTag::__installed_inventory_item_id)
                            }
                            "installed_inventory_item_id" => {
                                Ok(__FieldTag::__installed_inventory_item_id)
                            }
                            "availableInventoryItemId" => {
                                Ok(__FieldTag::__available_inventory_item_id)
                            }
                            "available_inventory_item_id" => {
                                Ok(__FieldTag::__available_inventory_item_id)
                            }
                            "fixedCpeUri" => Ok(__FieldTag::__fixed_cpe_uri),
                            "fixed_cpe_uri" => Ok(__FieldTag::__fixed_cpe_uri),
                            "upstreamFix" => Ok(__FieldTag::__upstream_fix),
                            "upstream_fix" => Ok(__FieldTag::__upstream_fix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vulnerability_report::vulnerability::Item;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Item")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__installed_inventory_item_id => {
                            if !fields.insert(__FieldTag::__installed_inventory_item_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installed_inventory_item_id",
                                ));
                            }
                            result.installed_inventory_item_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_inventory_item_id => {
                            if !fields.insert(__FieldTag::__available_inventory_item_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_inventory_item_id",
                                ));
                            }
                            result.available_inventory_item_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fixed_cpe_uri => {
                            if !fields.insert(__FieldTag::__fixed_cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_cpe_uri",
                                ));
                            }
                            result.fixed_cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upstream_fix => {
                            if !fields.insert(__FieldTag::__upstream_fix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upstream_fix",
                                ));
                            }
                            result.upstream_fix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetVulnerabilityReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVulnerabilityReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetVulnerabilityReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVulnerabilityReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVulnerabilityReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVulnerabilityReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVulnerabilityReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVulnerabilityReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVulnerabilityReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vulnerability_reports,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVulnerabilityReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vulnerabilityReports" => Ok(__FieldTag::__vulnerability_reports),
                            "vulnerability_reports" => Ok(__FieldTag::__vulnerability_reports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVulnerabilityReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVulnerabilityReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vulnerability_reports => {
                            if !fields.insert(__FieldTag::__vulnerability_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_reports",
                                ));
                            }
                            result.vulnerability_reports = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VulnerabilityReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CVSSv3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __exploitability_score,
            __impact_score,
            __attack_vector,
            __attack_complexity,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CVSSv3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "exploitabilityScore" => Ok(__FieldTag::__exploitability_score),
                            "exploitability_score" => Ok(__FieldTag::__exploitability_score),
                            "impactScore" => Ok(__FieldTag::__impact_score),
                            "impact_score" => Ok(__FieldTag::__impact_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CVSSv3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CVSSv3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exploitability_score => {
                            if !fields.insert(__FieldTag::__exploitability_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitability_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exploitability_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact_score => {
                            if !fields.insert(__FieldTag::__impact_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.impact_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvs_sv_3::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvs_sv_3::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
