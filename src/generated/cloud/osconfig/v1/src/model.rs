// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// This API resource represents the available inventory data for a
/// Compute Engine virtual machine (VM) instance at a given point in time.
///
/// You can use this API resource to determine the inventory data of your VM.
///
/// For more information, see [Information provided by OS inventory
/// management](https://cloud.google.com/compute/docs/instances/os-inventory-management#data-collected).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Inventory {
    /// Output only. The `Inventory` API resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/instances/{instance_id}/inventory`
    pub name: std::string::String,

    /// Base level operating system information for the VM.
    pub os_info: std::option::Option<crate::model::inventory::OsInfo>,

    /// Inventory items related to the VM keyed by an opaque unique identifier for
    /// each inventory item.  The identifier is unique to each distinct and
    /// addressable inventory item and will change, when there is a new package
    /// version.
    pub items: std::collections::HashMap<std::string::String, crate::model::inventory::Item>,

    /// Output only. Timestamp of the last reported inventory for the VM.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Inventory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Inventory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [os_info][crate::model::Inventory::os_info].
    pub fn set_os_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::inventory::OsInfo>,
    {
        self.os_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [os_info][crate::model::Inventory::os_info].
    pub fn set_or_clear_os_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::inventory::OsInfo>,
    {
        self.os_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::Inventory::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::inventory::Item>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::Inventory::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Inventory::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Inventory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.Inventory"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Inventory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __os_info,
            __items,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Inventory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "osInfo" => Ok(__FieldTag::__os_info),
                            "os_info" => Ok(__FieldTag::__os_info),
                            "items" => Ok(__FieldTag::__items),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Inventory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Inventory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_info => {
                            if !fields.insert(__FieldTag::__os_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_info",
                                ));
                            }
                            result.os_info = map
                                .next_value::<std::option::Option<crate::model::inventory::OsInfo>>(
                                )?;
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::inventory::Item,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Inventory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.os_info.is_some() {
            state.serialize_entry("osInfo", &self.os_info)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Inventory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Inventory");
        debug_struct.field("name", &self.name);
        debug_struct.field("os_info", &self.os_info);
        debug_struct.field("items", &self.items);
        debug_struct.field("update_time", &self.update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Inventory].
pub mod inventory {
    #[allow(unused_imports)]
    use super::*;

    /// Operating system information for the VM.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OsInfo {
        /// The VM hostname.
        pub hostname: std::string::String,

        /// The operating system long name.
        /// For example 'Debian GNU/Linux 9' or 'Microsoft Window Server 2019
        /// Datacenter'.
        pub long_name: std::string::String,

        /// The operating system short name.
        /// For example, 'windows' or 'debian'.
        pub short_name: std::string::String,

        /// The version of the operating system.
        pub version: std::string::String,

        /// The system architecture of the operating system.
        pub architecture: std::string::String,

        /// The kernel version of the operating system.
        pub kernel_version: std::string::String,

        /// The kernel release of the operating system.
        pub kernel_release: std::string::String,

        /// The current version of the OS Config agent running on the VM.
        pub osconfig_agent_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OsInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hostname][crate::model::inventory::OsInfo::hostname].
        pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.hostname = v.into();
            self
        }

        /// Sets the value of [long_name][crate::model::inventory::OsInfo::long_name].
        pub fn set_long_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.long_name = v.into();
            self
        }

        /// Sets the value of [short_name][crate::model::inventory::OsInfo::short_name].
        pub fn set_short_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.short_name = v.into();
            self
        }

        /// Sets the value of [version][crate::model::inventory::OsInfo::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }

        /// Sets the value of [architecture][crate::model::inventory::OsInfo::architecture].
        pub fn set_architecture<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.architecture = v.into();
            self
        }

        /// Sets the value of [kernel_version][crate::model::inventory::OsInfo::kernel_version].
        pub fn set_kernel_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kernel_version = v.into();
            self
        }

        /// Sets the value of [kernel_release][crate::model::inventory::OsInfo::kernel_release].
        pub fn set_kernel_release<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kernel_release = v.into();
            self
        }

        /// Sets the value of [osconfig_agent_version][crate::model::inventory::OsInfo::osconfig_agent_version].
        pub fn set_osconfig_agent_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.osconfig_agent_version = v.into();
            self
        }
    }

    impl wkt::message::Message for OsInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.OsInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OsInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __hostname,
                __long_name,
                __short_name,
                __version,
                __architecture,
                __kernel_version,
                __kernel_release,
                __osconfig_agent_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OsInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "hostname" => Ok(__FieldTag::__hostname),
                                "longName" => Ok(__FieldTag::__long_name),
                                "long_name" => Ok(__FieldTag::__long_name),
                                "shortName" => Ok(__FieldTag::__short_name),
                                "short_name" => Ok(__FieldTag::__short_name),
                                "version" => Ok(__FieldTag::__version),
                                "architecture" => Ok(__FieldTag::__architecture),
                                "kernelVersion" => Ok(__FieldTag::__kernel_version),
                                "kernel_version" => Ok(__FieldTag::__kernel_version),
                                "kernelRelease" => Ok(__FieldTag::__kernel_release),
                                "kernel_release" => Ok(__FieldTag::__kernel_release),
                                "osconfigAgentVersion" => Ok(__FieldTag::__osconfig_agent_version),
                                "osconfig_agent_version" => {
                                    Ok(__FieldTag::__osconfig_agent_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OsInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OsInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__hostname => {
                                if !fields.insert(__FieldTag::__hostname) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hostname",
                                    ));
                                }
                                result.hostname = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__long_name => {
                                if !fields.insert(__FieldTag::__long_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for long_name",
                                    ));
                                }
                                result.long_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__short_name => {
                                if !fields.insert(__FieldTag::__short_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for short_name",
                                    ));
                                }
                                result.short_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__architecture => {
                                if !fields.insert(__FieldTag::__architecture) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for architecture",
                                    ));
                                }
                                result.architecture = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kernel_version => {
                                if !fields.insert(__FieldTag::__kernel_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kernel_version",
                                    ));
                                }
                                result.kernel_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kernel_release => {
                                if !fields.insert(__FieldTag::__kernel_release) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kernel_release",
                                    ));
                                }
                                result.kernel_release = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__osconfig_agent_version => {
                                if !fields.insert(__FieldTag::__osconfig_agent_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for osconfig_agent_version",
                                    ));
                                }
                                result.osconfig_agent_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OsInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.hostname.is_empty() {
                state.serialize_entry("hostname", &self.hostname)?;
            }
            if !self.long_name.is_empty() {
                state.serialize_entry("longName", &self.long_name)?;
            }
            if !self.short_name.is_empty() {
                state.serialize_entry("shortName", &self.short_name)?;
            }
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self.architecture.is_empty() {
                state.serialize_entry("architecture", &self.architecture)?;
            }
            if !self.kernel_version.is_empty() {
                state.serialize_entry("kernelVersion", &self.kernel_version)?;
            }
            if !self.kernel_release.is_empty() {
                state.serialize_entry("kernelRelease", &self.kernel_release)?;
            }
            if !self.osconfig_agent_version.is_empty() {
                state.serialize_entry("osconfigAgentVersion", &self.osconfig_agent_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OsInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OsInfo");
            debug_struct.field("hostname", &self.hostname);
            debug_struct.field("long_name", &self.long_name);
            debug_struct.field("short_name", &self.short_name);
            debug_struct.field("version", &self.version);
            debug_struct.field("architecture", &self.architecture);
            debug_struct.field("kernel_version", &self.kernel_version);
            debug_struct.field("kernel_release", &self.kernel_release);
            debug_struct.field("osconfig_agent_version", &self.osconfig_agent_version);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A single piece of inventory on a VM.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Item {
        /// Identifier for this item, unique across items for this VM.
        pub id: std::string::String,

        /// The origin of this inventory item.
        pub origin_type: crate::model::inventory::item::OriginType,

        /// When this inventory item was first detected.
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// When this inventory item was last modified.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// The specific type of inventory, correlating to its specific details.
        pub r#type: crate::model::inventory::item::Type,

        /// Specific details of this inventory item based on its type.
        pub details: std::option::Option<crate::model::inventory::item::Details>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Item {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::inventory::Item::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [origin_type][crate::model::inventory::Item::origin_type].
        pub fn set_origin_type<T: std::convert::Into<crate::model::inventory::item::OriginType>>(
            mut self,
            v: T,
        ) -> Self {
            self.origin_type = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::inventory::Item::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::inventory::Item::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [update_time][crate::model::inventory::Item::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::inventory::Item::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [r#type][crate::model::inventory::Item::type].
        pub fn set_type<T: std::convert::Into<crate::model::inventory::item::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [details][crate::model::inventory::Item::details].
        ///
        /// Note that all the setters affecting `details` are mutually
        /// exclusive.
        pub fn set_details<
            T: std::convert::Into<std::option::Option<crate::model::inventory::item::Details>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = v.into();
            self
        }

        /// The value of [details][crate::model::inventory::Item::details]
        /// if it holds a `InstalledPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn installed_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::SoftwarePackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::item::Details::InstalledPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::Item::details]
        /// to hold a `InstalledPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_installed_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::SoftwarePackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::item::Details::InstalledPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::Item::details]
        /// if it holds a `AvailablePackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn available_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::SoftwarePackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::item::Details::AvailablePackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::Item::details]
        /// to hold a `AvailablePackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_available_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::SoftwarePackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::item::Details::AvailablePackage(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Item {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.Item"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Item {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __origin_type,
                __create_time,
                __update_time,
                __type,
                __installed_package,
                __available_package,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Item")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "originType" => Ok(__FieldTag::__origin_type),
                                "origin_type" => Ok(__FieldTag::__origin_type),
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "type" => Ok(__FieldTag::__type),
                                "installedPackage" => Ok(__FieldTag::__installed_package),
                                "installed_package" => Ok(__FieldTag::__installed_package),
                                "availablePackage" => Ok(__FieldTag::__available_package),
                                "available_package" => Ok(__FieldTag::__available_package),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Item;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Item")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__origin_type => {
                                if !fields.insert(__FieldTag::__origin_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for origin_type",
                                    ));
                                }
                                result.origin_type =
                                    map.next_value::<std::option::Option<
                                        crate::model::inventory::item::OriginType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map.next_value::<std::option::Option<crate::model::inventory::item::Type>>()?.unwrap_or_default();
                            }
                            __FieldTag::__installed_package => {
                                if !fields.insert(__FieldTag::__installed_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for installed_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.Item.installed_package, latest field was installedPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::item::Details::InstalledPackage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::inventory::SoftwarePackage,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__available_package => {
                                if !fields.insert(__FieldTag::__available_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for available_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.Item.available_package, latest field was availablePackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::item::Details::AvailablePackage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::inventory::SoftwarePackage,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Item {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !wkt::internal::is_default(&self.origin_type) {
                state.serialize_entry("originType", &self.origin_type)?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if let Some(value) = self.installed_package() {
                state.serialize_entry("installedPackage", value)?;
            }
            if let Some(value) = self.available_package() {
                state.serialize_entry("availablePackage", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Item {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Item");
            debug_struct.field("id", &self.id);
            debug_struct.field("origin_type", &self.origin_type);
            debug_struct.field("create_time", &self.create_time);
            debug_struct.field("update_time", &self.update_time);
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("details", &self.details);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Item].
    pub mod item {
        #[allow(unused_imports)]
        use super::*;

        /// The origin of a specific inventory item.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum OriginType {
            /// Invalid. An origin type must be specified.
            Unspecified,
            /// This inventory item was discovered as the result of the agent
            /// reporting inventory via the reporting API.
            InventoryReport,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [OriginType::value] or
            /// [OriginType::name].
            UnknownValue(origin_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod origin_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl OriginType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::InventoryReport => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ORIGIN_TYPE_UNSPECIFIED"),
                    Self::InventoryReport => std::option::Option::Some("INVENTORY_REPORT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for OriginType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for OriginType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for OriginType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::InventoryReport,
                    _ => Self::UnknownValue(origin_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for OriginType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ORIGIN_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "INVENTORY_REPORT" => Self::InventoryReport,
                    _ => Self::UnknownValue(origin_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for OriginType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::InventoryReport => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for OriginType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<OriginType>::new(
                    ".google.cloud.osconfig.v1.Inventory.Item.OriginType",
                ))
            }
        }

        /// The different types of inventory that are tracked on a VM.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Invalid. An type must be specified.
            Unspecified,
            /// This represents a package that is installed on the VM.
            InstalledPackage,
            /// This represents an update that is available for a package.
            AvailablePackage,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::InstalledPackage => std::option::Option::Some(1),
                    Self::AvailablePackage => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::InstalledPackage => std::option::Option::Some("INSTALLED_PACKAGE"),
                    Self::AvailablePackage => std::option::Option::Some("AVAILABLE_PACKAGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::InstalledPackage,
                    2 => Self::AvailablePackage,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "INSTALLED_PACKAGE" => Self::InstalledPackage,
                    "AVAILABLE_PACKAGE" => Self::AvailablePackage,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::InstalledPackage => serializer.serialize_i32(1),
                    Self::AvailablePackage => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.osconfig.v1.Inventory.Item.Type",
                ))
            }
        }

        /// Specific details of this inventory item based on its type.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Details {
            /// Software package present on the VM instance.
            InstalledPackage(std::boxed::Box<crate::model::inventory::SoftwarePackage>),
            /// Software package available to be installed on the VM instance.
            AvailablePackage(std::boxed::Box<crate::model::inventory::SoftwarePackage>),
        }
    }

    /// Software package information of the operating system.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SoftwarePackage {
        /// Information about the different types of software packages.
        pub details: std::option::Option<crate::model::inventory::software_package::Details>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SoftwarePackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details].
        ///
        /// Note that all the setters affecting `details` are mutually
        /// exclusive.
        pub fn set_details<
            T: std::convert::Into<
                    std::option::Option<crate::model::inventory::software_package::Details>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = v.into();
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `YumPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn yum_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::YumPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `YumPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_yum_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::YumPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `AptPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn apt_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::AptPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `AptPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_apt_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::AptPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `ZypperPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn zypper_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::ZypperPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `ZypperPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_zypper_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::ZypperPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `GoogetPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn googet_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::GoogetPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `GoogetPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_googet_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::GoogetPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `ZypperPatch`, `None` if the field is not set or
        /// holds a different branch.
        pub fn zypper_patch(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::ZypperPatch>> {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::ZypperPatch(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `ZypperPatch`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_zypper_patch<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::ZypperPatch>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::ZypperPatch(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `WuaPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn wua_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::WindowsUpdatePackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::WuaPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `WuaPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_wua_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::WindowsUpdatePackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::WuaPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `QfePackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn qfe_package(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>,
        > {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::QfePackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `QfePackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_qfe_package<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::QfePackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `CosPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cos_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::CosPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `CosPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_cos_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::CosPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `WindowsApplication`, `None` if the field is not set or
        /// holds a different branch.
        pub fn windows_application(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::WindowsApplication>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::WindowsApplication(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `WindowsApplication`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_windows_application<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::WindowsApplication>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::WindowsApplication(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SoftwarePackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.SoftwarePackage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SoftwarePackage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __yum_package,
                __apt_package,
                __zypper_package,
                __googet_package,
                __zypper_patch,
                __wua_package,
                __qfe_package,
                __cos_package,
                __windows_application,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SoftwarePackage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "yumPackage" => Ok(__FieldTag::__yum_package),
                                "yum_package" => Ok(__FieldTag::__yum_package),
                                "aptPackage" => Ok(__FieldTag::__apt_package),
                                "apt_package" => Ok(__FieldTag::__apt_package),
                                "zypperPackage" => Ok(__FieldTag::__zypper_package),
                                "zypper_package" => Ok(__FieldTag::__zypper_package),
                                "googetPackage" => Ok(__FieldTag::__googet_package),
                                "googet_package" => Ok(__FieldTag::__googet_package),
                                "zypperPatch" => Ok(__FieldTag::__zypper_patch),
                                "zypper_patch" => Ok(__FieldTag::__zypper_patch),
                                "wuaPackage" => Ok(__FieldTag::__wua_package),
                                "wua_package" => Ok(__FieldTag::__wua_package),
                                "qfePackage" => Ok(__FieldTag::__qfe_package),
                                "qfe_package" => Ok(__FieldTag::__qfe_package),
                                "cosPackage" => Ok(__FieldTag::__cos_package),
                                "cos_package" => Ok(__FieldTag::__cos_package),
                                "windowsApplication" => Ok(__FieldTag::__windows_application),
                                "windows_application" => Ok(__FieldTag::__windows_application),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SoftwarePackage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SoftwarePackage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__yum_package => {
                                if !fields.insert(__FieldTag::__yum_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for yum_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.yum_package, latest field was yumPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::YumPackage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::inventory::VersionedPackage,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__apt_package => {
                                if !fields.insert(__FieldTag::__apt_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for apt_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.apt_package, latest field was aptPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::AptPackage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::inventory::VersionedPackage,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__zypper_package => {
                                if !fields.insert(__FieldTag::__zypper_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for zypper_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.zypper_package, latest field was zypperPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::ZypperPackage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::inventory::VersionedPackage>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__googet_package => {
                                if !fields.insert(__FieldTag::__googet_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for googet_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.googet_package, latest field was googetPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::GoogetPackage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::inventory::VersionedPackage>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__zypper_patch => {
                                if !fields.insert(__FieldTag::__zypper_patch) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for zypper_patch",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.zypper_patch, latest field was zypperPatch",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::ZypperPatch(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::inventory::ZypperPatch>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__wua_package => {
                                if !fields.insert(__FieldTag::__wua_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for wua_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.wua_package, latest field was wuaPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::WuaPackage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::inventory::WindowsUpdatePackage,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__qfe_package => {
                                if !fields.insert(__FieldTag::__qfe_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qfe_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.qfe_package, latest field was qfePackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::QfePackage(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__cos_package => {
                                if !fields.insert(__FieldTag::__cos_package) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cos_package",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.cos_package, latest field was cosPackage",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::CosPackage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::inventory::VersionedPackage,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__windows_application => {
                                if !fields.insert(__FieldTag::__windows_application) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for windows_application",
                                    ));
                                }
                                if result.details.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `details`, a oneof with full ID .google.cloud.osconfig.v1.Inventory.SoftwarePackage.windows_application, latest field was windowsApplication",
                                    ));
                                }
                                result.details = std::option::Option::Some(
                                    crate::model::inventory::software_package::Details::WindowsApplication(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::inventory::WindowsApplication>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SoftwarePackage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.yum_package() {
                state.serialize_entry("yumPackage", value)?;
            }
            if let Some(value) = self.apt_package() {
                state.serialize_entry("aptPackage", value)?;
            }
            if let Some(value) = self.zypper_package() {
                state.serialize_entry("zypperPackage", value)?;
            }
            if let Some(value) = self.googet_package() {
                state.serialize_entry("googetPackage", value)?;
            }
            if let Some(value) = self.zypper_patch() {
                state.serialize_entry("zypperPatch", value)?;
            }
            if let Some(value) = self.wua_package() {
                state.serialize_entry("wuaPackage", value)?;
            }
            if let Some(value) = self.qfe_package() {
                state.serialize_entry("qfePackage", value)?;
            }
            if let Some(value) = self.cos_package() {
                state.serialize_entry("cosPackage", value)?;
            }
            if let Some(value) = self.windows_application() {
                state.serialize_entry("windowsApplication", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SoftwarePackage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SoftwarePackage");
            debug_struct.field("details", &self.details);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [SoftwarePackage].
    pub mod software_package {
        #[allow(unused_imports)]
        use super::*;

        /// Information about the different types of software packages.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Details {
            /// Yum package info.
            /// For details about the yum package manager, see
            /// <https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum>.
            YumPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of an APT package.
            /// For details about the apt package manager, see
            /// <https://wiki.debian.org/Apt>.
            AptPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of a Zypper package.
            /// For details about the Zypper package manager, see
            /// <https://en.opensuse.org/SDB:Zypper_manual>.
            ZypperPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of a Googet package.
            /// For details about the googet package manager, see
            /// <https://github.com/google/googet>.
            GoogetPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of a Zypper patch.
            /// For details about the Zypper package manager, see
            /// <https://en.opensuse.org/SDB:Zypper_manual>.
            ZypperPatch(std::boxed::Box<crate::model::inventory::ZypperPatch>),
            /// Details of a Windows Update package.
            /// See <https://docs.microsoft.com/en-us/windows/win32/api/_wua/> for
            /// information about Windows Update.
            WuaPackage(std::boxed::Box<crate::model::inventory::WindowsUpdatePackage>),
            /// Details of a Windows Quick Fix engineering package.
            /// See
            /// <https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering>
            /// for info in Windows Quick Fix Engineering.
            QfePackage(std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>),
            /// Details of a COS package.
            CosPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of Windows Application.
            WindowsApplication(std::boxed::Box<crate::model::inventory::WindowsApplication>),
        }
    }

    /// Information related to the a standard versioned package.  This includes
    /// package info for APT, Yum, Zypper, and Googet package managers.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VersionedPackage {
        /// The name of the package.
        pub package_name: std::string::String,

        /// The system architecture this package is intended for.
        pub architecture: std::string::String,

        /// The version of the package.
        pub version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VersionedPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [package_name][crate::model::inventory::VersionedPackage::package_name].
        pub fn set_package_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_name = v.into();
            self
        }

        /// Sets the value of [architecture][crate::model::inventory::VersionedPackage::architecture].
        pub fn set_architecture<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.architecture = v.into();
            self
        }

        /// Sets the value of [version][crate::model::inventory::VersionedPackage::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for VersionedPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.VersionedPackage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VersionedPackage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __package_name,
                __architecture,
                __version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VersionedPackage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "packageName" => Ok(__FieldTag::__package_name),
                                "package_name" => Ok(__FieldTag::__package_name),
                                "architecture" => Ok(__FieldTag::__architecture),
                                "version" => Ok(__FieldTag::__version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VersionedPackage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VersionedPackage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__package_name => {
                                if !fields.insert(__FieldTag::__package_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for package_name",
                                    ));
                                }
                                result.package_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__architecture => {
                                if !fields.insert(__FieldTag::__architecture) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for architecture",
                                    ));
                                }
                                result.architecture = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VersionedPackage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.package_name.is_empty() {
                state.serialize_entry("packageName", &self.package_name)?;
            }
            if !self.architecture.is_empty() {
                state.serialize_entry("architecture", &self.architecture)?;
            }
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for VersionedPackage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("VersionedPackage");
            debug_struct.field("package_name", &self.package_name);
            debug_struct.field("architecture", &self.architecture);
            debug_struct.field("version", &self.version);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Details related to a Zypper Patch.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ZypperPatch {
        /// The name of the patch.
        pub patch_name: std::string::String,

        /// The category of the patch.
        pub category: std::string::String,

        /// The severity specified for this patch
        pub severity: std::string::String,

        /// Any summary information provided about this patch.
        pub summary: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ZypperPatch {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [patch_name][crate::model::inventory::ZypperPatch::patch_name].
        pub fn set_patch_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.patch_name = v.into();
            self
        }

        /// Sets the value of [category][crate::model::inventory::ZypperPatch::category].
        pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.category = v.into();
            self
        }

        /// Sets the value of [severity][crate::model::inventory::ZypperPatch::severity].
        pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.severity = v.into();
            self
        }

        /// Sets the value of [summary][crate::model::inventory::ZypperPatch::summary].
        pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.summary = v.into();
            self
        }
    }

    impl wkt::message::Message for ZypperPatch {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.ZypperPatch"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ZypperPatch {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __patch_name,
                __category,
                __severity,
                __summary,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ZypperPatch")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "patchName" => Ok(__FieldTag::__patch_name),
                                "patch_name" => Ok(__FieldTag::__patch_name),
                                "category" => Ok(__FieldTag::__category),
                                "severity" => Ok(__FieldTag::__severity),
                                "summary" => Ok(__FieldTag::__summary),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ZypperPatch;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ZypperPatch")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__patch_name => {
                                if !fields.insert(__FieldTag::__patch_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for patch_name",
                                    ));
                                }
                                result.patch_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__category => {
                                if !fields.insert(__FieldTag::__category) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for category",
                                    ));
                                }
                                result.category = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__severity => {
                                if !fields.insert(__FieldTag::__severity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for severity",
                                    ));
                                }
                                result.severity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__summary => {
                                if !fields.insert(__FieldTag::__summary) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for summary",
                                    ));
                                }
                                result.summary = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ZypperPatch {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.patch_name.is_empty() {
                state.serialize_entry("patchName", &self.patch_name)?;
            }
            if !self.category.is_empty() {
                state.serialize_entry("category", &self.category)?;
            }
            if !self.severity.is_empty() {
                state.serialize_entry("severity", &self.severity)?;
            }
            if !self.summary.is_empty() {
                state.serialize_entry("summary", &self.summary)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ZypperPatch {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ZypperPatch");
            debug_struct.field("patch_name", &self.patch_name);
            debug_struct.field("category", &self.category);
            debug_struct.field("severity", &self.severity);
            debug_struct.field("summary", &self.summary);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Details related to a Windows Update package.
    /// Field data and names are taken from Windows Update API IUpdate Interface:
    /// <https://docs.microsoft.com/en-us/windows/win32/api/_wua/>
    /// Descriptive fields like title, and description are localized based on
    /// the locale of the VM being updated.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WindowsUpdatePackage {
        /// The localized title of the update package.
        pub title: std::string::String,

        /// The localized description of the update package.
        pub description: std::string::String,

        /// The categories that are associated with this update package.
        pub categories:
            std::vec::Vec<crate::model::inventory::windows_update_package::WindowsUpdateCategory>,

        /// A collection of Microsoft Knowledge Base article IDs that are associated
        /// with the update package.
        pub kb_article_ids: std::vec::Vec<std::string::String>,

        /// A hyperlink to the language-specific support information for the update.
        pub support_url: std::string::String,

        /// A collection of URLs that provide more information about the update
        /// package.
        pub more_info_urls: std::vec::Vec<std::string::String>,

        /// Gets the identifier of an update package.  Stays the same across
        /// revisions.
        pub update_id: std::string::String,

        /// The revision number of this update package.
        pub revision_number: i32,

        /// The last published date of the update, in (UTC) date and time.
        pub last_deployment_change_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsUpdatePackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [title][crate::model::inventory::WindowsUpdatePackage::title].
        pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [description][crate::model::inventory::WindowsUpdatePackage::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [categories][crate::model::inventory::WindowsUpdatePackage::categories].
        pub fn set_categories<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::inventory::windows_update_package::WindowsUpdateCategory,
                >,
        {
            use std::iter::Iterator;
            self.categories = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [kb_article_ids][crate::model::inventory::WindowsUpdatePackage::kb_article_ids].
        pub fn set_kb_article_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.kb_article_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [support_url][crate::model::inventory::WindowsUpdatePackage::support_url].
        pub fn set_support_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.support_url = v.into();
            self
        }

        /// Sets the value of [more_info_urls][crate::model::inventory::WindowsUpdatePackage::more_info_urls].
        pub fn set_more_info_urls<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.more_info_urls = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [update_id][crate::model::inventory::WindowsUpdatePackage::update_id].
        pub fn set_update_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.update_id = v.into();
            self
        }

        /// Sets the value of [revision_number][crate::model::inventory::WindowsUpdatePackage::revision_number].
        pub fn set_revision_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.revision_number = v.into();
            self
        }

        /// Sets the value of [last_deployment_change_time][crate::model::inventory::WindowsUpdatePackage::last_deployment_change_time].
        pub fn set_last_deployment_change_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_deployment_change_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_deployment_change_time][crate::model::inventory::WindowsUpdatePackage::last_deployment_change_time].
        pub fn set_or_clear_last_deployment_change_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_deployment_change_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for WindowsUpdatePackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsUpdatePackage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WindowsUpdatePackage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __title,
                __description,
                __categories,
                __kb_article_ids,
                __support_url,
                __more_info_urls,
                __update_id,
                __revision_number,
                __last_deployment_change_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WindowsUpdatePackage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "title" => Ok(__FieldTag::__title),
                                "description" => Ok(__FieldTag::__description),
                                "categories" => Ok(__FieldTag::__categories),
                                "kbArticleIds" => Ok(__FieldTag::__kb_article_ids),
                                "kb_article_ids" => Ok(__FieldTag::__kb_article_ids),
                                "supportUrl" => Ok(__FieldTag::__support_url),
                                "support_url" => Ok(__FieldTag::__support_url),
                                "moreInfoUrls" => Ok(__FieldTag::__more_info_urls),
                                "more_info_urls" => Ok(__FieldTag::__more_info_urls),
                                "updateId" => Ok(__FieldTag::__update_id),
                                "update_id" => Ok(__FieldTag::__update_id),
                                "revisionNumber" => Ok(__FieldTag::__revision_number),
                                "revision_number" => Ok(__FieldTag::__revision_number),
                                "lastDeploymentChangeTime" => {
                                    Ok(__FieldTag::__last_deployment_change_time)
                                }
                                "last_deployment_change_time" => {
                                    Ok(__FieldTag::__last_deployment_change_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WindowsUpdatePackage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WindowsUpdatePackage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__title => {
                                if !fields.insert(__FieldTag::__title) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for title",
                                    ));
                                }
                                result.title = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__categories => {
                                if !fields.insert(__FieldTag::__categories) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for categories",
                                    ));
                                }
                                result.categories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::inventory::windows_update_package::WindowsUpdateCategory>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__kb_article_ids => {
                                if !fields.insert(__FieldTag::__kb_article_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kb_article_ids",
                                    ));
                                }
                                result.kb_article_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__support_url => {
                                if !fields.insert(__FieldTag::__support_url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for support_url",
                                    ));
                                }
                                result.support_url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__more_info_urls => {
                                if !fields.insert(__FieldTag::__more_info_urls) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for more_info_urls",
                                    ));
                                }
                                result.more_info_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__update_id => {
                                if !fields.insert(__FieldTag::__update_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_id",
                                    ));
                                }
                                result.update_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__revision_number => {
                                if !fields.insert(__FieldTag::__revision_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revision_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.revision_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__last_deployment_change_time => {
                                if !fields.insert(__FieldTag::__last_deployment_change_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_deployment_change_time",
                                    ));
                                }
                                result.last_deployment_change_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WindowsUpdatePackage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.title.is_empty() {
                state.serialize_entry("title", &self.title)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self.categories.is_empty() {
                state.serialize_entry("categories", &self.categories)?;
            }
            if !self.kb_article_ids.is_empty() {
                state.serialize_entry("kbArticleIds", &self.kb_article_ids)?;
            }
            if !self.support_url.is_empty() {
                state.serialize_entry("supportUrl", &self.support_url)?;
            }
            if !self.more_info_urls.is_empty() {
                state.serialize_entry("moreInfoUrls", &self.more_info_urls)?;
            }
            if !self.update_id.is_empty() {
                state.serialize_entry("updateId", &self.update_id)?;
            }
            if !wkt::internal::is_default(&self.revision_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("revisionNumber", &__With(&self.revision_number))?;
            }
            if self.last_deployment_change_time.is_some() {
                state.serialize_entry(
                    "lastDeploymentChangeTime",
                    &self.last_deployment_change_time,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WindowsUpdatePackage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WindowsUpdatePackage");
            debug_struct.field("title", &self.title);
            debug_struct.field("description", &self.description);
            debug_struct.field("categories", &self.categories);
            debug_struct.field("kb_article_ids", &self.kb_article_ids);
            debug_struct.field("support_url", &self.support_url);
            debug_struct.field("more_info_urls", &self.more_info_urls);
            debug_struct.field("update_id", &self.update_id);
            debug_struct.field("revision_number", &self.revision_number);
            debug_struct.field(
                "last_deployment_change_time",
                &self.last_deployment_change_time,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [WindowsUpdatePackage].
    pub mod windows_update_package {
        #[allow(unused_imports)]
        use super::*;

        /// Categories specified by the Windows Update.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct WindowsUpdateCategory {
            /// The identifier of the windows update category.
            pub id: std::string::String,

            /// The name of the windows update category.
            pub name: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl WindowsUpdateCategory {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [id][crate::model::inventory::windows_update_package::WindowsUpdateCategory::id].
            pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.id = v.into();
                self
            }

            /// Sets the value of [name][crate::model::inventory::windows_update_package::WindowsUpdateCategory::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }
        }

        impl wkt::message::Message for WindowsUpdateCategory {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsUpdatePackage.WindowsUpdateCategory"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for WindowsUpdateCategory {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __id,
                    __name,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for WindowsUpdateCategory")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "id" => Ok(__FieldTag::__id),
                                    "name" => Ok(__FieldTag::__name),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = WindowsUpdateCategory;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct WindowsUpdateCategory")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__id => {
                                    if !fields.insert(__FieldTag::__id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for id"),
                                        );
                                    }
                                    result.id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for WindowsUpdateCategory {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.id.is_empty() {
                    state.serialize_entry("id", &self.id)?;
                }
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for WindowsUpdateCategory {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("WindowsUpdateCategory");
                debug_struct.field("id", &self.id);
                debug_struct.field("name", &self.name);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Information related to a Quick Fix Engineering package.
    /// Fields are taken from Windows QuickFixEngineering Interface and match
    /// the source names:
    /// <https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering>
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WindowsQuickFixEngineeringPackage {
        /// A short textual description of the QFE update.
        pub caption: std::string::String,

        /// A textual description of the QFE update.
        pub description: std::string::String,

        /// Unique identifier associated with a particular QFE update.
        pub hot_fix_id: std::string::String,

        /// Date that the QFE update was installed.  Mapped from installed_on field.
        pub install_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsQuickFixEngineeringPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [caption][crate::model::inventory::WindowsQuickFixEngineeringPackage::caption].
        pub fn set_caption<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.caption = v.into();
            self
        }

        /// Sets the value of [description][crate::model::inventory::WindowsQuickFixEngineeringPackage::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [hot_fix_id][crate::model::inventory::WindowsQuickFixEngineeringPackage::hot_fix_id].
        pub fn set_hot_fix_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.hot_fix_id = v.into();
            self
        }

        /// Sets the value of [install_time][crate::model::inventory::WindowsQuickFixEngineeringPackage::install_time].
        pub fn set_install_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.install_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [install_time][crate::model::inventory::WindowsQuickFixEngineeringPackage::install_time].
        pub fn set_or_clear_install_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.install_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for WindowsQuickFixEngineeringPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsQuickFixEngineeringPackage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WindowsQuickFixEngineeringPackage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __caption,
                __description,
                __hot_fix_id,
                __install_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter
                                .write_str("a field name for WindowsQuickFixEngineeringPackage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "caption" => Ok(__FieldTag::__caption),
                                "description" => Ok(__FieldTag::__description),
                                "hotFixId" => Ok(__FieldTag::__hot_fix_id),
                                "hot_fix_id" => Ok(__FieldTag::__hot_fix_id),
                                "installTime" => Ok(__FieldTag::__install_time),
                                "install_time" => Ok(__FieldTag::__install_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WindowsQuickFixEngineeringPackage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WindowsQuickFixEngineeringPackage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__caption => {
                                if !fields.insert(__FieldTag::__caption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for caption",
                                    ));
                                }
                                result.caption = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__hot_fix_id => {
                                if !fields.insert(__FieldTag::__hot_fix_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hot_fix_id",
                                    ));
                                }
                                result.hot_fix_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__install_time => {
                                if !fields.insert(__FieldTag::__install_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for install_time",
                                    ));
                                }
                                result.install_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WindowsQuickFixEngineeringPackage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.caption.is_empty() {
                state.serialize_entry("caption", &self.caption)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self.hot_fix_id.is_empty() {
                state.serialize_entry("hotFixId", &self.hot_fix_id)?;
            }
            if self.install_time.is_some() {
                state.serialize_entry("installTime", &self.install_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WindowsQuickFixEngineeringPackage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WindowsQuickFixEngineeringPackage");
            debug_struct.field("caption", &self.caption);
            debug_struct.field("description", &self.description);
            debug_struct.field("hot_fix_id", &self.hot_fix_id);
            debug_struct.field("install_time", &self.install_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Contains information about a Windows application that is retrieved from the
    /// Windows Registry. For more information about these fields, see:
    /// <https://docs.microsoft.com/en-us/windows/win32/msi/uninstall-registry-key>
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WindowsApplication {
        /// The name of the application or product.
        pub display_name: std::string::String,

        /// The version of the product or application in string format.
        pub display_version: std::string::String,

        /// The name of the manufacturer for the product or application.
        pub publisher: std::string::String,

        /// The last time this product received service. The value of this property
        /// is replaced each time a patch is applied or removed from the product or
        /// the command-line option is used to repair the product.
        pub install_date: std::option::Option<gtype::model::Date>,

        /// The internet address for technical support.
        pub help_link: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsApplication {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::inventory::WindowsApplication::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [display_version][crate::model::inventory::WindowsApplication::display_version].
        pub fn set_display_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_version = v.into();
            self
        }

        /// Sets the value of [publisher][crate::model::inventory::WindowsApplication::publisher].
        pub fn set_publisher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.publisher = v.into();
            self
        }

        /// Sets the value of [install_date][crate::model::inventory::WindowsApplication::install_date].
        pub fn set_install_date<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.install_date = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [install_date][crate::model::inventory::WindowsApplication::install_date].
        pub fn set_or_clear_install_date<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.install_date = v.map(|x| x.into());
            self
        }

        /// Sets the value of [help_link][crate::model::inventory::WindowsApplication::help_link].
        pub fn set_help_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.help_link = v.into();
            self
        }
    }

    impl wkt::message::Message for WindowsApplication {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsApplication"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WindowsApplication {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __display_version,
                __publisher,
                __install_date,
                __help_link,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WindowsApplication")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "displayVersion" => Ok(__FieldTag::__display_version),
                                "display_version" => Ok(__FieldTag::__display_version),
                                "publisher" => Ok(__FieldTag::__publisher),
                                "installDate" => Ok(__FieldTag::__install_date),
                                "install_date" => Ok(__FieldTag::__install_date),
                                "helpLink" => Ok(__FieldTag::__help_link),
                                "help_link" => Ok(__FieldTag::__help_link),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WindowsApplication;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WindowsApplication")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_version => {
                                if !fields.insert(__FieldTag::__display_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_version",
                                    ));
                                }
                                result.display_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__publisher => {
                                if !fields.insert(__FieldTag::__publisher) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for publisher",
                                    ));
                                }
                                result.publisher = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__install_date => {
                                if !fields.insert(__FieldTag::__install_date) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for install_date",
                                    ));
                                }
                                result.install_date =
                                    map.next_value::<std::option::Option<gtype::model::Date>>()?;
                            }
                            __FieldTag::__help_link => {
                                if !fields.insert(__FieldTag::__help_link) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for help_link",
                                    ));
                                }
                                result.help_link = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WindowsApplication {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.display_version.is_empty() {
                state.serialize_entry("displayVersion", &self.display_version)?;
            }
            if !self.publisher.is_empty() {
                state.serialize_entry("publisher", &self.publisher)?;
            }
            if self.install_date.is_some() {
                state.serialize_entry("installDate", &self.install_date)?;
            }
            if !self.help_link.is_empty() {
                state.serialize_entry("helpLink", &self.help_link)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WindowsApplication {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WindowsApplication");
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("display_version", &self.display_version);
            debug_struct.field("publisher", &self.publisher);
            debug_struct.field("install_date", &self.install_date);
            debug_struct.field("help_link", &self.help_link);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A request message for getting inventory data for the specified VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInventoryRequest {
    /// Required. API resource name for inventory resource.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}/inventory`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance}`, either Compute Engine  `instance-id` or `instance-name`
    /// can be provided.
    pub name: std::string::String,

    /// Inventory view indicating what information should be included in the
    /// inventory resource. If unspecified, the default view is BASIC.
    pub view: crate::model::InventoryView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInventoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetInventoryRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::InventoryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetInventoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInventoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInventoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInventoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInventoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::InventoryView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInventoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInventoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInventoryRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for listing inventory data for all VMs in the specified
/// location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInventoriesRequest {
    /// Required. The parent resource name.
    ///
    /// Format: `projects/{project}/locations/{location}/instances/-`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    pub parent: std::string::String,

    /// Inventory view indicating what information should be included in the
    /// inventory resource. If unspecified, the default view is BASIC.
    pub view: crate::model::InventoryView,

    /// The maximum number of results to return.
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListInventories` that indicates where this listing
    /// should continue from.
    pub page_token: std::string::String,

    /// If provided, this field specifies the criteria that must be met by a
    /// `Inventory` API resource to be included in the response.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInventoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInventoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListInventoriesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::InventoryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInventoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInventoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInventoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInventoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListInventoriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInventoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInventoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInventoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInventoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::InventoryView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInventoriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInventoriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInventoriesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing inventory data for all VMs in a specified
/// location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInventoriesResponse {
    /// List of inventory objects.
    pub inventories: std::vec::Vec<crate::model::Inventory>,

    /// The pagination token to retrieve the next page of inventory objects.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInventoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inventories][crate::model::ListInventoriesResponse::inventories].
    pub fn set_inventories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Inventory>,
    {
        use std::iter::Iterator;
        self.inventories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInventoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInventoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListInventoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInventoriesResponse {
    type PageItem = crate::model::Inventory;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.inventories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInventoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inventories,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInventoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inventories" => Ok(__FieldTag::__inventories),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInventoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInventoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inventories => {
                            if !fields.insert(__FieldTag::__inventories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventories",
                                ));
                            }
                            result.inventories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Inventory>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInventoriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.inventories.is_empty() {
            state.serialize_entry("inventories", &self.inventories)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInventoriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInventoriesResponse");
        debug_struct.field("inventories", &self.inventories);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An OS policy defines the desired state configuration for a VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OSPolicy {
    /// Required. The id of the OS policy with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the assignment.
    pub id: std::string::String,

    /// Policy description.
    /// Length of the description is limited to 1024 characters.
    pub description: std::string::String,

    /// Required. Policy mode
    pub mode: crate::model::os_policy::Mode,

    /// Required. List of resource groups for the policy.
    /// For a particular VM, resource groups are evaluated in the order specified
    /// and the first resource group that is applicable is selected and the rest
    /// are ignored.
    ///
    /// If none of the resource groups are applicable for a VM, the VM is
    /// considered to be non-compliant w.r.t this policy. This behavior can be
    /// toggled by the flag `allow_no_resource_group_match`
    pub resource_groups: std::vec::Vec<crate::model::os_policy::ResourceGroup>,

    /// This flag determines the OS policy compliance status when none of the
    /// resource groups within the policy are applicable for a VM. Set this value
    /// to `true` if the policy needs to be reported as compliant even if the
    /// policy has nothing to validate or enforce.
    pub allow_no_resource_group_match: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::OSPolicy::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::OSPolicy::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::os_policy::Mode>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [resource_groups][crate::model::OSPolicy::resource_groups].
    pub fn set_resource_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::os_policy::ResourceGroup>,
    {
        use std::iter::Iterator;
        self.resource_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_no_resource_group_match][crate::model::OSPolicy::allow_no_resource_group_match].
    pub fn set_allow_no_resource_group_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_no_resource_group_match = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OSPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __description,
            __mode,
            __resource_groups,
            __allow_no_resource_group_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "description" => Ok(__FieldTag::__description),
                            "mode" => Ok(__FieldTag::__mode),
                            "resourceGroups" => Ok(__FieldTag::__resource_groups),
                            "resource_groups" => Ok(__FieldTag::__resource_groups),
                            "allowNoResourceGroupMatch" => {
                                Ok(__FieldTag::__allow_no_resource_group_match)
                            }
                            "allow_no_resource_group_match" => {
                                Ok(__FieldTag::__allow_no_resource_group_match)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OSPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<crate::model::os_policy::Mode>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_groups => {
                            if !fields.insert(__FieldTag::__resource_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_groups",
                                ));
                            }
                            result.resource_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::os_policy::ResourceGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_no_resource_group_match => {
                            if !fields.insert(__FieldTag::__allow_no_resource_group_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_no_resource_group_match",
                                ));
                            }
                            result.allow_no_resource_group_match = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OSPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.resource_groups.is_empty() {
            state.serialize_entry("resourceGroups", &self.resource_groups)?;
        }
        if !wkt::internal::is_default(&self.allow_no_resource_group_match) {
            state.serialize_entry(
                "allowNoResourceGroupMatch",
                &self.allow_no_resource_group_match,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OSPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OSPolicy");
        debug_struct.field("id", &self.id);
        debug_struct.field("description", &self.description);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("resource_groups", &self.resource_groups);
        debug_struct.field(
            "allow_no_resource_group_match",
            &self.allow_no_resource_group_match,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OSPolicy].
pub mod os_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Filtering criteria to select VMs based on inventory details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InventoryFilter {
        /// Required. The OS short name
        pub os_short_name: std::string::String,

        /// The OS version
        ///
        /// Prefix matches are supported if asterisk(*) is provided as the
        /// last character. For example, to match all versions with a major
        /// version of `7`, specify the following value for this field `7.*`
        ///
        /// An empty string matches all OS versions.
        pub os_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InventoryFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [os_short_name][crate::model::os_policy::InventoryFilter::os_short_name].
        pub fn set_os_short_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.os_short_name = v.into();
            self
        }

        /// Sets the value of [os_version][crate::model::os_policy::InventoryFilter::os_version].
        pub fn set_os_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.os_version = v.into();
            self
        }
    }

    impl wkt::message::Message for InventoryFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.InventoryFilter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InventoryFilter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __os_short_name,
                __os_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InventoryFilter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "osShortName" => Ok(__FieldTag::__os_short_name),
                                "os_short_name" => Ok(__FieldTag::__os_short_name),
                                "osVersion" => Ok(__FieldTag::__os_version),
                                "os_version" => Ok(__FieldTag::__os_version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InventoryFilter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InventoryFilter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__os_short_name => {
                                if !fields.insert(__FieldTag::__os_short_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for os_short_name",
                                    ));
                                }
                                result.os_short_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__os_version => {
                                if !fields.insert(__FieldTag::__os_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for os_version",
                                    ));
                                }
                                result.os_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InventoryFilter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.os_short_name.is_empty() {
                state.serialize_entry("osShortName", &self.os_short_name)?;
            }
            if !self.os_version.is_empty() {
                state.serialize_entry("osVersion", &self.os_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InventoryFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InventoryFilter");
            debug_struct.field("os_short_name", &self.os_short_name);
            debug_struct.field("os_version", &self.os_version);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An OS policy resource is used to define the desired state configuration
    /// and provides a specific functionality like installing/removing packages,
    /// executing a script etc.
    ///
    /// The system ensures that resources are always in their desired state by
    /// taking necessary actions if they have drifted from their desired state.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Resource {
        /// Required. The id of the resource with the following restrictions:
        ///
        /// * Must contain only lowercase letters, numbers, and hyphens.
        /// * Must start with a letter.
        /// * Must be between 1-63 characters.
        /// * Must end with a number or a letter.
        /// * Must be unique within the OS policy.
        pub id: std::string::String,

        /// Resource type.
        pub resource_type: std::option::Option<crate::model::os_policy::resource::ResourceType>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::os_policy::Resource::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type].
        ///
        /// Note that all the setters affecting `resource_type` are mutually
        /// exclusive.
        pub fn set_resource_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::os_policy::resource::ResourceType>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `Pkg`, `None` if the field is not set or
        /// holds a different branch.
        pub fn pkg(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::PackageResource>>
        {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::Pkg(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `Pkg`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_pkg<
            T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::PackageResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::Pkg(v.into()),
            );
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `Repository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>,
        > {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::Repository(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `Repository`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_repository<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::Repository(v.into()),
            );
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `Exec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn exec(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::ExecResource>>
        {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::Exec(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `Exec`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_exec<
            T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::ExecResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::Exec(v.into()),
            );
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `File`, `None` if the field is not set or
        /// holds a different branch.
        pub fn file(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::FileResource>>
        {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::File(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `File`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_file<
            T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::FileResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::File(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Resource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __pkg,
                __repository,
                __exec,
                __file,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Resource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "pkg" => Ok(__FieldTag::__pkg),
                                "repository" => Ok(__FieldTag::__repository),
                                "exec" => Ok(__FieldTag::__exec),
                                "file" => Ok(__FieldTag::__file),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Resource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Resource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pkg => {
                                if !fields.insert(__FieldTag::__pkg) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pkg",
                                    ));
                                }
                                if result.resource_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.pkg, latest field was pkg",
                                    ));
                                }
                                result.resource_type = std::option::Option::Some(
                                    crate::model::os_policy::resource::ResourceType::Pkg(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::os_policy::resource::PackageResource,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__repository => {
                                if !fields.insert(__FieldTag::__repository) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository",
                                    ));
                                }
                                if result.resource_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.repository, latest field was repository",
                                    ));
                                }
                                result.resource_type = std::option::Option::Some(
                                    crate::model::os_policy::resource::ResourceType::Repository(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__exec => {
                                if !fields.insert(__FieldTag::__exec) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exec",
                                    ));
                                }
                                if result.resource_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.exec, latest field was exec",
                                    ));
                                }
                                result.resource_type = std::option::Option::Some(
                                    crate::model::os_policy::resource::ResourceType::Exec(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::os_policy::resource::ExecResource,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__file => {
                                if !fields.insert(__FieldTag::__file) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file",
                                    ));
                                }
                                if result.resource_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `resource_type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.file, latest field was file",
                                    ));
                                }
                                result.resource_type = std::option::Option::Some(
                                    crate::model::os_policy::resource::ResourceType::File(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::os_policy::resource::FileResource,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Resource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if let Some(value) = self.pkg() {
                state.serialize_entry("pkg", value)?;
            }
            if let Some(value) = self.repository() {
                state.serialize_entry("repository", value)?;
            }
            if let Some(value) = self.exec() {
                state.serialize_entry("exec", value)?;
            }
            if let Some(value) = self.file() {
                state.serialize_entry("file", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Resource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Resource");
            debug_struct.field("id", &self.id);
            debug_struct.field("resource_type", &self.resource_type);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Resource].
    pub mod resource {
        #[allow(unused_imports)]
        use super::*;

        /// A remote or local file.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct File {
            /// Defaults to false. When false, files are subject to validations
            /// based on the file type:
            ///
            /// Remote: A checksum must be specified.
            /// Cloud Storage: An object generation number must be specified.
            pub allow_insecure: bool,

            /// A specific type of file.
            pub r#type: std::option::Option<crate::model::os_policy::resource::file::Type>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl File {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allow_insecure][crate::model::os_policy::resource::File::allow_insecure].
            pub fn set_allow_insecure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.allow_insecure = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<crate::model::os_policy::resource::file::Type>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// if it holds a `Remote`, `None` if the field is not set or
            /// holds a different branch.
            pub fn remote(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::file::Remote>,
            > {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file::Type::Remote(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// to hold a `Remote`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_remote<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::file::Remote>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::os_policy::resource::file::Type::Remote(v.into()),
                );
                self
            }

            /// The value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// if it holds a `Gcs`, `None` if the field is not set or
            /// holds a different branch.
            pub fn gcs(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::file::Gcs>>
            {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file::Type::Gcs(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// to hold a `Gcs`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_gcs<
                T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::file::Gcs>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::os_policy::resource::file::Type::Gcs(v.into()),
                );
                self
            }

            /// The value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// if it holds a `LocalPath`, `None` if the field is not set or
            /// holds a different branch.
            pub fn local_path(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file::Type::LocalPath(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// to hold a `LocalPath`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_local_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::os_policy::resource::file::Type::LocalPath(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for File {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.File"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for File {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __remote,
                    __gcs,
                    __local_path,
                    __allow_insecure,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for File")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "remote" => Ok(__FieldTag::__remote),
                                    "gcs" => Ok(__FieldTag::__gcs),
                                    "localPath" => Ok(__FieldTag::__local_path),
                                    "local_path" => Ok(__FieldTag::__local_path),
                                    "allowInsecure" => Ok(__FieldTag::__allow_insecure),
                                    "allow_insecure" => Ok(__FieldTag::__allow_insecure),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = File;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct File")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__remote => {
                                    if !fields.insert(__FieldTag::__remote) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for remote"),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.File.remote, latest field was remote",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::os_policy::resource::file::Type::Remote(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::os_policy::resource::file::Remote,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__gcs => {
                                    if !fields.insert(__FieldTag::__gcs) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for gcs"),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.File.gcs, latest field was gcs",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::os_policy::resource::file::Type::Gcs(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::os_policy::resource::file::Gcs,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__local_path => {
                                    if !fields.insert(__FieldTag::__local_path) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for local_path",
                                            ),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.File.local_path, latest field was localPath",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::os_policy::resource::file::Type::LocalPath(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__allow_insecure => {
                                    if !fields.insert(__FieldTag::__allow_insecure) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allow_insecure",
                                            ),
                                        );
                                    }
                                    result.allow_insecure = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for File {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.remote() {
                    state.serialize_entry("remote", value)?;
                }
                if let Some(value) = self.gcs() {
                    state.serialize_entry("gcs", value)?;
                }
                if let Some(value) = self.local_path() {
                    state.serialize_entry("localPath", value)?;
                }
                if !wkt::internal::is_default(&self.allow_insecure) {
                    state.serialize_entry("allowInsecure", &self.allow_insecure)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for File {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("File");
                debug_struct.field("allow_insecure", &self.allow_insecure);
                debug_struct.field("r#type", &self.r#type);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [File].
        pub mod file {
            #[allow(unused_imports)]
            use super::*;

            /// Specifies a file available via some URI.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Remote {
                /// Required. URI from which to fetch the object. It should contain both
                /// the protocol and path following the format `{protocol}://{location}`.
                pub uri: std::string::String,

                /// SHA256 checksum of the remote file.
                pub sha256_checksum: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Remote {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [uri][crate::model::os_policy::resource::file::Remote::uri].
                pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.uri = v.into();
                    self
                }

                /// Sets the value of [sha256_checksum][crate::model::os_policy::resource::file::Remote::sha256_checksum].
                pub fn set_sha256_checksum<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.sha256_checksum = v.into();
                    self
                }
            }

            impl wkt::message::Message for Remote {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.File.Remote"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Remote {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __uri,
                        __sha256_checksum,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Remote")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "uri" => Ok(__FieldTag::__uri),
                                        "sha256Checksum" => Ok(__FieldTag::__sha256_checksum),
                                        "sha256_checksum" => Ok(__FieldTag::__sha256_checksum),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Remote;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Remote")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__uri => {
                                        if !fields.insert(__FieldTag::__uri) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for uri",
                                                ),
                                            );
                                        }
                                        result.uri = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__sha256_checksum => {
                                        if !fields.insert(__FieldTag::__sha256_checksum) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for sha256_checksum",
                                                ),
                                            );
                                        }
                                        result.sha256_checksum = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Remote {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.uri.is_empty() {
                        state.serialize_entry("uri", &self.uri)?;
                    }
                    if !self.sha256_checksum.is_empty() {
                        state.serialize_entry("sha256Checksum", &self.sha256_checksum)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Remote {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Remote");
                    debug_struct.field("uri", &self.uri);
                    debug_struct.field("sha256_checksum", &self.sha256_checksum);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Specifies a file available as a Cloud Storage Object.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Gcs {
                /// Required. Bucket of the Cloud Storage object.
                pub bucket: std::string::String,

                /// Required. Name of the Cloud Storage object.
                pub object: std::string::String,

                /// Generation number of the Cloud Storage object.
                pub generation: i64,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Gcs {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [bucket][crate::model::os_policy::resource::file::Gcs::bucket].
                pub fn set_bucket<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.bucket = v.into();
                    self
                }

                /// Sets the value of [object][crate::model::os_policy::resource::file::Gcs::object].
                pub fn set_object<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.object = v.into();
                    self
                }

                /// Sets the value of [generation][crate::model::os_policy::resource::file::Gcs::generation].
                pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.generation = v.into();
                    self
                }
            }

            impl wkt::message::Message for Gcs {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.File.Gcs"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Gcs {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __bucket,
                        __object,
                        __generation,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Gcs")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "bucket" => Ok(__FieldTag::__bucket),
                                        "object" => Ok(__FieldTag::__object),
                                        "generation" => Ok(__FieldTag::__generation),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Gcs;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Gcs")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__bucket => {
                                        if !fields.insert(__FieldTag::__bucket) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for bucket",
                                                ),
                                            );
                                        }
                                        result.bucket = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__object => {
                                        if !fields.insert(__FieldTag::__object) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for object",
                                                ),
                                            );
                                        }
                                        result.object = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__generation => {
                                        if !fields.insert(__FieldTag::__generation) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for generation",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.generation =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Gcs {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.bucket.is_empty() {
                        state.serialize_entry("bucket", &self.bucket)?;
                    }
                    if !self.object.is_empty() {
                        state.serialize_entry("object", &self.object)?;
                    }
                    if !wkt::internal::is_default(&self.generation) {
                        struct __With<'a>(&'a i64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("generation", &__With(&self.generation))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Gcs {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Gcs");
                    debug_struct.field("bucket", &self.bucket);
                    debug_struct.field("object", &self.object);
                    debug_struct.field("generation", &self.generation);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A specific type of file.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// A generic remote file.
                Remote(std::boxed::Box<crate::model::os_policy::resource::file::Remote>),
                /// A Cloud Storage object.
                Gcs(std::boxed::Box<crate::model::os_policy::resource::file::Gcs>),
                /// A local path within the VM to use.
                LocalPath(std::string::String),
            }
        }

        /// A resource that manages a system package.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PackageResource {
            /// Required. The desired state the agent should maintain for this package.
            pub desired_state: crate::model::os_policy::resource::package_resource::DesiredState,

            /// A system package.
            pub system_package: std::option::Option<
                crate::model::os_policy::resource::package_resource::SystemPackage,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PackageResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [desired_state][crate::model::os_policy::resource::PackageResource::desired_state].
            pub fn set_desired_state<
                T: std::convert::Into<
                        crate::model::os_policy::resource::package_resource::DesiredState,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.desired_state = v.into();
                self
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package].
            ///
            /// Note that all the setters affecting `system_package` are mutually
            /// exclusive.
            pub fn set_system_package<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::os_policy::resource::package_resource::SystemPackage,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = v.into();
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Apt`, `None` if the field is not set or
            /// holds a different branch.
            pub fn apt(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Apt(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Apt`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_apt<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Apt(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Deb`, `None` if the field is not set or
            /// holds a different branch.
            pub fn deb(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Deb(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Deb`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_deb<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Deb(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Yum`, `None` if the field is not set or
            /// holds a different branch.
            pub fn yum(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Yum(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Yum`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_yum<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Yum(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Zypper`, `None` if the field is not set or
            /// holds a different branch.
            pub fn zypper(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Zypper>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Zypper(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Zypper`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_zypper<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::package_resource::Zypper,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Zypper(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Rpm`, `None` if the field is not set or
            /// holds a different branch.
            pub fn rpm(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Rpm(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Rpm`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_rpm<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Rpm(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Googet`, `None` if the field is not set or
            /// holds a different branch.
            pub fn googet(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::GooGet>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Googet(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Googet`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_googet<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::package_resource::GooGet,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Googet(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Msi`, `None` if the field is not set or
            /// holds a different branch.
            pub fn msi(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Msi(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Msi`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_msi<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Msi(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for PackageResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PackageResource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __desired_state,
                    __apt,
                    __deb,
                    __yum,
                    __zypper,
                    __rpm,
                    __googet,
                    __msi,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PackageResource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "desiredState" => Ok(__FieldTag::__desired_state),
                                    "desired_state" => Ok(__FieldTag::__desired_state),
                                    "apt" => Ok(__FieldTag::__apt),
                                    "deb" => Ok(__FieldTag::__deb),
                                    "yum" => Ok(__FieldTag::__yum),
                                    "zypper" => Ok(__FieldTag::__zypper),
                                    "rpm" => Ok(__FieldTag::__rpm),
                                    "googet" => Ok(__FieldTag::__googet),
                                    "msi" => Ok(__FieldTag::__msi),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PackageResource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PackageResource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__desired_state => {
                                    if !fields.insert(__FieldTag::__desired_state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for desired_state",
                                            ),
                                        );
                                    }
                                    result.desired_state = map.next_value::<std::option::Option<crate::model::os_policy::resource::package_resource::DesiredState>>()?.unwrap_or_default();
                                }
                                __FieldTag::__apt => {
                                    if !fields.insert(__FieldTag::__apt) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for apt"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.apt, latest field was apt",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Apt(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__deb => {
                                    if !fields.insert(__FieldTag::__deb) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for deb"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.deb, latest field was deb",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Deb(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__yum => {
                                    if !fields.insert(__FieldTag::__yum) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for yum"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.yum, latest field was yum",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Yum(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__zypper => {
                                    if !fields.insert(__FieldTag::__zypper) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for zypper"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.zypper, latest field was zypper",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Zypper(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Zypper>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__rpm => {
                                    if !fields.insert(__FieldTag::__rpm) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for rpm"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.rpm, latest field was rpm",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Rpm(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__googet => {
                                    if !fields.insert(__FieldTag::__googet) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for googet"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.googet, latest field was googet",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Googet(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::GooGet>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__msi => {
                                    if !fields.insert(__FieldTag::__msi) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for msi"),
                                        );
                                    }
                                    if result.system_package.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `system_package`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.msi, latest field was msi",
                                            ),
                                        );
                                    }
                                    result.system_package = std::option::Option::Some(
                                        crate::model::os_policy::resource::package_resource::SystemPackage::Msi(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PackageResource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.desired_state) {
                    state.serialize_entry("desiredState", &self.desired_state)?;
                }
                if let Some(value) = self.apt() {
                    state.serialize_entry("apt", value)?;
                }
                if let Some(value) = self.deb() {
                    state.serialize_entry("deb", value)?;
                }
                if let Some(value) = self.yum() {
                    state.serialize_entry("yum", value)?;
                }
                if let Some(value) = self.zypper() {
                    state.serialize_entry("zypper", value)?;
                }
                if let Some(value) = self.rpm() {
                    state.serialize_entry("rpm", value)?;
                }
                if let Some(value) = self.googet() {
                    state.serialize_entry("googet", value)?;
                }
                if let Some(value) = self.msi() {
                    state.serialize_entry("msi", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for PackageResource {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("PackageResource");
                debug_struct.field("desired_state", &self.desired_state);
                debug_struct.field("system_package", &self.system_package);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [PackageResource].
        pub mod package_resource {
            #[allow(unused_imports)]
            use super::*;

            /// A deb package file. dpkg packages only support INSTALLED state.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Deb {
                /// Required. A deb package.
                pub source: std::option::Option<crate::model::os_policy::resource::File>,

                /// Whether dependencies should also be installed.
                ///
                /// - install when false: `dpkg -i package`
                /// - install when true: `apt-get update && apt-get -y install
                ///   package.deb`
                pub pull_deps: bool,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Deb {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::os_policy::resource::package_resource::Deb::source].
                pub fn set_source<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::os_policy::resource::File>,
                {
                    self.source = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [source][crate::model::os_policy::resource::package_resource::Deb::source].
                pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::os_policy::resource::File>,
                {
                    self.source = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [pull_deps][crate::model::os_policy::resource::package_resource::Deb::pull_deps].
                pub fn set_pull_deps<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.pull_deps = v.into();
                    self
                }
            }

            impl wkt::message::Message for Deb {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.Deb"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Deb {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __source,
                        __pull_deps,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Deb")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "source" => Ok(__FieldTag::__source),
                                        "pullDeps" => Ok(__FieldTag::__pull_deps),
                                        "pull_deps" => Ok(__FieldTag::__pull_deps),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Deb;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Deb")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__source => {
                                        if !fields.insert(__FieldTag::__source) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for source",
                                                ),
                                            );
                                        }
                                        result.source = map
                                            .next_value::<std::option::Option<
                                                crate::model::os_policy::resource::File,
                                            >>()?;
                                    }
                                    __FieldTag::__pull_deps => {
                                        if !fields.insert(__FieldTag::__pull_deps) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for pull_deps",
                                                ),
                                            );
                                        }
                                        result.pull_deps = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Deb {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.source.is_some() {
                        state.serialize_entry("source", &self.source)?;
                    }
                    if !wkt::internal::is_default(&self.pull_deps) {
                        state.serialize_entry("pullDeps", &self.pull_deps)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Deb {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Deb");
                    debug_struct.field("source", &self.source);
                    debug_struct.field("pull_deps", &self.pull_deps);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A package managed by APT.
            ///
            /// - install: `apt-get update && apt-get -y install [name]`
            /// - remove: `apt-get -y remove [name]`
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Apt {
                /// Required. Package name.
                pub name: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Apt {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::Apt::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for Apt {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.APT"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Apt {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __name,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Apt")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "name" => Ok(__FieldTag::__name),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Apt;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Apt")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__name => {
                                        if !fields.insert(__FieldTag::__name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for name",
                                                ),
                                            );
                                        }
                                        result.name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Apt {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.name.is_empty() {
                        state.serialize_entry("name", &self.name)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Apt {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Apt");
                    debug_struct.field("name", &self.name);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An RPM package file. RPM packages only support INSTALLED state.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Rpm {
                /// Required. An rpm package.
                pub source: std::option::Option<crate::model::os_policy::resource::File>,

                /// Whether dependencies should also be installed.
                ///
                /// - install when false: `rpm --upgrade --replacepkgs package.rpm`
                /// - install when true: `yum -y install package.rpm` or
                ///   `zypper -y install package.rpm`
                pub pull_deps: bool,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Rpm {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::os_policy::resource::package_resource::Rpm::source].
                pub fn set_source<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::os_policy::resource::File>,
                {
                    self.source = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [source][crate::model::os_policy::resource::package_resource::Rpm::source].
                pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::os_policy::resource::File>,
                {
                    self.source = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [pull_deps][crate::model::os_policy::resource::package_resource::Rpm::pull_deps].
                pub fn set_pull_deps<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.pull_deps = v.into();
                    self
                }
            }

            impl wkt::message::Message for Rpm {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.RPM"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Rpm {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __source,
                        __pull_deps,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Rpm")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "source" => Ok(__FieldTag::__source),
                                        "pullDeps" => Ok(__FieldTag::__pull_deps),
                                        "pull_deps" => Ok(__FieldTag::__pull_deps),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Rpm;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Rpm")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__source => {
                                        if !fields.insert(__FieldTag::__source) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for source",
                                                ),
                                            );
                                        }
                                        result.source = map
                                            .next_value::<std::option::Option<
                                                crate::model::os_policy::resource::File,
                                            >>()?;
                                    }
                                    __FieldTag::__pull_deps => {
                                        if !fields.insert(__FieldTag::__pull_deps) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for pull_deps",
                                                ),
                                            );
                                        }
                                        result.pull_deps = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Rpm {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.source.is_some() {
                        state.serialize_entry("source", &self.source)?;
                    }
                    if !wkt::internal::is_default(&self.pull_deps) {
                        state.serialize_entry("pullDeps", &self.pull_deps)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Rpm {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Rpm");
                    debug_struct.field("source", &self.source);
                    debug_struct.field("pull_deps", &self.pull_deps);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A package managed by YUM.
            ///
            /// - install: `yum -y install package`
            /// - remove: `yum -y remove package`
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Yum {
                /// Required. Package name.
                pub name: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Yum {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::Yum::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for Yum {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.YUM"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Yum {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __name,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Yum")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "name" => Ok(__FieldTag::__name),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Yum;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Yum")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__name => {
                                        if !fields.insert(__FieldTag::__name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for name",
                                                ),
                                            );
                                        }
                                        result.name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Yum {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.name.is_empty() {
                        state.serialize_entry("name", &self.name)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Yum {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Yum");
                    debug_struct.field("name", &self.name);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A package managed by Zypper.
            ///
            /// - install: `zypper -y install package`
            /// - remove: `zypper -y rm package`
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Zypper {
                /// Required. Package name.
                pub name: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Zypper {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::Zypper::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for Zypper {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.Zypper"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Zypper {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __name,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Zypper")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "name" => Ok(__FieldTag::__name),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Zypper;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Zypper")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__name => {
                                        if !fields.insert(__FieldTag::__name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for name",
                                                ),
                                            );
                                        }
                                        result.name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Zypper {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.name.is_empty() {
                        state.serialize_entry("name", &self.name)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Zypper {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Zypper");
                    debug_struct.field("name", &self.name);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A package managed by GooGet.
            ///
            /// - install: `googet -noconfirm install package`
            /// - remove: `googet -noconfirm remove package`
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct GooGet {
                /// Required. Package name.
                pub name: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GooGet {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::GooGet::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for GooGet {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.GooGet"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for GooGet {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __name,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for GooGet")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "name" => Ok(__FieldTag::__name),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = GooGet;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct GooGet")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__name => {
                                        if !fields.insert(__FieldTag::__name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for name",
                                                ),
                                            );
                                        }
                                        result.name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for GooGet {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.name.is_empty() {
                        state.serialize_entry("name", &self.name)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for GooGet {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("GooGet");
                    debug_struct.field("name", &self.name);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An MSI package. MSI packages only support INSTALLED state.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Msi {
                /// Required. The MSI package.
                pub source: std::option::Option<crate::model::os_policy::resource::File>,

                /// Additional properties to use during installation.
                /// This should be in the format of Property=Setting.
                /// Appended to the defaults of `ACTION=INSTALL
                /// REBOOT=ReallySuppress`.
                pub properties: std::vec::Vec<std::string::String>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Msi {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::os_policy::resource::package_resource::Msi::source].
                pub fn set_source<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::os_policy::resource::File>,
                {
                    self.source = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [source][crate::model::os_policy::resource::package_resource::Msi::source].
                pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::os_policy::resource::File>,
                {
                    self.source = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [properties][crate::model::os_policy::resource::package_resource::Msi::properties].
                pub fn set_properties<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.properties = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Msi {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.MSI"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Msi {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __source,
                        __properties,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Msi")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "source" => Ok(__FieldTag::__source),
                                        "properties" => Ok(__FieldTag::__properties),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Msi;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Msi")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__source => {
                                        if !fields.insert(__FieldTag::__source) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for source",
                                                ),
                                            );
                                        }
                                        result.source = map
                                            .next_value::<std::option::Option<
                                                crate::model::os_policy::resource::File,
                                            >>()?;
                                    }
                                    __FieldTag::__properties => {
                                        if !fields.insert(__FieldTag::__properties) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for properties",
                                                ),
                                            );
                                        }
                                        result.properties =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Msi {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.source.is_some() {
                        state.serialize_entry("source", &self.source)?;
                    }
                    if !self.properties.is_empty() {
                        state.serialize_entry("properties", &self.properties)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Msi {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Msi");
                    debug_struct.field("source", &self.source);
                    debug_struct.field("properties", &self.properties);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// The desired state that the OS Config agent maintains on the VM.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum DesiredState {
                /// Unspecified is invalid.
                Unspecified,
                /// Ensure that the package is installed.
                Installed,
                /// The agent ensures that the package is not installed and
                /// uninstalls it if detected.
                Removed,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [DesiredState::value] or
                /// [DesiredState::name].
                UnknownValue(desired_state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod desired_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl DesiredState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Installed => std::option::Option::Some(1),
                        Self::Removed => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("DESIRED_STATE_UNSPECIFIED"),
                        Self::Installed => std::option::Option::Some("INSTALLED"),
                        Self::Removed => std::option::Option::Some("REMOVED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for DesiredState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for DesiredState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for DesiredState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Installed,
                        2 => Self::Removed,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for DesiredState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "DESIRED_STATE_UNSPECIFIED" => Self::Unspecified,
                        "INSTALLED" => Self::Installed,
                        "REMOVED" => Self::Removed,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for DesiredState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Installed => serializer.serialize_i32(1),
                        Self::Removed => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for DesiredState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<DesiredState>::new(
                        ".google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.DesiredState",
                    ))
                }
            }

            /// A system package.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum SystemPackage {
                /// A package managed by Apt.
                Apt(std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>),
                /// A deb package file.
                Deb(std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>),
                /// A package managed by YUM.
                Yum(std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>),
                /// A package managed by Zypper.
                Zypper(
                    std::boxed::Box<crate::model::os_policy::resource::package_resource::Zypper>,
                ),
                /// An rpm package file.
                Rpm(std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>),
                /// A package managed by GooGet.
                Googet(
                    std::boxed::Box<crate::model::os_policy::resource::package_resource::GooGet>,
                ),
                /// An MSI package.
                Msi(std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>),
            }
        }

        /// A resource that manages a package repository.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct RepositoryResource {
            /// A specific type of repository.
            pub repository: std::option::Option<
                crate::model::os_policy::resource::repository_resource::Repository,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RepositoryResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository].
            ///
            /// Note that all the setters affecting `repository` are mutually
            /// exclusive.
            pub fn set_repository<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::os_policy::resource::repository_resource::Repository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = v.into();
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Apt`, `None` if the field is not set or
            /// holds a different branch.
            pub fn apt(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::AptRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Apt(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Apt`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_apt<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::repository_resource::AptRepository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Apt(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Yum`, `None` if the field is not set or
            /// holds a different branch.
            pub fn yum(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::YumRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Yum(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Yum`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_yum<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::repository_resource::YumRepository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Yum(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Zypper`, `None` if the field is not set or
            /// holds a different branch.
            pub fn zypper(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::ZypperRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Zypper(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Zypper`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_zypper<T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::repository_resource::ZypperRepository>>>(mut self, v: T) -> Self{
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Zypper(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Goo`, `None` if the field is not set or
            /// holds a different branch.
            pub fn goo(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::GooRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Goo(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Goo`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_goo<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::repository_resource::GooRepository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Goo(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for RepositoryResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for RepositoryResource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __apt,
                    __yum,
                    __zypper,
                    __goo,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for RepositoryResource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "apt" => Ok(__FieldTag::__apt),
                                    "yum" => Ok(__FieldTag::__yum),
                                    "zypper" => Ok(__FieldTag::__zypper),
                                    "goo" => Ok(__FieldTag::__goo),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = RepositoryResource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct RepositoryResource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__apt => {
                                    if !fields.insert(__FieldTag::__apt) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for apt"),
                                        );
                                    }
                                    if result.repository.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.apt, latest field was apt",
                                            ),
                                        );
                                    }
                                    result.repository = std::option::Option::Some(
                                        crate::model::os_policy::resource::repository_resource::Repository::Apt(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::AptRepository>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__yum => {
                                    if !fields.insert(__FieldTag::__yum) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for yum"),
                                        );
                                    }
                                    if result.repository.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.yum, latest field was yum",
                                            ),
                                        );
                                    }
                                    result.repository = std::option::Option::Some(
                                        crate::model::os_policy::resource::repository_resource::Repository::Yum(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::YumRepository>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__zypper => {
                                    if !fields.insert(__FieldTag::__zypper) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for zypper"),
                                        );
                                    }
                                    if result.repository.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.zypper, latest field was zypper",
                                            ),
                                        );
                                    }
                                    result.repository = std::option::Option::Some(
                                        crate::model::os_policy::resource::repository_resource::Repository::Zypper(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::ZypperRepository>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__goo => {
                                    if !fields.insert(__FieldTag::__goo) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for goo"),
                                        );
                                    }
                                    if result.repository.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `repository`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.goo, latest field was goo",
                                            ),
                                        );
                                    }
                                    result.repository = std::option::Option::Some(
                                        crate::model::os_policy::resource::repository_resource::Repository::Goo(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::repository_resource::GooRepository>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for RepositoryResource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.apt() {
                    state.serialize_entry("apt", value)?;
                }
                if let Some(value) = self.yum() {
                    state.serialize_entry("yum", value)?;
                }
                if let Some(value) = self.zypper() {
                    state.serialize_entry("zypper", value)?;
                }
                if let Some(value) = self.goo() {
                    state.serialize_entry("goo", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for RepositoryResource {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("RepositoryResource");
                debug_struct.field("repository", &self.repository);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [RepositoryResource].
        pub mod repository_resource {
            #[allow(unused_imports)]
            use super::*;

            /// Represents a single apt package repository. These will be added to
            /// a repo file that will be managed at
            /// `/etc/apt/sources.list.d/google_osconfig.list`.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct AptRepository {

                /// Required. Type of archive files in this repository.
                pub archive_type: crate::model::os_policy::resource::repository_resource::apt_repository::ArchiveType,

                /// Required. URI for this repository.
                pub uri: std::string::String,

                /// Required. Distribution of this repository.
                pub distribution: std::string::String,

                /// Required. List of components for this repository. Must contain at
                /// least one item.
                pub components: std::vec::Vec<std::string::String>,

                /// URI of the key file for this repository. The agent maintains a
                /// keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
                pub gpg_key: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl AptRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [archive_type][crate::model::os_policy::resource::repository_resource::AptRepository::archive_type].
                pub fn set_archive_type<T: std::convert::Into<crate::model::os_policy::resource::repository_resource::apt_repository::ArchiveType>>(mut self, v: T) -> Self{
                    self.archive_type = v.into();
                    self
                }

                /// Sets the value of [uri][crate::model::os_policy::resource::repository_resource::AptRepository::uri].
                pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.uri = v.into();
                    self
                }

                /// Sets the value of [distribution][crate::model::os_policy::resource::repository_resource::AptRepository::distribution].
                pub fn set_distribution<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.distribution = v.into();
                    self
                }

                /// Sets the value of [components][crate::model::os_policy::resource::repository_resource::AptRepository::components].
                pub fn set_components<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.components = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [gpg_key][crate::model::os_policy::resource::repository_resource::AptRepository::gpg_key].
                pub fn set_gpg_key<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.gpg_key = v.into();
                    self
                }
            }

            impl wkt::message::Message for AptRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepository"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for AptRepository {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __archive_type,
                        __uri,
                        __distribution,
                        __components,
                        __gpg_key,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for AptRepository")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "archiveType" => Ok(__FieldTag::__archive_type),
                                        "archive_type" => Ok(__FieldTag::__archive_type),
                                        "uri" => Ok(__FieldTag::__uri),
                                        "distribution" => Ok(__FieldTag::__distribution),
                                        "components" => Ok(__FieldTag::__components),
                                        "gpgKey" => Ok(__FieldTag::__gpg_key),
                                        "gpg_key" => Ok(__FieldTag::__gpg_key),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = AptRepository;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct AptRepository")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__archive_type => {
                                        if !fields.insert(__FieldTag::__archive_type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for archive_type",
                                                ),
                                            );
                                        }
                                        result.archive_type = map.next_value::<std::option::Option<crate::model::os_policy::resource::repository_resource::apt_repository::ArchiveType>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__uri => {
                                        if !fields.insert(__FieldTag::__uri) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for uri",
                                                ),
                                            );
                                        }
                                        result.uri = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__distribution => {
                                        if !fields.insert(__FieldTag::__distribution) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for distribution",
                                                ),
                                            );
                                        }
                                        result.distribution = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__components => {
                                        if !fields.insert(__FieldTag::__components) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for components",
                                                ),
                                            );
                                        }
                                        result.components =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__gpg_key => {
                                        if !fields.insert(__FieldTag::__gpg_key) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for gpg_key",
                                                ),
                                            );
                                        }
                                        result.gpg_key = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for AptRepository {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.archive_type) {
                        state.serialize_entry("archiveType", &self.archive_type)?;
                    }
                    if !self.uri.is_empty() {
                        state.serialize_entry("uri", &self.uri)?;
                    }
                    if !self.distribution.is_empty() {
                        state.serialize_entry("distribution", &self.distribution)?;
                    }
                    if !self.components.is_empty() {
                        state.serialize_entry("components", &self.components)?;
                    }
                    if !self.gpg_key.is_empty() {
                        state.serialize_entry("gpgKey", &self.gpg_key)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for AptRepository {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("AptRepository");
                    debug_struct.field("archive_type", &self.archive_type);
                    debug_struct.field("uri", &self.uri);
                    debug_struct.field("distribution", &self.distribution);
                    debug_struct.field("components", &self.components);
                    debug_struct.field("gpg_key", &self.gpg_key);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Defines additional types related to [AptRepository].
            pub mod apt_repository {
                #[allow(unused_imports)]
                use super::*;

                /// Type of archive.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum ArchiveType {
                    /// Unspecified is invalid.
                    Unspecified,
                    /// Deb indicates that the archive contains binary files.
                    Deb,
                    /// Deb-src indicates that the archive contains source files.
                    DebSrc,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [ArchiveType::value] or
                    /// [ArchiveType::name].
                    UnknownValue(archive_type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod archive_type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl ArchiveType {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Deb => std::option::Option::Some(1),
                            Self::DebSrc => std::option::Option::Some(2),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("ARCHIVE_TYPE_UNSPECIFIED")
                            }
                            Self::Deb => std::option::Option::Some("DEB"),
                            Self::DebSrc => std::option::Option::Some("DEB_SRC"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for ArchiveType {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for ArchiveType {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for ArchiveType {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Deb,
                            2 => Self::DebSrc,
                            _ => Self::UnknownValue(archive_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for ArchiveType {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "ARCHIVE_TYPE_UNSPECIFIED" => Self::Unspecified,
                            "DEB" => Self::Deb,
                            "DEB_SRC" => Self::DebSrc,
                            _ => Self::UnknownValue(archive_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for ArchiveType {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Deb => serializer.serialize_i32(1),
                            Self::DebSrc => serializer.serialize_i32(2),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for ArchiveType {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ArchiveType>::new(
                            ".google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType"))
                    }
                }
            }

            /// Represents a single yum package repository. These are added to a
            /// repo file that is managed at
            /// `/etc/yum.repos.d/google_osconfig.repo`.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct YumRepository {
                /// Required. A one word, unique name for this repository. This is  the
                /// `repo id` in the yum config file and also the `display_name` if
                /// `display_name` is omitted. This id is also used as the unique
                /// identifier when checking for resource conflicts.
                pub id: std::string::String,

                /// The display name of the repository.
                pub display_name: std::string::String,

                /// Required. The location of the repository directory.
                pub base_url: std::string::String,

                /// URIs of GPG keys.
                pub gpg_keys: std::vec::Vec<std::string::String>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl YumRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [id][crate::model::os_policy::resource::repository_resource::YumRepository::id].
                pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.id = v.into();
                    self
                }

                /// Sets the value of [display_name][crate::model::os_policy::resource::repository_resource::YumRepository::display_name].
                pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.display_name = v.into();
                    self
                }

                /// Sets the value of [base_url][crate::model::os_policy::resource::repository_resource::YumRepository::base_url].
                pub fn set_base_url<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.base_url = v.into();
                    self
                }

                /// Sets the value of [gpg_keys][crate::model::os_policy::resource::repository_resource::YumRepository::gpg_keys].
                pub fn set_gpg_keys<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gpg_keys = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for YumRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.YumRepository"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for YumRepository {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __id,
                        __display_name,
                        __base_url,
                        __gpg_keys,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for YumRepository")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "id" => Ok(__FieldTag::__id),
                                        "displayName" => Ok(__FieldTag::__display_name),
                                        "display_name" => Ok(__FieldTag::__display_name),
                                        "baseUrl" => Ok(__FieldTag::__base_url),
                                        "base_url" => Ok(__FieldTag::__base_url),
                                        "gpgKeys" => Ok(__FieldTag::__gpg_keys),
                                        "gpg_keys" => Ok(__FieldTag::__gpg_keys),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = YumRepository;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct YumRepository")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__id => {
                                        if !fields.insert(__FieldTag::__id) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field("multiple values for id"),
                                            );
                                        }
                                        result.id = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__display_name => {
                                        if !fields.insert(__FieldTag::__display_name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for display_name",
                                                ),
                                            );
                                        }
                                        result.display_name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__base_url => {
                                        if !fields.insert(__FieldTag::__base_url) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for base_url",
                                                ),
                                            );
                                        }
                                        result.base_url = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__gpg_keys => {
                                        if !fields.insert(__FieldTag::__gpg_keys) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for gpg_keys",
                                                ),
                                            );
                                        }
                                        result.gpg_keys =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for YumRepository {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.id.is_empty() {
                        state.serialize_entry("id", &self.id)?;
                    }
                    if !self.display_name.is_empty() {
                        state.serialize_entry("displayName", &self.display_name)?;
                    }
                    if !self.base_url.is_empty() {
                        state.serialize_entry("baseUrl", &self.base_url)?;
                    }
                    if !self.gpg_keys.is_empty() {
                        state.serialize_entry("gpgKeys", &self.gpg_keys)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for YumRepository {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("YumRepository");
                    debug_struct.field("id", &self.id);
                    debug_struct.field("display_name", &self.display_name);
                    debug_struct.field("base_url", &self.base_url);
                    debug_struct.field("gpg_keys", &self.gpg_keys);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a single zypper package repository. These are added to a
            /// repo file that is managed at
            /// `/etc/zypp/repos.d/google_osconfig.repo`.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ZypperRepository {
                /// Required. A one word, unique name for this repository. This is the
                /// `repo id` in the zypper config file and also the `display_name` if
                /// `display_name` is omitted. This id is also used as the unique
                /// identifier when checking for GuestPolicy conflicts.
                pub id: std::string::String,

                /// The display name of the repository.
                pub display_name: std::string::String,

                /// Required. The location of the repository directory.
                pub base_url: std::string::String,

                /// URIs of GPG keys.
                pub gpg_keys: std::vec::Vec<std::string::String>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ZypperRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [id][crate::model::os_policy::resource::repository_resource::ZypperRepository::id].
                pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.id = v.into();
                    self
                }

                /// Sets the value of [display_name][crate::model::os_policy::resource::repository_resource::ZypperRepository::display_name].
                pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.display_name = v.into();
                    self
                }

                /// Sets the value of [base_url][crate::model::os_policy::resource::repository_resource::ZypperRepository::base_url].
                pub fn set_base_url<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.base_url = v.into();
                    self
                }

                /// Sets the value of [gpg_keys][crate::model::os_policy::resource::repository_resource::ZypperRepository::gpg_keys].
                pub fn set_gpg_keys<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gpg_keys = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for ZypperRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.ZypperRepository"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ZypperRepository {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __id,
                        __display_name,
                        __base_url,
                        __gpg_keys,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ZypperRepository")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "id" => Ok(__FieldTag::__id),
                                        "displayName" => Ok(__FieldTag::__display_name),
                                        "display_name" => Ok(__FieldTag::__display_name),
                                        "baseUrl" => Ok(__FieldTag::__base_url),
                                        "base_url" => Ok(__FieldTag::__base_url),
                                        "gpgKeys" => Ok(__FieldTag::__gpg_keys),
                                        "gpg_keys" => Ok(__FieldTag::__gpg_keys),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ZypperRepository;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ZypperRepository")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__id => {
                                        if !fields.insert(__FieldTag::__id) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field("multiple values for id"),
                                            );
                                        }
                                        result.id = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__display_name => {
                                        if !fields.insert(__FieldTag::__display_name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for display_name",
                                                ),
                                            );
                                        }
                                        result.display_name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__base_url => {
                                        if !fields.insert(__FieldTag::__base_url) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for base_url",
                                                ),
                                            );
                                        }
                                        result.base_url = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__gpg_keys => {
                                        if !fields.insert(__FieldTag::__gpg_keys) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for gpg_keys",
                                                ),
                                            );
                                        }
                                        result.gpg_keys =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ZypperRepository {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.id.is_empty() {
                        state.serialize_entry("id", &self.id)?;
                    }
                    if !self.display_name.is_empty() {
                        state.serialize_entry("displayName", &self.display_name)?;
                    }
                    if !self.base_url.is_empty() {
                        state.serialize_entry("baseUrl", &self.base_url)?;
                    }
                    if !self.gpg_keys.is_empty() {
                        state.serialize_entry("gpgKeys", &self.gpg_keys)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ZypperRepository {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ZypperRepository");
                    debug_struct.field("id", &self.id);
                    debug_struct.field("display_name", &self.display_name);
                    debug_struct.field("base_url", &self.base_url);
                    debug_struct.field("gpg_keys", &self.gpg_keys);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a Goo package repository. These are added to a repo file
            /// that is managed at
            /// `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct GooRepository {
                /// Required. The name of the repository.
                pub name: std::string::String,

                /// Required. The url of the repository.
                pub url: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GooRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::repository_resource::GooRepository::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }

                /// Sets the value of [url][crate::model::os_policy::resource::repository_resource::GooRepository::url].
                pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.url = v.into();
                    self
                }
            }

            impl wkt::message::Message for GooRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.GooRepository"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for GooRepository {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __name,
                        __url,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for GooRepository")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "name" => Ok(__FieldTag::__name),
                                        "url" => Ok(__FieldTag::__url),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = GooRepository;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct GooRepository")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__name => {
                                        if !fields.insert(__FieldTag::__name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for name",
                                                ),
                                            );
                                        }
                                        result.name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__url => {
                                        if !fields.insert(__FieldTag::__url) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for url",
                                                ),
                                            );
                                        }
                                        result.url = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for GooRepository {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.name.is_empty() {
                        state.serialize_entry("name", &self.name)?;
                    }
                    if !self.url.is_empty() {
                        state.serialize_entry("url", &self.url)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for GooRepository {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("GooRepository");
                    debug_struct.field("name", &self.name);
                    debug_struct.field("url", &self.url);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A specific type of repository.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Repository {
                /// An Apt Repository.
                Apt(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::AptRepository,
                    >,
                ),
                /// A Yum Repository.
                Yum(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::YumRepository,
                    >,
                ),
                /// A Zypper Repository.
                Zypper(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::ZypperRepository,
                    >,
                ),
                /// A Goo Repository.
                Goo(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::GooRepository,
                    >,
                ),
            }
        }

        /// A resource that allows executing scripts on the VM.
        ///
        /// The `ExecResource` has 2 stages: `validate` and `enforce` and both stages
        /// accept a script as an argument to execute.
        ///
        /// When the `ExecResource` is applied by the agent, it first executes the
        /// script in the `validate` stage. The `validate` stage can signal that the
        /// `ExecResource` is already in the desired state by returning an exit code
        /// of `100`. If the `ExecResource` is not in the desired state, it should
        /// return an exit code of `101`. Any other exit code returned by this stage
        /// is considered an error.
        ///
        /// If the `ExecResource` is not in the desired state based on the exit code
        /// from the `validate` stage, the agent proceeds to execute the script from
        /// the `enforce` stage. If the `ExecResource` is already in the desired
        /// state, the `enforce` stage will not be run.
        /// Similar to `validate` stage, the `enforce` stage should return an exit
        /// code of `100` to indicate that the resource in now in its desired state.
        /// Any other exit code is considered an error.
        ///
        /// NOTE: An exit code of `100` was chosen over `0` (and `101` vs `1`) to
        /// have an explicit indicator of `in desired state`, `not in desired state`
        /// and errors. Because, for example, Powershell will always return an exit
        /// code of `0` unless an `exit` statement is provided in the script. So, for
        /// reasons of consistency and being explicit, exit codes `100` and `101`
        /// were chosen.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ExecResource {
            /// Required. What to run to validate this resource is in the desired
            /// state. An exit code of 100 indicates "in desired state", and exit code
            /// of 101 indicates "not in desired state". Any other exit code indicates
            /// a failure running validate.
            pub validate:
                std::option::Option<crate::model::os_policy::resource::exec_resource::Exec>,

            /// What to run to bring this resource into the desired state.
            /// An exit code of 100 indicates "success", any other exit code indicates
            /// a failure running enforce.
            pub enforce:
                std::option::Option<crate::model::os_policy::resource::exec_resource::Exec>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ExecResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [validate][crate::model::os_policy::resource::ExecResource::validate].
            pub fn set_validate<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::os_policy::resource::exec_resource::Exec>,
            {
                self.validate = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [validate][crate::model::os_policy::resource::ExecResource::validate].
            pub fn set_or_clear_validate<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::os_policy::resource::exec_resource::Exec>,
            {
                self.validate = v.map(|x| x.into());
                self
            }

            /// Sets the value of [enforce][crate::model::os_policy::resource::ExecResource::enforce].
            pub fn set_enforce<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::os_policy::resource::exec_resource::Exec>,
            {
                self.enforce = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [enforce][crate::model::os_policy::resource::ExecResource::enforce].
            pub fn set_or_clear_enforce<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::os_policy::resource::exec_resource::Exec>,
            {
                self.enforce = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ExecResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ExecResource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __validate,
                    __enforce,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ExecResource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "validate" => Ok(__FieldTag::__validate),
                                    "enforce" => Ok(__FieldTag::__enforce),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ExecResource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ExecResource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__validate => {
                                    if !fields.insert(__FieldTag::__validate) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for validate",
                                            ),
                                        );
                                    }
                                    result.validate = map
                                        .next_value::<std::option::Option<
                                            crate::model::os_policy::resource::exec_resource::Exec,
                                        >>()?;
                                }
                                __FieldTag::__enforce => {
                                    if !fields.insert(__FieldTag::__enforce) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for enforce",
                                            ),
                                        );
                                    }
                                    result.enforce = map.next_value::<std::option::Option<
                                        crate::model::os_policy::resource::exec_resource::Exec,
                                    >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ExecResource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.validate.is_some() {
                    state.serialize_entry("validate", &self.validate)?;
                }
                if self.enforce.is_some() {
                    state.serialize_entry("enforce", &self.enforce)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ExecResource {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ExecResource");
                debug_struct.field("validate", &self.validate);
                debug_struct.field("enforce", &self.enforce);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [ExecResource].
        pub mod exec_resource {
            #[allow(unused_imports)]
            use super::*;

            /// A file or script to execute.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Exec {
                /// Optional arguments to pass to the source during execution.
                pub args: std::vec::Vec<std::string::String>,

                /// Required. The script interpreter to use.
                pub interpreter:
                    crate::model::os_policy::resource::exec_resource::exec::Interpreter,

                /// Only recorded for enforce Exec.
                /// Path to an output file (that is created by this Exec) whose
                /// content will be recorded in OSPolicyResourceCompliance after a
                /// successful run. Absence or failure to read this file will result in
                /// this ExecResource being non-compliant. Output file size is limited to
                /// 100K bytes.
                pub output_file_path: std::string::String,

                /// What to execute.
                pub source: std::option::Option<
                    crate::model::os_policy::resource::exec_resource::exec::Source,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Exec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [args][crate::model::os_policy::resource::exec_resource::Exec::args].
                pub fn set_args<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.args = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [interpreter][crate::model::os_policy::resource::exec_resource::Exec::interpreter].
                pub fn set_interpreter<
                    T: std::convert::Into<
                            crate::model::os_policy::resource::exec_resource::exec::Interpreter,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.interpreter = v.into();
                    self
                }

                /// Sets the value of [output_file_path][crate::model::os_policy::resource::exec_resource::Exec::output_file_path].
                pub fn set_output_file_path<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.output_file_path = v.into();
                    self
                }

                /// Sets the value of [source][crate::model::os_policy::resource::exec_resource::Exec::source].
                ///
                /// Note that all the setters affecting `source` are mutually
                /// exclusive.
                pub fn set_source<
                    T: std::convert::Into<
                            std::option::Option<
                                crate::model::os_policy::resource::exec_resource::exec::Source,
                            >,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }

                /// The value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// if it holds a `File`, `None` if the field is not set or
                /// holds a different branch.
                pub fn file(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::File>>
                {
                    #[allow(unreachable_patterns)]
                    self.source.as_ref().and_then(|v| match v {
                        crate::model::os_policy::resource::exec_resource::exec::Source::File(v) => {
                            std::option::Option::Some(v)
                        }
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// to hold a `File`.
                ///
                /// Note that all the setters affecting `source` are
                /// mutually exclusive.
                pub fn set_file<
                    T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::File>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = std::option::Option::Some(
                        crate::model::os_policy::resource::exec_resource::exec::Source::File(
                            v.into(),
                        ),
                    );
                    self
                }

                /// The value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// if it holds a `Script`, `None` if the field is not set or
                /// holds a different branch.
                pub fn script(&self) -> std::option::Option<&std::string::String> {
                    #[allow(unreachable_patterns)]
                    self.source.as_ref().and_then(|v| match v {
                        crate::model::os_policy::resource::exec_resource::exec::Source::Script(
                            v,
                        ) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// to hold a `Script`.
                ///
                /// Note that all the setters affecting `source` are
                /// mutually exclusive.
                pub fn set_script<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = std::option::Option::Some(
                        crate::model::os_policy::resource::exec_resource::exec::Source::Script(
                            v.into(),
                        ),
                    );
                    self
                }
            }

            impl wkt::message::Message for Exec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Exec {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __file,
                        __script,
                        __args,
                        __interpreter,
                        __output_file_path,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Exec")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "file" => Ok(__FieldTag::__file),
                                        "script" => Ok(__FieldTag::__script),
                                        "args" => Ok(__FieldTag::__args),
                                        "interpreter" => Ok(__FieldTag::__interpreter),
                                        "outputFilePath" => Ok(__FieldTag::__output_file_path),
                                        "output_file_path" => Ok(__FieldTag::__output_file_path),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Exec;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Exec")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__file => {
                                        if !fields.insert(__FieldTag::__file) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for file",
                                                ),
                                            );
                                        }
                                        if result.source.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.file, latest field was file",
                                                ),
                                            );
                                        }
                                        result.source = std::option::Option::Some(
                                            crate::model::os_policy::resource::exec_resource::exec::Source::File(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::File>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__script => {
                                        if !fields.insert(__FieldTag::__script) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for script",
                                                ),
                                            );
                                        }
                                        if result.source.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.script, latest field was script",
                                                ),
                                            );
                                        }
                                        result.source = std::option::Option::Some(
                                            crate::model::os_policy::resource::exec_resource::exec::Source::Script(
                                                map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__args => {
                                        if !fields.insert(__FieldTag::__args) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for args",
                                                ),
                                            );
                                        }
                                        result.args =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__interpreter => {
                                        if !fields.insert(__FieldTag::__interpreter) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for interpreter",
                                                ),
                                            );
                                        }
                                        result.interpreter = map.next_value::<std::option::Option<crate::model::os_policy::resource::exec_resource::exec::Interpreter>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__output_file_path => {
                                        if !fields.insert(__FieldTag::__output_file_path) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for output_file_path",
                                                ),
                                            );
                                        }
                                        result.output_file_path = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Exec {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if let Some(value) = self.file() {
                        state.serialize_entry("file", value)?;
                    }
                    if let Some(value) = self.script() {
                        state.serialize_entry("script", value)?;
                    }
                    if !self.args.is_empty() {
                        state.serialize_entry("args", &self.args)?;
                    }
                    if !wkt::internal::is_default(&self.interpreter) {
                        state.serialize_entry("interpreter", &self.interpreter)?;
                    }
                    if !self.output_file_path.is_empty() {
                        state.serialize_entry("outputFilePath", &self.output_file_path)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Exec {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Exec");
                    debug_struct.field("args", &self.args);
                    debug_struct.field("interpreter", &self.interpreter);
                    debug_struct.field("output_file_path", &self.output_file_path);
                    debug_struct.field("source", &self.source);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Defines additional types related to [Exec].
            pub mod exec {
                #[allow(unused_imports)]
                use super::*;

                /// The interpreter to use.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Interpreter {
                    /// Invalid value, the request will return validation error.
                    Unspecified,
                    /// If an interpreter is not specified, the
                    /// source is executed directly. This execution, without an
                    /// interpreter, only succeeds for executables and scripts that have <a
                    /// href="https://en.wikipedia.org/wiki/Shebang_(Unix)"
                    /// class="external"\>shebang lines</a>.
                    None,
                    /// Indicates that the script runs with `/bin/sh` on Linux and
                    /// `cmd.exe` on Windows.
                    Shell,
                    /// Indicates that the script runs with PowerShell.
                    Powershell,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Interpreter::value] or
                    /// [Interpreter::name].
                    UnknownValue(interpreter::UnknownValue),
                }

                #[doc(hidden)]
                pub mod interpreter {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Interpreter {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::None => std::option::Option::Some(1),
                            Self::Shell => std::option::Option::Some(2),
                            Self::Powershell => std::option::Option::Some(3),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("INTERPRETER_UNSPECIFIED")
                            }
                            Self::None => std::option::Option::Some("NONE"),
                            Self::Shell => std::option::Option::Some("SHELL"),
                            Self::Powershell => std::option::Option::Some("POWERSHELL"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Interpreter {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Interpreter {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Interpreter {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::None,
                            2 => Self::Shell,
                            3 => Self::Powershell,
                            _ => Self::UnknownValue(interpreter::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Interpreter {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "INTERPRETER_UNSPECIFIED" => Self::Unspecified,
                            "NONE" => Self::None,
                            "SHELL" => Self::Shell,
                            "POWERSHELL" => Self::Powershell,
                            _ => Self::UnknownValue(interpreter::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Interpreter {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::None => serializer.serialize_i32(1),
                            Self::Shell => serializer.serialize_i32(2),
                            Self::Powershell => serializer.serialize_i32(3),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Interpreter {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Interpreter>::new(
                            ".google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.Interpreter"))
                    }
                }

                /// What to execute.
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Source {
                    /// A remote or local file.
                    File(std::boxed::Box<crate::model::os_policy::resource::File>),
                    /// An inline script.
                    /// The size of the script is limited to 1024 characters.
                    Script(std::string::String),
                }
            }
        }

        /// A resource that manages the state of a file.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FileResource {
            /// Required. The absolute path of the file within the VM.
            pub path: std::string::String,

            /// Required. Desired state of the file.
            pub state: crate::model::os_policy::resource::file_resource::DesiredState,

            /// Consists of three octal digits which represent, in
            /// order, the permissions of the owner, group, and other users for the
            /// file (similarly to the numeric mode used in the linux chmod
            /// utility). Each digit represents a three bit number with the 4 bit
            /// corresponding to the read permissions, the 2 bit corresponds to the
            /// write bit, and the one bit corresponds to the execute permission.
            /// Default behavior is 755.
            ///
            /// Below are some examples of permissions and their associated values:
            /// read, write, and execute: 7
            /// read and execute: 5
            /// read and write: 6
            /// read only: 4
            pub permissions: std::string::String,

            /// The source for the contents of the file.
            pub source:
                std::option::Option<crate::model::os_policy::resource::file_resource::Source>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FileResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [path][crate::model::os_policy::resource::FileResource::path].
            pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.path = v.into();
                self
            }

            /// Sets the value of [state][crate::model::os_policy::resource::FileResource::state].
            pub fn set_state<
                T: std::convert::Into<crate::model::os_policy::resource::file_resource::DesiredState>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.state = v.into();
                self
            }

            /// Sets the value of [permissions][crate::model::os_policy::resource::FileResource::permissions].
            pub fn set_permissions<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.permissions = v.into();
                self
            }

            /// Sets the value of [source][crate::model::os_policy::resource::FileResource::source].
            ///
            /// Note that all the setters affecting `source` are mutually
            /// exclusive.
            pub fn set_source<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::os_policy::resource::file_resource::Source,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.source = v.into();
                self
            }

            /// The value of [source][crate::model::os_policy::resource::FileResource::source]
            /// if it holds a `File`, `None` if the field is not set or
            /// holds a different branch.
            pub fn file(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::File>>
            {
                #[allow(unreachable_patterns)]
                self.source.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file_resource::Source::File(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [source][crate::model::os_policy::resource::FileResource::source]
            /// to hold a `File`.
            ///
            /// Note that all the setters affecting `source` are
            /// mutually exclusive.
            pub fn set_file<
                T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::File>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.source = std::option::Option::Some(
                    crate::model::os_policy::resource::file_resource::Source::File(v.into()),
                );
                self
            }

            /// The value of [source][crate::model::os_policy::resource::FileResource::source]
            /// if it holds a `Content`, `None` if the field is not set or
            /// holds a different branch.
            pub fn content(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.source.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file_resource::Source::Content(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [source][crate::model::os_policy::resource::FileResource::source]
            /// to hold a `Content`.
            ///
            /// Note that all the setters affecting `source` are
            /// mutually exclusive.
            pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.source = std::option::Option::Some(
                    crate::model::os_policy::resource::file_resource::Source::Content(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for FileResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.FileResource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FileResource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __file,
                    __content,
                    __path,
                    __state,
                    __permissions,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FileResource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "file" => Ok(__FieldTag::__file),
                                    "content" => Ok(__FieldTag::__content),
                                    "path" => Ok(__FieldTag::__path),
                                    "state" => Ok(__FieldTag::__state),
                                    "permissions" => Ok(__FieldTag::__permissions),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FileResource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FileResource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__file => {
                                    if !fields.insert(__FieldTag::__file) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for file"),
                                        );
                                    }
                                    if result.source.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.file, latest field was file",
                                            ),
                                        );
                                    }
                                    result.source = std::option::Option::Some(
                                        crate::model::os_policy::resource::file_resource::Source::File(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy::resource::File>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__content => {
                                    if !fields.insert(__FieldTag::__content) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for content",
                                            ),
                                        );
                                    }
                                    if result.source.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `source`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.content, latest field was content",
                                            ),
                                        );
                                    }
                                    result.source = std::option::Option::Some(
                                        crate::model::os_policy::resource::file_resource::Source::Content(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__path => {
                                    if !fields.insert(__FieldTag::__path) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for path"),
                                        );
                                    }
                                    result.path = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map.next_value::<std::option::Option<crate::model::os_policy::resource::file_resource::DesiredState>>()?.unwrap_or_default();
                                }
                                __FieldTag::__permissions => {
                                    if !fields.insert(__FieldTag::__permissions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for permissions",
                                            ),
                                        );
                                    }
                                    result.permissions = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FileResource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.file() {
                    state.serialize_entry("file", value)?;
                }
                if let Some(value) = self.content() {
                    state.serialize_entry("content", value)?;
                }
                if !self.path.is_empty() {
                    state.serialize_entry("path", &self.path)?;
                }
                if !wkt::internal::is_default(&self.state) {
                    state.serialize_entry("state", &self.state)?;
                }
                if !self.permissions.is_empty() {
                    state.serialize_entry("permissions", &self.permissions)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FileResource {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FileResource");
                debug_struct.field("path", &self.path);
                debug_struct.field("state", &self.state);
                debug_struct.field("permissions", &self.permissions);
                debug_struct.field("source", &self.source);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [FileResource].
        pub mod file_resource {
            #[allow(unused_imports)]
            use super::*;

            /// Desired state of the file.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum DesiredState {
                /// Unspecified is invalid.
                Unspecified,
                /// Ensure file at path is present.
                Present,
                /// Ensure file at path is absent.
                Absent,
                /// Ensure the contents of the file at path matches. If the file does
                /// not exist it will be created.
                ContentsMatch,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [DesiredState::value] or
                /// [DesiredState::name].
                UnknownValue(desired_state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod desired_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl DesiredState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Present => std::option::Option::Some(1),
                        Self::Absent => std::option::Option::Some(2),
                        Self::ContentsMatch => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("DESIRED_STATE_UNSPECIFIED"),
                        Self::Present => std::option::Option::Some("PRESENT"),
                        Self::Absent => std::option::Option::Some("ABSENT"),
                        Self::ContentsMatch => std::option::Option::Some("CONTENTS_MATCH"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for DesiredState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for DesiredState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for DesiredState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Present,
                        2 => Self::Absent,
                        3 => Self::ContentsMatch,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for DesiredState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "DESIRED_STATE_UNSPECIFIED" => Self::Unspecified,
                        "PRESENT" => Self::Present,
                        "ABSENT" => Self::Absent,
                        "CONTENTS_MATCH" => Self::ContentsMatch,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for DesiredState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Present => serializer.serialize_i32(1),
                        Self::Absent => serializer.serialize_i32(2),
                        Self::ContentsMatch => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for DesiredState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<DesiredState>::new(
                        ".google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.DesiredState",
                    ))
                }
            }

            /// The source for the contents of the file.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Source {
                /// A remote or local source.
                File(std::boxed::Box<crate::model::os_policy::resource::File>),
                /// A a file with this content.
                /// The size of the content is limited to 1024 characters.
                Content(std::string::String),
            }
        }

        /// Resource type.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ResourceType {
            /// Package resource
            Pkg(std::boxed::Box<crate::model::os_policy::resource::PackageResource>),
            /// Package repository resource
            Repository(std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>),
            /// Exec resource
            Exec(std::boxed::Box<crate::model::os_policy::resource::ExecResource>),
            /// File resource
            File(std::boxed::Box<crate::model::os_policy::resource::FileResource>),
        }
    }

    /// Resource groups provide a mechanism to group OS policy resources.
    ///
    /// Resource groups enable OS policy authors to create a single OS policy
    /// to be applied to VMs running different operating Systems.
    ///
    /// When the OS policy is applied to a target VM, the appropriate resource
    /// group within the OS policy is selected based on the `OSFilter` specified
    /// within the resource group.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceGroup {
        /// List of inventory filters for the resource group.
        ///
        /// The resources in this resource group are applied to the target VM if it
        /// satisfies at least one of the following inventory filters.
        ///
        /// For example, to apply this resource group to VMs running either `RHEL` or
        /// `CentOS` operating systems, specify 2 items for the list with following
        /// values:
        /// inventory_filters[0].os_short_name='rhel' and
        /// inventory_filters[1].os_short_name='centos'
        ///
        /// If the list is empty, this resource group will be applied to the target
        /// VM unconditionally.
        pub inventory_filters: std::vec::Vec<crate::model::os_policy::InventoryFilter>,

        /// Required. List of resources configured for this resource group.
        /// The resources are executed in the exact order specified here.
        pub resources: std::vec::Vec<crate::model::os_policy::Resource>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceGroup {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [inventory_filters][crate::model::os_policy::ResourceGroup::inventory_filters].
        pub fn set_inventory_filters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy::InventoryFilter>,
        {
            use std::iter::Iterator;
            self.inventory_filters = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [resources][crate::model::os_policy::ResourceGroup::resources].
        pub fn set_resources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy::Resource>,
        {
            use std::iter::Iterator;
            self.resources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ResourceGroup {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.ResourceGroup"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __inventory_filters,
                __resources,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceGroup")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inventoryFilters" => Ok(__FieldTag::__inventory_filters),
                                "inventory_filters" => Ok(__FieldTag::__inventory_filters),
                                "resources" => Ok(__FieldTag::__resources),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceGroup;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceGroup")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__inventory_filters => {
                                if !fields.insert(__FieldTag::__inventory_filters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inventory_filters",
                                    ));
                                }
                                result.inventory_filters = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::os_policy::InventoryFilter>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resources => {
                                if !fields.insert(__FieldTag::__resources) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resources",
                                    ));
                                }
                                result.resources = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::os_policy::Resource>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.inventory_filters.is_empty() {
                state.serialize_entry("inventoryFilters", &self.inventory_filters)?;
            }
            if !self.resources.is_empty() {
                state.serialize_entry("resources", &self.resources)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ResourceGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ResourceGroup");
            debug_struct.field("inventory_filters", &self.inventory_filters);
            debug_struct.field("resources", &self.resources);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Policy mode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Invalid mode
        Unspecified,
        /// This mode checks if the configuration resources in the policy are in
        /// their desired state. No actions are performed if they are not in the
        /// desired state. This mode is used for reporting purposes.
        Validation,
        /// This mode checks if the configuration resources in the policy are in
        /// their desired state, and if not, enforces the desired state.
        Enforcement,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Validation => std::option::Option::Some(1),
                Self::Enforcement => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Validation => std::option::Option::Some("VALIDATION"),
                Self::Enforcement => std::option::Option::Some("ENFORCEMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Validation,
                2 => Self::Enforcement,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "VALIDATION" => Self::Validation,
                "ENFORCEMENT" => Self::Enforcement,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Validation => serializer.serialize_i32(1),
                Self::Enforcement => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.osconfig.v1.OSPolicy.Mode",
            ))
        }
    }
}

/// Get a report of the OS policy assignment for a VM instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOSPolicyAssignmentReportRequest {
    /// Required. API resource name for OS policy assignment report.
    ///
    /// Format:
    /// `/projects/{project}/locations/{location}/instances/{instance}/osPolicyAssignments/{assignment}/report`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance_id}`, either Compute Engine `instance-id` or `instance-name`
    /// can be provided.
    /// For `{assignment_id}`, the OSPolicyAssignment id must be provided.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOSPolicyAssignmentReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOSPolicyAssignmentReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOSPolicyAssignmentReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetOSPolicyAssignmentReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOSPolicyAssignmentReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOSPolicyAssignmentReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOSPolicyAssignmentReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOSPolicyAssignmentReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOSPolicyAssignmentReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetOSPolicyAssignmentReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOSPolicyAssignmentReportRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List the OS policy assignment reports for VM instances.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentReportsRequest {
    /// Required. The parent resource name.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}/osPolicyAssignments/{assignment}/reports`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance}`, either `instance-name`, `instance-id`, or `-` can be
    /// provided. If '-' is provided, the response will include
    /// OSPolicyAssignmentReports for all instances in the project/location.
    /// For `{assignment}`, either `assignment-id` or `-` can be provided. If '-'
    /// is provided, the response will include OSPolicyAssignmentReports for all
    /// OSPolicyAssignments in the project/location.
    /// Either {instance} or {assignment} must be `-`.
    ///
    /// For example:
    /// `projects/{project}/locations/{location}/instances/{instance}/osPolicyAssignments/-/reports`
    /// returns all reports for the instance
    /// `projects/{project}/locations/{location}/instances/-/osPolicyAssignments/{assignment-id}/reports`
    /// returns all the reports for the given assignment across all instances.
    /// `projects/{project}/locations/{location}/instances/-/osPolicyAssignments/-/reports`
    /// returns all the reports for all assignments across all instances.
    pub parent: std::string::String,

    /// The maximum number of results to return.
    pub page_size: i32,

    /// If provided, this field specifies the criteria that must be met by the
    /// `OSPolicyAssignmentReport` API resource that is included in the response.
    pub filter: std::string::String,

    /// A pagination token returned from a previous call to the
    /// `ListOSPolicyAssignmentReports` method that indicates where this listing
    /// should continue from.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSPolicyAssignmentReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSPolicyAssignmentReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOSPolicyAssignmentReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSPolicyAssignmentReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentReportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSPolicyAssignmentReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __filter,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSPolicyAssignmentReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSPolicyAssignmentReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSPolicyAssignmentReportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOSPolicyAssignmentReportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOSPolicyAssignmentReportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing OS Policy assignment reports including the
/// page of results and page token.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentReportsResponse {
    /// List of OS policy assignment reports.
    pub os_policy_assignment_reports: std::vec::Vec<crate::model::OSPolicyAssignmentReport>,

    /// The pagination token to retrieve the next page of OS policy assignment
    /// report objects.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignment_reports][crate::model::ListOSPolicyAssignmentReportsResponse::os_policy_assignment_reports].
    pub fn set_os_policy_assignment_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicyAssignmentReport>,
    {
        use std::iter::Iterator;
        self.os_policy_assignment_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSPolicyAssignmentReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSPolicyAssignmentReportsResponse {
    type PageItem = crate::model::OSPolicyAssignmentReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_policy_assignment_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSPolicyAssignmentReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignment_reports,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListOSPolicyAssignmentReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignmentReports" => {
                                Ok(__FieldTag::__os_policy_assignment_reports)
                            }
                            "os_policy_assignment_reports" => {
                                Ok(__FieldTag::__os_policy_assignment_reports)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSPolicyAssignmentReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignment_reports => {
                            if !fields.insert(__FieldTag::__os_policy_assignment_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment_reports",
                                ));
                            }
                            result.os_policy_assignment_reports = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OSPolicyAssignmentReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSPolicyAssignmentReportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_policy_assignment_reports.is_empty() {
            state.serialize_entry(
                "osPolicyAssignmentReports",
                &self.os_policy_assignment_reports,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOSPolicyAssignmentReportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOSPolicyAssignmentReportsResponse");
        debug_struct.field(
            "os_policy_assignment_reports",
            &self.os_policy_assignment_reports,
        );
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A report of the OS policy assignment status for a given instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OSPolicyAssignmentReport {
    /// The `OSPolicyAssignmentReport` API resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/instances/{instance_id}/osPolicyAssignments/{os_policy_assignment_id}/report`
    pub name: std::string::String,

    /// The Compute Engine VM instance name.
    pub instance: std::string::String,

    /// Reference to the `OSPolicyAssignment` API resource that the `OSPolicy`
    /// belongs to.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
    pub os_policy_assignment: std::string::String,

    /// Compliance data for each `OSPolicy` that is applied to the VM.
    pub os_policy_compliances:
        std::vec::Vec<crate::model::os_policy_assignment_report::OSPolicyCompliance>,

    /// Timestamp for when the report was last generated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Unique identifier of the last attempted run to apply the OS policies
    /// associated with this assignment on the VM.
    ///
    /// This ID is logged by the OS Config agent while applying the OS
    /// policies associated with this assignment on the VM.
    /// NOTE: If the service is unable to successfully connect to the agent for
    /// this run, then this id will not be available in the agent logs.
    pub last_run_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicyAssignmentReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSPolicyAssignmentReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::OSPolicyAssignmentReport::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [os_policy_assignment][crate::model::OSPolicyAssignmentReport::os_policy_assignment].
    pub fn set_os_policy_assignment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment = v.into();
        self
    }

    /// Sets the value of [os_policy_compliances][crate::model::OSPolicyAssignmentReport::os_policy_compliances].
    pub fn set_os_policy_compliances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::os_policy_assignment_report::OSPolicyCompliance>,
    {
        use std::iter::Iterator;
        self.os_policy_compliances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::OSPolicyAssignmentReport::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::OSPolicyAssignmentReport::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_run_id][crate::model::OSPolicyAssignmentReport::last_run_id].
    pub fn set_last_run_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_run_id = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicyAssignmentReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OSPolicyAssignmentReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance,
            __os_policy_assignment,
            __os_policy_compliances,
            __update_time,
            __last_run_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyAssignmentReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instance" => Ok(__FieldTag::__instance),
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "osPolicyCompliances" => Ok(__FieldTag::__os_policy_compliances),
                            "os_policy_compliances" => Ok(__FieldTag::__os_policy_compliances),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastRunId" => Ok(__FieldTag::__last_run_id),
                            "last_run_id" => Ok(__FieldTag::__last_run_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OSPolicyAssignmentReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyAssignmentReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_compliances => {
                            if !fields.insert(__FieldTag::__os_policy_compliances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_compliances",
                                ));
                            }
                            result.os_policy_compliances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment_report::OSPolicyCompliance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_run_id => {
                            if !fields.insert(__FieldTag::__last_run_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_run_id",
                                ));
                            }
                            result.last_run_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OSPolicyAssignmentReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.os_policy_assignment.is_empty() {
            state.serialize_entry("osPolicyAssignment", &self.os_policy_assignment)?;
        }
        if !self.os_policy_compliances.is_empty() {
            state.serialize_entry("osPolicyCompliances", &self.os_policy_compliances)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.last_run_id.is_empty() {
            state.serialize_entry("lastRunId", &self.last_run_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OSPolicyAssignmentReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OSPolicyAssignmentReport");
        debug_struct.field("name", &self.name);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("os_policy_assignment", &self.os_policy_assignment);
        debug_struct.field("os_policy_compliances", &self.os_policy_compliances);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("last_run_id", &self.last_run_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OSPolicyAssignmentReport].
pub mod os_policy_assignment_report {
    #[allow(unused_imports)]
    use super::*;

    /// Compliance data for an OS policy
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OSPolicyCompliance {

        /// The OS policy id
        pub os_policy_id: std::string::String,

        /// The compliance state of the OS policy.
        pub compliance_state: crate::model::os_policy_assignment_report::os_policy_compliance::ComplianceState,

        /// The reason for the OS policy to be in an unknown compliance state.
        /// This field is always populated when `compliance_state` is `UNKNOWN`.
        ///
        /// If populated, the field can contain one of the following values:
        ///
        /// * `vm-not-running`: The VM was not running.
        /// * `os-policies-not-supported-by-agent`: The version of the OS Config
        ///   agent running on the VM does not support running OS policies.
        /// * `no-agent-detected`: The OS Config agent is not detected for the VM.
        /// * `resource-execution-errors`: The OS Config agent encountered errors
        ///   while executing one or more resources in the policy. See
        ///   `os_policy_resource_compliances` for details.
        /// * `task-timeout`: The task sent to the agent to apply the policy timed
        ///   out.
        /// * `unexpected-agent-state`: The OS Config agent did not report the final
        ///   status of the task that attempted to apply the policy. Instead, the agent
        ///   unexpectedly started working on a different task. This mostly happens
        ///   when the agent or VM unexpectedly restarts while applying OS policies.
        /// * `internal-service-errors`: Internal service errors were encountered
        ///   while attempting to apply the policy.
        pub compliance_state_reason: std::string::String,

        /// Compliance data for each resource within the policy that is applied to
        /// the VM.
        pub os_policy_resource_compliances: std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OSPolicyCompliance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [os_policy_id][crate::model::os_policy_assignment_report::OSPolicyCompliance::os_policy_id].
        pub fn set_os_policy_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.os_policy_id = v.into();
            self
        }

        /// Sets the value of [compliance_state][crate::model::os_policy_assignment_report::OSPolicyCompliance::compliance_state].
        pub fn set_compliance_state<T: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::ComplianceState>>(mut self, v: T) -> Self{
            self.compliance_state = v.into();
            self
        }

        /// Sets the value of [compliance_state_reason][crate::model::os_policy_assignment_report::OSPolicyCompliance::compliance_state_reason].
        pub fn set_compliance_state_reason<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.compliance_state_reason = v.into();
            self
        }

        /// Sets the value of [os_policy_resource_compliances][crate::model::os_policy_assignment_report::OSPolicyCompliance::os_policy_resource_compliances].
        pub fn set_os_policy_resource_compliances<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance>
        {
            use std::iter::Iterator;
            self.os_policy_resource_compliances = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for OSPolicyCompliance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OSPolicyCompliance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __os_policy_id,
                __compliance_state,
                __compliance_state_reason,
                __os_policy_resource_compliances,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OSPolicyCompliance")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "osPolicyId" => Ok(__FieldTag::__os_policy_id),
                                "os_policy_id" => Ok(__FieldTag::__os_policy_id),
                                "complianceState" => Ok(__FieldTag::__compliance_state),
                                "compliance_state" => Ok(__FieldTag::__compliance_state),
                                "complianceStateReason" => {
                                    Ok(__FieldTag::__compliance_state_reason)
                                }
                                "compliance_state_reason" => {
                                    Ok(__FieldTag::__compliance_state_reason)
                                }
                                "osPolicyResourceCompliances" => {
                                    Ok(__FieldTag::__os_policy_resource_compliances)
                                }
                                "os_policy_resource_compliances" => {
                                    Ok(__FieldTag::__os_policy_resource_compliances)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OSPolicyCompliance;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OSPolicyCompliance")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__os_policy_id => {
                                if !fields.insert(__FieldTag::__os_policy_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for os_policy_id",
                                    ));
                                }
                                result.os_policy_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__compliance_state => {
                                if !fields.insert(__FieldTag::__compliance_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compliance_state",
                                    ));
                                }
                                result.compliance_state = map.next_value::<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::ComplianceState>>()?.unwrap_or_default();
                            }
                            __FieldTag::__compliance_state_reason => {
                                if !fields.insert(__FieldTag::__compliance_state_reason) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compliance_state_reason",
                                    ));
                                }
                                result.compliance_state_reason = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__os_policy_resource_compliances => {
                                if !fields.insert(__FieldTag::__os_policy_resource_compliances) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for os_policy_resource_compliances",
                                    ));
                                }
                                result.os_policy_resource_compliances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OSPolicyCompliance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.os_policy_id.is_empty() {
                state.serialize_entry("osPolicyId", &self.os_policy_id)?;
            }
            if !wkt::internal::is_default(&self.compliance_state) {
                state.serialize_entry("complianceState", &self.compliance_state)?;
            }
            if !self.compliance_state_reason.is_empty() {
                state.serialize_entry("complianceStateReason", &self.compliance_state_reason)?;
            }
            if !self.os_policy_resource_compliances.is_empty() {
                state.serialize_entry(
                    "osPolicyResourceCompliances",
                    &self.os_policy_resource_compliances,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OSPolicyCompliance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OSPolicyCompliance");
            debug_struct.field("os_policy_id", &self.os_policy_id);
            debug_struct.field("compliance_state", &self.compliance_state);
            debug_struct.field("compliance_state_reason", &self.compliance_state_reason);
            debug_struct.field(
                "os_policy_resource_compliances",
                &self.os_policy_resource_compliances,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [OSPolicyCompliance].
    pub mod os_policy_compliance {
        #[allow(unused_imports)]
        use super::*;

        /// Compliance data for an OS policy resource.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct OSPolicyResourceCompliance {

            /// The ID of the OS policy resource.
            pub os_policy_resource_id: std::string::String,

            /// Ordered list of configuration completed by the agent for the OS policy
            /// resource.
            pub config_steps: std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep>,

            /// The compliance state of the resource.
            pub compliance_state: crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ComplianceState,

            /// A reason for the resource to be in the given compliance state.
            /// This field is always populated when `compliance_state` is `UNKNOWN`.
            ///
            /// The following values are supported when `compliance_state == UNKNOWN`
            ///
            /// * `execution-errors`: Errors were encountered by the agent while
            ///   executing the resource and the compliance state couldn't be
            ///   determined.
            /// * `execution-skipped-by-agent`: Resource execution was skipped by the
            ///   agent because errors were encountered while executing prior resources
            ///   in the OS policy.
            /// * `os-policy-execution-attempt-failed`: The execution of the OS policy
            ///   containing this resource failed and the compliance state couldn't be
            ///   determined.
            pub compliance_state_reason: std::string::String,

            /// Resource specific output.
            pub output: std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OSPolicyResourceCompliance {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [os_policy_resource_id][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::os_policy_resource_id].
            pub fn set_os_policy_resource_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.os_policy_resource_id = v.into();
                self
            }

            /// Sets the value of [config_steps][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::config_steps].
            pub fn set_config_steps<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep>
            {
                use std::iter::Iterator;
                self.config_steps = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [compliance_state][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::compliance_state].
            pub fn set_compliance_state<T: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ComplianceState>>(mut self, v: T) -> Self{
                self.compliance_state = v.into();
                self
            }

            /// Sets the value of [compliance_state_reason][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::compliance_state_reason].
            pub fn set_compliance_state_reason<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.compliance_state_reason = v.into();
                self
            }

            /// Sets the value of [output][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::output].
            ///
            /// Note that all the setters affecting `output` are mutually
            /// exclusive.
            pub fn set_output<T: std::convert::Into<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output>>>(mut self, v: T) -> Self
            {
                self.output = v.into();
                self
            }

            /// The value of [output][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::output]
            /// if it holds a `ExecResourceOutput`, `None` if the field is not set or
            /// holds a different branch.
            pub fn exec_resource_output(&self) -> std::option::Option<&std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>>{
                #[allow(unreachable_patterns)]
                self.output.as_ref().and_then(|v| match v {
                    crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output::ExecResourceOutput(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [output][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::output]
            /// to hold a `ExecResourceOutput`.
            ///
            /// Note that all the setters affecting `output` are
            /// mutually exclusive.
            pub fn set_exec_resource_output<T: std::convert::Into<std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>>>(mut self, v: T) -> Self{
                self.output = std::option::Option::Some(
                    crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output::ExecResourceOutput(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for OSPolicyResourceCompliance {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for OSPolicyResourceCompliance {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __os_policy_resource_id,
                    __config_steps,
                    __compliance_state,
                    __compliance_state_reason,
                    __exec_resource_output,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for OSPolicyResourceCompliance")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "osPolicyResourceId" => Ok(__FieldTag::__os_policy_resource_id),
                                    "os_policy_resource_id" => {
                                        Ok(__FieldTag::__os_policy_resource_id)
                                    }
                                    "configSteps" => Ok(__FieldTag::__config_steps),
                                    "config_steps" => Ok(__FieldTag::__config_steps),
                                    "complianceState" => Ok(__FieldTag::__compliance_state),
                                    "compliance_state" => Ok(__FieldTag::__compliance_state),
                                    "complianceStateReason" => {
                                        Ok(__FieldTag::__compliance_state_reason)
                                    }
                                    "compliance_state_reason" => {
                                        Ok(__FieldTag::__compliance_state_reason)
                                    }
                                    "execResourceOutput" => Ok(__FieldTag::__exec_resource_output),
                                    "exec_resource_output" => {
                                        Ok(__FieldTag::__exec_resource_output)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = OSPolicyResourceCompliance;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct OSPolicyResourceCompliance")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__os_policy_resource_id => {
                                    if !fields.insert(__FieldTag::__os_policy_resource_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for os_policy_resource_id",
                                            ),
                                        );
                                    }
                                    result.os_policy_resource_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__config_steps => {
                                    if !fields.insert(__FieldTag::__config_steps) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for config_steps",
                                            ),
                                        );
                                    }
                                    result.config_steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__compliance_state => {
                                    if !fields.insert(__FieldTag::__compliance_state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for compliance_state",
                                            ),
                                        );
                                    }
                                    result.compliance_state = map.next_value::<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ComplianceState>>()?.unwrap_or_default();
                                }
                                __FieldTag::__compliance_state_reason => {
                                    if !fields.insert(__FieldTag::__compliance_state_reason) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for compliance_state_reason",
                                            ),
                                        );
                                    }
                                    result.compliance_state_reason = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__exec_resource_output => {
                                    if !fields.insert(__FieldTag::__exec_resource_output) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for exec_resource_output",
                                            ),
                                        );
                                    }
                                    if result.output.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `output`, a oneof with full ID .google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.exec_resource_output, latest field was execResourceOutput",
                                            ),
                                        );
                                    }
                                    result.output = std::option::Option::Some(
                                        crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output::ExecResourceOutput(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for OSPolicyResourceCompliance {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.os_policy_resource_id.is_empty() {
                    state.serialize_entry("osPolicyResourceId", &self.os_policy_resource_id)?;
                }
                if !self.config_steps.is_empty() {
                    state.serialize_entry("configSteps", &self.config_steps)?;
                }
                if !wkt::internal::is_default(&self.compliance_state) {
                    state.serialize_entry("complianceState", &self.compliance_state)?;
                }
                if !self.compliance_state_reason.is_empty() {
                    state
                        .serialize_entry("complianceStateReason", &self.compliance_state_reason)?;
                }
                if let Some(value) = self.exec_resource_output() {
                    state.serialize_entry("execResourceOutput", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for OSPolicyResourceCompliance {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("OSPolicyResourceCompliance");
                debug_struct.field("os_policy_resource_id", &self.os_policy_resource_id);
                debug_struct.field("config_steps", &self.config_steps);
                debug_struct.field("compliance_state", &self.compliance_state);
                debug_struct.field("compliance_state_reason", &self.compliance_state_reason);
                debug_struct.field("output", &self.output);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [OSPolicyResourceCompliance].
        pub mod os_policy_resource_compliance {
            #[allow(unused_imports)]
            use super::*;

            /// Step performed by the OS Config agent for configuring an
            /// `OSPolicy` resource to its desired state.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct OSPolicyResourceConfigStep {

                /// Configuration step type.
                pub r#type: crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::os_policy_resource_config_step::Type,

                /// An error message recorded during the execution of this step.
                /// Only populated if errors were encountered during this step execution.
                pub error_message: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OSPolicyResourceConfigStep {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [r#type][crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep::type].
                pub fn set_type<T: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::os_policy_resource_config_step::Type>>(mut self, v: T) -> Self{
                    self.r#type = v.into();
                    self
                }

                /// Sets the value of [error_message][crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep::error_message].
                pub fn set_error_message<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.error_message = v.into();
                    self
                }
            }

            impl wkt::message::Message for OSPolicyResourceConfigStep {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for OSPolicyResourceConfigStep {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __type,
                        __error_message,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter
                                        .write_str("a field name for OSPolicyResourceConfigStep")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "type" => Ok(__FieldTag::__type),
                                        "errorMessage" => Ok(__FieldTag::__error_message),
                                        "error_message" => Ok(__FieldTag::__error_message),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = OSPolicyResourceConfigStep;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct OSPolicyResourceConfigStep")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__type => {
                                        if !fields.insert(__FieldTag::__type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for type",
                                                ),
                                            );
                                        }
                                        result.r#type = map.next_value::<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::os_policy_resource_config_step::Type>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__error_message => {
                                        if !fields.insert(__FieldTag::__error_message) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for error_message",
                                                ),
                                            );
                                        }
                                        result.error_message = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for OSPolicyResourceConfigStep {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.r#type) {
                        state.serialize_entry("type", &self.r#type)?;
                    }
                    if !self.error_message.is_empty() {
                        state.serialize_entry("errorMessage", &self.error_message)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for OSPolicyResourceConfigStep {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("OSPolicyResourceConfigStep");
                    debug_struct.field("r#type", &self.r#type);
                    debug_struct.field("error_message", &self.error_message);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Defines additional types related to [OSPolicyResourceConfigStep].
            pub mod os_policy_resource_config_step {
                #[allow(unused_imports)]
                use super::*;

                /// Supported configuration step types
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Type {
                    /// Default value. This value is unused.
                    Unspecified,
                    /// Checks for resource conflicts such as schema errors.
                    Validation,
                    /// Checks the current status of the desired state for a resource.
                    DesiredStateCheck,
                    /// Enforces the desired state for a resource that is not in desired
                    /// state.
                    DesiredStateEnforcement,
                    /// Re-checks the status of the desired state. This check is done
                    /// for a resource after the enforcement of all OS policies.
                    ///
                    /// This step is used to determine the final desired state status for
                    /// the resource. It accounts for any resources that might have drifted
                    /// from their desired state due to side effects from executing other
                    /// resources.
                    DesiredStateCheckPostEnforcement,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Type::value] or
                    /// [Type::name].
                    UnknownValue(r#type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod r#type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Type {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Validation => std::option::Option::Some(1),
                            Self::DesiredStateCheck => std::option::Option::Some(2),
                            Self::DesiredStateEnforcement => std::option::Option::Some(3),
                            Self::DesiredStateCheckPostEnforcement => std::option::Option::Some(4),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                            Self::Validation => std::option::Option::Some("VALIDATION"),
                            Self::DesiredStateCheck => {
                                std::option::Option::Some("DESIRED_STATE_CHECK")
                            }
                            Self::DesiredStateEnforcement => {
                                std::option::Option::Some("DESIRED_STATE_ENFORCEMENT")
                            }
                            Self::DesiredStateCheckPostEnforcement => {
                                std::option::Option::Some("DESIRED_STATE_CHECK_POST_ENFORCEMENT")
                            }
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Type {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Type {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Type {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Validation,
                            2 => Self::DesiredStateCheck,
                            3 => Self::DesiredStateEnforcement,
                            4 => Self::DesiredStateCheckPostEnforcement,
                            _ => Self::UnknownValue(r#type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Type {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "TYPE_UNSPECIFIED" => Self::Unspecified,
                            "VALIDATION" => Self::Validation,
                            "DESIRED_STATE_CHECK" => Self::DesiredStateCheck,
                            "DESIRED_STATE_ENFORCEMENT" => Self::DesiredStateEnforcement,
                            "DESIRED_STATE_CHECK_POST_ENFORCEMENT" => {
                                Self::DesiredStateCheckPostEnforcement
                            }
                            _ => Self::UnknownValue(r#type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Type {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Validation => serializer.serialize_i32(1),
                            Self::DesiredStateCheck => serializer.serialize_i32(2),
                            Self::DesiredStateEnforcement => serializer.serialize_i32(3),
                            Self::DesiredStateCheckPostEnforcement => serializer.serialize_i32(4),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Type {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                            ".google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep.Type"))
                    }
                }
            }

            /// ExecResource specific output.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ExecResourceOutput {
                /// Output from enforcement phase output file (if run).
                /// Output size is limited to 100K bytes.
                pub enforcement_output: ::bytes::Bytes,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ExecResourceOutput {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [enforcement_output][crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput::enforcement_output].
                pub fn set_enforcement_output<T: std::convert::Into<::bytes::Bytes>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.enforcement_output = v.into();
                    self
                }
            }

            impl wkt::message::Message for ExecResourceOutput {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ExecResourceOutput"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ExecResourceOutput {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __enforcement_output,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ExecResourceOutput")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "enforcementOutput" => Ok(__FieldTag::__enforcement_output),
                                        "enforcement_output" => {
                                            Ok(__FieldTag::__enforcement_output)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ExecResourceOutput;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ExecResourceOutput")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__enforcement_output => {
                                        if !fields.insert(__FieldTag::__enforcement_output) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for enforcement_output",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<::bytes::Bytes>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<serde_with::base64::Base64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.enforcement_output =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ExecResourceOutput {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.enforcement_output.is_empty() {
                        struct __With<'a>(&'a ::bytes::Bytes);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<serde_with::base64::Base64>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "enforcementOutput",
                            &__With(&self.enforcement_output),
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ExecResourceOutput {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ExecResourceOutput");
                    debug_struct.field("enforcement_output", &self.enforcement_output);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Possible compliance states for a resource.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ComplianceState {
                /// The resource is in an unknown compliance state.
                ///
                /// To get more details about why the policy is in this state, review
                /// the output of the `compliance_state_reason` field.
                Unknown,
                /// Resource is compliant.
                Compliant,
                /// Resource is non-compliant.
                NonCompliant,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ComplianceState::value] or
                /// [ComplianceState::name].
                UnknownValue(compliance_state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod compliance_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl ComplianceState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unknown => std::option::Option::Some(0),
                        Self::Compliant => std::option::Option::Some(1),
                        Self::NonCompliant => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unknown => std::option::Option::Some("UNKNOWN"),
                        Self::Compliant => std::option::Option::Some("COMPLIANT"),
                        Self::NonCompliant => std::option::Option::Some("NON_COMPLIANT"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for ComplianceState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for ComplianceState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for ComplianceState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unknown,
                        1 => Self::Compliant,
                        2 => Self::NonCompliant,
                        _ => Self::UnknownValue(compliance_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for ComplianceState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "UNKNOWN" => Self::Unknown,
                        "COMPLIANT" => Self::Compliant,
                        "NON_COMPLIANT" => Self::NonCompliant,
                        _ => Self::UnknownValue(compliance_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for ComplianceState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unknown => serializer.serialize_i32(0),
                        Self::Compliant => serializer.serialize_i32(1),
                        Self::NonCompliant => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for ComplianceState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComplianceState>::new(
                        ".google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ComplianceState"))
                }
            }

            /// Resource specific output.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Output {
                /// ExecResource specific output.
                ExecResourceOutput(std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>),
            }
        }

        /// Possible compliance states for an os policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ComplianceState {
            /// The policy is in an unknown compliance state.
            ///
            /// Refer to the field `compliance_state_reason` to learn the exact reason
            /// for the policy to be in this compliance state.
            Unknown,
            /// Policy is compliant.
            ///
            /// The policy is compliant if all the underlying resources are also
            /// compliant.
            Compliant,
            /// Policy is non-compliant.
            ///
            /// The policy is non-compliant if one or more underlying resources are
            /// non-compliant.
            NonCompliant,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ComplianceState::value] or
            /// [ComplianceState::name].
            UnknownValue(compliance_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod compliance_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ComplianceState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unknown => std::option::Option::Some(0),
                    Self::Compliant => std::option::Option::Some(1),
                    Self::NonCompliant => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::Compliant => std::option::Option::Some("COMPLIANT"),
                    Self::NonCompliant => std::option::Option::Some("NON_COMPLIANT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ComplianceState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ComplianceState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ComplianceState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unknown,
                    1 => Self::Compliant,
                    2 => Self::NonCompliant,
                    _ => Self::UnknownValue(compliance_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ComplianceState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN" => Self::Unknown,
                    "COMPLIANT" => Self::Compliant,
                    "NON_COMPLIANT" => Self::NonCompliant,
                    _ => Self::UnknownValue(compliance_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ComplianceState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unknown => serializer.serialize_i32(0),
                    Self::Compliant => serializer.serialize_i32(1),
                    Self::NonCompliant => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ComplianceState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComplianceState>::new(
                    ".google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.ComplianceState"))
            }
        }
    }
}

/// OS policy assignment is an API resource that is used to
/// apply a set of OS policies to a dynamically targeted group of Compute Engine
/// VM instances.
///
/// An OS policy is used to define the desired state configuration for a
/// Compute Engine VM instance through a set of configuration resources that
/// provide capabilities such as installing or removing software packages, or
/// executing a script.
///
/// For more information, see [OS policy and OS policy
/// assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OSPolicyAssignment {
    /// Resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id}`
    ///
    /// This field is ignored when you create an OS policy assignment.
    pub name: std::string::String,

    /// OS policy assignment description.
    /// Length of the description is limited to 1024 characters.
    pub description: std::string::String,

    /// Required. List of OS policies to be applied to the VMs.
    pub os_policies: std::vec::Vec<crate::model::OSPolicy>,

    /// Required. Filter to select VMs.
    pub instance_filter: std::option::Option<crate::model::os_policy_assignment::InstanceFilter>,

    /// Required. Rollout to deploy the OS policy assignment.
    /// A rollout is triggered in the following situations:
    ///
    /// 1. OSPolicyAssignment is created.
    /// 1. OSPolicyAssignment is updated and the update contains changes to one of
    ///    the following fields:
    ///    - instance_filter
    ///    - os_policies
    /// 1. OSPolicyAssignment is deleted.
    pub rollout: std::option::Option<crate::model::os_policy_assignment::Rollout>,

    /// Output only. The assignment revision ID
    /// A new revision is committed whenever a rollout is triggered for a OS policy
    /// assignment
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The etag for this OS policy assignment.
    /// If this is provided on update, it must match the server's etag.
    pub etag: std::string::String,

    /// Output only. OS policy assignment rollout state
    pub rollout_state: crate::model::os_policy_assignment::RolloutState,

    /// Output only. Indicates that this revision has been successfully rolled out
    /// in this zone and new VMs will be assigned OS policies from this revision.
    ///
    /// For a given OS policy assignment, there is only one revision with a value
    /// of `true` for this field.
    pub baseline: bool,

    /// Output only. Indicates that this revision deletes the OS policy assignment.
    pub deleted: bool,

    /// Output only. Indicates that reconciliation is in progress for the revision.
    /// This value is `true` when the `rollout_state` is one of:
    ///
    /// * IN_PROGRESS
    /// * CANCELLING
    pub reconciling: bool,

    /// Output only. Server generated unique id for the OS policy assignment
    /// resource.
    pub uid: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicyAssignment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSPolicyAssignment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSPolicyAssignment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [os_policies][crate::model::OSPolicyAssignment::os_policies].
    pub fn set_os_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicy>,
    {
        use std::iter::Iterator;
        self.os_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_filter][crate::model::OSPolicyAssignment::instance_filter].
    pub fn set_instance_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::os_policy_assignment::InstanceFilter>,
    {
        self.instance_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_filter][crate::model::OSPolicyAssignment::instance_filter].
    pub fn set_or_clear_instance_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::os_policy_assignment::InstanceFilter>,
    {
        self.instance_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout][crate::model::OSPolicyAssignment::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::os_policy_assignment::Rollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::OSPolicyAssignment::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::os_policy_assignment::Rollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision_id][crate::model::OSPolicyAssignment::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::OSPolicyAssignment::revision_create_time].
    pub fn set_revision_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [revision_create_time][crate::model::OSPolicyAssignment::revision_create_time].
    pub fn set_or_clear_revision_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::OSPolicyAssignment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [rollout_state][crate::model::OSPolicyAssignment::rollout_state].
    pub fn set_rollout_state<
        T: std::convert::Into<crate::model::os_policy_assignment::RolloutState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_state = v.into();
        self
    }

    /// Sets the value of [baseline][crate::model::OSPolicyAssignment::baseline].
    pub fn set_baseline<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.baseline = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::OSPolicyAssignment::deleted].
    pub fn set_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deleted = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::OSPolicyAssignment::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::OSPolicyAssignment::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicyAssignment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OSPolicyAssignment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __os_policies,
            __instance_filter,
            __rollout,
            __revision_id,
            __revision_create_time,
            __etag,
            __rollout_state,
            __baseline,
            __deleted,
            __reconciling,
            __uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyAssignment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "osPolicies" => Ok(__FieldTag::__os_policies),
                            "os_policies" => Ok(__FieldTag::__os_policies),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "revisionCreateTime" => Ok(__FieldTag::__revision_create_time),
                            "revision_create_time" => Ok(__FieldTag::__revision_create_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "rolloutState" => Ok(__FieldTag::__rollout_state),
                            "rollout_state" => Ok(__FieldTag::__rollout_state),
                            "baseline" => Ok(__FieldTag::__baseline),
                            "deleted" => Ok(__FieldTag::__deleted),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "uid" => Ok(__FieldTag::__uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OSPolicyAssignment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyAssignment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policies => {
                            if !fields.insert(__FieldTag::__os_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policies",
                                ));
                            }
                            result.os_policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OSPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<
                                crate::model::os_policy_assignment::InstanceFilter,
                            >>()?;
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout =
                                map.next_value::<std::option::Option<
                                    crate::model::os_policy_assignment::Rollout,
                                >>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_create_time => {
                            if !fields.insert(__FieldTag::__revision_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_create_time",
                                ));
                            }
                            result.revision_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_state => {
                            if !fields.insert(__FieldTag::__rollout_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_state",
                                ));
                            }
                            result.rollout_state = map
                                .next_value::<std::option::Option<
                                    crate::model::os_policy_assignment::RolloutState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__baseline => {
                            if !fields.insert(__FieldTag::__baseline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for baseline",
                                ));
                            }
                            result.baseline = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OSPolicyAssignment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.os_policies.is_empty() {
            state.serialize_entry("osPolicies", &self.os_policies)?;
        }
        if self.instance_filter.is_some() {
            state.serialize_entry("instanceFilter", &self.instance_filter)?;
        }
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if self.revision_create_time.is_some() {
            state.serialize_entry("revisionCreateTime", &self.revision_create_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.rollout_state) {
            state.serialize_entry("rolloutState", &self.rollout_state)?;
        }
        if !wkt::internal::is_default(&self.baseline) {
            state.serialize_entry("baseline", &self.baseline)?;
        }
        if !wkt::internal::is_default(&self.deleted) {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OSPolicyAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OSPolicyAssignment");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("os_policies", &self.os_policies);
        debug_struct.field("instance_filter", &self.instance_filter);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("revision_create_time", &self.revision_create_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("rollout_state", &self.rollout_state);
        debug_struct.field("baseline", &self.baseline);
        debug_struct.field("deleted", &self.deleted);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("uid", &self.uid);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OSPolicyAssignment].
pub mod os_policy_assignment {
    #[allow(unused_imports)]
    use super::*;

    /// Message representing label set.
    ///
    /// * A label is a key value pair set for a VM.
    /// * A LabelSet is a set of labels.
    /// * Labels within a LabelSet are ANDed. In other words, a LabelSet is
    ///   applicable for a VM only if it matches all the labels in the
    ///   LabelSet.
    /// * Example: A LabelSet with 2 labels: `env=prod` and `type=webserver` will
    ///   only be applicable for those VMs with both labels
    ///   present.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LabelSet {
        /// Labels are identified by key/value pairs in this map.
        /// A VM should contain all the key/value pairs specified in this
        /// map to be selected.
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LabelSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::os_policy_assignment::LabelSet::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for LabelSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.LabelSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LabelSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __labels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LabelSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "labels" => Ok(__FieldTag::__labels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LabelSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LabelSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LabelSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for LabelSet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("LabelSet");
            debug_struct.field("labels", &self.labels);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Filters to select target VMs for an assignment.
    ///
    /// If more than one filter criteria is specified below, a VM will be selected
    /// if and only if it satisfies all of them.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceFilter {
        /// Target all VMs in the project. If true, no other criteria is
        /// permitted.
        pub all: bool,

        /// List of label sets used for VM inclusion.
        ///
        /// If the list has more than one `LabelSet`, the VM is included if any
        /// of the label sets are applicable for the VM.
        pub inclusion_labels: std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,

        /// List of label sets used for VM exclusion.
        ///
        /// If the list has more than one label set, the VM is excluded if any
        /// of the label sets are applicable for the VM.
        pub exclusion_labels: std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,

        /// List of inventories to select VMs.
        ///
        /// A VM is selected if its inventory data matches at least one of the
        /// following inventories.
        pub inventories:
            std::vec::Vec<crate::model::os_policy_assignment::instance_filter::Inventory>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [all][crate::model::os_policy_assignment::InstanceFilter::all].
        pub fn set_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.all = v.into();
            self
        }

        /// Sets the value of [inclusion_labels][crate::model::os_policy_assignment::InstanceFilter::inclusion_labels].
        pub fn set_inclusion_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment::LabelSet>,
        {
            use std::iter::Iterator;
            self.inclusion_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclusion_labels][crate::model::os_policy_assignment::InstanceFilter::exclusion_labels].
        pub fn set_exclusion_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment::LabelSet>,
        {
            use std::iter::Iterator;
            self.exclusion_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [inventories][crate::model::os_policy_assignment::InstanceFilter::inventories].
        pub fn set_inventories<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment::instance_filter::Inventory>,
        {
            use std::iter::Iterator;
            self.inventories = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InstanceFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.InstanceFilter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InstanceFilter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __all,
                __inclusion_labels,
                __exclusion_labels,
                __inventories,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InstanceFilter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "all" => Ok(__FieldTag::__all),
                                "inclusionLabels" => Ok(__FieldTag::__inclusion_labels),
                                "inclusion_labels" => Ok(__FieldTag::__inclusion_labels),
                                "exclusionLabels" => Ok(__FieldTag::__exclusion_labels),
                                "exclusion_labels" => Ok(__FieldTag::__exclusion_labels),
                                "inventories" => Ok(__FieldTag::__inventories),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InstanceFilter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InstanceFilter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__all => {
                                if !fields.insert(__FieldTag::__all) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for all",
                                    ));
                                }
                                result.all = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__inclusion_labels => {
                                if !fields.insert(__FieldTag::__inclusion_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inclusion_labels",
                                    ));
                                }
                                result.inclusion_labels = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__exclusion_labels => {
                                if !fields.insert(__FieldTag::__exclusion_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exclusion_labels",
                                    ));
                                }
                                result.exclusion_labels = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__inventories => {
                                if !fields.insert(__FieldTag::__inventories) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inventories",
                                    ));
                                }
                                result.inventories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::os_policy_assignment::instance_filter::Inventory>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InstanceFilter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.all) {
                state.serialize_entry("all", &self.all)?;
            }
            if !self.inclusion_labels.is_empty() {
                state.serialize_entry("inclusionLabels", &self.inclusion_labels)?;
            }
            if !self.exclusion_labels.is_empty() {
                state.serialize_entry("exclusionLabels", &self.exclusion_labels)?;
            }
            if !self.inventories.is_empty() {
                state.serialize_entry("inventories", &self.inventories)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InstanceFilter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InstanceFilter");
            debug_struct.field("all", &self.all);
            debug_struct.field("inclusion_labels", &self.inclusion_labels);
            debug_struct.field("exclusion_labels", &self.exclusion_labels);
            debug_struct.field("inventories", &self.inventories);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [InstanceFilter].
    pub mod instance_filter {
        #[allow(unused_imports)]
        use super::*;

        /// VM inventory details.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Inventory {
            /// Required. The OS short name
            pub os_short_name: std::string::String,

            /// The OS version
            ///
            /// Prefix matches are supported if asterisk(*) is provided as the
            /// last character. For example, to match all versions with a major
            /// version of `7`, specify the following value for this field `7.*`
            ///
            /// An empty string matches all OS versions.
            pub os_version: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Inventory {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [os_short_name][crate::model::os_policy_assignment::instance_filter::Inventory::os_short_name].
            pub fn set_os_short_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.os_short_name = v.into();
                self
            }

            /// Sets the value of [os_version][crate::model::os_policy_assignment::instance_filter::Inventory::os_version].
            pub fn set_os_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.os_version = v.into();
                self
            }
        }

        impl wkt::message::Message for Inventory {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.InstanceFilter.Inventory"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Inventory {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __os_short_name,
                    __os_version,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Inventory")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "osShortName" => Ok(__FieldTag::__os_short_name),
                                    "os_short_name" => Ok(__FieldTag::__os_short_name),
                                    "osVersion" => Ok(__FieldTag::__os_version),
                                    "os_version" => Ok(__FieldTag::__os_version),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Inventory;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Inventory")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__os_short_name => {
                                    if !fields.insert(__FieldTag::__os_short_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for os_short_name",
                                            ),
                                        );
                                    }
                                    result.os_short_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__os_version => {
                                    if !fields.insert(__FieldTag::__os_version) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for os_version",
                                            ),
                                        );
                                    }
                                    result.os_version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Inventory {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.os_short_name.is_empty() {
                    state.serialize_entry("osShortName", &self.os_short_name)?;
                }
                if !self.os_version.is_empty() {
                    state.serialize_entry("osVersion", &self.os_version)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Inventory {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Inventory");
                debug_struct.field("os_short_name", &self.os_short_name);
                debug_struct.field("os_version", &self.os_version);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Message to configure the rollout at the zonal level for the OS policy
    /// assignment.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Rollout {
        /// Required. The maximum number (or percentage) of VMs per zone to disrupt
        /// at any given moment.
        pub disruption_budget: std::option::Option<crate::model::FixedOrPercent>,

        /// Required. This determines the minimum duration of time to wait after the
        /// configuration changes are applied through the current rollout. A
        /// VM continues to count towards the `disruption_budget` at least
        /// until this duration of time has passed after configuration changes are
        /// applied.
        pub min_wait_duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Rollout {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disruption_budget][crate::model::os_policy_assignment::Rollout::disruption_budget].
        pub fn set_disruption_budget<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::FixedOrPercent>,
        {
            self.disruption_budget = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [disruption_budget][crate::model::os_policy_assignment::Rollout::disruption_budget].
        pub fn set_or_clear_disruption_budget<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::FixedOrPercent>,
        {
            self.disruption_budget = v.map(|x| x.into());
            self
        }

        /// Sets the value of [min_wait_duration][crate::model::os_policy_assignment::Rollout::min_wait_duration].
        pub fn set_min_wait_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_wait_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_wait_duration][crate::model::os_policy_assignment::Rollout::min_wait_duration].
        pub fn set_or_clear_min_wait_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_wait_duration = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Rollout {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.Rollout"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Rollout {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __disruption_budget,
                __min_wait_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Rollout")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "disruptionBudget" => Ok(__FieldTag::__disruption_budget),
                                "disruption_budget" => Ok(__FieldTag::__disruption_budget),
                                "minWaitDuration" => Ok(__FieldTag::__min_wait_duration),
                                "min_wait_duration" => Ok(__FieldTag::__min_wait_duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Rollout;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Rollout")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__disruption_budget => {
                                if !fields.insert(__FieldTag::__disruption_budget) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disruption_budget",
                                    ));
                                }
                                result.disruption_budget = map.next_value::<std::option::Option<crate::model::FixedOrPercent>>()?
                                    ;
                            }
                            __FieldTag::__min_wait_duration => {
                                if !fields.insert(__FieldTag::__min_wait_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_wait_duration",
                                    ));
                                }
                                result.min_wait_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Rollout {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.disruption_budget.is_some() {
                state.serialize_entry("disruptionBudget", &self.disruption_budget)?;
            }
            if self.min_wait_duration.is_some() {
                state.serialize_entry("minWaitDuration", &self.min_wait_duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Rollout {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Rollout");
            debug_struct.field("disruption_budget", &self.disruption_budget);
            debug_struct.field("min_wait_duration", &self.min_wait_duration);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// OS policy assignment rollout state
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutState {
        /// Invalid value
        Unspecified,
        /// The rollout is in progress.
        InProgress,
        /// The rollout is being cancelled.
        Cancelling,
        /// The rollout is cancelled.
        Cancelled,
        /// The rollout has completed successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutState::value] or
        /// [RolloutState::name].
        UnknownValue(rollout_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Cancelling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutState>::new(
                ".google.cloud.osconfig.v1.OSPolicyAssignment.RolloutState",
            ))
        }
    }
}

/// OS policy assignment operation metadata provided by OS policy assignment API
/// methods that return long running operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OSPolicyAssignmentOperationMetadata {
    /// Reference to the `OSPolicyAssignment` API resource.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
    pub os_policy_assignment: std::string::String,

    /// The OS policy assignment API method.
    pub api_method: crate::model::os_policy_assignment_operation_metadata::APIMethod,

    /// State of the rollout
    pub rollout_state: crate::model::os_policy_assignment_operation_metadata::RolloutState,

    /// Rollout start time
    pub rollout_start_time: std::option::Option<wkt::Timestamp>,

    /// Rollout update time
    pub rollout_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicyAssignmentOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignment][crate::model::OSPolicyAssignmentOperationMetadata::os_policy_assignment].
    pub fn set_os_policy_assignment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment = v.into();
        self
    }

    /// Sets the value of [api_method][crate::model::OSPolicyAssignmentOperationMetadata::api_method].
    pub fn set_api_method<
        T: std::convert::Into<crate::model::os_policy_assignment_operation_metadata::APIMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.api_method = v.into();
        self
    }

    /// Sets the value of [rollout_state][crate::model::OSPolicyAssignmentOperationMetadata::rollout_state].
    pub fn set_rollout_state<
        T: std::convert::Into<crate::model::os_policy_assignment_operation_metadata::RolloutState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_state = v.into();
        self
    }

    /// Sets the value of [rollout_start_time][crate::model::OSPolicyAssignmentOperationMetadata::rollout_start_time].
    pub fn set_rollout_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.rollout_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_start_time][crate::model::OSPolicyAssignmentOperationMetadata::rollout_start_time].
    pub fn set_or_clear_rollout_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.rollout_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_update_time][crate::model::OSPolicyAssignmentOperationMetadata::rollout_update_time].
    pub fn set_rollout_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.rollout_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_update_time][crate::model::OSPolicyAssignmentOperationMetadata::rollout_update_time].
    pub fn set_or_clear_rollout_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.rollout_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OSPolicyAssignmentOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OSPolicyAssignmentOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignment,
            __api_method,
            __rollout_state,
            __rollout_start_time,
            __rollout_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OSPolicyAssignmentOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "apiMethod" => Ok(__FieldTag::__api_method),
                            "api_method" => Ok(__FieldTag::__api_method),
                            "rolloutState" => Ok(__FieldTag::__rollout_state),
                            "rollout_state" => Ok(__FieldTag::__rollout_state),
                            "rolloutStartTime" => Ok(__FieldTag::__rollout_start_time),
                            "rollout_start_time" => Ok(__FieldTag::__rollout_start_time),
                            "rolloutUpdateTime" => Ok(__FieldTag::__rollout_update_time),
                            "rollout_update_time" => Ok(__FieldTag::__rollout_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OSPolicyAssignmentOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OSPolicyAssignmentOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_method => {
                            if !fields.insert(__FieldTag::__api_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_method",
                                ));
                            }
                            result.api_method = map.next_value::<std::option::Option<crate::model::os_policy_assignment_operation_metadata::APIMethod>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rollout_state => {
                            if !fields.insert(__FieldTag::__rollout_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_state",
                                ));
                            }
                            result.rollout_state = map.next_value::<std::option::Option<crate::model::os_policy_assignment_operation_metadata::RolloutState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rollout_start_time => {
                            if !fields.insert(__FieldTag::__rollout_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_start_time",
                                ));
                            }
                            result.rollout_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rollout_update_time => {
                            if !fields.insert(__FieldTag::__rollout_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_update_time",
                                ));
                            }
                            result.rollout_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OSPolicyAssignmentOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_policy_assignment.is_empty() {
            state.serialize_entry("osPolicyAssignment", &self.os_policy_assignment)?;
        }
        if !wkt::internal::is_default(&self.api_method) {
            state.serialize_entry("apiMethod", &self.api_method)?;
        }
        if !wkt::internal::is_default(&self.rollout_state) {
            state.serialize_entry("rolloutState", &self.rollout_state)?;
        }
        if self.rollout_start_time.is_some() {
            state.serialize_entry("rolloutStartTime", &self.rollout_start_time)?;
        }
        if self.rollout_update_time.is_some() {
            state.serialize_entry("rolloutUpdateTime", &self.rollout_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OSPolicyAssignmentOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OSPolicyAssignmentOperationMetadata");
        debug_struct.field("os_policy_assignment", &self.os_policy_assignment);
        debug_struct.field("api_method", &self.api_method);
        debug_struct.field("rollout_state", &self.rollout_state);
        debug_struct.field("rollout_start_time", &self.rollout_start_time);
        debug_struct.field("rollout_update_time", &self.rollout_update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OSPolicyAssignmentOperationMetadata].
pub mod os_policy_assignment_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The OS policy assignment API method.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum APIMethod {
        /// Invalid value
        Unspecified,
        /// Create OS policy assignment API method
        Create,
        /// Update OS policy assignment API method
        Update,
        /// Delete OS policy assignment API method
        Delete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [APIMethod::value] or
        /// [APIMethod::name].
        UnknownValue(api_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod api_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl APIMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("API_METHOD_UNSPECIFIED"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for APIMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for APIMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for APIMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                _ => Self::UnknownValue(api_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for APIMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "API_METHOD_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                _ => Self::UnknownValue(api_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for APIMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for APIMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<APIMethod>::new(
                ".google.cloud.osconfig.v1.OSPolicyAssignmentOperationMetadata.APIMethod",
            ))
        }
    }

    /// State of the rollout
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutState {
        /// Invalid value
        Unspecified,
        /// The rollout is in progress.
        InProgress,
        /// The rollout is being cancelled.
        Cancelling,
        /// The rollout is cancelled.
        Cancelled,
        /// The rollout has completed successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutState::value] or
        /// [RolloutState::name].
        UnknownValue(rollout_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Cancelling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutState>::new(
                ".google.cloud.osconfig.v1.OSPolicyAssignmentOperationMetadata.RolloutState",
            ))
        }
    }
}

/// A request message to create an OS policy assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateOSPolicyAssignmentRequest {
    /// Required. The parent resource name in the form:
    /// projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Required. The OS policy assignment to be created.
    pub os_policy_assignment: std::option::Option<crate::model::OSPolicyAssignment>,

    /// Required. The logical name of the OS policy assignment in the project
    /// with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the project.
    pub os_policy_assignment_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOSPolicyAssignmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [os_policy_assignment][crate::model::CreateOSPolicyAssignmentRequest::os_policy_assignment].
    pub fn set_os_policy_assignment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        self.os_policy_assignment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [os_policy_assignment][crate::model::CreateOSPolicyAssignmentRequest::os_policy_assignment].
    pub fn set_or_clear_os_policy_assignment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        self.os_policy_assignment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [os_policy_assignment_id][crate::model::CreateOSPolicyAssignmentRequest::os_policy_assignment_id].
    pub fn set_os_policy_assignment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CreateOSPolicyAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __os_policy_assignment,
            __os_policy_assignment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "osPolicyAssignmentId" => Ok(__FieldTag::__os_policy_assignment_id),
                            "os_policy_assignment_id" => Ok(__FieldTag::__os_policy_assignment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map.next_value::<std::option::Option<crate::model::OSPolicyAssignment>>()?
                                ;
                        }
                        __FieldTag::__os_policy_assignment_id => {
                            if !fields.insert(__FieldTag::__os_policy_assignment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment_id",
                                ));
                            }
                            result.os_policy_assignment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateOSPolicyAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.os_policy_assignment.is_some() {
            state.serialize_entry("osPolicyAssignment", &self.os_policy_assignment)?;
        }
        if !self.os_policy_assignment_id.is_empty() {
            state.serialize_entry("osPolicyAssignmentId", &self.os_policy_assignment_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateOSPolicyAssignmentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("os_policy_assignment", &self.os_policy_assignment);
        debug_struct.field("os_policy_assignment_id", &self.os_policy_assignment_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message to update an OS policy assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateOSPolicyAssignmentRequest {
    /// Required. The updated OS policy assignment.
    pub os_policy_assignment: std::option::Option<crate::model::OSPolicyAssignment>,

    /// Optional. Field mask that controls which fields of the assignment should be
    /// updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignment][crate::model::UpdateOSPolicyAssignmentRequest::os_policy_assignment].
    pub fn set_os_policy_assignment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        self.os_policy_assignment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [os_policy_assignment][crate::model::UpdateOSPolicyAssignmentRequest::os_policy_assignment].
    pub fn set_or_clear_os_policy_assignment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        self.os_policy_assignment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateOSPolicyAssignmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateOSPolicyAssignmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.UpdateOSPolicyAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignment" => Ok(__FieldTag::__os_policy_assignment),
                            "os_policy_assignment" => Ok(__FieldTag::__os_policy_assignment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignment => {
                            if !fields.insert(__FieldTag::__os_policy_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignment",
                                ));
                            }
                            result.os_policy_assignment = map.next_value::<std::option::Option<crate::model::OSPolicyAssignment>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateOSPolicyAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.os_policy_assignment.is_some() {
            state.serialize_entry("osPolicyAssignment", &self.os_policy_assignment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateOSPolicyAssignmentRequest");
        debug_struct.field("os_policy_assignment", &self.os_policy_assignment);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message to get an OS policy assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOSPolicyAssignmentRequest {
    /// Required. The resource name of OS policy assignment.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/osPolicyAssignments/{os_policy_assignment}@{revisionId}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOSPolicyAssignmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetOSPolicyAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOSPolicyAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOSPolicyAssignmentRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message to list OS policy assignments for a parent resource
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentsRequest {
    /// Required. The parent resource name.
    pub parent: std::string::String,

    /// The maximum number of assignments to return.
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListOSPolicyAssignments` that indicates where this listing should continue
    /// from.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSPolicyAssignmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSPolicyAssignmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSPolicyAssignmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSPolicyAssignmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSPolicyAssignmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSPolicyAssignmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSPolicyAssignmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOSPolicyAssignmentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOSPolicyAssignmentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing all assignments under given parent.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentsResponse {
    /// The list of assignments
    pub os_policy_assignments: std::vec::Vec<crate::model::OSPolicyAssignment>,

    /// The pagination token to retrieve the next page of OS policy assignments.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignments][crate::model::ListOSPolicyAssignmentsResponse::os_policy_assignments].
    pub fn set_os_policy_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        use std::iter::Iterator;
        self.os_policy_assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSPolicyAssignmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSPolicyAssignmentsResponse {
    type PageItem = crate::model::OSPolicyAssignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_policy_assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSPolicyAssignmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOSPolicyAssignmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignments" => Ok(__FieldTag::__os_policy_assignments),
                            "os_policy_assignments" => Ok(__FieldTag::__os_policy_assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSPolicyAssignmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignments => {
                            if !fields.insert(__FieldTag::__os_policy_assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignments",
                                ));
                            }
                            result.os_policy_assignments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OSPolicyAssignment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSPolicyAssignmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_policy_assignments.is_empty() {
            state.serialize_entry("osPolicyAssignments", &self.os_policy_assignments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOSPolicyAssignmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOSPolicyAssignmentsResponse");
        debug_struct.field("os_policy_assignments", &self.os_policy_assignments);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message to list revisions for a OS policy assignment
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentRevisionsRequest {
    /// Required. The name of the OS policy assignment to list revisions for.
    pub name: std::string::String,

    /// The maximum number of revisions to return.
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListOSPolicyAssignmentRevisions` that indicates where this listing should
    /// continue from.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListOSPolicyAssignmentRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSPolicyAssignmentRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSPolicyAssignmentRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentRevisionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSPolicyAssignmentRevisionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListOSPolicyAssignmentRevisionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSPolicyAssignmentRevisionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentRevisionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSPolicyAssignmentRevisionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOSPolicyAssignmentRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOSPolicyAssignmentRevisionsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing all revisions for a OS policy assignment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentRevisionsResponse {
    /// The OS policy assignment revisions
    pub os_policy_assignments: std::vec::Vec<crate::model::OSPolicyAssignment>,

    /// The pagination token to retrieve the next page of OS policy assignment
    /// revisions.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignments][crate::model::ListOSPolicyAssignmentRevisionsResponse::os_policy_assignments].
    pub fn set_os_policy_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        use std::iter::Iterator;
        self.os_policy_assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSPolicyAssignmentRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSPolicyAssignmentRevisionsResponse {
    type PageItem = crate::model::OSPolicyAssignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_policy_assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOSPolicyAssignmentRevisionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_policy_assignments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListOSPolicyAssignmentRevisionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osPolicyAssignments" => Ok(__FieldTag::__os_policy_assignments),
                            "os_policy_assignments" => Ok(__FieldTag::__os_policy_assignments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOSPolicyAssignmentRevisionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOSPolicyAssignmentRevisionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_policy_assignments => {
                            if !fields.insert(__FieldTag::__os_policy_assignments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_policy_assignments",
                                ));
                            }
                            result.os_policy_assignments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OSPolicyAssignment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOSPolicyAssignmentRevisionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_policy_assignments.is_empty() {
            state.serialize_entry("osPolicyAssignments", &self.os_policy_assignments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOSPolicyAssignmentRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOSPolicyAssignmentRevisionsResponse");
        debug_struct.field("os_policy_assignments", &self.os_policy_assignments);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for deleting a OS policy assignment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteOSPolicyAssignmentRequest {
    /// Required. The name of the OS policy assignment to be deleted
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOSPolicyAssignmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.DeleteOSPolicyAssignmentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteOSPolicyAssignmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteOSPolicyAssignmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteOSPolicyAssignmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteOSPolicyAssignmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteOSPolicyAssignmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteOSPolicyAssignmentRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message encapsulating a value that can be either absolute ("fixed") or
/// relative ("percent") to a value.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FixedOrPercent {
    /// Type of the value.
    pub mode: std::option::Option<crate::model::fixed_or_percent::Mode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FixedOrPercent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::FixedOrPercent::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::fixed_or_percent::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::FixedOrPercent::mode]
    /// if it holds a `Fixed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::fixed_or_percent::Mode::Fixed(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::FixedOrPercent::mode]
    /// to hold a `Fixed`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_fixed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::fixed_or_percent::Mode::Fixed(v.into()));
        self
    }

    /// The value of [mode][crate::model::FixedOrPercent::mode]
    /// if it holds a `Percent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn percent(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::fixed_or_percent::Mode::Percent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::FixedOrPercent::mode]
    /// to hold a `Percent`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::fixed_or_percent::Mode::Percent(v.into()));
        self
    }
}

impl wkt::message::Message for FixedOrPercent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.FixedOrPercent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FixedOrPercent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fixed,
            __percent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FixedOrPercent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fixed" => Ok(__FieldTag::__fixed),
                            "percent" => Ok(__FieldTag::__percent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FixedOrPercent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FixedOrPercent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fixed => {
                            if !fields.insert(__FieldTag::__fixed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.osconfig.v1.FixedOrPercent.fixed, latest field was fixed",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::fixed_or_percent::Mode::Fixed(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.osconfig.v1.FixedOrPercent.percent, latest field was percent",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::fixed_or_percent::Mode::Percent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FixedOrPercent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.fixed() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fixed", &__With(value))?;
        }
        if let Some(value) = self.percent() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FixedOrPercent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FixedOrPercent");
        debug_struct.field("mode", &self.mode);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FixedOrPercent].
pub mod fixed_or_percent {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the value.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Specifies a fixed value.
        Fixed(i32),
        /// Specifies the relative value defined as a percentage, which will be
        /// multiplied by a reference value.
        Percent(i32),
    }
}

/// Patch deployments are configurations that individual patch jobs use to
/// complete a patch. These configurations include instance filter, package
/// repository settings, and a schedule. For more information about creating and
/// managing patch deployments, see [Scheduling patch
/// jobs](https://cloud.google.com/compute/docs/os-patch-management/schedule-patch-jobs).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchDeployment {
    /// Unique name for the patch deployment resource in a project. The patch
    /// deployment name is in the form:
    /// `projects/{project_id}/patchDeployments/{patch_deployment_id}`.
    /// This field is ignored when you create a new patch deployment.
    pub name: std::string::String,

    /// Optional. Description of the patch deployment. Length of the description is
    /// limited to 1024 characters.
    pub description: std::string::String,

    /// Required. VM instances to patch.
    pub instance_filter: std::option::Option<crate::model::PatchInstanceFilter>,

    /// Optional. Patch configuration that is applied.
    pub patch_config: std::option::Option<crate::model::PatchConfig>,

    /// Optional. Duration of the patch. After the duration ends, the patch times
    /// out.
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. Time the patch deployment was created. Timestamp is in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the patch deployment was last updated. Timestamp is in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time a patch job was started by this deployment.
    /// Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text
    /// format.
    pub last_execute_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Rollout strategy of the patch job.
    pub rollout: std::option::Option<crate::model::PatchRollout>,

    /// Output only. Current state of the patch deployment.
    pub state: crate::model::patch_deployment::State,

    /// Schedule for the patch.
    pub schedule: std::option::Option<crate::model::patch_deployment::Schedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PatchDeployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PatchDeployment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [instance_filter][crate::model::PatchDeployment::instance_filter].
    pub fn set_instance_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchInstanceFilter>,
    {
        self.instance_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_filter][crate::model::PatchDeployment::instance_filter].
    pub fn set_or_clear_instance_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchInstanceFilter>,
    {
        self.instance_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [patch_config][crate::model::PatchDeployment::patch_config].
    pub fn set_patch_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchConfig>,
    {
        self.patch_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_config][crate::model::PatchDeployment::patch_config].
    pub fn set_or_clear_patch_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchConfig>,
    {
        self.patch_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::PatchDeployment::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::PatchDeployment::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::PatchDeployment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PatchDeployment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PatchDeployment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PatchDeployment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_execute_time][crate::model::PatchDeployment::last_execute_time].
    pub fn set_last_execute_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_execute_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_execute_time][crate::model::PatchDeployment::last_execute_time].
    pub fn set_or_clear_last_execute_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_execute_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout][crate::model::PatchDeployment::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchRollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::PatchDeployment::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchRollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::PatchDeployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::patch_deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::PatchDeployment::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::patch_deployment::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::PatchDeployment::schedule]
    /// if it holds a `OneTimeSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn one_time_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OneTimeSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::patch_deployment::Schedule::OneTimeSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::PatchDeployment::schedule]
    /// to hold a `OneTimeSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_one_time_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::OneTimeSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::patch_deployment::Schedule::OneTimeSchedule(v.into()),
        );
        self
    }

    /// The value of [schedule][crate::model::PatchDeployment::schedule]
    /// if it holds a `RecurringSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recurring_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecurringSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::patch_deployment::Schedule::RecurringSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::PatchDeployment::schedule]
    /// to hold a `RecurringSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_recurring_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::RecurringSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::patch_deployment::Schedule::RecurringSchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PatchDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchDeployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __instance_filter,
            __patch_config,
            __duration,
            __one_time_schedule,
            __recurring_schedule,
            __create_time,
            __update_time,
            __last_execute_time,
            __rollout,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "patchConfig" => Ok(__FieldTag::__patch_config),
                            "patch_config" => Ok(__FieldTag::__patch_config),
                            "duration" => Ok(__FieldTag::__duration),
                            "oneTimeSchedule" => Ok(__FieldTag::__one_time_schedule),
                            "one_time_schedule" => Ok(__FieldTag::__one_time_schedule),
                            "recurringSchedule" => Ok(__FieldTag::__recurring_schedule),
                            "recurring_schedule" => Ok(__FieldTag::__recurring_schedule),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastExecuteTime" => Ok(__FieldTag::__last_execute_time),
                            "last_execute_time" => Ok(__FieldTag::__last_execute_time),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<crate::model::PatchInstanceFilter>>()?
                                ;
                        }
                        __FieldTag::__patch_config => {
                            if !fields.insert(__FieldTag::__patch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_config",
                                ));
                            }
                            result.patch_config =
                                map.next_value::<std::option::Option<crate::model::PatchConfig>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__one_time_schedule => {
                            if !fields.insert(__FieldTag::__one_time_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for one_time_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.osconfig.v1.PatchDeployment.one_time_schedule, latest field was oneTimeSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::patch_deployment::Schedule::OneTimeSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OneTimeSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__recurring_schedule => {
                            if !fields.insert(__FieldTag::__recurring_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurring_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.osconfig.v1.PatchDeployment.recurring_schedule, latest field was recurringSchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::patch_deployment::Schedule::RecurringSchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RecurringSchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_execute_time => {
                            if !fields.insert(__FieldTag::__last_execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execute_time",
                                ));
                            }
                            result.last_execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<crate::model::PatchRollout>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::patch_deployment::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchDeployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.instance_filter.is_some() {
            state.serialize_entry("instanceFilter", &self.instance_filter)?;
        }
        if self.patch_config.is_some() {
            state.serialize_entry("patchConfig", &self.patch_config)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if let Some(value) = self.one_time_schedule() {
            state.serialize_entry("oneTimeSchedule", value)?;
        }
        if let Some(value) = self.recurring_schedule() {
            state.serialize_entry("recurringSchedule", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_execute_time.is_some() {
            state.serialize_entry("lastExecuteTime", &self.last_execute_time)?;
        }
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PatchDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchDeployment");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("instance_filter", &self.instance_filter);
        debug_struct.field("patch_config", &self.patch_config);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("last_execute_time", &self.last_execute_time);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("state", &self.state);
        debug_struct.field("schedule", &self.schedule);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PatchDeployment].
pub mod patch_deployment {
    #[allow(unused_imports)]
    use super::*;

    /// Represents state of patch peployment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Active value means that patch deployment generates Patch Jobs.
        Active,
        /// Paused value means that patch deployment does not generate
        /// Patch jobs. Requires user action to move in and out from this state.
        Paused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Paused,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PAUSED" => Self::Paused,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.osconfig.v1.PatchDeployment.State",
            ))
        }
    }

    /// Schedule for the patch.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Required. Schedule a one-time execution.
        OneTimeSchedule(std::boxed::Box<crate::model::OneTimeSchedule>),
        /// Required. Schedule recurring executions.
        RecurringSchedule(std::boxed::Box<crate::model::RecurringSchedule>),
    }
}

/// Sets the time for a one time patch deployment. Timestamp is in
/// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OneTimeSchedule {
    /// Required. The desired patch job execution time.
    pub execute_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OneTimeSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execute_time][crate::model::OneTimeSchedule::execute_time].
    pub fn set_execute_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.execute_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execute_time][crate::model::OneTimeSchedule::execute_time].
    pub fn set_or_clear_execute_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.execute_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OneTimeSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OneTimeSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OneTimeSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execute_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OneTimeSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executeTime" => Ok(__FieldTag::__execute_time),
                            "execute_time" => Ok(__FieldTag::__execute_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OneTimeSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OneTimeSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execute_time => {
                            if !fields.insert(__FieldTag::__execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execute_time",
                                ));
                            }
                            result.execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OneTimeSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.execute_time.is_some() {
            state.serialize_entry("executeTime", &self.execute_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OneTimeSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OneTimeSchedule");
        debug_struct.field("execute_time", &self.execute_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sets the time for recurring patch deployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecurringSchedule {
    /// Required. Defines the time zone that `time_of_day` is relative to.
    /// The rules for daylight saving time are determined by the chosen time zone.
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Optional. The time that the recurring schedule becomes effective.
    /// Defaults to `create_time` of the patch deployment.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The end time at which a recurring patch deployment schedule is no
    /// longer active.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Required. Time of the day to run a recurring deployment.
    pub time_of_day: std::option::Option<gtype::model::TimeOfDay>,

    /// Required. The frequency unit of this recurring schedule.
    pub frequency: crate::model::recurring_schedule::Frequency,

    /// Output only. The time the last patch job ran successfully.
    pub last_execute_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the next patch job is scheduled to run.
    pub next_execute_time: std::option::Option<wkt::Timestamp>,

    /// Configurations for this recurring schedule.
    /// Configurations must match frequency.
    pub schedule_config: std::option::Option<crate::model::recurring_schedule::ScheduleConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecurringSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_zone][crate::model::RecurringSchedule::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::RecurringSchedule::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeZone>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::RecurringSchedule::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::RecurringSchedule::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::RecurringSchedule::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::RecurringSchedule::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_of_day][crate::model::RecurringSchedule::time_of_day].
    pub fn set_time_of_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.time_of_day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_of_day][crate::model::RecurringSchedule::time_of_day].
    pub fn set_or_clear_time_of_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.time_of_day = v.map(|x| x.into());
        self
    }

    /// Sets the value of [frequency][crate::model::RecurringSchedule::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::recurring_schedule::Frequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// Sets the value of [last_execute_time][crate::model::RecurringSchedule::last_execute_time].
    pub fn set_last_execute_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_execute_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_execute_time][crate::model::RecurringSchedule::last_execute_time].
    pub fn set_or_clear_last_execute_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_execute_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_execute_time][crate::model::RecurringSchedule::next_execute_time].
    pub fn set_next_execute_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_execute_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_execute_time][crate::model::RecurringSchedule::next_execute_time].
    pub fn set_or_clear_next_execute_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_execute_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule_config][crate::model::RecurringSchedule::schedule_config].
    ///
    /// Note that all the setters affecting `schedule_config` are mutually
    /// exclusive.
    pub fn set_schedule_config<
        T: std::convert::Into<std::option::Option<crate::model::recurring_schedule::ScheduleConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_config = v.into();
        self
    }

    /// The value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// if it holds a `Weekly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn weekly(&self) -> std::option::Option<&std::boxed::Box<crate::model::WeeklySchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule_config.as_ref().and_then(|v| match v {
            crate::model::recurring_schedule::ScheduleConfig::Weekly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// to hold a `Weekly`.
    ///
    /// Note that all the setters affecting `schedule_config` are
    /// mutually exclusive.
    pub fn set_weekly<T: std::convert::Into<std::boxed::Box<crate::model::WeeklySchedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_config = std::option::Option::Some(
            crate::model::recurring_schedule::ScheduleConfig::Weekly(v.into()),
        );
        self
    }

    /// The value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// if it holds a `Monthly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn monthly(&self) -> std::option::Option<&std::boxed::Box<crate::model::MonthlySchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule_config.as_ref().and_then(|v| match v {
            crate::model::recurring_schedule::ScheduleConfig::Monthly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// to hold a `Monthly`.
    ///
    /// Note that all the setters affecting `schedule_config` are
    /// mutually exclusive.
    pub fn set_monthly<T: std::convert::Into<std::boxed::Box<crate::model::MonthlySchedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_config = std::option::Option::Some(
            crate::model::recurring_schedule::ScheduleConfig::Monthly(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RecurringSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.RecurringSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecurringSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_zone,
            __start_time,
            __end_time,
            __time_of_day,
            __frequency,
            __weekly,
            __monthly,
            __last_execute_time,
            __next_execute_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecurringSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "timeOfDay" => Ok(__FieldTag::__time_of_day),
                            "time_of_day" => Ok(__FieldTag::__time_of_day),
                            "frequency" => Ok(__FieldTag::__frequency),
                            "weekly" => Ok(__FieldTag::__weekly),
                            "monthly" => Ok(__FieldTag::__monthly),
                            "lastExecuteTime" => Ok(__FieldTag::__last_execute_time),
                            "last_execute_time" => Ok(__FieldTag::__last_execute_time),
                            "nextExecuteTime" => Ok(__FieldTag::__next_execute_time),
                            "next_execute_time" => Ok(__FieldTag::__next_execute_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecurringSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecurringSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<gtype::model::TimeZone>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__time_of_day => {
                            if !fields.insert(__FieldTag::__time_of_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_of_day",
                                ));
                            }
                            result.time_of_day =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            result.frequency =
                                map.next_value::<std::option::Option<
                                    crate::model::recurring_schedule::Frequency,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__weekly => {
                            if !fields.insert(__FieldTag::__weekly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly",
                                ));
                            }
                            if result.schedule_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule_config`, a oneof with full ID .google.cloud.osconfig.v1.RecurringSchedule.weekly, latest field was weekly",
                                ));
                            }
                            result.schedule_config = std::option::Option::Some(
                                crate::model::recurring_schedule::ScheduleConfig::Weekly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WeeklySchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__monthly => {
                            if !fields.insert(__FieldTag::__monthly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monthly",
                                ));
                            }
                            if result.schedule_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule_config`, a oneof with full ID .google.cloud.osconfig.v1.RecurringSchedule.monthly, latest field was monthly",
                                ));
                            }
                            result.schedule_config = std::option::Option::Some(
                                crate::model::recurring_schedule::ScheduleConfig::Monthly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MonthlySchedule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__last_execute_time => {
                            if !fields.insert(__FieldTag::__last_execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_execute_time",
                                ));
                            }
                            result.last_execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_execute_time => {
                            if !fields.insert(__FieldTag::__next_execute_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_execute_time",
                                ));
                            }
                            result.next_execute_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecurringSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time_zone.is_some() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.time_of_day.is_some() {
            state.serialize_entry("timeOfDay", &self.time_of_day)?;
        }
        if !wkt::internal::is_default(&self.frequency) {
            state.serialize_entry("frequency", &self.frequency)?;
        }
        if let Some(value) = self.weekly() {
            state.serialize_entry("weekly", value)?;
        }
        if let Some(value) = self.monthly() {
            state.serialize_entry("monthly", value)?;
        }
        if self.last_execute_time.is_some() {
            state.serialize_entry("lastExecuteTime", &self.last_execute_time)?;
        }
        if self.next_execute_time.is_some() {
            state.serialize_entry("nextExecuteTime", &self.next_execute_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecurringSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecurringSchedule");
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("time_of_day", &self.time_of_day);
        debug_struct.field("frequency", &self.frequency);
        debug_struct.field("last_execute_time", &self.last_execute_time);
        debug_struct.field("next_execute_time", &self.next_execute_time);
        debug_struct.field("schedule_config", &self.schedule_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RecurringSchedule].
pub mod recurring_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the frequency of the recurring patch deployments.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Frequency {
        /// Invalid. A frequency must be specified.
        Unspecified,
        /// Indicates that the frequency of recurrence should be expressed in terms
        /// of weeks.
        Weekly,
        /// Indicates that the frequency of recurrence should be expressed in terms
        /// of months.
        Monthly,
        /// Indicates that the frequency of recurrence should be expressed in terms
        /// of days.
        Daily,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Frequency::value] or
        /// [Frequency::name].
        UnknownValue(frequency::UnknownValue),
    }

    #[doc(hidden)]
    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Frequency {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Weekly => std::option::Option::Some(1),
                Self::Monthly => std::option::Option::Some(2),
                Self::Daily => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FREQUENCY_UNSPECIFIED"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Frequency {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Frequency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Frequency {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Weekly,
                2 => Self::Monthly,
                3 => Self::Daily,
                _ => Self::UnknownValue(frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Frequency {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FREQUENCY_UNSPECIFIED" => Self::Unspecified,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "DAILY" => Self::Daily,
                _ => Self::UnknownValue(frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Frequency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Weekly => serializer.serialize_i32(1),
                Self::Monthly => serializer.serialize_i32(2),
                Self::Daily => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Frequency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Frequency>::new(
                ".google.cloud.osconfig.v1.RecurringSchedule.Frequency",
            ))
        }
    }

    /// Configurations for this recurring schedule.
    /// Configurations must match frequency.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScheduleConfig {
        /// Required. Schedule with weekly executions.
        Weekly(std::boxed::Box<crate::model::WeeklySchedule>),
        /// Required. Schedule with monthly executions.
        Monthly(std::boxed::Box<crate::model::MonthlySchedule>),
    }
}

/// Represents a weekly schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WeeklySchedule {
    /// Required. Day of the week.
    pub day_of_week: gtype::model::DayOfWeek,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_week][crate::model::WeeklySchedule::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }
}

impl wkt::message::Message for WeeklySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.WeeklySchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WeeklySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __day_of_week,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeeklySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WeeklySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeeklySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WeeklySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.day_of_week) {
            state.serialize_entry("dayOfWeek", &self.day_of_week)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WeeklySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WeeklySchedule");
        debug_struct.field("day_of_week", &self.day_of_week);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a monthly schedule. An example of a valid monthly schedule is
/// "on the third Tuesday of the month" or "on the 15th of the month".
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MonthlySchedule {
    /// One day in a month.
    pub day_of_month: std::option::Option<crate::model::monthly_schedule::DayOfMonth>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonthlySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_month][crate::model::MonthlySchedule::day_of_month].
    ///
    /// Note that all the setters affecting `day_of_month` are mutually
    /// exclusive.
    pub fn set_day_of_month<
        T: std::convert::Into<std::option::Option<crate::model::monthly_schedule::DayOfMonth>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.day_of_month = v.into();
        self
    }

    /// The value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// if it holds a `WeekDayOfMonth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn week_day_of_month(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WeekDayOfMonth>> {
        #[allow(unreachable_patterns)]
        self.day_of_month.as_ref().and_then(|v| match v {
            crate::model::monthly_schedule::DayOfMonth::WeekDayOfMonth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// to hold a `WeekDayOfMonth`.
    ///
    /// Note that all the setters affecting `day_of_month` are
    /// mutually exclusive.
    pub fn set_week_day_of_month<
        T: std::convert::Into<std::boxed::Box<crate::model::WeekDayOfMonth>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.day_of_month = std::option::Option::Some(
            crate::model::monthly_schedule::DayOfMonth::WeekDayOfMonth(v.into()),
        );
        self
    }

    /// The value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// if it holds a `MonthDay`, `None` if the field is not set or
    /// holds a different branch.
    pub fn month_day(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.day_of_month.as_ref().and_then(|v| match v {
            crate::model::monthly_schedule::DayOfMonth::MonthDay(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// to hold a `MonthDay`.
    ///
    /// Note that all the setters affecting `day_of_month` are
    /// mutually exclusive.
    pub fn set_month_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.day_of_month = std::option::Option::Some(
            crate::model::monthly_schedule::DayOfMonth::MonthDay(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MonthlySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.MonthlySchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MonthlySchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __week_day_of_month,
            __month_day,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonthlySchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weekDayOfMonth" => Ok(__FieldTag::__week_day_of_month),
                            "week_day_of_month" => Ok(__FieldTag::__week_day_of_month),
                            "monthDay" => Ok(__FieldTag::__month_day),
                            "month_day" => Ok(__FieldTag::__month_day),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MonthlySchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonthlySchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__week_day_of_month => {
                            if !fields.insert(__FieldTag::__week_day_of_month) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for week_day_of_month",
                                ));
                            }
                            if result.day_of_month.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `day_of_month`, a oneof with full ID .google.cloud.osconfig.v1.MonthlySchedule.week_day_of_month, latest field was weekDayOfMonth",
                                ));
                            }
                            result.day_of_month = std::option::Option::Some(
                                crate::model::monthly_schedule::DayOfMonth::WeekDayOfMonth(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WeekDayOfMonth>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__month_day => {
                            if !fields.insert(__FieldTag::__month_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for month_day",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.day_of_month.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `day_of_month`, a oneof with full ID .google.cloud.osconfig.v1.MonthlySchedule.month_day, latest field was monthDay",
                                ));
                            }
                            result.day_of_month = std::option::Option::Some(
                                crate::model::monthly_schedule::DayOfMonth::MonthDay(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MonthlySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.week_day_of_month() {
            state.serialize_entry("weekDayOfMonth", value)?;
        }
        if let Some(value) = self.month_day() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("monthDay", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MonthlySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonthlySchedule");
        debug_struct.field("day_of_month", &self.day_of_month);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MonthlySchedule].
pub mod monthly_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// One day in a month.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DayOfMonth {
        /// Required. Week day in a month.
        WeekDayOfMonth(std::boxed::Box<crate::model::WeekDayOfMonth>),
        /// Required. One day of the month. 1-31 indicates the 1st to the 31st day.
        /// -1 indicates the last day of the month. Months without the target day
        /// will be skipped. For example, a schedule to run "every month on the 31st"
        /// will not run in February, April, June, etc.
        MonthDay(i32),
    }
}

/// Represents one week day in a month. An example is "the 4th Sunday".
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WeekDayOfMonth {
    /// Required. Week number in a month. 1-4 indicates the 1st to 4th week of the
    /// month. -1 indicates the last week of the month.
    pub week_ordinal: i32,

    /// Required. A day of the week.
    pub day_of_week: gtype::model::DayOfWeek,

    /// Optional. Represents the number of days before or after the given week day
    /// of month that the patch deployment is scheduled for. For example if
    /// `week_ordinal` and `day_of_week` values point to the second day of the
    /// month and this `day_offset` value is set to `3`, the patch deployment takes
    /// place three days after the second Tuesday of the month. If this value is
    /// negative, for example -5, the patches are deployed five days before before
    /// the second Tuesday of the month. Allowed values are in range [-30, 30].
    pub day_offset: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeekDayOfMonth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [week_ordinal][crate::model::WeekDayOfMonth::week_ordinal].
    pub fn set_week_ordinal<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.week_ordinal = v.into();
        self
    }

    /// Sets the value of [day_of_week][crate::model::WeekDayOfMonth::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [day_offset][crate::model::WeekDayOfMonth::day_offset].
    pub fn set_day_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.day_offset = v.into();
        self
    }
}

impl wkt::message::Message for WeekDayOfMonth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.WeekDayOfMonth"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WeekDayOfMonth {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __week_ordinal,
            __day_of_week,
            __day_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeekDayOfMonth")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weekOrdinal" => Ok(__FieldTag::__week_ordinal),
                            "week_ordinal" => Ok(__FieldTag::__week_ordinal),
                            "dayOfWeek" => Ok(__FieldTag::__day_of_week),
                            "day_of_week" => Ok(__FieldTag::__day_of_week),
                            "dayOffset" => Ok(__FieldTag::__day_offset),
                            "day_offset" => Ok(__FieldTag::__day_offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WeekDayOfMonth;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeekDayOfMonth")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__week_ordinal => {
                            if !fields.insert(__FieldTag::__week_ordinal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for week_ordinal",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.week_ordinal = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__day_of_week => {
                            if !fields.insert(__FieldTag::__day_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_of_week",
                                ));
                            }
                            result.day_of_week = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__day_offset => {
                            if !fields.insert(__FieldTag::__day_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day_offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.day_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WeekDayOfMonth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.week_ordinal) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("weekOrdinal", &__With(&self.week_ordinal))?;
        }
        if !wkt::internal::is_default(&self.day_of_week) {
            state.serialize_entry("dayOfWeek", &self.day_of_week)?;
        }
        if !wkt::internal::is_default(&self.day_offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dayOffset", &__With(&self.day_offset))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WeekDayOfMonth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WeekDayOfMonth");
        debug_struct.field("week_ordinal", &self.week_ordinal);
        debug_struct.field("day_of_week", &self.day_of_week);
        debug_struct.field("day_offset", &self.day_offset);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for creating a patch deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePatchDeploymentRequest {
    /// Required. The project to apply this patch deployment to in the form
    /// `projects/*`.
    pub parent: std::string::String,

    /// Required. A name for the patch deployment in the project. When creating a
    /// name the following rules apply:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the project.
    pub patch_deployment_id: std::string::String,

    /// Required. The patch deployment to create.
    pub patch_deployment: std::option::Option<crate::model::PatchDeployment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePatchDeploymentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [patch_deployment_id][crate::model::CreatePatchDeploymentRequest::patch_deployment_id].
    pub fn set_patch_deployment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.patch_deployment_id = v.into();
        self
    }

    /// Sets the value of [patch_deployment][crate::model::CreatePatchDeploymentRequest::patch_deployment].
    pub fn set_patch_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchDeployment>,
    {
        self.patch_deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_deployment][crate::model::CreatePatchDeploymentRequest::patch_deployment].
    pub fn set_or_clear_patch_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchDeployment>,
    {
        self.patch_deployment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CreatePatchDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __patch_deployment_id,
            __patch_deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "patchDeploymentId" => Ok(__FieldTag::__patch_deployment_id),
                            "patch_deployment_id" => Ok(__FieldTag::__patch_deployment_id),
                            "patchDeployment" => Ok(__FieldTag::__patch_deployment),
                            "patch_deployment" => Ok(__FieldTag::__patch_deployment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__patch_deployment_id => {
                            if !fields.insert(__FieldTag::__patch_deployment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment_id",
                                ));
                            }
                            result.patch_deployment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__patch_deployment => {
                            if !fields.insert(__FieldTag::__patch_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment",
                                ));
                            }
                            result.patch_deployment = map
                                .next_value::<std::option::Option<crate::model::PatchDeployment>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePatchDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.patch_deployment_id.is_empty() {
            state.serialize_entry("patchDeploymentId", &self.patch_deployment_id)?;
        }
        if self.patch_deployment.is_some() {
            state.serialize_entry("patchDeployment", &self.patch_deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePatchDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePatchDeploymentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("patch_deployment_id", &self.patch_deployment_id);
        debug_struct.field("patch_deployment", &self.patch_deployment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for retrieving a patch deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetPatchDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPatchDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPatchDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPatchDeploymentRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for listing patch deployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPatchDeploymentsRequest {
    /// Required. The resource name of the parent in the form `projects/*`.
    pub parent: std::string::String,

    /// Optional. The maximum number of patch deployments to return. Default is
    /// 100.
    pub page_size: i32,

    /// Optional. A pagination token returned from a previous call to
    /// ListPatchDeployments that indicates where this listing should continue
    /// from.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPatchDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPatchDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPatchDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchDeploymentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPatchDeploymentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchDeploymentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPatchDeploymentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchDeploymentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPatchDeploymentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPatchDeploymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPatchDeploymentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing patch deployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPatchDeploymentsResponse {
    /// The list of patch deployments.
    pub patch_deployments: std::vec::Vec<crate::model::PatchDeployment>,

    /// A pagination token that can be used to get the next page of patch
    /// deployments.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_deployments][crate::model::ListPatchDeploymentsResponse::patch_deployments].
    pub fn set_patch_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PatchDeployment>,
    {
        use std::iter::Iterator;
        self.patch_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPatchDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPatchDeploymentsResponse {
    type PageItem = crate::model::PatchDeployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.patch_deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPatchDeploymentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_deployments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchDeploymentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchDeployments" => Ok(__FieldTag::__patch_deployments),
                            "patch_deployments" => Ok(__FieldTag::__patch_deployments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPatchDeploymentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchDeploymentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_deployments => {
                            if !fields.insert(__FieldTag::__patch_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployments",
                                ));
                            }
                            result.patch_deployments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PatchDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPatchDeploymentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patch_deployments.is_empty() {
            state.serialize_entry("patchDeployments", &self.patch_deployments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPatchDeploymentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPatchDeploymentsResponse");
        debug_struct.field("patch_deployments", &self.patch_deployments);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for deleting a patch deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.DeletePatchDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePatchDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePatchDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePatchDeploymentRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for updating a patch deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePatchDeploymentRequest {
    /// Required. The patch deployment to Update.
    pub patch_deployment: std::option::Option<crate::model::PatchDeployment>,

    /// Optional. Field mask that controls which fields of the patch deployment
    /// should be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_deployment][crate::model::UpdatePatchDeploymentRequest::patch_deployment].
    pub fn set_patch_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchDeployment>,
    {
        self.patch_deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_deployment][crate::model::UpdatePatchDeploymentRequest::patch_deployment].
    pub fn set_or_clear_patch_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchDeployment>,
    {
        self.patch_deployment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePatchDeploymentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePatchDeploymentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.UpdatePatchDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_deployment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchDeployment" => Ok(__FieldTag::__patch_deployment),
                            "patch_deployment" => Ok(__FieldTag::__patch_deployment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_deployment => {
                            if !fields.insert(__FieldTag::__patch_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment",
                                ));
                            }
                            result.patch_deployment = map
                                .next_value::<std::option::Option<crate::model::PatchDeployment>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePatchDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.patch_deployment.is_some() {
            state.serialize_entry("patchDeployment", &self.patch_deployment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdatePatchDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdatePatchDeploymentRequest");
        debug_struct.field("patch_deployment", &self.patch_deployment);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for pausing a patch deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PausePatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PausePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PausePatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PausePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PausePatchDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PausePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PausePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PausePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PausePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PausePatchDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PausePatchDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PausePatchDeploymentRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for resuming a patch deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumePatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumePatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ResumePatchDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumePatchDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumePatchDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumePatchDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumePatchDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumePatchDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumePatchDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumePatchDeploymentRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message to initiate patching across Compute Engine
/// instances.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutePatchJobRequest {
    /// Required. The project in which to run this patch in the form `projects/*`
    pub parent: std::string::String,

    /// Description of the patch job. Length of the description is limited
    /// to 1024 characters.
    pub description: std::string::String,

    /// Required. Instances to patch, either explicitly or filtered by some
    /// criteria such as zone or labels.
    pub instance_filter: std::option::Option<crate::model::PatchInstanceFilter>,

    /// Patch configuration being applied. If omitted, instances are
    /// patched using the default configurations.
    pub patch_config: std::option::Option<crate::model::PatchConfig>,

    /// Duration of the patch job. After the duration ends, the patch job
    /// times out.
    pub duration: std::option::Option<wkt::Duration>,

    /// If this patch is a dry-run only, instances are contacted but
    /// will do nothing.
    pub dry_run: bool,

    /// Display name for this patch job. This does not have to be unique.
    pub display_name: std::string::String,

    /// Rollout strategy of the patch job.
    pub rollout: std::option::Option<crate::model::PatchRollout>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutePatchJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExecutePatchJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ExecutePatchJobRequest::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [instance_filter][crate::model::ExecutePatchJobRequest::instance_filter].
    pub fn set_instance_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchInstanceFilter>,
    {
        self.instance_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_filter][crate::model::ExecutePatchJobRequest::instance_filter].
    pub fn set_or_clear_instance_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchInstanceFilter>,
    {
        self.instance_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [patch_config][crate::model::ExecutePatchJobRequest::patch_config].
    pub fn set_patch_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchConfig>,
    {
        self.patch_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_config][crate::model::ExecutePatchJobRequest::patch_config].
    pub fn set_or_clear_patch_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchConfig>,
    {
        self.patch_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::ExecutePatchJobRequest::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::ExecutePatchJobRequest::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dry_run][crate::model::ExecutePatchJobRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ExecutePatchJobRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::ExecutePatchJobRequest::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchRollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::ExecutePatchJobRequest::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchRollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecutePatchJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ExecutePatchJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutePatchJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __description,
            __instance_filter,
            __patch_config,
            __duration,
            __dry_run,
            __display_name,
            __rollout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutePatchJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "description" => Ok(__FieldTag::__description),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "patchConfig" => Ok(__FieldTag::__patch_config),
                            "patch_config" => Ok(__FieldTag::__patch_config),
                            "duration" => Ok(__FieldTag::__duration),
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "rollout" => Ok(__FieldTag::__rollout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutePatchJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutePatchJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<crate::model::PatchInstanceFilter>>()?
                                ;
                        }
                        __FieldTag::__patch_config => {
                            if !fields.insert(__FieldTag::__patch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_config",
                                ));
                            }
                            result.patch_config =
                                map.next_value::<std::option::Option<crate::model::PatchConfig>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<crate::model::PatchRollout>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutePatchJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.instance_filter.is_some() {
            state.serialize_entry("instanceFilter", &self.instance_filter)?;
        }
        if self.patch_config.is_some() {
            state.serialize_entry("patchConfig", &self.patch_config)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !wkt::internal::is_default(&self.dry_run) {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecutePatchJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutePatchJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("description", &self.description);
        debug_struct.field("instance_filter", &self.instance_filter);
        debug_struct.field("patch_config", &self.patch_config);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("dry_run", &self.dry_run);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("rollout", &self.rollout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get an active or completed patch job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPatchJobRequest {
    /// Required. Name of the patch in the form `projects/*/patchJobs/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPatchJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPatchJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPatchJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetPatchJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPatchJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPatchJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPatchJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPatchJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPatchJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPatchJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPatchJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list details for all instances that are part of a patch job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPatchJobInstanceDetailsRequest {
    /// Required. The parent for the instances are in the form of
    /// `projects/*/patchJobs/*`.
    pub parent: std::string::String,

    /// The maximum number of instance details records to return.  Default is 100.
    pub page_size: i32,

    /// A pagination token returned from a previous call
    /// that indicates where this listing should continue from.
    pub page_token: std::string::String,

    /// A filter expression that filters results listed in the response. This
    /// field supports filtering results by instance zone, name, state, or
    /// `failure_reason`.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobInstanceDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPatchJobInstanceDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPatchJobInstanceDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPatchJobInstanceDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPatchJobInstanceDetailsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobInstanceDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobInstanceDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPatchJobInstanceDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobInstanceDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPatchJobInstanceDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobInstanceDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPatchJobInstanceDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPatchJobInstanceDetailsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPatchJobInstanceDetailsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing the instances details for a patch job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPatchJobInstanceDetailsResponse {
    /// A list of instance status.
    pub patch_job_instance_details: std::vec::Vec<crate::model::PatchJobInstanceDetails>,

    /// A pagination token that can be used to get the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobInstanceDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_job_instance_details][crate::model::ListPatchJobInstanceDetailsResponse::patch_job_instance_details].
    pub fn set_patch_job_instance_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PatchJobInstanceDetails>,
    {
        use std::iter::Iterator;
        self.patch_job_instance_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPatchJobInstanceDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobInstanceDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobInstanceDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPatchJobInstanceDetailsResponse {
    type PageItem = crate::model::PatchJobInstanceDetails;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.patch_job_instance_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPatchJobInstanceDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_job_instance_details,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobInstanceDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchJobInstanceDetails" => {
                                Ok(__FieldTag::__patch_job_instance_details)
                            }
                            "patch_job_instance_details" => {
                                Ok(__FieldTag::__patch_job_instance_details)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPatchJobInstanceDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobInstanceDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_job_instance_details => {
                            if !fields.insert(__FieldTag::__patch_job_instance_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_job_instance_details",
                                ));
                            }
                            result.patch_job_instance_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PatchJobInstanceDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPatchJobInstanceDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patch_job_instance_details.is_empty() {
            state.serialize_entry("patchJobInstanceDetails", &self.patch_job_instance_details)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPatchJobInstanceDetailsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPatchJobInstanceDetailsResponse");
        debug_struct.field(
            "patch_job_instance_details",
            &self.patch_job_instance_details,
        );
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Patch details for a VM instance. For more information about reviewing VM
/// instance details, see
/// [Listing all VM instance details for a specific patch
/// job](https://cloud.google.com/compute/docs/os-patch-management/manage-patch-jobs#list-instance-details).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchJobInstanceDetails {
    /// The instance name in the form `projects/*/zones/*/instances/*`
    pub name: std::string::String,

    /// The unique identifier for the instance. This identifier is
    /// defined by the server.
    pub instance_system_id: std::string::String,

    /// Current state of instance patch.
    pub state: crate::model::instance::PatchState,

    /// If the patch fails, this field provides the reason.
    pub failure_reason: std::string::String,

    /// The number of times the agent that the agent attempts to apply the patch.
    pub attempt_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchJobInstanceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PatchJobInstanceDetails::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_system_id][crate::model::PatchJobInstanceDetails::instance_system_id].
    pub fn set_instance_system_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_system_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PatchJobInstanceDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::PatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [failure_reason][crate::model::PatchJobInstanceDetails::failure_reason].
    pub fn set_failure_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_reason = v.into();
        self
    }

    /// Sets the value of [attempt_count][crate::model::PatchJobInstanceDetails::attempt_count].
    pub fn set_attempt_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.attempt_count = v.into();
        self
    }
}

impl wkt::message::Message for PatchJobInstanceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchJobInstanceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchJobInstanceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __instance_system_id,
            __state,
            __failure_reason,
            __attempt_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchJobInstanceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "instanceSystemId" => Ok(__FieldTag::__instance_system_id),
                            "instance_system_id" => Ok(__FieldTag::__instance_system_id),
                            "state" => Ok(__FieldTag::__state),
                            "failureReason" => Ok(__FieldTag::__failure_reason),
                            "failure_reason" => Ok(__FieldTag::__failure_reason),
                            "attemptCount" => Ok(__FieldTag::__attempt_count),
                            "attempt_count" => Ok(__FieldTag::__attempt_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchJobInstanceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchJobInstanceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_system_id => {
                            if !fields.insert(__FieldTag::__instance_system_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_system_id",
                                ));
                            }
                            result.instance_system_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::instance::PatchState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failure_reason => {
                            if !fields.insert(__FieldTag::__failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_reason",
                                ));
                            }
                            result.failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attempt_count => {
                            if !fields.insert(__FieldTag::__attempt_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempt_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attempt_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchJobInstanceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instance_system_id.is_empty() {
            state.serialize_entry("instanceSystemId", &self.instance_system_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.failure_reason.is_empty() {
            state.serialize_entry("failureReason", &self.failure_reason)?;
        }
        if !wkt::internal::is_default(&self.attempt_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("attemptCount", &__With(&self.attempt_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PatchJobInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchJobInstanceDetails");
        debug_struct.field("name", &self.name);
        debug_struct.field("instance_system_id", &self.instance_system_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("failure_reason", &self.failure_reason);
        debug_struct.field("attempt_count", &self.attempt_count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for listing patch jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPatchJobsRequest {
    /// Required. In the form of `projects/*`
    pub parent: std::string::String,

    /// The maximum number of instance status to return.
    pub page_size: i32,

    /// A pagination token returned from a previous call
    /// that indicates where this listing should continue from.
    pub page_token: std::string::String,

    /// If provided, this field specifies the criteria that must be met by patch
    /// jobs to be included in the response.
    /// Currently, filtering is only available on the patch_deployment field.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPatchJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPatchJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPatchJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPatchJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPatchJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPatchJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPatchJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPatchJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPatchJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing patch jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPatchJobsResponse {
    /// The list of patch jobs.
    pub patch_jobs: std::vec::Vec<crate::model::PatchJob>,

    /// A pagination token that can be used to get the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_jobs][crate::model::ListPatchJobsResponse::patch_jobs].
    pub fn set_patch_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PatchJob>,
    {
        use std::iter::Iterator;
        self.patch_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPatchJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPatchJobsResponse {
    type PageItem = crate::model::PatchJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.patch_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPatchJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPatchJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchJobs" => Ok(__FieldTag::__patch_jobs),
                            "patch_jobs" => Ok(__FieldTag::__patch_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPatchJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPatchJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_jobs => {
                            if !fields.insert(__FieldTag::__patch_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_jobs",
                                ));
                            }
                            result.patch_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PatchJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPatchJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.patch_jobs.is_empty() {
            state.serialize_entry("patchJobs", &self.patch_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPatchJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPatchJobsResponse");
        debug_struct.field("patch_jobs", &self.patch_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A high level representation of a patch job that is either in progress
/// or has completed.
///
/// Instance details are not included in the job. To paginate through instance
/// details, use ListPatchJobInstanceDetails.
///
/// For more information about patch jobs, see
/// [Creating patch
/// jobs](https://cloud.google.com/compute/docs/os-patch-management/create-patch-job).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchJob {
    /// Unique identifier for this patch job in the form
    /// `projects/*/patchJobs/*`
    pub name: std::string::String,

    /// Display name for this patch job. This is not a unique identifier.
    pub display_name: std::string::String,

    /// Description of the patch job. Length of the description is limited
    /// to 1024 characters.
    pub description: std::string::String,

    /// Time this patch job was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Last time this patch job was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The current state of the PatchJob.
    pub state: crate::model::patch_job::State,

    /// Instances to patch.
    pub instance_filter: std::option::Option<crate::model::PatchInstanceFilter>,

    /// Patch configuration being applied.
    pub patch_config: std::option::Option<crate::model::PatchConfig>,

    /// Duration of the patch job. After the duration ends, the
    /// patch job times out.
    pub duration: std::option::Option<wkt::Duration>,

    /// Summary of instance details.
    pub instance_details_summary:
        std::option::Option<crate::model::patch_job::InstanceDetailsSummary>,

    /// If this patch job is a dry run, the agent reports that it has
    /// finished without running any updates on the VM instance.
    pub dry_run: bool,

    /// If this patch job failed, this message provides information about the
    /// failure.
    pub error_message: std::string::String,

    /// Reflects the overall progress of the patch job in the range of
    /// 0.0 being no progress to 100.0 being complete.
    pub percent_complete: f64,

    /// Output only. Name of the patch deployment that created this patch job.
    pub patch_deployment: std::string::String,

    /// Rollout strategy being applied.
    pub rollout: std::option::Option<crate::model::PatchRollout>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PatchJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PatchJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PatchJob::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PatchJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PatchJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PatchJob::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PatchJob::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::PatchJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::patch_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [instance_filter][crate::model::PatchJob::instance_filter].
    pub fn set_instance_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchInstanceFilter>,
    {
        self.instance_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_filter][crate::model::PatchJob::instance_filter].
    pub fn set_or_clear_instance_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchInstanceFilter>,
    {
        self.instance_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [patch_config][crate::model::PatchJob::patch_config].
    pub fn set_patch_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchConfig>,
    {
        self.patch_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_config][crate::model::PatchJob::patch_config].
    pub fn set_or_clear_patch_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchConfig>,
    {
        self.patch_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::PatchJob::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::PatchJob::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_details_summary][crate::model::PatchJob::instance_details_summary].
    pub fn set_instance_details_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::patch_job::InstanceDetailsSummary>,
    {
        self.instance_details_summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_details_summary][crate::model::PatchJob::instance_details_summary].
    pub fn set_or_clear_instance_details_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::patch_job::InstanceDetailsSummary>,
    {
        self.instance_details_summary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dry_run][crate::model::PatchJob::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::PatchJob::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [percent_complete][crate::model::PatchJob::percent_complete].
    pub fn set_percent_complete<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.percent_complete = v.into();
        self
    }

    /// Sets the value of [patch_deployment][crate::model::PatchJob::patch_deployment].
    pub fn set_patch_deployment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.patch_deployment = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::PatchJob::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PatchRollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::PatchJob::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PatchRollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PatchJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            __state,
            __instance_filter,
            __patch_config,
            __duration,
            __instance_details_summary,
            __dry_run,
            __error_message,
            __percent_complete,
            __patch_deployment,
            __rollout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "instanceFilter" => Ok(__FieldTag::__instance_filter),
                            "instance_filter" => Ok(__FieldTag::__instance_filter),
                            "patchConfig" => Ok(__FieldTag::__patch_config),
                            "patch_config" => Ok(__FieldTag::__patch_config),
                            "duration" => Ok(__FieldTag::__duration),
                            "instanceDetailsSummary" => Ok(__FieldTag::__instance_details_summary),
                            "instance_details_summary" => {
                                Ok(__FieldTag::__instance_details_summary)
                            }
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "percentComplete" => Ok(__FieldTag::__percent_complete),
                            "percent_complete" => Ok(__FieldTag::__percent_complete),
                            "patchDeployment" => Ok(__FieldTag::__patch_deployment),
                            "patch_deployment" => Ok(__FieldTag::__patch_deployment),
                            "rollout" => Ok(__FieldTag::__rollout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::patch_job::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_filter => {
                            if !fields.insert(__FieldTag::__instance_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_filter",
                                ));
                            }
                            result.instance_filter = map.next_value::<std::option::Option<crate::model::PatchInstanceFilter>>()?
                                ;
                        }
                        __FieldTag::__patch_config => {
                            if !fields.insert(__FieldTag::__patch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_config",
                                ));
                            }
                            result.patch_config =
                                map.next_value::<std::option::Option<crate::model::PatchConfig>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__instance_details_summary => {
                            if !fields.insert(__FieldTag::__instance_details_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_details_summary",
                                ));
                            }
                            result.instance_details_summary = map
                                .next_value::<std::option::Option<
                                    crate::model::patch_job::InstanceDetailsSummary,
                                >>()?;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__percent_complete => {
                            if !fields.insert(__FieldTag::__percent_complete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent_complete",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent_complete =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__patch_deployment => {
                            if !fields.insert(__FieldTag::__patch_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_deployment",
                                ));
                            }
                            result.patch_deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<crate::model::PatchRollout>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.instance_filter.is_some() {
            state.serialize_entry("instanceFilter", &self.instance_filter)?;
        }
        if self.patch_config.is_some() {
            state.serialize_entry("patchConfig", &self.patch_config)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.instance_details_summary.is_some() {
            state.serialize_entry("instanceDetailsSummary", &self.instance_details_summary)?;
        }
        if !wkt::internal::is_default(&self.dry_run) {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !wkt::internal::is_default(&self.percent_complete) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percentComplete", &__With(&self.percent_complete))?;
        }
        if !self.patch_deployment.is_empty() {
            state.serialize_entry("patchDeployment", &self.patch_deployment)?;
        }
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PatchJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("instance_filter", &self.instance_filter);
        debug_struct.field("patch_config", &self.patch_config);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("instance_details_summary", &self.instance_details_summary);
        debug_struct.field("dry_run", &self.dry_run);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("percent_complete", &self.percent_complete);
        debug_struct.field("patch_deployment", &self.patch_deployment);
        debug_struct.field("rollout", &self.rollout);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PatchJob].
pub mod patch_job {
    #[allow(unused_imports)]
    use super::*;

    /// A summary of the current patch state across all instances that this patch
    /// job affects. Contains counts of instances in different states. These states
    /// map to `InstancePatchState`. List patch job instance details to see the
    /// specific states of each instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceDetailsSummary {
        /// Number of instances pending patch job.
        pub pending_instance_count: i64,

        /// Number of instances that are inactive.
        pub inactive_instance_count: i64,

        /// Number of instances notified about patch job.
        pub notified_instance_count: i64,

        /// Number of instances that have started.
        pub started_instance_count: i64,

        /// Number of instances that are downloading patches.
        pub downloading_patches_instance_count: i64,

        /// Number of instances that are applying patches.
        pub applying_patches_instance_count: i64,

        /// Number of instances rebooting.
        pub rebooting_instance_count: i64,

        /// Number of instances that have completed successfully.
        pub succeeded_instance_count: i64,

        /// Number of instances that require reboot.
        pub succeeded_reboot_required_instance_count: i64,

        /// Number of instances that failed.
        pub failed_instance_count: i64,

        /// Number of instances that have acked and will start shortly.
        pub acked_instance_count: i64,

        /// Number of instances that exceeded the time out while applying the patch.
        pub timed_out_instance_count: i64,

        /// Number of instances that are running the pre-patch step.
        pub pre_patch_step_instance_count: i64,

        /// Number of instances that are running the post-patch step.
        pub post_patch_step_instance_count: i64,

        /// Number of instances that do not appear to be running the agent. Check to
        /// ensure that the agent is installed, running, and able to communicate with
        /// the service.
        pub no_agent_detected_instance_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceDetailsSummary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pending_instance_count][crate::model::patch_job::InstanceDetailsSummary::pending_instance_count].
        pub fn set_pending_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.pending_instance_count = v.into();
            self
        }

        /// Sets the value of [inactive_instance_count][crate::model::patch_job::InstanceDetailsSummary::inactive_instance_count].
        pub fn set_inactive_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.inactive_instance_count = v.into();
            self
        }

        /// Sets the value of [notified_instance_count][crate::model::patch_job::InstanceDetailsSummary::notified_instance_count].
        pub fn set_notified_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.notified_instance_count = v.into();
            self
        }

        /// Sets the value of [started_instance_count][crate::model::patch_job::InstanceDetailsSummary::started_instance_count].
        pub fn set_started_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.started_instance_count = v.into();
            self
        }

        /// Sets the value of [downloading_patches_instance_count][crate::model::patch_job::InstanceDetailsSummary::downloading_patches_instance_count].
        pub fn set_downloading_patches_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.downloading_patches_instance_count = v.into();
            self
        }

        /// Sets the value of [applying_patches_instance_count][crate::model::patch_job::InstanceDetailsSummary::applying_patches_instance_count].
        pub fn set_applying_patches_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.applying_patches_instance_count = v.into();
            self
        }

        /// Sets the value of [rebooting_instance_count][crate::model::patch_job::InstanceDetailsSummary::rebooting_instance_count].
        pub fn set_rebooting_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.rebooting_instance_count = v.into();
            self
        }

        /// Sets the value of [succeeded_instance_count][crate::model::patch_job::InstanceDetailsSummary::succeeded_instance_count].
        pub fn set_succeeded_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.succeeded_instance_count = v.into();
            self
        }

        /// Sets the value of [succeeded_reboot_required_instance_count][crate::model::patch_job::InstanceDetailsSummary::succeeded_reboot_required_instance_count].
        pub fn set_succeeded_reboot_required_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.succeeded_reboot_required_instance_count = v.into();
            self
        }

        /// Sets the value of [failed_instance_count][crate::model::patch_job::InstanceDetailsSummary::failed_instance_count].
        pub fn set_failed_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.failed_instance_count = v.into();
            self
        }

        /// Sets the value of [acked_instance_count][crate::model::patch_job::InstanceDetailsSummary::acked_instance_count].
        pub fn set_acked_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.acked_instance_count = v.into();
            self
        }

        /// Sets the value of [timed_out_instance_count][crate::model::patch_job::InstanceDetailsSummary::timed_out_instance_count].
        pub fn set_timed_out_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.timed_out_instance_count = v.into();
            self
        }

        /// Sets the value of [pre_patch_step_instance_count][crate::model::patch_job::InstanceDetailsSummary::pre_patch_step_instance_count].
        pub fn set_pre_patch_step_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.pre_patch_step_instance_count = v.into();
            self
        }

        /// Sets the value of [post_patch_step_instance_count][crate::model::patch_job::InstanceDetailsSummary::post_patch_step_instance_count].
        pub fn set_post_patch_step_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.post_patch_step_instance_count = v.into();
            self
        }

        /// Sets the value of [no_agent_detected_instance_count][crate::model::patch_job::InstanceDetailsSummary::no_agent_detected_instance_count].
        pub fn set_no_agent_detected_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.no_agent_detected_instance_count = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceDetailsSummary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.PatchJob.InstanceDetailsSummary"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InstanceDetailsSummary {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pending_instance_count,
                __inactive_instance_count,
                __notified_instance_count,
                __started_instance_count,
                __downloading_patches_instance_count,
                __applying_patches_instance_count,
                __rebooting_instance_count,
                __succeeded_instance_count,
                __succeeded_reboot_required_instance_count,
                __failed_instance_count,
                __acked_instance_count,
                __timed_out_instance_count,
                __pre_patch_step_instance_count,
                __post_patch_step_instance_count,
                __no_agent_detected_instance_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InstanceDetailsSummary")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pendingInstanceCount" => Ok(__FieldTag::__pending_instance_count),
                                "pending_instance_count" => {
                                    Ok(__FieldTag::__pending_instance_count)
                                }
                                "inactiveInstanceCount" => {
                                    Ok(__FieldTag::__inactive_instance_count)
                                }
                                "inactive_instance_count" => {
                                    Ok(__FieldTag::__inactive_instance_count)
                                }
                                "notifiedInstanceCount" => {
                                    Ok(__FieldTag::__notified_instance_count)
                                }
                                "notified_instance_count" => {
                                    Ok(__FieldTag::__notified_instance_count)
                                }
                                "startedInstanceCount" => Ok(__FieldTag::__started_instance_count),
                                "started_instance_count" => {
                                    Ok(__FieldTag::__started_instance_count)
                                }
                                "downloadingPatchesInstanceCount" => {
                                    Ok(__FieldTag::__downloading_patches_instance_count)
                                }
                                "downloading_patches_instance_count" => {
                                    Ok(__FieldTag::__downloading_patches_instance_count)
                                }
                                "applyingPatchesInstanceCount" => {
                                    Ok(__FieldTag::__applying_patches_instance_count)
                                }
                                "applying_patches_instance_count" => {
                                    Ok(__FieldTag::__applying_patches_instance_count)
                                }
                                "rebootingInstanceCount" => {
                                    Ok(__FieldTag::__rebooting_instance_count)
                                }
                                "rebooting_instance_count" => {
                                    Ok(__FieldTag::__rebooting_instance_count)
                                }
                                "succeededInstanceCount" => {
                                    Ok(__FieldTag::__succeeded_instance_count)
                                }
                                "succeeded_instance_count" => {
                                    Ok(__FieldTag::__succeeded_instance_count)
                                }
                                "succeededRebootRequiredInstanceCount" => {
                                    Ok(__FieldTag::__succeeded_reboot_required_instance_count)
                                }
                                "succeeded_reboot_required_instance_count" => {
                                    Ok(__FieldTag::__succeeded_reboot_required_instance_count)
                                }
                                "failedInstanceCount" => Ok(__FieldTag::__failed_instance_count),
                                "failed_instance_count" => Ok(__FieldTag::__failed_instance_count),
                                "ackedInstanceCount" => Ok(__FieldTag::__acked_instance_count),
                                "acked_instance_count" => Ok(__FieldTag::__acked_instance_count),
                                "timedOutInstanceCount" => {
                                    Ok(__FieldTag::__timed_out_instance_count)
                                }
                                "timed_out_instance_count" => {
                                    Ok(__FieldTag::__timed_out_instance_count)
                                }
                                "prePatchStepInstanceCount" => {
                                    Ok(__FieldTag::__pre_patch_step_instance_count)
                                }
                                "pre_patch_step_instance_count" => {
                                    Ok(__FieldTag::__pre_patch_step_instance_count)
                                }
                                "postPatchStepInstanceCount" => {
                                    Ok(__FieldTag::__post_patch_step_instance_count)
                                }
                                "post_patch_step_instance_count" => {
                                    Ok(__FieldTag::__post_patch_step_instance_count)
                                }
                                "noAgentDetectedInstanceCount" => {
                                    Ok(__FieldTag::__no_agent_detected_instance_count)
                                }
                                "no_agent_detected_instance_count" => {
                                    Ok(__FieldTag::__no_agent_detected_instance_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InstanceDetailsSummary;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InstanceDetailsSummary")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pending_instance_count => {
                                if !fields.insert(__FieldTag::__pending_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pending_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.pending_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__inactive_instance_count => {
                                if !fields.insert(__FieldTag::__inactive_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inactive_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.inactive_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__notified_instance_count => {
                                if !fields.insert(__FieldTag::__notified_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for notified_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.notified_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__started_instance_count => {
                                if !fields.insert(__FieldTag::__started_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for started_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.started_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__downloading_patches_instance_count => {
                                if !fields.insert(__FieldTag::__downloading_patches_instance_count)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for downloading_patches_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.downloading_patches_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__applying_patches_instance_count => {
                                if !fields.insert(__FieldTag::__applying_patches_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for applying_patches_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.applying_patches_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__rebooting_instance_count => {
                                if !fields.insert(__FieldTag::__rebooting_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rebooting_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.rebooting_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__succeeded_instance_count => {
                                if !fields.insert(__FieldTag::__succeeded_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for succeeded_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.succeeded_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__succeeded_reboot_required_instance_count => {
                                if !fields
                                    .insert(__FieldTag::__succeeded_reboot_required_instance_count)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for succeeded_reboot_required_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.succeeded_reboot_required_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__failed_instance_count => {
                                if !fields.insert(__FieldTag::__failed_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for failed_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.failed_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__acked_instance_count => {
                                if !fields.insert(__FieldTag::__acked_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for acked_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.acked_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__timed_out_instance_count => {
                                if !fields.insert(__FieldTag::__timed_out_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for timed_out_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.timed_out_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__pre_patch_step_instance_count => {
                                if !fields.insert(__FieldTag::__pre_patch_step_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pre_patch_step_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.pre_patch_step_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__post_patch_step_instance_count => {
                                if !fields.insert(__FieldTag::__post_patch_step_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for post_patch_step_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.post_patch_step_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__no_agent_detected_instance_count => {
                                if !fields.insert(__FieldTag::__no_agent_detected_instance_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_agent_detected_instance_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.no_agent_detected_instance_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InstanceDetailsSummary {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.pending_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "pendingInstanceCount",
                    &__With(&self.pending_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.inactive_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "inactiveInstanceCount",
                    &__With(&self.inactive_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.notified_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "notifiedInstanceCount",
                    &__With(&self.notified_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.started_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "startedInstanceCount",
                    &__With(&self.started_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.downloading_patches_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "downloadingPatchesInstanceCount",
                    &__With(&self.downloading_patches_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.applying_patches_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "applyingPatchesInstanceCount",
                    &__With(&self.applying_patches_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.rebooting_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "rebootingInstanceCount",
                    &__With(&self.rebooting_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.succeeded_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "succeededInstanceCount",
                    &__With(&self.succeeded_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.succeeded_reboot_required_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "succeededRebootRequiredInstanceCount",
                    &__With(&self.succeeded_reboot_required_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.failed_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("failedInstanceCount", &__With(&self.failed_instance_count))?;
            }
            if !wkt::internal::is_default(&self.acked_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("ackedInstanceCount", &__With(&self.acked_instance_count))?;
            }
            if !wkt::internal::is_default(&self.timed_out_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "timedOutInstanceCount",
                    &__With(&self.timed_out_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.pre_patch_step_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "prePatchStepInstanceCount",
                    &__With(&self.pre_patch_step_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.post_patch_step_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "postPatchStepInstanceCount",
                    &__With(&self.post_patch_step_instance_count),
                )?;
            }
            if !wkt::internal::is_default(&self.no_agent_detected_instance_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "noAgentDetectedInstanceCount",
                    &__With(&self.no_agent_detected_instance_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InstanceDetailsSummary {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InstanceDetailsSummary");
            debug_struct.field("pending_instance_count", &self.pending_instance_count);
            debug_struct.field("inactive_instance_count", &self.inactive_instance_count);
            debug_struct.field("notified_instance_count", &self.notified_instance_count);
            debug_struct.field("started_instance_count", &self.started_instance_count);
            debug_struct.field(
                "downloading_patches_instance_count",
                &self.downloading_patches_instance_count,
            );
            debug_struct.field(
                "applying_patches_instance_count",
                &self.applying_patches_instance_count,
            );
            debug_struct.field("rebooting_instance_count", &self.rebooting_instance_count);
            debug_struct.field("succeeded_instance_count", &self.succeeded_instance_count);
            debug_struct.field(
                "succeeded_reboot_required_instance_count",
                &self.succeeded_reboot_required_instance_count,
            );
            debug_struct.field("failed_instance_count", &self.failed_instance_count);
            debug_struct.field("acked_instance_count", &self.acked_instance_count);
            debug_struct.field("timed_out_instance_count", &self.timed_out_instance_count);
            debug_struct.field(
                "pre_patch_step_instance_count",
                &self.pre_patch_step_instance_count,
            );
            debug_struct.field(
                "post_patch_step_instance_count",
                &self.post_patch_step_instance_count,
            );
            debug_struct.field(
                "no_agent_detected_instance_count",
                &self.no_agent_detected_instance_count,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Enumeration of the various states a patch job passes through as it
    /// executes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State must be specified.
        Unspecified,
        /// The patch job was successfully initiated.
        Started,
        /// The patch job is looking up instances to run the patch on.
        InstanceLookup,
        /// Instances are being patched.
        Patching,
        /// Patch job completed successfully.
        Succeeded,
        /// Patch job completed but there were errors.
        CompletedWithErrors,
        /// The patch job was canceled.
        Canceled,
        /// The patch job timed out.
        TimedOut,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(1),
                Self::InstanceLookup => std::option::Option::Some(2),
                Self::Patching => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::CompletedWithErrors => std::option::Option::Some(5),
                Self::Canceled => std::option::Option::Some(6),
                Self::TimedOut => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::InstanceLookup => std::option::Option::Some("INSTANCE_LOOKUP"),
                Self::Patching => std::option::Option::Some("PATCHING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::CompletedWithErrors => std::option::Option::Some("COMPLETED_WITH_ERRORS"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::TimedOut => std::option::Option::Some("TIMED_OUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Started,
                2 => Self::InstanceLookup,
                3 => Self::Patching,
                4 => Self::Succeeded,
                5 => Self::CompletedWithErrors,
                6 => Self::Canceled,
                7 => Self::TimedOut,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "INSTANCE_LOOKUP" => Self::InstanceLookup,
                "PATCHING" => Self::Patching,
                "SUCCEEDED" => Self::Succeeded,
                "COMPLETED_WITH_ERRORS" => Self::CompletedWithErrors,
                "CANCELED" => Self::Canceled,
                "TIMED_OUT" => Self::TimedOut,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(1),
                Self::InstanceLookup => serializer.serialize_i32(2),
                Self::Patching => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::CompletedWithErrors => serializer.serialize_i32(5),
                Self::Canceled => serializer.serialize_i32(6),
                Self::TimedOut => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.osconfig.v1.PatchJob.State",
            ))
        }
    }
}

/// Patch configuration specifications. Contains details on how to apply the
/// patch(es) to a VM instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchConfig {
    /// Post-patch reboot settings.
    pub reboot_config: crate::model::patch_config::RebootConfig,

    /// Apt update settings. Use this setting to override the default `apt` patch
    /// rules.
    pub apt: std::option::Option<crate::model::AptSettings>,

    /// Yum update settings. Use this setting to override the default `yum` patch
    /// rules.
    pub yum: std::option::Option<crate::model::YumSettings>,

    /// Goo update settings. Use this setting to override the default `goo` patch
    /// rules.
    pub goo: std::option::Option<crate::model::GooSettings>,

    /// Zypper update settings. Use this setting to override the default `zypper`
    /// patch rules.
    pub zypper: std::option::Option<crate::model::ZypperSettings>,

    /// Windows update settings. Use this override the default windows patch rules.
    pub windows_update: std::option::Option<crate::model::WindowsUpdateSettings>,

    /// The `ExecStep` to run before the patch update.
    pub pre_step: std::option::Option<crate::model::ExecStep>,

    /// The `ExecStep` to run after the patch update.
    pub post_step: std::option::Option<crate::model::ExecStep>,

    /// Allows the patch job to run on Managed instance groups (MIGs).
    pub mig_instances_allowed: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reboot_config][crate::model::PatchConfig::reboot_config].
    pub fn set_reboot_config<T: std::convert::Into<crate::model::patch_config::RebootConfig>>(
        mut self,
        v: T,
    ) -> Self {
        self.reboot_config = v.into();
        self
    }

    /// Sets the value of [apt][crate::model::PatchConfig::apt].
    pub fn set_apt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AptSettings>,
    {
        self.apt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [apt][crate::model::PatchConfig::apt].
    pub fn set_or_clear_apt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AptSettings>,
    {
        self.apt = v.map(|x| x.into());
        self
    }

    /// Sets the value of [yum][crate::model::PatchConfig::yum].
    pub fn set_yum<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::YumSettings>,
    {
        self.yum = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [yum][crate::model::PatchConfig::yum].
    pub fn set_or_clear_yum<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::YumSettings>,
    {
        self.yum = v.map(|x| x.into());
        self
    }

    /// Sets the value of [goo][crate::model::PatchConfig::goo].
    pub fn set_goo<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GooSettings>,
    {
        self.goo = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [goo][crate::model::PatchConfig::goo].
    pub fn set_or_clear_goo<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GooSettings>,
    {
        self.goo = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zypper][crate::model::PatchConfig::zypper].
    pub fn set_zypper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ZypperSettings>,
    {
        self.zypper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zypper][crate::model::PatchConfig::zypper].
    pub fn set_or_clear_zypper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ZypperSettings>,
    {
        self.zypper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_update][crate::model::PatchConfig::windows_update].
    pub fn set_windows_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdateSettings>,
    {
        self.windows_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_update][crate::model::PatchConfig::windows_update].
    pub fn set_or_clear_windows_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsUpdateSettings>,
    {
        self.windows_update = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pre_step][crate::model::PatchConfig::pre_step].
    pub fn set_pre_step<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecStep>,
    {
        self.pre_step = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pre_step][crate::model::PatchConfig::pre_step].
    pub fn set_or_clear_pre_step<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecStep>,
    {
        self.pre_step = v.map(|x| x.into());
        self
    }

    /// Sets the value of [post_step][crate::model::PatchConfig::post_step].
    pub fn set_post_step<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecStep>,
    {
        self.post_step = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [post_step][crate::model::PatchConfig::post_step].
    pub fn set_or_clear_post_step<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecStep>,
    {
        self.post_step = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mig_instances_allowed][crate::model::PatchConfig::mig_instances_allowed].
    pub fn set_mig_instances_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mig_instances_allowed = v.into();
        self
    }
}

impl wkt::message::Message for PatchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reboot_config,
            __apt,
            __yum,
            __goo,
            __zypper,
            __windows_update,
            __pre_step,
            __post_step,
            __mig_instances_allowed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rebootConfig" => Ok(__FieldTag::__reboot_config),
                            "reboot_config" => Ok(__FieldTag::__reboot_config),
                            "apt" => Ok(__FieldTag::__apt),
                            "yum" => Ok(__FieldTag::__yum),
                            "goo" => Ok(__FieldTag::__goo),
                            "zypper" => Ok(__FieldTag::__zypper),
                            "windowsUpdate" => Ok(__FieldTag::__windows_update),
                            "windows_update" => Ok(__FieldTag::__windows_update),
                            "preStep" => Ok(__FieldTag::__pre_step),
                            "pre_step" => Ok(__FieldTag::__pre_step),
                            "postStep" => Ok(__FieldTag::__post_step),
                            "post_step" => Ok(__FieldTag::__post_step),
                            "migInstancesAllowed" => Ok(__FieldTag::__mig_instances_allowed),
                            "mig_instances_allowed" => Ok(__FieldTag::__mig_instances_allowed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reboot_config => {
                            if !fields.insert(__FieldTag::__reboot_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reboot_config",
                                ));
                            }
                            result.reboot_config = map.next_value::<std::option::Option<crate::model::patch_config::RebootConfig>>()?.unwrap_or_default();
                        }
                        __FieldTag::__apt => {
                            if !fields.insert(__FieldTag::__apt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apt",
                                ));
                            }
                            result.apt =
                                map.next_value::<std::option::Option<crate::model::AptSettings>>()?;
                        }
                        __FieldTag::__yum => {
                            if !fields.insert(__FieldTag::__yum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yum",
                                ));
                            }
                            result.yum =
                                map.next_value::<std::option::Option<crate::model::YumSettings>>()?;
                        }
                        __FieldTag::__goo => {
                            if !fields.insert(__FieldTag::__goo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for goo",
                                ));
                            }
                            result.goo =
                                map.next_value::<std::option::Option<crate::model::GooSettings>>()?;
                        }
                        __FieldTag::__zypper => {
                            if !fields.insert(__FieldTag::__zypper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zypper",
                                ));
                            }
                            result.zypper = map
                                .next_value::<std::option::Option<crate::model::ZypperSettings>>(
                                )?;
                        }
                        __FieldTag::__windows_update => {
                            if !fields.insert(__FieldTag::__windows_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_update",
                                ));
                            }
                            result.windows_update = map.next_value::<std::option::Option<crate::model::WindowsUpdateSettings>>()?
                                ;
                        }
                        __FieldTag::__pre_step => {
                            if !fields.insert(__FieldTag::__pre_step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pre_step",
                                ));
                            }
                            result.pre_step =
                                map.next_value::<std::option::Option<crate::model::ExecStep>>()?;
                        }
                        __FieldTag::__post_step => {
                            if !fields.insert(__FieldTag::__post_step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_step",
                                ));
                            }
                            result.post_step =
                                map.next_value::<std::option::Option<crate::model::ExecStep>>()?;
                        }
                        __FieldTag::__mig_instances_allowed => {
                            if !fields.insert(__FieldTag::__mig_instances_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mig_instances_allowed",
                                ));
                            }
                            result.mig_instances_allowed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.reboot_config) {
            state.serialize_entry("rebootConfig", &self.reboot_config)?;
        }
        if self.apt.is_some() {
            state.serialize_entry("apt", &self.apt)?;
        }
        if self.yum.is_some() {
            state.serialize_entry("yum", &self.yum)?;
        }
        if self.goo.is_some() {
            state.serialize_entry("goo", &self.goo)?;
        }
        if self.zypper.is_some() {
            state.serialize_entry("zypper", &self.zypper)?;
        }
        if self.windows_update.is_some() {
            state.serialize_entry("windowsUpdate", &self.windows_update)?;
        }
        if self.pre_step.is_some() {
            state.serialize_entry("preStep", &self.pre_step)?;
        }
        if self.post_step.is_some() {
            state.serialize_entry("postStep", &self.post_step)?;
        }
        if !wkt::internal::is_default(&self.mig_instances_allowed) {
            state.serialize_entry("migInstancesAllowed", &self.mig_instances_allowed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PatchConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchConfig");
        debug_struct.field("reboot_config", &self.reboot_config);
        debug_struct.field("apt", &self.apt);
        debug_struct.field("yum", &self.yum);
        debug_struct.field("goo", &self.goo);
        debug_struct.field("zypper", &self.zypper);
        debug_struct.field("windows_update", &self.windows_update);
        debug_struct.field("pre_step", &self.pre_step);
        debug_struct.field("post_step", &self.post_step);
        debug_struct.field("mig_instances_allowed", &self.mig_instances_allowed);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PatchConfig].
pub mod patch_config {
    #[allow(unused_imports)]
    use super::*;

    /// Post-patch reboot settings.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RebootConfig {
        /// The default behavior is DEFAULT.
        Unspecified,
        /// The agent decides if a reboot is necessary by checking signals such as
        /// registry keys on Windows or `/var/run/reboot-required` on APT based
        /// systems. On RPM based systems, a set of core system package install times
        /// are compared with system boot time.
        Default,
        /// Always reboot the machine after the update completes.
        Always,
        /// Never reboot the machine after the update completes.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RebootConfig::value] or
        /// [RebootConfig::name].
        UnknownValue(reboot_config::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reboot_config {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RebootConfig {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::Always => std::option::Option::Some(2),
                Self::Never => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REBOOT_CONFIG_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RebootConfig {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RebootConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RebootConfig {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::Always,
                3 => Self::Never,
                _ => Self::UnknownValue(reboot_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RebootConfig {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REBOOT_CONFIG_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                _ => Self::UnknownValue(reboot_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RebootConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::Always => serializer.serialize_i32(2),
                Self::Never => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RebootConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RebootConfig>::new(
                ".google.cloud.osconfig.v1.PatchConfig.RebootConfig",
            ))
        }
    }
}

/// Namespace for instance state enums.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Instance");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Patch state of an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PatchState {
        /// Unspecified.
        Unspecified,
        /// The instance is not yet notified.
        Pending,
        /// Instance is inactive and cannot be patched.
        Inactive,
        /// The instance is notified that it should be patched.
        Notified,
        /// The instance has started the patching process.
        Started,
        /// The instance is downloading patches.
        DownloadingPatches,
        /// The instance is applying patches.
        ApplyingPatches,
        /// The instance is rebooting.
        Rebooting,
        /// The instance has completed applying patches.
        Succeeded,
        /// The instance has completed applying patches but a reboot is required.
        SucceededRebootRequired,
        /// The instance has failed to apply the patch.
        Failed,
        /// The instance acked the notification and will start shortly.
        Acked,
        /// The instance exceeded the time out while applying the patch.
        TimedOut,
        /// The instance is running the pre-patch step.
        RunningPrePatchStep,
        /// The instance is running the post-patch step.
        RunningPostPatchStep,
        /// The service could not detect the presence of the agent. Check to ensure
        /// that the agent is installed, running, and able to communicate with the
        /// service.
        NoAgentDetected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PatchState::value] or
        /// [PatchState::name].
        UnknownValue(patch_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod patch_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PatchState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::Notified => std::option::Option::Some(3),
                Self::Started => std::option::Option::Some(4),
                Self::DownloadingPatches => std::option::Option::Some(5),
                Self::ApplyingPatches => std::option::Option::Some(6),
                Self::Rebooting => std::option::Option::Some(7),
                Self::Succeeded => std::option::Option::Some(8),
                Self::SucceededRebootRequired => std::option::Option::Some(9),
                Self::Failed => std::option::Option::Some(10),
                Self::Acked => std::option::Option::Some(11),
                Self::TimedOut => std::option::Option::Some(12),
                Self::RunningPrePatchStep => std::option::Option::Some(13),
                Self::RunningPostPatchStep => std::option::Option::Some(14),
                Self::NoAgentDetected => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PATCH_STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Notified => std::option::Option::Some("NOTIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::DownloadingPatches => std::option::Option::Some("DOWNLOADING_PATCHES"),
                Self::ApplyingPatches => std::option::Option::Some("APPLYING_PATCHES"),
                Self::Rebooting => std::option::Option::Some("REBOOTING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::SucceededRebootRequired => {
                    std::option::Option::Some("SUCCEEDED_REBOOT_REQUIRED")
                }
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Acked => std::option::Option::Some("ACKED"),
                Self::TimedOut => std::option::Option::Some("TIMED_OUT"),
                Self::RunningPrePatchStep => std::option::Option::Some("RUNNING_PRE_PATCH_STEP"),
                Self::RunningPostPatchStep => std::option::Option::Some("RUNNING_POST_PATCH_STEP"),
                Self::NoAgentDetected => std::option::Option::Some("NO_AGENT_DETECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PatchState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PatchState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PatchState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Inactive,
                3 => Self::Notified,
                4 => Self::Started,
                5 => Self::DownloadingPatches,
                6 => Self::ApplyingPatches,
                7 => Self::Rebooting,
                8 => Self::Succeeded,
                9 => Self::SucceededRebootRequired,
                10 => Self::Failed,
                11 => Self::Acked,
                12 => Self::TimedOut,
                13 => Self::RunningPrePatchStep,
                14 => Self::RunningPostPatchStep,
                15 => Self::NoAgentDetected,
                _ => Self::UnknownValue(patch_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PatchState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PATCH_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "INACTIVE" => Self::Inactive,
                "NOTIFIED" => Self::Notified,
                "STARTED" => Self::Started,
                "DOWNLOADING_PATCHES" => Self::DownloadingPatches,
                "APPLYING_PATCHES" => Self::ApplyingPatches,
                "REBOOTING" => Self::Rebooting,
                "SUCCEEDED" => Self::Succeeded,
                "SUCCEEDED_REBOOT_REQUIRED" => Self::SucceededRebootRequired,
                "FAILED" => Self::Failed,
                "ACKED" => Self::Acked,
                "TIMED_OUT" => Self::TimedOut,
                "RUNNING_PRE_PATCH_STEP" => Self::RunningPrePatchStep,
                "RUNNING_POST_PATCH_STEP" => Self::RunningPostPatchStep,
                "NO_AGENT_DETECTED" => Self::NoAgentDetected,
                _ => Self::UnknownValue(patch_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PatchState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::Notified => serializer.serialize_i32(3),
                Self::Started => serializer.serialize_i32(4),
                Self::DownloadingPatches => serializer.serialize_i32(5),
                Self::ApplyingPatches => serializer.serialize_i32(6),
                Self::Rebooting => serializer.serialize_i32(7),
                Self::Succeeded => serializer.serialize_i32(8),
                Self::SucceededRebootRequired => serializer.serialize_i32(9),
                Self::Failed => serializer.serialize_i32(10),
                Self::Acked => serializer.serialize_i32(11),
                Self::TimedOut => serializer.serialize_i32(12),
                Self::RunningPrePatchStep => serializer.serialize_i32(13),
                Self::RunningPostPatchStep => serializer.serialize_i32(14),
                Self::NoAgentDetected => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PatchState>::new(
                ".google.cloud.osconfig.v1.Instance.PatchState",
            ))
        }
    }
}

/// Message for canceling a patch job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelPatchJobRequest {
    /// Required. Name of the patch in the form `projects/*/patchJobs/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelPatchJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelPatchJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelPatchJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CancelPatchJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelPatchJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelPatchJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelPatchJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelPatchJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelPatchJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelPatchJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelPatchJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Apt patching is completed by executing `apt-get update && apt-get
/// upgrade`. Additional options can be set to control how this is executed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AptSettings {
    /// By changing the type to DIST, the patching is performed
    /// using `apt-get dist-upgrade` instead.
    pub r#type: crate::model::apt_settings::Type,

    /// List of packages to exclude from update. These packages will be excluded
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of packages to be updated. These are the only packages
    /// that will be updated. If these packages are not installed, they will be
    /// ignored. This field cannot be specified with any other patch configuration
    /// fields.
    pub exclusive_packages: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AptSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AptSettings::type].
    pub fn set_type<T: std::convert::Into<crate::model::apt_settings::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [excludes][crate::model::AptSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_packages][crate::model::AptSettings::exclusive_packages].
    pub fn set_exclusive_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AptSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.AptSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AptSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __excludes,
            __exclusive_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AptSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePackages" => Ok(__FieldTag::__exclusive_packages),
                            "exclusive_packages" => Ok(__FieldTag::__exclusive_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AptSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AptSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::apt_settings::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_packages => {
                            if !fields.insert(__FieldTag::__exclusive_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_packages",
                                ));
                            }
                            result.exclusive_packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AptSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.excludes.is_empty() {
            state.serialize_entry("excludes", &self.excludes)?;
        }
        if !self.exclusive_packages.is_empty() {
            state.serialize_entry("exclusivePackages", &self.exclusive_packages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AptSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AptSettings");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("excludes", &self.excludes);
        debug_struct.field("exclusive_packages", &self.exclusive_packages);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AptSettings].
pub mod apt_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Apt patch type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// By default, upgrade will be performed.
        Unspecified,
        /// Runs `apt-get dist-upgrade`.
        Dist,
        /// Runs `apt-get upgrade`.
        Upgrade,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dist => std::option::Option::Some(1),
                Self::Upgrade => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Dist => std::option::Option::Some("DIST"),
                Self::Upgrade => std::option::Option::Some("UPGRADE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dist,
                2 => Self::Upgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "DIST" => Self::Dist,
                "UPGRADE" => Self::Upgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dist => serializer.serialize_i32(1),
                Self::Upgrade => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.osconfig.v1.AptSettings.Type",
            ))
        }
    }
}

/// Yum patching is performed by executing `yum update`. Additional options
/// can be set to control how this is executed.
///
/// Note that not all settings are supported on all platforms.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct YumSettings {
    /// Adds the `--security` flag to `yum update`. Not supported on
    /// all platforms.
    pub security: bool,

    /// Will cause patch to run `yum update-minimal` instead.
    pub minimal: bool,

    /// List of packages to exclude from update. These packages are excluded by
    /// using the yum `--exclude` flag.
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of packages to be updated. These are the only packages
    /// that will be updated. If these packages are not installed, they will be
    /// ignored. This field must not be specified with any other patch
    /// configuration fields.
    pub exclusive_packages: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl YumSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [security][crate::model::YumSettings::security].
    pub fn set_security<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.security = v.into();
        self
    }

    /// Sets the value of [minimal][crate::model::YumSettings::minimal].
    pub fn set_minimal<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.minimal = v.into();
        self
    }

    /// Sets the value of [excludes][crate::model::YumSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_packages][crate::model::YumSettings::exclusive_packages].
    pub fn set_exclusive_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for YumSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.YumSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for YumSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __security,
            __minimal,
            __excludes,
            __exclusive_packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for YumSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "security" => Ok(__FieldTag::__security),
                            "minimal" => Ok(__FieldTag::__minimal),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePackages" => Ok(__FieldTag::__exclusive_packages),
                            "exclusive_packages" => Ok(__FieldTag::__exclusive_packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = YumSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct YumSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__security => {
                            if !fields.insert(__FieldTag::__security) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security",
                                ));
                            }
                            result.security = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimal => {
                            if !fields.insert(__FieldTag::__minimal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimal",
                                ));
                            }
                            result.minimal = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_packages => {
                            if !fields.insert(__FieldTag::__exclusive_packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_packages",
                                ));
                            }
                            result.exclusive_packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for YumSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.security) {
            state.serialize_entry("security", &self.security)?;
        }
        if !wkt::internal::is_default(&self.minimal) {
            state.serialize_entry("minimal", &self.minimal)?;
        }
        if !self.excludes.is_empty() {
            state.serialize_entry("excludes", &self.excludes)?;
        }
        if !self.exclusive_packages.is_empty() {
            state.serialize_entry("exclusivePackages", &self.exclusive_packages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for YumSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("YumSettings");
        debug_struct.field("security", &self.security);
        debug_struct.field("minimal", &self.minimal);
        debug_struct.field("excludes", &self.excludes);
        debug_struct.field("exclusive_packages", &self.exclusive_packages);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Googet patching is performed by running `googet update`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GooSettings {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GooSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for GooSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GooSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GooSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GooSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GooSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GooSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GooSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GooSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GooSettings");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Zypper patching is performed by running `zypper patch`.
/// See also <https://en.opensuse.org/SDB:Zypper_manual>.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZypperSettings {
    /// Adds the `--with-optional` flag to `zypper patch`.
    pub with_optional: bool,

    /// Adds the `--with-update` flag, to `zypper patch`.
    pub with_update: bool,

    /// Install only patches with these categories.
    /// Common categories include security, recommended, and feature.
    pub categories: std::vec::Vec<std::string::String>,

    /// Install only patches with these severities.
    /// Common severities include critical, important, moderate, and low.
    pub severities: std::vec::Vec<std::string::String>,

    /// List of patches to exclude from update.
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of patches to be updated. These are the only patches
    /// that will be installed using 'zypper patch patch:<patch_name>' command.
    /// This field must not be used with any other patch configuration fields.
    pub exclusive_patches: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZypperSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [with_optional][crate::model::ZypperSettings::with_optional].
    pub fn set_with_optional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.with_optional = v.into();
        self
    }

    /// Sets the value of [with_update][crate::model::ZypperSettings::with_update].
    pub fn set_with_update<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.with_update = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::ZypperSettings::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [severities][crate::model::ZypperSettings::severities].
    pub fn set_severities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.severities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [excludes][crate::model::ZypperSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_patches][crate::model::ZypperSettings::exclusive_patches].
    pub fn set_exclusive_patches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_patches = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ZypperSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ZypperSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ZypperSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __with_optional,
            __with_update,
            __categories,
            __severities,
            __excludes,
            __exclusive_patches,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZypperSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "withOptional" => Ok(__FieldTag::__with_optional),
                            "with_optional" => Ok(__FieldTag::__with_optional),
                            "withUpdate" => Ok(__FieldTag::__with_update),
                            "with_update" => Ok(__FieldTag::__with_update),
                            "categories" => Ok(__FieldTag::__categories),
                            "severities" => Ok(__FieldTag::__severities),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePatches" => Ok(__FieldTag::__exclusive_patches),
                            "exclusive_patches" => Ok(__FieldTag::__exclusive_patches),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ZypperSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZypperSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__with_optional => {
                            if !fields.insert(__FieldTag::__with_optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for with_optional",
                                ));
                            }
                            result.with_optional = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__with_update => {
                            if !fields.insert(__FieldTag::__with_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for with_update",
                                ));
                            }
                            result.with_update = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severities => {
                            if !fields.insert(__FieldTag::__severities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severities",
                                ));
                            }
                            result.severities = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_patches => {
                            if !fields.insert(__FieldTag::__exclusive_patches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_patches",
                                ));
                            }
                            result.exclusive_patches = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ZypperSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.with_optional) {
            state.serialize_entry("withOptional", &self.with_optional)?;
        }
        if !wkt::internal::is_default(&self.with_update) {
            state.serialize_entry("withUpdate", &self.with_update)?;
        }
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if !self.severities.is_empty() {
            state.serialize_entry("severities", &self.severities)?;
        }
        if !self.excludes.is_empty() {
            state.serialize_entry("excludes", &self.excludes)?;
        }
        if !self.exclusive_patches.is_empty() {
            state.serialize_entry("exclusivePatches", &self.exclusive_patches)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ZypperSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ZypperSettings");
        debug_struct.field("with_optional", &self.with_optional);
        debug_struct.field("with_update", &self.with_update);
        debug_struct.field("categories", &self.categories);
        debug_struct.field("severities", &self.severities);
        debug_struct.field("excludes", &self.excludes);
        debug_struct.field("exclusive_patches", &self.exclusive_patches);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Windows patching is performed using the Windows Update Agent.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WindowsUpdateSettings {
    /// Only apply updates of these windows update classifications. If empty, all
    /// updates are applied.
    pub classifications: std::vec::Vec<crate::model::windows_update_settings::Classification>,

    /// List of KBs to exclude from update.
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of kbs to be updated. These are the only patches
    /// that will be updated. This field must not be used with other
    /// patch configurations.
    pub exclusive_patches: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsUpdateSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [classifications][crate::model::WindowsUpdateSettings::classifications].
    pub fn set_classifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::windows_update_settings::Classification>,
    {
        use std::iter::Iterator;
        self.classifications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [excludes][crate::model::WindowsUpdateSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_patches][crate::model::WindowsUpdateSettings::exclusive_patches].
    pub fn set_exclusive_patches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_patches = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WindowsUpdateSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.WindowsUpdateSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WindowsUpdateSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __classifications,
            __excludes,
            __exclusive_patches,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsUpdateSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "classifications" => Ok(__FieldTag::__classifications),
                            "excludes" => Ok(__FieldTag::__excludes),
                            "exclusivePatches" => Ok(__FieldTag::__exclusive_patches),
                            "exclusive_patches" => Ok(__FieldTag::__exclusive_patches),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WindowsUpdateSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsUpdateSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__classifications => {
                            if !fields.insert(__FieldTag::__classifications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classifications",
                                ));
                            }
                            result.classifications = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::windows_update_settings::Classification,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excludes => {
                            if !fields.insert(__FieldTag::__excludes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes",
                                ));
                            }
                            result.excludes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclusive_patches => {
                            if !fields.insert(__FieldTag::__exclusive_patches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_patches",
                                ));
                            }
                            result.exclusive_patches = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WindowsUpdateSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.classifications.is_empty() {
            state.serialize_entry("classifications", &self.classifications)?;
        }
        if !self.excludes.is_empty() {
            state.serialize_entry("excludes", &self.excludes)?;
        }
        if !self.exclusive_patches.is_empty() {
            state.serialize_entry("exclusivePatches", &self.exclusive_patches)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WindowsUpdateSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WindowsUpdateSettings");
        debug_struct.field("classifications", &self.classifications);
        debug_struct.field("excludes", &self.excludes);
        debug_struct.field("exclusive_patches", &self.exclusive_patches);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WindowsUpdateSettings].
pub mod windows_update_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Microsoft Windows update classifications as defined in
    /// [1]
    /// <https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro>
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Classification {
        /// Invalid. If classifications are included, they must be specified.
        Unspecified,
        /// "A widely released fix for a specific problem that addresses a critical,
        /// non-security-related bug." [1]
        Critical,
        /// "A widely released fix for a product-specific, security-related
        /// vulnerability. Security vulnerabilities are rated by their severity. The
        /// severity rating is indicated in the Microsoft security bulletin as
        /// critical, important, moderate, or low." [1]
        Security,
        /// "A widely released and frequent software update that contains additions
        /// to a product's definition database. Definition databases are often used
        /// to detect objects that have specific attributes, such as malicious code,
        /// phishing websites, or junk mail." [1]
        Definition,
        /// "Software that controls the input and output of a device." [1]
        Driver,
        /// "New product functionality that is first distributed outside the context
        /// of a product release and that is typically included in the next full
        /// product release." [1]
        FeaturePack,
        /// "A tested, cumulative set of all hotfixes, security updates, critical
        /// updates, and updates. Additionally, service packs may contain additional
        /// fixes for problems that are found internally since the release of the
        /// product. Service packs my also contain a limited number of
        /// customer-requested design changes or features." [1]
        ServicePack,
        /// "A utility or feature that helps complete a task or set of tasks." [1]
        Tool,
        /// "A tested, cumulative set of hotfixes, security updates, critical
        /// updates, and updates that are packaged together for easy deployment. A
        /// rollup generally targets a specific area, such as security, or a
        /// component of a product, such as Internet Information Services (IIS)." [1]
        UpdateRollup,
        /// "A widely released fix for a specific problem. An update addresses a
        /// noncritical, non-security-related bug." [1]
        Update,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Classification::value] or
        /// [Classification::name].
        UnknownValue(classification::UnknownValue),
    }

    #[doc(hidden)]
    pub mod classification {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Classification {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Critical => std::option::Option::Some(1),
                Self::Security => std::option::Option::Some(2),
                Self::Definition => std::option::Option::Some(3),
                Self::Driver => std::option::Option::Some(4),
                Self::FeaturePack => std::option::Option::Some(5),
                Self::ServicePack => std::option::Option::Some(6),
                Self::Tool => std::option::Option::Some(7),
                Self::UpdateRollup => std::option::Option::Some(8),
                Self::Update => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLASSIFICATION_UNSPECIFIED"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::Definition => std::option::Option::Some("DEFINITION"),
                Self::Driver => std::option::Option::Some("DRIVER"),
                Self::FeaturePack => std::option::Option::Some("FEATURE_PACK"),
                Self::ServicePack => std::option::Option::Some("SERVICE_PACK"),
                Self::Tool => std::option::Option::Some("TOOL"),
                Self::UpdateRollup => std::option::Option::Some("UPDATE_ROLLUP"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Classification {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Classification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Classification {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Critical,
                2 => Self::Security,
                3 => Self::Definition,
                4 => Self::Driver,
                5 => Self::FeaturePack,
                6 => Self::ServicePack,
                7 => Self::Tool,
                8 => Self::UpdateRollup,
                9 => Self::Update,
                _ => Self::UnknownValue(classification::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Classification {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLASSIFICATION_UNSPECIFIED" => Self::Unspecified,
                "CRITICAL" => Self::Critical,
                "SECURITY" => Self::Security,
                "DEFINITION" => Self::Definition,
                "DRIVER" => Self::Driver,
                "FEATURE_PACK" => Self::FeaturePack,
                "SERVICE_PACK" => Self::ServicePack,
                "TOOL" => Self::Tool,
                "UPDATE_ROLLUP" => Self::UpdateRollup,
                "UPDATE" => Self::Update,
                _ => Self::UnknownValue(classification::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Classification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Critical => serializer.serialize_i32(1),
                Self::Security => serializer.serialize_i32(2),
                Self::Definition => serializer.serialize_i32(3),
                Self::Driver => serializer.serialize_i32(4),
                Self::FeaturePack => serializer.serialize_i32(5),
                Self::ServicePack => serializer.serialize_i32(6),
                Self::Tool => serializer.serialize_i32(7),
                Self::UpdateRollup => serializer.serialize_i32(8),
                Self::Update => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Classification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Classification>::new(
                ".google.cloud.osconfig.v1.WindowsUpdateSettings.Classification",
            ))
        }
    }
}

/// A step that runs an executable for a PatchJob.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    pub linux_exec_step_config: std::option::Option<crate::model::ExecStepConfig>,

    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    pub windows_exec_step_config: std::option::Option<crate::model::ExecStepConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [linux_exec_step_config][crate::model::ExecStep::linux_exec_step_config].
    pub fn set_linux_exec_step_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecStepConfig>,
    {
        self.linux_exec_step_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [linux_exec_step_config][crate::model::ExecStep::linux_exec_step_config].
    pub fn set_or_clear_linux_exec_step_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecStepConfig>,
    {
        self.linux_exec_step_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_exec_step_config][crate::model::ExecStep::windows_exec_step_config].
    pub fn set_windows_exec_step_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecStepConfig>,
    {
        self.windows_exec_step_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_exec_step_config][crate::model::ExecStep::windows_exec_step_config].
    pub fn set_or_clear_windows_exec_step_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecStepConfig>,
    {
        self.windows_exec_step_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ExecStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __linux_exec_step_config,
            __windows_exec_step_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linuxExecStepConfig" => Ok(__FieldTag::__linux_exec_step_config),
                            "linux_exec_step_config" => Ok(__FieldTag::__linux_exec_step_config),
                            "windowsExecStepConfig" => Ok(__FieldTag::__windows_exec_step_config),
                            "windows_exec_step_config" => {
                                Ok(__FieldTag::__windows_exec_step_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__linux_exec_step_config => {
                            if !fields.insert(__FieldTag::__linux_exec_step_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_exec_step_config",
                                ));
                            }
                            result.linux_exec_step_config = map
                                .next_value::<std::option::Option<crate::model::ExecStepConfig>>(
                                )?;
                        }
                        __FieldTag::__windows_exec_step_config => {
                            if !fields.insert(__FieldTag::__windows_exec_step_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_exec_step_config",
                                ));
                            }
                            result.windows_exec_step_config = map
                                .next_value::<std::option::Option<crate::model::ExecStepConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.linux_exec_step_config.is_some() {
            state.serialize_entry("linuxExecStepConfig", &self.linux_exec_step_config)?;
        }
        if self.windows_exec_step_config.is_some() {
            state.serialize_entry("windowsExecStepConfig", &self.windows_exec_step_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecStep");
        debug_struct.field("linux_exec_step_config", &self.linux_exec_step_config);
        debug_struct.field("windows_exec_step_config", &self.windows_exec_step_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Common configurations for an ExecStep.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the
    /// execution can return to indicate a success.
    pub allowed_success_codes: std::vec::Vec<i32>,

    /// The script interpreter to use to run the script. If no interpreter is
    /// specified the script will be executed directly, which will likely
    /// only succeed for scripts with [shebang lines]
    /// (<https://en.wikipedia.org/wiki/Shebang_>\(Unix\)).
    pub interpreter: crate::model::exec_step_config::Interpreter,

    /// Location of the executable.
    pub executable: std::option::Option<crate::model::exec_step_config::Executable>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecStepConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_success_codes][crate::model::ExecStepConfig::allowed_success_codes].
    pub fn set_allowed_success_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.allowed_success_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [interpreter][crate::model::ExecStepConfig::interpreter].
    pub fn set_interpreter<T: std::convert::Into<crate::model::exec_step_config::Interpreter>>(
        mut self,
        v: T,
    ) -> Self {
        self.interpreter = v.into();
        self
    }

    /// Sets the value of [executable][crate::model::ExecStepConfig::executable].
    ///
    /// Note that all the setters affecting `executable` are mutually
    /// exclusive.
    pub fn set_executable<
        T: std::convert::Into<std::option::Option<crate::model::exec_step_config::Executable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.executable = v.into();
        self
    }

    /// The value of [executable][crate::model::ExecStepConfig::executable]
    /// if it holds a `LocalPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn local_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.executable.as_ref().and_then(|v| match v {
            crate::model::exec_step_config::Executable::LocalPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [executable][crate::model::ExecStepConfig::executable]
    /// to hold a `LocalPath`.
    ///
    /// Note that all the setters affecting `executable` are
    /// mutually exclusive.
    pub fn set_local_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.executable = std::option::Option::Some(
            crate::model::exec_step_config::Executable::LocalPath(v.into()),
        );
        self
    }

    /// The value of [executable][crate::model::ExecStepConfig::executable]
    /// if it holds a `GcsObject`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_object(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsObject>> {
        #[allow(unreachable_patterns)]
        self.executable.as_ref().and_then(|v| match v {
            crate::model::exec_step_config::Executable::GcsObject(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [executable][crate::model::ExecStepConfig::executable]
    /// to hold a `GcsObject`.
    ///
    /// Note that all the setters affecting `executable` are
    /// mutually exclusive.
    pub fn set_gcs_object<T: std::convert::Into<std::boxed::Box<crate::model::GcsObject>>>(
        mut self,
        v: T,
    ) -> Self {
        self.executable = std::option::Option::Some(
            crate::model::exec_step_config::Executable::GcsObject(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecStepConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ExecStepConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecStepConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_path,
            __gcs_object,
            __allowed_success_codes,
            __interpreter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecStepConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localPath" => Ok(__FieldTag::__local_path),
                            "local_path" => Ok(__FieldTag::__local_path),
                            "gcsObject" => Ok(__FieldTag::__gcs_object),
                            "gcs_object" => Ok(__FieldTag::__gcs_object),
                            "allowedSuccessCodes" => Ok(__FieldTag::__allowed_success_codes),
                            "allowed_success_codes" => Ok(__FieldTag::__allowed_success_codes),
                            "interpreter" => Ok(__FieldTag::__interpreter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecStepConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecStepConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_path => {
                            if !fields.insert(__FieldTag::__local_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_path",
                                ));
                            }
                            if result.executable.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `executable`, a oneof with full ID .google.cloud.osconfig.v1.ExecStepConfig.local_path, latest field was localPath",
                                ));
                            }
                            result.executable = std::option::Option::Some(
                                crate::model::exec_step_config::Executable::LocalPath(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_object => {
                            if !fields.insert(__FieldTag::__gcs_object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_object",
                                ));
                            }
                            if result.executable.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `executable`, a oneof with full ID .google.cloud.osconfig.v1.ExecStepConfig.gcs_object, latest field was gcsObject",
                                ));
                            }
                            result.executable = std::option::Option::Some(
                                crate::model::exec_step_config::Executable::GcsObject(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsObject>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__allowed_success_codes => {
                            if !fields.insert(__FieldTag::__allowed_success_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_success_codes",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allowed_success_codes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__interpreter => {
                            if !fields.insert(__FieldTag::__interpreter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interpreter",
                                ));
                            }
                            result.interpreter =
                                map.next_value::<std::option::Option<
                                    crate::model::exec_step_config::Interpreter,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecStepConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.local_path() {
            state.serialize_entry("localPath", value)?;
        }
        if let Some(value) = self.gcs_object() {
            state.serialize_entry("gcsObject", value)?;
        }
        if !self.allowed_success_codes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("allowedSuccessCodes", &__With(&self.allowed_success_codes))?;
        }
        if !wkt::internal::is_default(&self.interpreter) {
            state.serialize_entry("interpreter", &self.interpreter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecStepConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecStepConfig");
        debug_struct.field("allowed_success_codes", &self.allowed_success_codes);
        debug_struct.field("interpreter", &self.interpreter);
        debug_struct.field("executable", &self.executable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExecStepConfig].
pub mod exec_step_config {
    #[allow(unused_imports)]
    use super::*;

    /// The interpreter used to execute the a file.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Interpreter {
        /// Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
        /// interpreter will be parsed from the shebang line of the script if
        /// unspecified.
        Unspecified,
        /// Indicates that the script is run with `/bin/sh` on Linux and `cmd`
        /// on Windows.
        Shell,
        /// Indicates that the file is run with PowerShell flags
        /// `-NonInteractive`, `-NoProfile`, and `-ExecutionPolicy Bypass`.
        Powershell,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Interpreter::value] or
        /// [Interpreter::name].
        UnknownValue(interpreter::UnknownValue),
    }

    #[doc(hidden)]
    pub mod interpreter {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Interpreter {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Shell => std::option::Option::Some(1),
                Self::Powershell => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INTERPRETER_UNSPECIFIED"),
                Self::Shell => std::option::Option::Some("SHELL"),
                Self::Powershell => std::option::Option::Some("POWERSHELL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Interpreter {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Interpreter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Interpreter {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Shell,
                2 => Self::Powershell,
                _ => Self::UnknownValue(interpreter::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Interpreter {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERPRETER_UNSPECIFIED" => Self::Unspecified,
                "SHELL" => Self::Shell,
                "POWERSHELL" => Self::Powershell,
                _ => Self::UnknownValue(interpreter::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Interpreter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Shell => serializer.serialize_i32(1),
                Self::Powershell => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Interpreter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Interpreter>::new(
                ".google.cloud.osconfig.v1.ExecStepConfig.Interpreter",
            ))
        }
    }

    /// Location of the executable.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Executable {
        /// An absolute path to the executable on the VM.
        LocalPath(std::string::String),
        /// A Cloud Storage object containing the executable.
        GcsObject(std::boxed::Box<crate::model::GcsObject>),
    }
}

/// Cloud Storage object representation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsObject {
    /// Required. Bucket of the Cloud Storage object.
    pub bucket: std::string::String,

    /// Required. Name of the Cloud Storage object.
    pub object: std::string::String,

    /// Required. Generation number of the Cloud Storage object. This is used to
    /// ensure that the ExecStep specified by this PatchJob does not change.
    pub generation_number: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsObject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GcsObject::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::GcsObject::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation_number][crate::model::GcsObject::generation_number].
    pub fn set_generation_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation_number = v.into();
        self
    }
}

impl wkt::message::Message for GcsObject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GcsObject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsObject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsObject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generationNumber" => Ok(__FieldTag::__generation_number),
                            "generation_number" => Ok(__FieldTag::__generation_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsObject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsObject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation_number => {
                            if !fields.insert(__FieldTag::__generation_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation_number",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsObject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation_number) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generationNumber", &__With(&self.generation_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsObject");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation_number", &self.generation_number);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A filter to target VM instances for patching. The targeted
/// VMs must meet all criteria specified. So if both labels and zones are
/// specified, the patch job targets only VMs with those labels and in those
/// zones.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchInstanceFilter {
    /// Target all VM instances in the project. If true, no other criteria is
    /// permitted.
    pub all: bool,

    /// Targets VM instances matching ANY of these GroupLabels. This allows
    /// targeting of disparate groups of VM instances.
    pub group_labels: std::vec::Vec<crate::model::patch_instance_filter::GroupLabel>,

    /// Targets VM instances in ANY of these zones. Leave empty to target VM
    /// instances in any zone.
    pub zones: std::vec::Vec<std::string::String>,

    /// Targets any of the VM instances specified. Instances are specified by their
    /// URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`,
    /// `projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`, or
    /// `<https://www.googleapis.com/compute/v1/projects/>[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`
    pub instances: std::vec::Vec<std::string::String>,

    /// Targets VMs whose name starts with one of these prefixes. Similar to
    /// labels, this is another way to group VMs when targeting configs, for
    /// example prefix="prod-".
    pub instance_name_prefixes: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchInstanceFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all][crate::model::PatchInstanceFilter::all].
    pub fn set_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all = v.into();
        self
    }

    /// Sets the value of [group_labels][crate::model::PatchInstanceFilter::group_labels].
    pub fn set_group_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::patch_instance_filter::GroupLabel>,
    {
        use std::iter::Iterator;
        self.group_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [zones][crate::model::PatchInstanceFilter::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instances][crate::model::PatchInstanceFilter::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_name_prefixes][crate::model::PatchInstanceFilter::instance_name_prefixes].
    pub fn set_instance_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PatchInstanceFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchInstanceFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchInstanceFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all,
            __group_labels,
            __zones,
            __instances,
            __instance_name_prefixes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchInstanceFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "all" => Ok(__FieldTag::__all),
                            "groupLabels" => Ok(__FieldTag::__group_labels),
                            "group_labels" => Ok(__FieldTag::__group_labels),
                            "zones" => Ok(__FieldTag::__zones),
                            "instances" => Ok(__FieldTag::__instances),
                            "instanceNamePrefixes" => Ok(__FieldTag::__instance_name_prefixes),
                            "instance_name_prefixes" => Ok(__FieldTag::__instance_name_prefixes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchInstanceFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchInstanceFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all => {
                            if !fields.insert(__FieldTag::__all) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all",
                                ));
                            }
                            result.all = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_labels => {
                            if !fields.insert(__FieldTag::__group_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_labels",
                                ));
                            }
                            result.group_labels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::patch_instance_filter::GroupLabel>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zones => {
                            if !fields.insert(__FieldTag::__zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zones",
                                ));
                            }
                            result.zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_name_prefixes => {
                            if !fields.insert(__FieldTag::__instance_name_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_name_prefixes",
                                ));
                            }
                            result.instance_name_prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchInstanceFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.all) {
            state.serialize_entry("all", &self.all)?;
        }
        if !self.group_labels.is_empty() {
            state.serialize_entry("groupLabels", &self.group_labels)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.instance_name_prefixes.is_empty() {
            state.serialize_entry("instanceNamePrefixes", &self.instance_name_prefixes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PatchInstanceFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchInstanceFilter");
        debug_struct.field("all", &self.all);
        debug_struct.field("group_labels", &self.group_labels);
        debug_struct.field("zones", &self.zones);
        debug_struct.field("instances", &self.instances);
        debug_struct.field("instance_name_prefixes", &self.instance_name_prefixes);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PatchInstanceFilter].
pub mod patch_instance_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Targets a group of VM instances by using their [assigned
    /// labels](https://cloud.google.com/compute/docs/labeling-resources). Labels
    /// are key-value pairs. A `GroupLabel` is a combination of labels
    /// that is used to target VMs for a patch job.
    ///
    /// For example, a patch job can target VMs that have the following
    /// `GroupLabel`: `{"env":"test", "app":"web"}`. This means that the patch job
    /// is applied to VMs that have both the labels `env=test` and `app=web`.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroupLabel {
        /// Compute Engine instance labels that must be present for a VM
        /// instance to be targeted by this filter.
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupLabel {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::patch_instance_filter::GroupLabel::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for GroupLabel {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.PatchInstanceFilter.GroupLabel"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroupLabel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __labels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroupLabel")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "labels" => Ok(__FieldTag::__labels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroupLabel;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroupLabel")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GroupLabel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GroupLabel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GroupLabel");
            debug_struct.field("labels", &self.labels);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Patch rollout configuration specifications. Contains details on the
/// concurrency control when applying patch(es) to all targeted VMs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchRollout {
    /// Mode of the patch rollout.
    pub mode: crate::model::patch_rollout::Mode,

    /// The maximum number (or percentage) of VMs per zone to disrupt at any given
    /// moment. The number of VMs calculated from multiplying the percentage by the
    /// total number of VMs in a zone is rounded up.
    ///
    /// During patching, a VM is considered disrupted from the time the agent is
    /// notified to begin until patching has completed. This disruption time
    /// includes the time to complete reboot and any post-patch steps.
    ///
    /// A VM contributes to the disruption budget if its patching operation fails
    /// either when applying the patches, running pre or post patch steps, or if it
    /// fails to respond with a success notification before timing out. VMs that
    /// are not running or do not have an active agent do not count toward this
    /// disruption budget.
    ///
    /// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded,
    /// the patch job stops, because continuing to the next zone requires
    /// completion of the patch process in the previous zone.
    ///
    /// For example, if the disruption budget has a fixed value of `10`, and 8 VMs
    /// fail to patch in the current zone, the patch job continues to patch 2 VMs
    /// at a time until the zone is completed. When that zone is completed
    /// successfully, patching begins with 10 VMs at a time in the next zone. If 10
    /// VMs in the next zone fail to patch, the patch job stops.
    pub disruption_budget: std::option::Option<crate::model::FixedOrPercent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchRollout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::PatchRollout::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::patch_rollout::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [disruption_budget][crate::model::PatchRollout::disruption_budget].
    pub fn set_disruption_budget<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.disruption_budget = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disruption_budget][crate::model::PatchRollout::disruption_budget].
    pub fn set_or_clear_disruption_budget<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.disruption_budget = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PatchRollout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchRollout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchRollout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __disruption_budget,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchRollout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "disruptionBudget" => Ok(__FieldTag::__disruption_budget),
                            "disruption_budget" => Ok(__FieldTag::__disruption_budget),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchRollout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchRollout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::patch_rollout::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disruption_budget => {
                            if !fields.insert(__FieldTag::__disruption_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disruption_budget",
                                ));
                            }
                            result.disruption_budget = map
                                .next_value::<std::option::Option<crate::model::FixedOrPercent>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchRollout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.disruption_budget.is_some() {
            state.serialize_entry("disruptionBudget", &self.disruption_budget)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PatchRollout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchRollout");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("disruption_budget", &self.disruption_budget);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PatchRollout].
pub mod patch_rollout {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the rollout.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode must be specified.
        Unspecified,
        /// Patches are applied one zone at a time. The patch job begins in the
        /// region with the lowest number of targeted VMs. Within the region,
        /// patching begins in the zone with the lowest number of targeted VMs. If
        /// multiple regions (or zones within a region) have the same number of
        /// targeted VMs, a tie-breaker is achieved by sorting the regions or zones
        /// in alphabetical order.
        ZoneByZone,
        /// Patches are applied to VMs in all zones at the same time.
        ConcurrentZones,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ZoneByZone => std::option::Option::Some(1),
                Self::ConcurrentZones => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::ZoneByZone => std::option::Option::Some("ZONE_BY_ZONE"),
                Self::ConcurrentZones => std::option::Option::Some("CONCURRENT_ZONES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ZoneByZone,
                2 => Self::ConcurrentZones,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "ZONE_BY_ZONE" => Self::ZoneByZone,
                "CONCURRENT_ZONES" => Self::ConcurrentZones,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ZoneByZone => serializer.serialize_i32(1),
                Self::ConcurrentZones => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.osconfig.v1.PatchRollout.Mode",
            ))
        }
    }
}

/// This API resource represents the vulnerability report for a specified
/// Compute Engine virtual machine (VM) instance at a given point in time.
///
/// For more information, see [Vulnerability
/// reports](https://cloud.google.com/compute/docs/instances/os-inventory-management#vulnerability-reports).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VulnerabilityReport {
    /// Output only. The `vulnerabilityReport` API resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/instances/{instance_id}/vulnerabilityReport`
    pub name: std::string::String,

    /// Output only. List of vulnerabilities affecting the VM.
    pub vulnerabilities: std::vec::Vec<crate::model::vulnerability_report::Vulnerability>,

    /// Output only. The timestamp for when the last vulnerability report was generated for the
    /// VM.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VulnerabilityReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [vulnerabilities][crate::model::VulnerabilityReport::vulnerabilities].
    pub fn set_vulnerabilities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_report::Vulnerability>,
    {
        use std::iter::Iterator;
        self.vulnerabilities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::VulnerabilityReport::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VulnerabilityReport::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VulnerabilityReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VulnerabilityReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __vulnerabilities,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VulnerabilityReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "vulnerabilities" => Ok(__FieldTag::__vulnerabilities),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VulnerabilityReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VulnerabilityReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vulnerabilities => {
                            if !fields.insert(__FieldTag::__vulnerabilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerabilities",
                                ));
                            }
                            result.vulnerabilities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::vulnerability_report::Vulnerability,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VulnerabilityReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.vulnerabilities.is_empty() {
            state.serialize_entry("vulnerabilities", &self.vulnerabilities)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VulnerabilityReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VulnerabilityReport");
        debug_struct.field("name", &self.name);
        debug_struct.field("vulnerabilities", &self.vulnerabilities);
        debug_struct.field("update_time", &self.update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VulnerabilityReport].
pub mod vulnerability_report {
    #[allow(unused_imports)]
    use super::*;

    /// A vulnerability affecting the VM instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Vulnerability {
        /// Contains metadata as per the upstream feed of the operating system and
        /// NVD.
        pub details:
            std::option::Option<crate::model::vulnerability_report::vulnerability::Details>,

        /// Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
        /// This field displays the inventory items affected by this vulnerability.
        /// If the vulnerability report was not updated after the VM inventory
        /// update, these values might not display in VM inventory. For some distros,
        /// this field may be empty.
        #[deprecated]
        pub installed_inventory_item_ids: std::vec::Vec<std::string::String>,

        /// Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
        /// If the vulnerability report was not updated after the VM inventory
        /// update, these values might not display in VM inventory. If there is no
        /// available fix, the field is empty. The `inventory_item` value specifies
        /// the latest `SoftwarePackage` available to the VM that fixes the
        /// vulnerability.
        #[deprecated]
        pub available_inventory_item_ids: std::vec::Vec<std::string::String>,

        /// The timestamp for when the vulnerability was first detected.
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// The timestamp for when the vulnerability was last modified.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// List of items affected by the vulnerability.
        pub items: std::vec::Vec<crate::model::vulnerability_report::vulnerability::Item>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Vulnerability {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [details][crate::model::vulnerability_report::Vulnerability::details].
        pub fn set_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::vulnerability_report::vulnerability::Details>,
        {
            self.details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [details][crate::model::vulnerability_report::Vulnerability::details].
        pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::vulnerability_report::vulnerability::Details>,
        {
            self.details = v.map(|x| x.into());
            self
        }

        /// Sets the value of [installed_inventory_item_ids][crate::model::vulnerability_report::Vulnerability::installed_inventory_item_ids].
        #[deprecated]
        pub fn set_installed_inventory_item_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.installed_inventory_item_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [available_inventory_item_ids][crate::model::vulnerability_report::Vulnerability::available_inventory_item_ids].
        #[deprecated]
        pub fn set_available_inventory_item_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.available_inventory_item_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [create_time][crate::model::vulnerability_report::Vulnerability::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::vulnerability_report::Vulnerability::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [update_time][crate::model::vulnerability_report::Vulnerability::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::vulnerability_report::Vulnerability::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [items][crate::model::vulnerability_report::Vulnerability::items].
        pub fn set_items<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_report::vulnerability::Item>,
        {
            use std::iter::Iterator;
            self.items = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Vulnerability {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Vulnerability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __details,
                __installed_inventory_item_ids,
                __available_inventory_item_ids,
                __create_time,
                __update_time,
                __items,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Vulnerability")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "details" => Ok(__FieldTag::__details),
                                "installedInventoryItemIds" => {
                                    Ok(__FieldTag::__installed_inventory_item_ids)
                                }
                                "installed_inventory_item_ids" => {
                                    Ok(__FieldTag::__installed_inventory_item_ids)
                                }
                                "availableInventoryItemIds" => {
                                    Ok(__FieldTag::__available_inventory_item_ids)
                                }
                                "available_inventory_item_ids" => {
                                    Ok(__FieldTag::__available_inventory_item_ids)
                                }
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "items" => Ok(__FieldTag::__items),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Vulnerability;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Vulnerability")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__details => {
                                if !fields.insert(__FieldTag::__details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for details",
                                    ));
                                }
                                result.details = map.next_value::<std::option::Option<
                                    crate::model::vulnerability_report::vulnerability::Details,
                                >>()?;
                            }
                            __FieldTag::__installed_inventory_item_ids => {
                                if !fields.insert(__FieldTag::__installed_inventory_item_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for installed_inventory_item_ids",
                                    ));
                                }
                                result.installed_inventory_item_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__available_inventory_item_ids => {
                                if !fields.insert(__FieldTag::__available_inventory_item_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for available_inventory_item_ids",
                                    ));
                                }
                                result.available_inventory_item_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__items => {
                                if !fields.insert(__FieldTag::__items) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for items",
                                    ));
                                }
                                result.items = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::vulnerability_report::vulnerability::Item,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Vulnerability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.details.is_some() {
                state.serialize_entry("details", &self.details)?;
            }
            if !self.installed_inventory_item_ids.is_empty() {
                state.serialize_entry(
                    "installedInventoryItemIds",
                    &self.installed_inventory_item_ids,
                )?;
            }
            if !self.available_inventory_item_ids.is_empty() {
                state.serialize_entry(
                    "availableInventoryItemIds",
                    &self.available_inventory_item_ids,
                )?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self.items.is_empty() {
                state.serialize_entry("items", &self.items)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Vulnerability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Vulnerability");
            debug_struct.field("details", &self.details);
            debug_struct.field(
                "installed_inventory_item_ids",
                &self.installed_inventory_item_ids,
            );
            debug_struct.field(
                "available_inventory_item_ids",
                &self.available_inventory_item_ids,
            );
            debug_struct.field("create_time", &self.create_time);
            debug_struct.field("update_time", &self.update_time);
            debug_struct.field("items", &self.items);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Vulnerability].
    pub mod vulnerability {
        #[allow(unused_imports)]
        use super::*;

        /// Contains metadata information for the vulnerability. This information is
        /// collected from the upstream feed of the operating system.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Details {
            /// The CVE of the vulnerability. CVE cannot be
            /// empty and the combination of <cve, classification> should be unique
            /// across vulnerabilities for a VM.
            pub cve: std::string::String,

            /// The CVSS V2 score of this vulnerability. CVSS V2 score is on a scale of
            /// 0 - 10 where 0 indicates low severity and 10 indicates high severity.
            pub cvss_v2_score: f32,

            /// The full description of the CVSSv3 for this vulnerability from NVD.
            pub cvss_v3: std::option::Option<crate::model::CVSSv3>,

            /// Assigned severity/impact ranking from the distro.
            pub severity: std::string::String,

            /// The note or description describing the vulnerability from the distro.
            pub description: std::string::String,

            /// Corresponds to the references attached to the `VulnerabilityDetails`.
            pub references: std::vec::Vec<
                crate::model::vulnerability_report::vulnerability::details::Reference,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Details {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cve][crate::model::vulnerability_report::vulnerability::Details::cve].
            pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.cve = v.into();
                self
            }

            /// Sets the value of [cvss_v2_score][crate::model::vulnerability_report::vulnerability::Details::cvss_v2_score].
            pub fn set_cvss_v2_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.cvss_v2_score = v.into();
                self
            }

            /// Sets the value of [cvss_v3][crate::model::vulnerability_report::vulnerability::Details::cvss_v3].
            pub fn set_cvss_v3<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::CVSSv3>,
            {
                self.cvss_v3 = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [cvss_v3][crate::model::vulnerability_report::vulnerability::Details::cvss_v3].
            pub fn set_or_clear_cvss_v3<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::CVSSv3>,
            {
                self.cvss_v3 = v.map(|x| x.into());
                self
            }

            /// Sets the value of [severity][crate::model::vulnerability_report::vulnerability::Details::severity].
            pub fn set_severity<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.severity = v.into();
                self
            }

            /// Sets the value of [description][crate::model::vulnerability_report::vulnerability::Details::description].
            pub fn set_description<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.description = v.into();
                self
            }

            /// Sets the value of [references][crate::model::vulnerability_report::vulnerability::Details::references].
            pub fn set_references<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::vulnerability_report::vulnerability::details::Reference,
                    >,
            {
                use std::iter::Iterator;
                self.references = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Details {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability.Details"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Details {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __cve,
                    __cvss_v2_score,
                    __cvss_v3,
                    __severity,
                    __description,
                    __references,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Details")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "cve" => Ok(__FieldTag::__cve),
                                    "cvssV2Score" => Ok(__FieldTag::__cvss_v2_score),
                                    "cvss_v2_score" => Ok(__FieldTag::__cvss_v2_score),
                                    "cvssV3" => Ok(__FieldTag::__cvss_v3),
                                    "cvss_v3" => Ok(__FieldTag::__cvss_v3),
                                    "severity" => Ok(__FieldTag::__severity),
                                    "description" => Ok(__FieldTag::__description),
                                    "references" => Ok(__FieldTag::__references),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Details;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Details")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__cve => {
                                    if !fields.insert(__FieldTag::__cve) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for cve"),
                                        );
                                    }
                                    result.cve = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__cvss_v2_score => {
                                    if !fields.insert(__FieldTag::__cvss_v2_score) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cvss_v2_score",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.cvss_v2_score =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__cvss_v3 => {
                                    if !fields.insert(__FieldTag::__cvss_v3) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cvss_v3",
                                            ),
                                        );
                                    }
                                    result.cvss_v3 = map
                                        .next_value::<std::option::Option<crate::model::CVSSv3>>(
                                        )?;
                                }
                                __FieldTag::__severity => {
                                    if !fields.insert(__FieldTag::__severity) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for severity",
                                            ),
                                        );
                                    }
                                    result.severity = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__description => {
                                    if !fields.insert(__FieldTag::__description) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for description",
                                            ),
                                        );
                                    }
                                    result.description = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__references => {
                                    if !fields.insert(__FieldTag::__references) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for references",
                                            ),
                                        );
                                    }
                                    result.references = map.next_value::<std::option::Option<std::vec::Vec<crate::model::vulnerability_report::vulnerability::details::Reference>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Details {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.cve.is_empty() {
                    state.serialize_entry("cve", &self.cve)?;
                }
                if !wkt::internal::is_default(&self.cvss_v2_score) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("cvssV2Score", &__With(&self.cvss_v2_score))?;
                }
                if self.cvss_v3.is_some() {
                    state.serialize_entry("cvssV3", &self.cvss_v3)?;
                }
                if !self.severity.is_empty() {
                    state.serialize_entry("severity", &self.severity)?;
                }
                if !self.description.is_empty() {
                    state.serialize_entry("description", &self.description)?;
                }
                if !self.references.is_empty() {
                    state.serialize_entry("references", &self.references)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Details {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Details");
                debug_struct.field("cve", &self.cve);
                debug_struct.field("cvss_v2_score", &self.cvss_v2_score);
                debug_struct.field("cvss_v3", &self.cvss_v3);
                debug_struct.field("severity", &self.severity);
                debug_struct.field("description", &self.description);
                debug_struct.field("references", &self.references);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Details].
        pub mod details {
            #[allow(unused_imports)]
            use super::*;

            /// A reference for this vulnerability.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Reference {
                /// The url of the reference.
                pub url: std::string::String,

                /// The source of the reference e.g. NVD.
                pub source: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Reference {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [url][crate::model::vulnerability_report::vulnerability::details::Reference::url].
                pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.url = v.into();
                    self
                }

                /// Sets the value of [source][crate::model::vulnerability_report::vulnerability::details::Reference::source].
                pub fn set_source<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }
            }

            impl wkt::message::Message for Reference {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability.Details.Reference"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Reference {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __url,
                        __source,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Reference")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "url" => Ok(__FieldTag::__url),
                                        "source" => Ok(__FieldTag::__source),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Reference;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Reference")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__url => {
                                        if !fields.insert(__FieldTag::__url) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for url",
                                                ),
                                            );
                                        }
                                        result.url = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__source => {
                                        if !fields.insert(__FieldTag::__source) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for source",
                                                ),
                                            );
                                        }
                                        result.source = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Reference {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.url.is_empty() {
                        state.serialize_entry("url", &self.url)?;
                    }
                    if !self.source.is_empty() {
                        state.serialize_entry("source", &self.source)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Reference {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Reference");
                    debug_struct.field("url", &self.url);
                    debug_struct.field("source", &self.source);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }

        /// OS inventory item that is affected by a vulnerability or fixed as a
        /// result of a vulnerability.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Item {
            /// Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
            /// This field displays the inventory items affected by this vulnerability.
            /// If the vulnerability report was not updated after the VM inventory
            /// update, these values might not display in VM inventory. For some
            /// operating systems, this field might be empty.
            pub installed_inventory_item_id: std::string::String,

            /// Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
            /// If the vulnerability report was not updated after the VM inventory
            /// update, these values might not display in VM inventory. If there is no
            /// available fix, the field is empty. The `inventory_item` value specifies
            /// the latest `SoftwarePackage` available to the VM that fixes the
            /// vulnerability.
            pub available_inventory_item_id: std::string::String,

            /// The recommended [CPE URI](https://cpe.mitre.org/specification/) update
            /// that contains a fix for this vulnerability.
            pub fixed_cpe_uri: std::string::String,

            /// The upstream OS patch, packages or KB that fixes the vulnerability.
            pub upstream_fix: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Item {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [installed_inventory_item_id][crate::model::vulnerability_report::vulnerability::Item::installed_inventory_item_id].
            pub fn set_installed_inventory_item_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.installed_inventory_item_id = v.into();
                self
            }

            /// Sets the value of [available_inventory_item_id][crate::model::vulnerability_report::vulnerability::Item::available_inventory_item_id].
            pub fn set_available_inventory_item_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.available_inventory_item_id = v.into();
                self
            }

            /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_report::vulnerability::Item::fixed_cpe_uri].
            pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.fixed_cpe_uri = v.into();
                self
            }

            /// Sets the value of [upstream_fix][crate::model::vulnerability_report::vulnerability::Item::upstream_fix].
            pub fn set_upstream_fix<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.upstream_fix = v.into();
                self
            }
        }

        impl wkt::message::Message for Item {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability.Item"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Item {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __installed_inventory_item_id,
                    __available_inventory_item_id,
                    __fixed_cpe_uri,
                    __upstream_fix,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Item")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "installedInventoryItemId" => {
                                        Ok(__FieldTag::__installed_inventory_item_id)
                                    }
                                    "installed_inventory_item_id" => {
                                        Ok(__FieldTag::__installed_inventory_item_id)
                                    }
                                    "availableInventoryItemId" => {
                                        Ok(__FieldTag::__available_inventory_item_id)
                                    }
                                    "available_inventory_item_id" => {
                                        Ok(__FieldTag::__available_inventory_item_id)
                                    }
                                    "fixedCpeUri" => Ok(__FieldTag::__fixed_cpe_uri),
                                    "fixed_cpe_uri" => Ok(__FieldTag::__fixed_cpe_uri),
                                    "upstreamFix" => Ok(__FieldTag::__upstream_fix),
                                    "upstream_fix" => Ok(__FieldTag::__upstream_fix),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Item;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Item")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__installed_inventory_item_id => {
                                    if !fields.insert(__FieldTag::__installed_inventory_item_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for installed_inventory_item_id",
                                            ),
                                        );
                                    }
                                    result.installed_inventory_item_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__available_inventory_item_id => {
                                    if !fields.insert(__FieldTag::__available_inventory_item_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for available_inventory_item_id",
                                            ),
                                        );
                                    }
                                    result.available_inventory_item_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__fixed_cpe_uri => {
                                    if !fields.insert(__FieldTag::__fixed_cpe_uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for fixed_cpe_uri",
                                            ),
                                        );
                                    }
                                    result.fixed_cpe_uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__upstream_fix => {
                                    if !fields.insert(__FieldTag::__upstream_fix) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for upstream_fix",
                                            ),
                                        );
                                    }
                                    result.upstream_fix = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Item {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.installed_inventory_item_id.is_empty() {
                    state.serialize_entry(
                        "installedInventoryItemId",
                        &self.installed_inventory_item_id,
                    )?;
                }
                if !self.available_inventory_item_id.is_empty() {
                    state.serialize_entry(
                        "availableInventoryItemId",
                        &self.available_inventory_item_id,
                    )?;
                }
                if !self.fixed_cpe_uri.is_empty() {
                    state.serialize_entry("fixedCpeUri", &self.fixed_cpe_uri)?;
                }
                if !self.upstream_fix.is_empty() {
                    state.serialize_entry("upstreamFix", &self.upstream_fix)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Item {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Item");
                debug_struct.field(
                    "installed_inventory_item_id",
                    &self.installed_inventory_item_id,
                );
                debug_struct.field(
                    "available_inventory_item_id",
                    &self.available_inventory_item_id,
                );
                debug_struct.field("fixed_cpe_uri", &self.fixed_cpe_uri);
                debug_struct.field("upstream_fix", &self.upstream_fix);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// A request message for getting the vulnerability report for the specified VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVulnerabilityReportRequest {
    /// Required. API resource name for vulnerability resource.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}/vulnerabilityReport`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance}`, either Compute Engine `instance-id` or `instance-name`
    /// can be provided.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVulnerabilityReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVulnerabilityReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVulnerabilityReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetVulnerabilityReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVulnerabilityReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVulnerabilityReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVulnerabilityReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVulnerabilityReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVulnerabilityReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVulnerabilityReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVulnerabilityReportRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request message for listing vulnerability reports for all VM instances in
/// the specified location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVulnerabilityReportsRequest {
    /// Required. The parent resource name.
    ///
    /// Format: `projects/{project}/locations/{location}/instances/-`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    pub parent: std::string::String,

    /// The maximum number of results to return.
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListVulnerabilityReports` that indicates where this listing
    /// should continue from.
    pub page_token: std::string::String,

    /// If provided, this field specifies the criteria that must be met by a
    /// `vulnerabilityReport` API resource to be included in the response.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVulnerabilityReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVulnerabilityReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVulnerabilityReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVulnerabilityReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVulnerabilityReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVulnerabilityReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListVulnerabilityReportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVulnerabilityReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVulnerabilityReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVulnerabilityReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVulnerabilityReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVulnerabilityReportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVulnerabilityReportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVulnerabilityReportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A response message for listing vulnerability reports for all VM instances in
/// the specified location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVulnerabilityReportsResponse {
    /// List of vulnerabilityReport objects.
    pub vulnerability_reports: std::vec::Vec<crate::model::VulnerabilityReport>,

    /// The pagination token to retrieve the next page of vulnerabilityReports
    /// object.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVulnerabilityReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vulnerability_reports][crate::model::ListVulnerabilityReportsResponse::vulnerability_reports].
    pub fn set_vulnerability_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VulnerabilityReport>,
    {
        use std::iter::Iterator;
        self.vulnerability_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVulnerabilityReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVulnerabilityReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListVulnerabilityReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVulnerabilityReportsResponse {
    type PageItem = crate::model::VulnerabilityReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vulnerability_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVulnerabilityReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vulnerability_reports,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVulnerabilityReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vulnerabilityReports" => Ok(__FieldTag::__vulnerability_reports),
                            "vulnerability_reports" => Ok(__FieldTag::__vulnerability_reports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVulnerabilityReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVulnerabilityReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vulnerability_reports => {
                            if !fields.insert(__FieldTag::__vulnerability_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_reports",
                                ));
                            }
                            result.vulnerability_reports = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VulnerabilityReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVulnerabilityReportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vulnerability_reports.is_empty() {
            state.serialize_entry("vulnerabilityReports", &self.vulnerability_reports)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVulnerabilityReportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVulnerabilityReportsResponse");
        debug_struct.field("vulnerability_reports", &self.vulnerability_reports);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Common Vulnerability Scoring System version 3.
/// For details, see <https://www.first.org/cvss/specification-document>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CVSSv3 {
    /// The base score is a function of the base metric scores.
    /// <https://www.first.org/cvss/specification-document#Base-Metrics>
    pub base_score: f32,

    /// The Exploitability sub-score equation is derived from the Base
    /// Exploitability metrics.
    /// <https://www.first.org/cvss/specification-document#2-1-Exploitability-Metrics>
    pub exploitability_score: f32,

    /// The Impact sub-score equation is derived from the Base Impact metrics.
    pub impact_score: f32,

    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    pub attack_vector: crate::model::cvs_sv_3::AttackVector,

    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    pub attack_complexity: crate::model::cvs_sv_3::AttackComplexity,

    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    pub privileges_required: crate::model::cvs_sv_3::PrivilegesRequired,

    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    pub user_interaction: crate::model::cvs_sv_3::UserInteraction,

    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    pub scope: crate::model::cvs_sv_3::Scope,

    /// This metric measures the impact to the confidentiality of the information
    /// resources managed by a software component due to a successfully exploited
    /// vulnerability.
    pub confidentiality_impact: crate::model::cvs_sv_3::Impact,

    /// This metric measures the impact to integrity of a successfully exploited
    /// vulnerability.
    pub integrity_impact: crate::model::cvs_sv_3::Impact,

    /// This metric measures the impact to the availability of the impacted
    /// component resulting from a successfully exploited vulnerability.
    pub availability_impact: crate::model::cvs_sv_3::Impact,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CVSSv3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::CVSSv3::base_score].
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::CVSSv3::exploitability_score].
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::CVSSv3::impact_score].
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::CVSSv3::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvs_sv_3::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::CVSSv3::attack_complexity].
    pub fn set_attack_complexity<
        T: std::convert::Into<crate::model::cvs_sv_3::AttackComplexity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::CVSSv3::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvs_sv_3::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::CVSSv3::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvs_sv_3::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::CVSSv3::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvs_sv_3::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::CVSSv3::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::CVSSv3::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::CVSSv3::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for CVSSv3 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CVSSv3"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CVSSv3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __exploitability_score,
            __impact_score,
            __attack_vector,
            __attack_complexity,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CVSSv3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "exploitabilityScore" => Ok(__FieldTag::__exploitability_score),
                            "exploitability_score" => Ok(__FieldTag::__exploitability_score),
                            "impactScore" => Ok(__FieldTag::__impact_score),
                            "impact_score" => Ok(__FieldTag::__impact_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CVSSv3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CVSSv3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exploitability_score => {
                            if !fields.insert(__FieldTag::__exploitability_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitability_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exploitability_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__impact_score => {
                            if !fields.insert(__FieldTag::__impact_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.impact_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvs_sv_3::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvs_sv_3::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvs_sv_3::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvs_sv_3::Impact>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CVSSv3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.base_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("baseScore", &__With(&self.base_score))?;
        }
        if !wkt::internal::is_default(&self.exploitability_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exploitabilityScore", &__With(&self.exploitability_score))?;
        }
        if !wkt::internal::is_default(&self.impact_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("impactScore", &__With(&self.impact_score))?;
        }
        if !wkt::internal::is_default(&self.attack_vector) {
            state.serialize_entry("attackVector", &self.attack_vector)?;
        }
        if !wkt::internal::is_default(&self.attack_complexity) {
            state.serialize_entry("attackComplexity", &self.attack_complexity)?;
        }
        if !wkt::internal::is_default(&self.privileges_required) {
            state.serialize_entry("privilegesRequired", &self.privileges_required)?;
        }
        if !wkt::internal::is_default(&self.user_interaction) {
            state.serialize_entry("userInteraction", &self.user_interaction)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !wkt::internal::is_default(&self.confidentiality_impact) {
            state.serialize_entry("confidentialityImpact", &self.confidentiality_impact)?;
        }
        if !wkt::internal::is_default(&self.integrity_impact) {
            state.serialize_entry("integrityImpact", &self.integrity_impact)?;
        }
        if !wkt::internal::is_default(&self.availability_impact) {
            state.serialize_entry("availabilityImpact", &self.availability_impact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CVSSv3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CVSSv3");
        debug_struct.field("base_score", &self.base_score);
        debug_struct.field("exploitability_score", &self.exploitability_score);
        debug_struct.field("impact_score", &self.impact_score);
        debug_struct.field("attack_vector", &self.attack_vector);
        debug_struct.field("attack_complexity", &self.attack_complexity);
        debug_struct.field("privileges_required", &self.privileges_required);
        debug_struct.field("user_interaction", &self.user_interaction);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("confidentiality_impact", &self.confidentiality_impact);
        debug_struct.field("integrity_impact", &self.integrity_impact);
        debug_struct.field("availability_impact", &self.availability_impact);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CVSSv3].
pub mod cvs_sv_3 {
    #[allow(unused_imports)]
    use super::*;

    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        /// Invalid value.
        Unspecified,
        /// The vulnerable component is bound to the network stack and the set of
        /// possible attackers extends beyond the other options listed below, up to
        /// and including the entire Internet.
        Network,
        /// The vulnerable component is bound to the network stack, but the attack is
        /// limited at the protocol level to a logically adjacent topology.
        Adjacent,
        /// The vulnerable component is not bound to the network stack and the
        /// attacker's path is via read/write/execute capabilities.
        Local,
        /// The attack requires the attacker to physically touch or manipulate the
        /// vulnerable component.
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".google.cloud.osconfig.v1.CVSSv3.AttackVector",
            ))
        }
    }

    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        /// Invalid value.
        Unspecified,
        /// Specialized access conditions or extenuating circumstances do not exist.
        /// An attacker can expect repeatable success when attacking the vulnerable
        /// component.
        Low,
        /// A successful attack depends on conditions beyond the attacker's control.
        /// That is, a successful attack cannot be accomplished at will, but requires
        /// the attacker to invest in some measurable amount of effort in preparation
        /// or execution against the vulnerable component before a successful attack
        /// can be expected.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".google.cloud.osconfig.v1.CVSSv3.AttackComplexity",
            ))
        }
    }

    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        /// Invalid value.
        Unspecified,
        /// The attacker is unauthorized prior to attack, and therefore does not
        /// require any access to settings or files of the vulnerable system to
        /// carry out an attack.
        None,
        /// The attacker requires privileges that provide basic user capabilities
        /// that could normally affect only settings and files owned by a user.
        /// Alternatively, an attacker with Low privileges has the ability to access
        /// only non-sensitive resources.
        Low,
        /// The attacker requires privileges that provide significant (e.g.,
        /// administrative) control over the vulnerable component allowing access to
        /// component-wide settings and files.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".google.cloud.osconfig.v1.CVSSv3.PrivilegesRequired",
            ))
        }
    }

    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        /// Invalid value.
        Unspecified,
        /// The vulnerable system can be exploited without interaction from any user.
        None,
        /// Successful exploitation of this vulnerability requires a user to take
        /// some action before the vulnerability can be exploited.
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".google.cloud.osconfig.v1.CVSSv3.UserInteraction",
            ))
        }
    }

    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Invalid value.
        Unspecified,
        /// An exploited vulnerability can only affect resources managed by the same
        /// security authority.
        Unchanged,
        /// An exploited vulnerability can affect resources beyond the security scope
        /// managed by the security authority of the vulnerable component.
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.osconfig.v1.CVSSv3.Scope",
            ))
        }
    }

    /// The Impact metrics capture the effects of a successfully exploited
    /// vulnerability on the component that suffers the worst outcome that is most
    /// directly and predictably associated with the attack.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        /// Invalid value.
        Unspecified,
        /// High impact.
        High,
        /// Low impact.
        Low,
        /// No impact.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".google.cloud.osconfig.v1.CVSSv3.Impact",
            ))
        }
    }
}

/// The view for inventory objects.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InventoryView {
    /// The default value.
    /// The API defaults to the BASIC view.
    Unspecified,
    /// Returns the basic inventory information that includes `os_info`.
    Basic,
    /// Returns all fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InventoryView::value] or
    /// [InventoryView::name].
    UnknownValue(inventory_view::UnknownValue),
}

#[doc(hidden)]
pub mod inventory_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InventoryView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INVENTORY_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InventoryView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InventoryView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InventoryView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(inventory_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InventoryView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INVENTORY_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(inventory_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InventoryView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InventoryView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InventoryView>::new(
            ".google.cloud.osconfig.v1.InventoryView",
        ))
    }
}
