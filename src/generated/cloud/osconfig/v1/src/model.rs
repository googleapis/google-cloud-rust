// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// This API resource represents the available inventory data for a
/// Compute Engine virtual machine (VM) instance at a given point in time.
///
/// You can use this API resource to determine the inventory data of your VM.
///
/// For more information, see [Information provided by OS inventory
/// management](https://cloud.google.com/compute/docs/instances/os-inventory-management#data-collected).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Inventory {
    /// Output only. The `Inventory` API resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/instances/{instance_id}/inventory`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Base level operating system information for the VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub os_info: std::option::Option<crate::model::inventory::OsInfo>,

    /// Inventory items related to the VM keyed by an opaque unique identifier for
    /// each inventory item.  The identifier is unique to each distinct and
    /// addressable inventory item and will change, when there is a new package
    /// version.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub items: std::collections::HashMap<std::string::String, crate::model::inventory::Item>,

    /// Output only. Timestamp of the last reported inventory for the VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Inventory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Inventory::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [os_info][crate::model::Inventory::os_info].
    pub fn set_os_info<
        T: std::convert::Into<std::option::Option<crate::model::inventory::OsInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_info = v.into();
        self
    }

    /// Sets the value of [items][crate::model::Inventory::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::inventory::Item>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::Inventory::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for Inventory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.Inventory"
    }
}

/// Defines additional types related to [Inventory].
pub mod inventory {
    #[allow(unused_imports)]
    use super::*;

    /// Operating system information for the VM.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OsInfo {
        /// The VM hostname.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub hostname: std::string::String,

        /// The operating system long name.
        /// For example 'Debian GNU/Linux 9' or 'Microsoft Window Server 2019
        /// Datacenter'.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub long_name: std::string::String,

        /// The operating system short name.
        /// For example, 'windows' or 'debian'.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub short_name: std::string::String,

        /// The version of the operating system.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,

        /// The system architecture of the operating system.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub architecture: std::string::String,

        /// The kernel version of the operating system.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kernel_version: std::string::String,

        /// The kernel release of the operating system.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kernel_release: std::string::String,

        /// The current version of the OS Config agent running on the VM.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub osconfig_agent_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OsInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hostname][crate::model::inventory::OsInfo::hostname].
        pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.hostname = v.into();
            self
        }

        /// Sets the value of [long_name][crate::model::inventory::OsInfo::long_name].
        pub fn set_long_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.long_name = v.into();
            self
        }

        /// Sets the value of [short_name][crate::model::inventory::OsInfo::short_name].
        pub fn set_short_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.short_name = v.into();
            self
        }

        /// Sets the value of [version][crate::model::inventory::OsInfo::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }

        /// Sets the value of [architecture][crate::model::inventory::OsInfo::architecture].
        pub fn set_architecture<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.architecture = v.into();
            self
        }

        /// Sets the value of [kernel_version][crate::model::inventory::OsInfo::kernel_version].
        pub fn set_kernel_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kernel_version = v.into();
            self
        }

        /// Sets the value of [kernel_release][crate::model::inventory::OsInfo::kernel_release].
        pub fn set_kernel_release<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kernel_release = v.into();
            self
        }

        /// Sets the value of [osconfig_agent_version][crate::model::inventory::OsInfo::osconfig_agent_version].
        pub fn set_osconfig_agent_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.osconfig_agent_version = v.into();
            self
        }
    }

    impl wkt::message::Message for OsInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.OsInfo"
        }
    }

    /// A single piece of inventory on a VM.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Item {
        /// Identifier for this item, unique across items for this VM.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// The origin of this inventory item.
        pub origin_type: crate::model::inventory::item::OriginType,

        /// When this inventory item was first detected.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// When this inventory item was last modified.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// The specific type of inventory, correlating to its specific details.
        #[serde(rename = "type")]
        pub r#type: crate::model::inventory::item::Type,

        /// Specific details of this inventory item based on its type.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub details: std::option::Option<crate::model::inventory::item::Details>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Item {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::inventory::Item::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [origin_type][crate::model::inventory::Item::origin_type].
        pub fn set_origin_type<T: std::convert::Into<crate::model::inventory::item::OriginType>>(
            mut self,
            v: T,
        ) -> Self {
            self.origin_type = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::inventory::Item::create_time].
        pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.create_time = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::inventory::Item::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::inventory::Item::type].
        pub fn set_type<T: std::convert::Into<crate::model::inventory::item::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [details][crate::model::inventory::Item::details].
        ///
        /// Note that all the setters affecting `details` are mutually
        /// exclusive.
        pub fn set_details<
            T: std::convert::Into<std::option::Option<crate::model::inventory::item::Details>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = v.into();
            self
        }

        /// The value of [details][crate::model::inventory::Item::details]
        /// if it holds a `InstalledPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn installed_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::SoftwarePackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::item::Details::InstalledPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::Item::details]
        /// to hold a `InstalledPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_installed_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::SoftwarePackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::item::Details::InstalledPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::Item::details]
        /// if it holds a `AvailablePackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn available_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::SoftwarePackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::item::Details::AvailablePackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::Item::details]
        /// to hold a `AvailablePackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_available_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::SoftwarePackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::item::Details::AvailablePackage(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Item {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.Item"
        }
    }

    /// Defines additional types related to [Item].
    pub mod item {
        #[allow(unused_imports)]
        use super::*;

        /// The origin of a specific inventory item.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum OriginType {
            /// Invalid. An origin type must be specified.
            Unspecified,
            /// This inventory item was discovered as the result of the agent
            /// reporting inventory via the reporting API.
            InventoryReport,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [OriginType::value] or
            /// [OriginType::name].
            UnknownValue(origin_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod origin_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl OriginType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::InventoryReport => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ORIGIN_TYPE_UNSPECIFIED"),
                    Self::InventoryReport => std::option::Option::Some("INVENTORY_REPORT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for OriginType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for OriginType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for OriginType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::InventoryReport,
                    _ => Self::UnknownValue(origin_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for OriginType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ORIGIN_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "INVENTORY_REPORT" => Self::InventoryReport,
                    _ => Self::UnknownValue(origin_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for OriginType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::InventoryReport => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for OriginType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<OriginType>::new(
                    ".google.cloud.osconfig.v1.Inventory.Item.OriginType",
                ))
            }
        }

        /// The different types of inventory that are tracked on a VM.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Invalid. An type must be specified.
            Unspecified,
            /// This represents a package that is installed on the VM.
            InstalledPackage,
            /// This represents an update that is available for a package.
            AvailablePackage,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::InstalledPackage => std::option::Option::Some(1),
                    Self::AvailablePackage => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::InstalledPackage => std::option::Option::Some("INSTALLED_PACKAGE"),
                    Self::AvailablePackage => std::option::Option::Some("AVAILABLE_PACKAGE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::InstalledPackage,
                    2 => Self::AvailablePackage,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "INSTALLED_PACKAGE" => Self::InstalledPackage,
                    "AVAILABLE_PACKAGE" => Self::AvailablePackage,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::InstalledPackage => serializer.serialize_i32(1),
                    Self::AvailablePackage => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.osconfig.v1.Inventory.Item.Type",
                ))
            }
        }

        /// Specific details of this inventory item based on its type.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Details {
            /// Software package present on the VM instance.
            InstalledPackage(std::boxed::Box<crate::model::inventory::SoftwarePackage>),
            /// Software package available to be installed on the VM instance.
            AvailablePackage(std::boxed::Box<crate::model::inventory::SoftwarePackage>),
        }
    }

    /// Software package information of the operating system.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SoftwarePackage {
        /// Information about the different types of software packages.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub details: std::option::Option<crate::model::inventory::software_package::Details>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SoftwarePackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details].
        ///
        /// Note that all the setters affecting `details` are mutually
        /// exclusive.
        pub fn set_details<
            T: std::convert::Into<
                    std::option::Option<crate::model::inventory::software_package::Details>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = v.into();
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `YumPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn yum_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::YumPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `YumPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_yum_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::YumPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `AptPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn apt_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::AptPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `AptPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_apt_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::AptPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `ZypperPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn zypper_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::ZypperPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `ZypperPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_zypper_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::ZypperPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `GoogetPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn googet_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::GoogetPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `GoogetPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_googet_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::GoogetPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `ZypperPatch`, `None` if the field is not set or
        /// holds a different branch.
        pub fn zypper_patch(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::ZypperPatch>> {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::ZypperPatch(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `ZypperPatch`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_zypper_patch<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::ZypperPatch>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::ZypperPatch(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `WuaPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn wua_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::WindowsUpdatePackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::WuaPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `WuaPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_wua_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::WindowsUpdatePackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::WuaPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `QfePackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn qfe_package(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>,
        > {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::QfePackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `QfePackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_qfe_package<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::QfePackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `CosPackage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cos_package(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::VersionedPackage>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::CosPackage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `CosPackage`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_cos_package<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::VersionedPackage>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::CosPackage(v.into()),
            );
            self
        }

        /// The value of [details][crate::model::inventory::SoftwarePackage::details]
        /// if it holds a `WindowsApplication`, `None` if the field is not set or
        /// holds a different branch.
        pub fn windows_application(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::inventory::WindowsApplication>>
        {
            #[allow(unreachable_patterns)]
            self.details.as_ref().and_then(|v| match v {
                crate::model::inventory::software_package::Details::WindowsApplication(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [details][crate::model::inventory::SoftwarePackage::details]
        /// to hold a `WindowsApplication`.
        ///
        /// Note that all the setters affecting `details` are
        /// mutually exclusive.
        pub fn set_windows_application<
            T: std::convert::Into<std::boxed::Box<crate::model::inventory::WindowsApplication>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = std::option::Option::Some(
                crate::model::inventory::software_package::Details::WindowsApplication(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SoftwarePackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.SoftwarePackage"
        }
    }

    /// Defines additional types related to [SoftwarePackage].
    pub mod software_package {
        #[allow(unused_imports)]
        use super::*;

        /// Information about the different types of software packages.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Details {
            /// Yum package info.
            /// For details about the yum package manager, see
            /// <https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum>.
            YumPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of an APT package.
            /// For details about the apt package manager, see
            /// <https://wiki.debian.org/Apt>.
            AptPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of a Zypper package.
            /// For details about the Zypper package manager, see
            /// <https://en.opensuse.org/SDB:Zypper_manual>.
            ZypperPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of a Googet package.
            /// For details about the googet package manager, see
            /// <https://github.com/google/googet>.
            GoogetPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of a Zypper patch.
            /// For details about the Zypper package manager, see
            /// <https://en.opensuse.org/SDB:Zypper_manual>.
            ZypperPatch(std::boxed::Box<crate::model::inventory::ZypperPatch>),
            /// Details of a Windows Update package.
            /// See <https://docs.microsoft.com/en-us/windows/win32/api/_wua/> for
            /// information about Windows Update.
            WuaPackage(std::boxed::Box<crate::model::inventory::WindowsUpdatePackage>),
            /// Details of a Windows Quick Fix engineering package.
            /// See
            /// <https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering>
            /// for info in Windows Quick Fix Engineering.
            QfePackage(std::boxed::Box<crate::model::inventory::WindowsQuickFixEngineeringPackage>),
            /// Details of a COS package.
            CosPackage(std::boxed::Box<crate::model::inventory::VersionedPackage>),
            /// Details of Windows Application.
            WindowsApplication(std::boxed::Box<crate::model::inventory::WindowsApplication>),
        }
    }

    /// Information related to the a standard versioned package.  This includes
    /// package info for APT, Yum, Zypper, and Googet package managers.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VersionedPackage {
        /// The name of the package.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub package_name: std::string::String,

        /// The system architecture this package is intended for.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub architecture: std::string::String,

        /// The version of the package.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VersionedPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [package_name][crate::model::inventory::VersionedPackage::package_name].
        pub fn set_package_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.package_name = v.into();
            self
        }

        /// Sets the value of [architecture][crate::model::inventory::VersionedPackage::architecture].
        pub fn set_architecture<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.architecture = v.into();
            self
        }

        /// Sets the value of [version][crate::model::inventory::VersionedPackage::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for VersionedPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.VersionedPackage"
        }
    }

    /// Details related to a Zypper Patch.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ZypperPatch {
        /// The name of the patch.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub patch_name: std::string::String,

        /// The category of the patch.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub category: std::string::String,

        /// The severity specified for this patch
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub severity: std::string::String,

        /// Any summary information provided about this patch.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub summary: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ZypperPatch {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [patch_name][crate::model::inventory::ZypperPatch::patch_name].
        pub fn set_patch_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.patch_name = v.into();
            self
        }

        /// Sets the value of [category][crate::model::inventory::ZypperPatch::category].
        pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.category = v.into();
            self
        }

        /// Sets the value of [severity][crate::model::inventory::ZypperPatch::severity].
        pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.severity = v.into();
            self
        }

        /// Sets the value of [summary][crate::model::inventory::ZypperPatch::summary].
        pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.summary = v.into();
            self
        }
    }

    impl wkt::message::Message for ZypperPatch {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.ZypperPatch"
        }
    }

    /// Details related to a Windows Update package.
    /// Field data and names are taken from Windows Update API IUpdate Interface:
    /// <https://docs.microsoft.com/en-us/windows/win32/api/_wua/>
    /// Descriptive fields like title, and description are localized based on
    /// the locale of the VM being updated.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WindowsUpdatePackage {
        /// The localized title of the update package.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub title: std::string::String,

        /// The localized description of the update package.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// The categories that are associated with this update package.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub categories:
            std::vec::Vec<crate::model::inventory::windows_update_package::WindowsUpdateCategory>,

        /// A collection of Microsoft Knowledge Base article IDs that are associated
        /// with the update package.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub kb_article_ids: std::vec::Vec<std::string::String>,

        /// A hyperlink to the language-specific support information for the update.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub support_url: std::string::String,

        /// A collection of URLs that provide more information about the update
        /// package.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub more_info_urls: std::vec::Vec<std::string::String>,

        /// Gets the identifier of an update package.  Stays the same across
        /// revisions.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub update_id: std::string::String,

        /// The revision number of this update package.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub revision_number: i32,

        /// The last published date of the update, in (UTC) date and time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_deployment_change_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsUpdatePackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [title][crate::model::inventory::WindowsUpdatePackage::title].
        pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [description][crate::model::inventory::WindowsUpdatePackage::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [categories][crate::model::inventory::WindowsUpdatePackage::categories].
        pub fn set_categories<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::inventory::windows_update_package::WindowsUpdateCategory,
                >,
        {
            use std::iter::Iterator;
            self.categories = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [kb_article_ids][crate::model::inventory::WindowsUpdatePackage::kb_article_ids].
        pub fn set_kb_article_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.kb_article_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [support_url][crate::model::inventory::WindowsUpdatePackage::support_url].
        pub fn set_support_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.support_url = v.into();
            self
        }

        /// Sets the value of [more_info_urls][crate::model::inventory::WindowsUpdatePackage::more_info_urls].
        pub fn set_more_info_urls<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.more_info_urls = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [update_id][crate::model::inventory::WindowsUpdatePackage::update_id].
        pub fn set_update_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.update_id = v.into();
            self
        }

        /// Sets the value of [revision_number][crate::model::inventory::WindowsUpdatePackage::revision_number].
        pub fn set_revision_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.revision_number = v.into();
            self
        }

        /// Sets the value of [last_deployment_change_time][crate::model::inventory::WindowsUpdatePackage::last_deployment_change_time].
        pub fn set_last_deployment_change_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.last_deployment_change_time = v.into();
            self
        }
    }

    impl wkt::message::Message for WindowsUpdatePackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsUpdatePackage"
        }
    }

    /// Defines additional types related to [WindowsUpdatePackage].
    pub mod windows_update_package {
        #[allow(unused_imports)]
        use super::*;

        /// Categories specified by the Windows Update.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct WindowsUpdateCategory {
            /// The identifier of the windows update category.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub id: std::string::String,

            /// The name of the windows update category.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl WindowsUpdateCategory {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [id][crate::model::inventory::windows_update_package::WindowsUpdateCategory::id].
            pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.id = v.into();
                self
            }

            /// Sets the value of [name][crate::model::inventory::windows_update_package::WindowsUpdateCategory::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }
        }

        impl wkt::message::Message for WindowsUpdateCategory {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsUpdatePackage.WindowsUpdateCategory"
            }
        }
    }

    /// Information related to a Quick Fix Engineering package.
    /// Fields are taken from Windows QuickFixEngineering Interface and match
    /// the source names:
    /// <https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering>
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WindowsQuickFixEngineeringPackage {
        /// A short textual description of the QFE update.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub caption: std::string::String,

        /// A textual description of the QFE update.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// Unique identifier associated with a particular QFE update.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub hot_fix_id: std::string::String,

        /// Date that the QFE update was installed.  Mapped from installed_on field.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub install_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsQuickFixEngineeringPackage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [caption][crate::model::inventory::WindowsQuickFixEngineeringPackage::caption].
        pub fn set_caption<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.caption = v.into();
            self
        }

        /// Sets the value of [description][crate::model::inventory::WindowsQuickFixEngineeringPackage::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [hot_fix_id][crate::model::inventory::WindowsQuickFixEngineeringPackage::hot_fix_id].
        pub fn set_hot_fix_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.hot_fix_id = v.into();
            self
        }

        /// Sets the value of [install_time][crate::model::inventory::WindowsQuickFixEngineeringPackage::install_time].
        pub fn set_install_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.install_time = v.into();
            self
        }
    }

    impl wkt::message::Message for WindowsQuickFixEngineeringPackage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsQuickFixEngineeringPackage"
        }
    }

    /// Contains information about a Windows application that is retrieved from the
    /// Windows Registry. For more information about these fields, see:
    /// <https://docs.microsoft.com/en-us/windows/win32/msi/uninstall-registry-key>
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WindowsApplication {
        /// The name of the application or product.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// The version of the product or application in string format.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_version: std::string::String,

        /// The name of the manufacturer for the product or application.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub publisher: std::string::String,

        /// The last time this product received service. The value of this property
        /// is replaced each time a patch is applied or removed from the product or
        /// the command-line option is used to repair the product.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub install_date: std::option::Option<gtype::model::Date>,

        /// The internet address for technical support.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub help_link: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WindowsApplication {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::inventory::WindowsApplication::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [display_version][crate::model::inventory::WindowsApplication::display_version].
        pub fn set_display_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_version = v.into();
            self
        }

        /// Sets the value of [publisher][crate::model::inventory::WindowsApplication::publisher].
        pub fn set_publisher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.publisher = v.into();
            self
        }

        /// Sets the value of [install_date][crate::model::inventory::WindowsApplication::install_date].
        pub fn set_install_date<T: std::convert::Into<std::option::Option<gtype::model::Date>>>(
            mut self,
            v: T,
        ) -> Self {
            self.install_date = v.into();
            self
        }

        /// Sets the value of [help_link][crate::model::inventory::WindowsApplication::help_link].
        pub fn set_help_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.help_link = v.into();
            self
        }
    }

    impl wkt::message::Message for WindowsApplication {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.Inventory.WindowsApplication"
        }
    }
}

/// A request message for getting inventory data for the specified VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInventoryRequest {
    /// Required. API resource name for inventory resource.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}/inventory`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance}`, either Compute Engine  `instance-id` or `instance-name`
    /// can be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Inventory view indicating what information should be included in the
    /// inventory resource. If unspecified, the default view is BASIC.
    pub view: crate::model::InventoryView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInventoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetInventoryRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::InventoryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetInventoryRequest"
    }
}

/// A request message for listing inventory data for all VMs in the specified
/// location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInventoriesRequest {
    /// Required. The parent resource name.
    ///
    /// Format: `projects/{project}/locations/{location}/instances/-`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Inventory view indicating what information should be included in the
    /// inventory resource. If unspecified, the default view is BASIC.
    pub view: crate::model::InventoryView,

    /// The maximum number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListInventories` that indicates where this listing
    /// should continue from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If provided, this field specifies the criteria that must be met by a
    /// `Inventory` API resource to be included in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInventoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInventoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListInventoriesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::InventoryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInventoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInventoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInventoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInventoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListInventoriesRequest"
    }
}

/// A response message for listing inventory data for all VMs in a specified
/// location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInventoriesResponse {
    /// List of inventory objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inventories: std::vec::Vec<crate::model::Inventory>,

    /// The pagination token to retrieve the next page of inventory objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInventoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inventories][crate::model::ListInventoriesResponse::inventories].
    pub fn set_inventories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Inventory>,
    {
        use std::iter::Iterator;
        self.inventories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInventoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInventoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListInventoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInventoriesResponse {
    type PageItem = crate::model::Inventory;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.inventories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// An OS policy defines the desired state configuration for a VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OSPolicy {
    /// Required. The id of the OS policy with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the assignment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Policy description.
    /// Length of the description is limited to 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Policy mode
    pub mode: crate::model::os_policy::Mode,

    /// Required. List of resource groups for the policy.
    /// For a particular VM, resource groups are evaluated in the order specified
    /// and the first resource group that is applicable is selected and the rest
    /// are ignored.
    ///
    /// If none of the resource groups are applicable for a VM, the VM is
    /// considered to be non-compliant w.r.t this policy. This behavior can be
    /// toggled by the flag `allow_no_resource_group_match`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_groups: std::vec::Vec<crate::model::os_policy::ResourceGroup>,

    /// This flag determines the OS policy compliance status when none of the
    /// resource groups within the policy are applicable for a VM. Set this value
    /// to `true` if the policy needs to be reported as compliant even if the
    /// policy has nothing to validate or enforce.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_no_resource_group_match: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::OSPolicy::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::OSPolicy::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::os_policy::Mode>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [resource_groups][crate::model::OSPolicy::resource_groups].
    pub fn set_resource_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::os_policy::ResourceGroup>,
    {
        use std::iter::Iterator;
        self.resource_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_no_resource_group_match][crate::model::OSPolicy::allow_no_resource_group_match].
    pub fn set_allow_no_resource_group_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_no_resource_group_match = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy"
    }
}

/// Defines additional types related to [OSPolicy].
pub mod os_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Filtering criteria to select VMs based on inventory details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InventoryFilter {
        /// Required. The OS short name
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub os_short_name: std::string::String,

        /// The OS version
        ///
        /// Prefix matches are supported if asterisk(*) is provided as the
        /// last character. For example, to match all versions with a major
        /// version of `7`, specify the following value for this field `7.*`
        ///
        /// An empty string matches all OS versions.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub os_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InventoryFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [os_short_name][crate::model::os_policy::InventoryFilter::os_short_name].
        pub fn set_os_short_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.os_short_name = v.into();
            self
        }

        /// Sets the value of [os_version][crate::model::os_policy::InventoryFilter::os_version].
        pub fn set_os_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.os_version = v.into();
            self
        }
    }

    impl wkt::message::Message for InventoryFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.InventoryFilter"
        }
    }

    /// An OS policy resource is used to define the desired state configuration
    /// and provides a specific functionality like installing/removing packages,
    /// executing a script etc.
    ///
    /// The system ensures that resources are always in their desired state by
    /// taking necessary actions if they have drifted from their desired state.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Resource {
        /// Required. The id of the resource with the following restrictions:
        ///
        /// * Must contain only lowercase letters, numbers, and hyphens.
        /// * Must start with a letter.
        /// * Must be between 1-63 characters.
        /// * Must end with a number or a letter.
        /// * Must be unique within the OS policy.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Resource type.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub resource_type: std::option::Option<crate::model::os_policy::resource::ResourceType>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::os_policy::Resource::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type].
        ///
        /// Note that all the setters affecting `resource_type` are mutually
        /// exclusive.
        pub fn set_resource_type<
            T: std::convert::Into<
                    std::option::Option<crate::model::os_policy::resource::ResourceType>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `Pkg`, `None` if the field is not set or
        /// holds a different branch.
        pub fn pkg(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::PackageResource>>
        {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::Pkg(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `Pkg`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_pkg<
            T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::PackageResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::Pkg(v.into()),
            );
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `Repository`, `None` if the field is not set or
        /// holds a different branch.
        pub fn repository(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>,
        > {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::Repository(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `Repository`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_repository<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::Repository(v.into()),
            );
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `Exec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn exec(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::ExecResource>>
        {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::Exec(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `Exec`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_exec<
            T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::ExecResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::Exec(v.into()),
            );
            self
        }

        /// The value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// if it holds a `File`, `None` if the field is not set or
        /// holds a different branch.
        pub fn file(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::FileResource>>
        {
            #[allow(unreachable_patterns)]
            self.resource_type.as_ref().and_then(|v| match v {
                crate::model::os_policy::resource::ResourceType::File(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resource_type][crate::model::os_policy::Resource::resource_type]
        /// to hold a `File`.
        ///
        /// Note that all the setters affecting `resource_type` are
        /// mutually exclusive.
        pub fn set_file<
            T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::FileResource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = std::option::Option::Some(
                crate::model::os_policy::resource::ResourceType::File(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource"
        }
    }

    /// Defines additional types related to [Resource].
    pub mod resource {
        #[allow(unused_imports)]
        use super::*;

        /// A remote or local file.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct File {
            /// Defaults to false. When false, files are subject to validations
            /// based on the file type:
            ///
            /// Remote: A checksum must be specified.
            /// Cloud Storage: An object generation number must be specified.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub allow_insecure: bool,

            /// A specific type of file.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<crate::model::os_policy::resource::file::Type>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl File {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allow_insecure][crate::model::os_policy::resource::File::allow_insecure].
            pub fn set_allow_insecure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.allow_insecure = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<
                T: std::convert::Into<
                        std::option::Option<crate::model::os_policy::resource::file::Type>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// if it holds a `Remote`, `None` if the field is not set or
            /// holds a different branch.
            pub fn remote(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::file::Remote>,
            > {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file::Type::Remote(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// to hold a `Remote`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_remote<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::file::Remote>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::os_policy::resource::file::Type::Remote(v.into()),
                );
                self
            }

            /// The value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// if it holds a `Gcs`, `None` if the field is not set or
            /// holds a different branch.
            pub fn gcs(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::file::Gcs>>
            {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file::Type::Gcs(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// to hold a `Gcs`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_gcs<
                T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::file::Gcs>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::os_policy::resource::file::Type::Gcs(v.into()),
                );
                self
            }

            /// The value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// if it holds a `LocalPath`, `None` if the field is not set or
            /// holds a different branch.
            pub fn local_path(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file::Type::LocalPath(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::os_policy::resource::File::r#type]
            /// to hold a `LocalPath`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_local_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::os_policy::resource::file::Type::LocalPath(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for File {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.File"
            }
        }

        /// Defines additional types related to [File].
        pub mod file {
            #[allow(unused_imports)]
            use super::*;

            /// Specifies a file available via some URI.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Remote {
                /// Required. URI from which to fetch the object. It should contain both
                /// the protocol and path following the format `{protocol}://{location}`.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub uri: std::string::String,

                /// SHA256 checksum of the remote file.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub sha256_checksum: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Remote {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [uri][crate::model::os_policy::resource::file::Remote::uri].
                pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.uri = v.into();
                    self
                }

                /// Sets the value of [sha256_checksum][crate::model::os_policy::resource::file::Remote::sha256_checksum].
                pub fn set_sha256_checksum<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.sha256_checksum = v.into();
                    self
                }
            }

            impl wkt::message::Message for Remote {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.File.Remote"
                }
            }

            /// Specifies a file available as a Cloud Storage Object.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Gcs {
                /// Required. Bucket of the Cloud Storage object.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub bucket: std::string::String,

                /// Required. Name of the Cloud Storage object.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub object: std::string::String,

                /// Generation number of the Cloud Storage object.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                #[serde_as(as = "serde_with::DisplayFromStr")]
                pub generation: i64,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Gcs {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [bucket][crate::model::os_policy::resource::file::Gcs::bucket].
                pub fn set_bucket<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.bucket = v.into();
                    self
                }

                /// Sets the value of [object][crate::model::os_policy::resource::file::Gcs::object].
                pub fn set_object<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.object = v.into();
                    self
                }

                /// Sets the value of [generation][crate::model::os_policy::resource::file::Gcs::generation].
                pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.generation = v.into();
                    self
                }
            }

            impl wkt::message::Message for Gcs {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.File.Gcs"
                }
            }

            /// A specific type of file.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Type {
                /// A generic remote file.
                Remote(std::boxed::Box<crate::model::os_policy::resource::file::Remote>),
                /// A Cloud Storage object.
                Gcs(std::boxed::Box<crate::model::os_policy::resource::file::Gcs>),
                /// A local path within the VM to use.
                LocalPath(std::string::String),
            }
        }

        /// A resource that manages a system package.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PackageResource {
            /// Required. The desired state the agent should maintain for this package.
            pub desired_state: crate::model::os_policy::resource::package_resource::DesiredState,

            /// A system package.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub system_package: std::option::Option<
                crate::model::os_policy::resource::package_resource::SystemPackage,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PackageResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [desired_state][crate::model::os_policy::resource::PackageResource::desired_state].
            pub fn set_desired_state<
                T: std::convert::Into<
                        crate::model::os_policy::resource::package_resource::DesiredState,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.desired_state = v.into();
                self
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package].
            ///
            /// Note that all the setters affecting `system_package` are mutually
            /// exclusive.
            pub fn set_system_package<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::os_policy::resource::package_resource::SystemPackage,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = v.into();
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Apt`, `None` if the field is not set or
            /// holds a different branch.
            pub fn apt(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Apt(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Apt`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_apt<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Apt(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Deb`, `None` if the field is not set or
            /// holds a different branch.
            pub fn deb(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Deb(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Deb`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_deb<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Deb(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Yum`, `None` if the field is not set or
            /// holds a different branch.
            pub fn yum(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Yum(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Yum`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_yum<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Yum(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Zypper`, `None` if the field is not set or
            /// holds a different branch.
            pub fn zypper(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Zypper>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Zypper(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Zypper`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_zypper<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::package_resource::Zypper,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Zypper(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Rpm`, `None` if the field is not set or
            /// holds a different branch.
            pub fn rpm(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Rpm(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Rpm`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_rpm<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Rpm(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Googet`, `None` if the field is not set or
            /// holds a different branch.
            pub fn googet(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::GooGet>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Googet(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Googet`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_googet<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::package_resource::GooGet,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Googet(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// if it holds a `Msi`, `None` if the field is not set or
            /// holds a different branch.
            pub fn msi(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>,
            > {
                #[allow(unreachable_patterns)]
                self.system_package.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::package_resource::SystemPackage::Msi(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [system_package][crate::model::os_policy::resource::PackageResource::system_package]
            /// to hold a `Msi`.
            ///
            /// Note that all the setters affecting `system_package` are
            /// mutually exclusive.
            pub fn set_msi<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.system_package = std::option::Option::Some(
                    crate::model::os_policy::resource::package_resource::SystemPackage::Msi(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for PackageResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource"
            }
        }

        /// Defines additional types related to [PackageResource].
        pub mod package_resource {
            #[allow(unused_imports)]
            use super::*;

            /// A deb package file. dpkg packages only support INSTALLED state.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Deb {
                /// Required. A deb package.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub source: std::option::Option<crate::model::os_policy::resource::File>,

                /// Whether dependencies should also be installed.
                ///
                /// - install when false: `dpkg -i package`
                /// - install when true: `apt-get update && apt-get -y install
                ///   package.deb`
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub pull_deps: bool,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Deb {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::os_policy::resource::package_resource::Deb::source].
                pub fn set_source<
                    T: std::convert::Into<
                            std::option::Option<crate::model::os_policy::resource::File>,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }

                /// Sets the value of [pull_deps][crate::model::os_policy::resource::package_resource::Deb::pull_deps].
                pub fn set_pull_deps<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.pull_deps = v.into();
                    self
                }
            }

            impl wkt::message::Message for Deb {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.Deb"
                }
            }

            /// A package managed by APT.
            ///
            /// - install: `apt-get update && apt-get -y install [name]`
            /// - remove: `apt-get -y remove [name]`
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Apt {
                /// Required. Package name.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub name: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Apt {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::Apt::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for Apt {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.APT"
                }
            }

            /// An RPM package file. RPM packages only support INSTALLED state.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Rpm {
                /// Required. An rpm package.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub source: std::option::Option<crate::model::os_policy::resource::File>,

                /// Whether dependencies should also be installed.
                ///
                /// - install when false: `rpm --upgrade --replacepkgs package.rpm`
                /// - install when true: `yum -y install package.rpm` or
                ///   `zypper -y install package.rpm`
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub pull_deps: bool,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Rpm {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::os_policy::resource::package_resource::Rpm::source].
                pub fn set_source<
                    T: std::convert::Into<
                            std::option::Option<crate::model::os_policy::resource::File>,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }

                /// Sets the value of [pull_deps][crate::model::os_policy::resource::package_resource::Rpm::pull_deps].
                pub fn set_pull_deps<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.pull_deps = v.into();
                    self
                }
            }

            impl wkt::message::Message for Rpm {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.RPM"
                }
            }

            /// A package managed by YUM.
            ///
            /// - install: `yum -y install package`
            /// - remove: `yum -y remove package`
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Yum {
                /// Required. Package name.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub name: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Yum {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::Yum::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for Yum {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.YUM"
                }
            }

            /// A package managed by Zypper.
            ///
            /// - install: `zypper -y install package`
            /// - remove: `zypper -y rm package`
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Zypper {
                /// Required. Package name.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub name: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Zypper {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::Zypper::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for Zypper {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.Zypper"
                }
            }

            /// A package managed by GooGet.
            ///
            /// - install: `googet -noconfirm install package`
            /// - remove: `googet -noconfirm remove package`
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct GooGet {
                /// Required. Package name.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub name: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GooGet {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::package_resource::GooGet::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }
            }

            impl wkt::message::Message for GooGet {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.GooGet"
                }
            }

            /// An MSI package. MSI packages only support INSTALLED state.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Msi {
                /// Required. The MSI package.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub source: std::option::Option<crate::model::os_policy::resource::File>,

                /// Additional properties to use during installation.
                /// This should be in the format of Property=Setting.
                /// Appended to the defaults of `ACTION=INSTALL
                /// REBOOT=ReallySuppress`.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub properties: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Msi {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::os_policy::resource::package_resource::Msi::source].
                pub fn set_source<
                    T: std::convert::Into<
                            std::option::Option<crate::model::os_policy::resource::File>,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }

                /// Sets the value of [properties][crate::model::os_policy::resource::package_resource::Msi::properties].
                pub fn set_properties<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.properties = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Msi {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.MSI"
                }
            }

            /// The desired state that the OS Config agent maintains on the VM.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum DesiredState {
                /// Unspecified is invalid.
                Unspecified,
                /// Ensure that the package is installed.
                Installed,
                /// The agent ensures that the package is not installed and
                /// uninstalls it if detected.
                Removed,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [DesiredState::value] or
                /// [DesiredState::name].
                UnknownValue(desired_state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod desired_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl DesiredState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Installed => std::option::Option::Some(1),
                        Self::Removed => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("DESIRED_STATE_UNSPECIFIED"),
                        Self::Installed => std::option::Option::Some("INSTALLED"),
                        Self::Removed => std::option::Option::Some("REMOVED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for DesiredState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for DesiredState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for DesiredState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Installed,
                        2 => Self::Removed,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for DesiredState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "DESIRED_STATE_UNSPECIFIED" => Self::Unspecified,
                        "INSTALLED" => Self::Installed,
                        "REMOVED" => Self::Removed,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for DesiredState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Installed => serializer.serialize_i32(1),
                        Self::Removed => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for DesiredState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<DesiredState>::new(
                        ".google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.DesiredState",
                    ))
                }
            }

            /// A system package.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum SystemPackage {
                /// A package managed by Apt.
                Apt(std::boxed::Box<crate::model::os_policy::resource::package_resource::Apt>),
                /// A deb package file.
                Deb(std::boxed::Box<crate::model::os_policy::resource::package_resource::Deb>),
                /// A package managed by YUM.
                Yum(std::boxed::Box<crate::model::os_policy::resource::package_resource::Yum>),
                /// A package managed by Zypper.
                Zypper(
                    std::boxed::Box<crate::model::os_policy::resource::package_resource::Zypper>,
                ),
                /// An rpm package file.
                Rpm(std::boxed::Box<crate::model::os_policy::resource::package_resource::Rpm>),
                /// A package managed by GooGet.
                Googet(
                    std::boxed::Box<crate::model::os_policy::resource::package_resource::GooGet>,
                ),
                /// An MSI package.
                Msi(std::boxed::Box<crate::model::os_policy::resource::package_resource::Msi>),
            }
        }

        /// A resource that manages a package repository.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RepositoryResource {
            /// A specific type of repository.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub repository: std::option::Option<
                crate::model::os_policy::resource::repository_resource::Repository,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RepositoryResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository].
            ///
            /// Note that all the setters affecting `repository` are mutually
            /// exclusive.
            pub fn set_repository<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::os_policy::resource::repository_resource::Repository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = v.into();
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Apt`, `None` if the field is not set or
            /// holds a different branch.
            pub fn apt(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::AptRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Apt(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Apt`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_apt<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::repository_resource::AptRepository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Apt(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Yum`, `None` if the field is not set or
            /// holds a different branch.
            pub fn yum(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::YumRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Yum(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Yum`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_yum<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::repository_resource::YumRepository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Yum(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Zypper`, `None` if the field is not set or
            /// holds a different branch.
            pub fn zypper(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::ZypperRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Zypper(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Zypper`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_zypper<T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::repository_resource::ZypperRepository>>>(mut self, v: T) -> Self{
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Zypper(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// if it holds a `Goo`, `None` if the field is not set or
            /// holds a different branch.
            pub fn goo(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::os_policy::resource::repository_resource::GooRepository,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.repository.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::repository_resource::Repository::Goo(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [repository][crate::model::os_policy::resource::RepositoryResource::repository]
            /// to hold a `Goo`.
            ///
            /// Note that all the setters affecting `repository` are
            /// mutually exclusive.
            pub fn set_goo<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::os_policy::resource::repository_resource::GooRepository,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.repository = std::option::Option::Some(
                    crate::model::os_policy::resource::repository_resource::Repository::Goo(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for RepositoryResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource"
            }
        }

        /// Defines additional types related to [RepositoryResource].
        pub mod repository_resource {
            #[allow(unused_imports)]
            use super::*;

            /// Represents a single apt package repository. These will be added to
            /// a repo file that will be managed at
            /// `/etc/apt/sources.list.d/google_osconfig.list`.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct AptRepository {

                /// Required. Type of archive files in this repository.
                pub archive_type: crate::model::os_policy::resource::repository_resource::apt_repository::ArchiveType,

                /// Required. URI for this repository.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub uri: std::string::String,

                /// Required. Distribution of this repository.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub distribution: std::string::String,

                /// Required. List of components for this repository. Must contain at
                /// least one item.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub components: std::vec::Vec<std::string::String>,

                /// URI of the key file for this repository. The agent maintains a
                /// keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub gpg_key: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl AptRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [archive_type][crate::model::os_policy::resource::repository_resource::AptRepository::archive_type].
                pub fn set_archive_type<T: std::convert::Into<crate::model::os_policy::resource::repository_resource::apt_repository::ArchiveType>>(mut self, v: T) -> Self{
                    self.archive_type = v.into();
                    self
                }

                /// Sets the value of [uri][crate::model::os_policy::resource::repository_resource::AptRepository::uri].
                pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.uri = v.into();
                    self
                }

                /// Sets the value of [distribution][crate::model::os_policy::resource::repository_resource::AptRepository::distribution].
                pub fn set_distribution<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.distribution = v.into();
                    self
                }

                /// Sets the value of [components][crate::model::os_policy::resource::repository_resource::AptRepository::components].
                pub fn set_components<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.components = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [gpg_key][crate::model::os_policy::resource::repository_resource::AptRepository::gpg_key].
                pub fn set_gpg_key<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.gpg_key = v.into();
                    self
                }
            }

            impl wkt::message::Message for AptRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepository"
                }
            }

            /// Defines additional types related to [AptRepository].
            pub mod apt_repository {
                #[allow(unused_imports)]
                use super::*;

                /// Type of archive.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum ArchiveType {
                    /// Unspecified is invalid.
                    Unspecified,
                    /// Deb indicates that the archive contains binary files.
                    Deb,
                    /// Deb-src indicates that the archive contains source files.
                    DebSrc,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [ArchiveType::value] or
                    /// [ArchiveType::name].
                    UnknownValue(archive_type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod archive_type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl ArchiveType {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Deb => std::option::Option::Some(1),
                            Self::DebSrc => std::option::Option::Some(2),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("ARCHIVE_TYPE_UNSPECIFIED")
                            }
                            Self::Deb => std::option::Option::Some("DEB"),
                            Self::DebSrc => std::option::Option::Some("DEB_SRC"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for ArchiveType {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for ArchiveType {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for ArchiveType {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Deb,
                            2 => Self::DebSrc,
                            _ => Self::UnknownValue(archive_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for ArchiveType {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "ARCHIVE_TYPE_UNSPECIFIED" => Self::Unspecified,
                            "DEB" => Self::Deb,
                            "DEB_SRC" => Self::DebSrc,
                            _ => Self::UnknownValue(archive_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for ArchiveType {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Deb => serializer.serialize_i32(1),
                            Self::DebSrc => serializer.serialize_i32(2),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for ArchiveType {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ArchiveType>::new(
                            ".google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType"))
                    }
                }
            }

            /// Represents a single yum package repository. These are added to a
            /// repo file that is managed at
            /// `/etc/yum.repos.d/google_osconfig.repo`.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct YumRepository {
                /// Required. A one word, unique name for this repository. This is  the
                /// `repo id` in the yum config file and also the `display_name` if
                /// `display_name` is omitted. This id is also used as the unique
                /// identifier when checking for resource conflicts.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub id: std::string::String,

                /// The display name of the repository.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub display_name: std::string::String,

                /// Required. The location of the repository directory.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub base_url: std::string::String,

                /// URIs of GPG keys.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub gpg_keys: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl YumRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [id][crate::model::os_policy::resource::repository_resource::YumRepository::id].
                pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.id = v.into();
                    self
                }

                /// Sets the value of [display_name][crate::model::os_policy::resource::repository_resource::YumRepository::display_name].
                pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.display_name = v.into();
                    self
                }

                /// Sets the value of [base_url][crate::model::os_policy::resource::repository_resource::YumRepository::base_url].
                pub fn set_base_url<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.base_url = v.into();
                    self
                }

                /// Sets the value of [gpg_keys][crate::model::os_policy::resource::repository_resource::YumRepository::gpg_keys].
                pub fn set_gpg_keys<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gpg_keys = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for YumRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.YumRepository"
                }
            }

            /// Represents a single zypper package repository. These are added to a
            /// repo file that is managed at
            /// `/etc/zypp/repos.d/google_osconfig.repo`.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ZypperRepository {
                /// Required. A one word, unique name for this repository. This is the
                /// `repo id` in the zypper config file and also the `display_name` if
                /// `display_name` is omitted. This id is also used as the unique
                /// identifier when checking for GuestPolicy conflicts.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub id: std::string::String,

                /// The display name of the repository.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub display_name: std::string::String,

                /// Required. The location of the repository directory.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub base_url: std::string::String,

                /// URIs of GPG keys.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub gpg_keys: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ZypperRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [id][crate::model::os_policy::resource::repository_resource::ZypperRepository::id].
                pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.id = v.into();
                    self
                }

                /// Sets the value of [display_name][crate::model::os_policy::resource::repository_resource::ZypperRepository::display_name].
                pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.display_name = v.into();
                    self
                }

                /// Sets the value of [base_url][crate::model::os_policy::resource::repository_resource::ZypperRepository::base_url].
                pub fn set_base_url<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.base_url = v.into();
                    self
                }

                /// Sets the value of [gpg_keys][crate::model::os_policy::resource::repository_resource::ZypperRepository::gpg_keys].
                pub fn set_gpg_keys<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gpg_keys = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for ZypperRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.ZypperRepository"
                }
            }

            /// Represents a Goo package repository. These are added to a repo file
            /// that is managed at
            /// `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct GooRepository {
                /// Required. The name of the repository.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub name: std::string::String,

                /// Required. The url of the repository.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub url: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GooRepository {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::os_policy::resource::repository_resource::GooRepository::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }

                /// Sets the value of [url][crate::model::os_policy::resource::repository_resource::GooRepository::url].
                pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.url = v.into();
                    self
                }
            }

            impl wkt::message::Message for GooRepository {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.GooRepository"
                }
            }

            /// A specific type of repository.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Repository {
                /// An Apt Repository.
                Apt(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::AptRepository,
                    >,
                ),
                /// A Yum Repository.
                Yum(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::YumRepository,
                    >,
                ),
                /// A Zypper Repository.
                Zypper(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::ZypperRepository,
                    >,
                ),
                /// A Goo Repository.
                Goo(
                    std::boxed::Box<
                        crate::model::os_policy::resource::repository_resource::GooRepository,
                    >,
                ),
            }
        }

        /// A resource that allows executing scripts on the VM.
        ///
        /// The `ExecResource` has 2 stages: `validate` and `enforce` and both stages
        /// accept a script as an argument to execute.
        ///
        /// When the `ExecResource` is applied by the agent, it first executes the
        /// script in the `validate` stage. The `validate` stage can signal that the
        /// `ExecResource` is already in the desired state by returning an exit code
        /// of `100`. If the `ExecResource` is not in the desired state, it should
        /// return an exit code of `101`. Any other exit code returned by this stage
        /// is considered an error.
        ///
        /// If the `ExecResource` is not in the desired state based on the exit code
        /// from the `validate` stage, the agent proceeds to execute the script from
        /// the `enforce` stage. If the `ExecResource` is already in the desired
        /// state, the `enforce` stage will not be run.
        /// Similar to `validate` stage, the `enforce` stage should return an exit
        /// code of `100` to indicate that the resource in now in its desired state.
        /// Any other exit code is considered an error.
        ///
        /// NOTE: An exit code of `100` was chosen over `0` (and `101` vs `1`) to
        /// have an explicit indicator of `in desired state`, `not in desired state`
        /// and errors. Because, for example, Powershell will always return an exit
        /// code of `0` unless an `exit` statement is provided in the script. So, for
        /// reasons of consistency and being explicit, exit codes `100` and `101`
        /// were chosen.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ExecResource {
            /// Required. What to run to validate this resource is in the desired
            /// state. An exit code of 100 indicates "in desired state", and exit code
            /// of 101 indicates "not in desired state". Any other exit code indicates
            /// a failure running validate.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub validate:
                std::option::Option<crate::model::os_policy::resource::exec_resource::Exec>,

            /// What to run to bring this resource into the desired state.
            /// An exit code of 100 indicates "success", any other exit code indicates
            /// a failure running enforce.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub enforce:
                std::option::Option<crate::model::os_policy::resource::exec_resource::Exec>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ExecResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [validate][crate::model::os_policy::resource::ExecResource::validate].
            pub fn set_validate<
                T: std::convert::Into<
                        std::option::Option<crate::model::os_policy::resource::exec_resource::Exec>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.validate = v.into();
                self
            }

            /// Sets the value of [enforce][crate::model::os_policy::resource::ExecResource::enforce].
            pub fn set_enforce<
                T: std::convert::Into<
                        std::option::Option<crate::model::os_policy::resource::exec_resource::Exec>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.enforce = v.into();
                self
            }
        }

        impl wkt::message::Message for ExecResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource"
            }
        }

        /// Defines additional types related to [ExecResource].
        pub mod exec_resource {
            #[allow(unused_imports)]
            use super::*;

            /// A file or script to execute.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Exec {
                /// Optional arguments to pass to the source during execution.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub args: std::vec::Vec<std::string::String>,

                /// Required. The script interpreter to use.
                pub interpreter:
                    crate::model::os_policy::resource::exec_resource::exec::Interpreter,

                /// Only recorded for enforce Exec.
                /// Path to an output file (that is created by this Exec) whose
                /// content will be recorded in OSPolicyResourceCompliance after a
                /// successful run. Absence or failure to read this file will result in
                /// this ExecResource being non-compliant. Output file size is limited to
                /// 100K bytes.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub output_file_path: std::string::String,

                /// What to execute.
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub source: std::option::Option<
                    crate::model::os_policy::resource::exec_resource::exec::Source,
                >,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Exec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [args][crate::model::os_policy::resource::exec_resource::Exec::args].
                pub fn set_args<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.args = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [interpreter][crate::model::os_policy::resource::exec_resource::Exec::interpreter].
                pub fn set_interpreter<
                    T: std::convert::Into<
                            crate::model::os_policy::resource::exec_resource::exec::Interpreter,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.interpreter = v.into();
                    self
                }

                /// Sets the value of [output_file_path][crate::model::os_policy::resource::exec_resource::Exec::output_file_path].
                pub fn set_output_file_path<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.output_file_path = v.into();
                    self
                }

                /// Sets the value of [source][crate::model::os_policy::resource::exec_resource::Exec::source].
                ///
                /// Note that all the setters affecting `source` are mutually
                /// exclusive.
                pub fn set_source<
                    T: std::convert::Into<
                            std::option::Option<
                                crate::model::os_policy::resource::exec_resource::exec::Source,
                            >,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }

                /// The value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// if it holds a `File`, `None` if the field is not set or
                /// holds a different branch.
                pub fn file(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::File>>
                {
                    #[allow(unreachable_patterns)]
                    self.source.as_ref().and_then(|v| match v {
                        crate::model::os_policy::resource::exec_resource::exec::Source::File(v) => {
                            std::option::Option::Some(v)
                        }
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// to hold a `File`.
                ///
                /// Note that all the setters affecting `source` are
                /// mutually exclusive.
                pub fn set_file<
                    T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::File>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = std::option::Option::Some(
                        crate::model::os_policy::resource::exec_resource::exec::Source::File(
                            v.into(),
                        ),
                    );
                    self
                }

                /// The value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// if it holds a `Script`, `None` if the field is not set or
                /// holds a different branch.
                pub fn script(&self) -> std::option::Option<&std::string::String> {
                    #[allow(unreachable_patterns)]
                    self.source.as_ref().and_then(|v| match v {
                        crate::model::os_policy::resource::exec_resource::exec::Source::Script(
                            v,
                        ) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [source][crate::model::os_policy::resource::exec_resource::Exec::source]
                /// to hold a `Script`.
                ///
                /// Note that all the setters affecting `source` are
                /// mutually exclusive.
                pub fn set_script<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = std::option::Option::Some(
                        crate::model::os_policy::resource::exec_resource::exec::Source::Script(
                            v.into(),
                        ),
                    );
                    self
                }
            }

            impl wkt::message::Message for Exec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec"
                }
            }

            /// Defines additional types related to [Exec].
            pub mod exec {
                #[allow(unused_imports)]
                use super::*;

                /// The interpreter to use.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Interpreter {
                    /// Invalid value, the request will return validation error.
                    Unspecified,
                    /// If an interpreter is not specified, the
                    /// source is executed directly. This execution, without an
                    /// interpreter, only succeeds for executables and scripts that have <a
                    /// href="https://en.wikipedia.org/wiki/Shebang_(Unix)"
                    /// class="external"\>shebang lines</a>.
                    None,
                    /// Indicates that the script runs with `/bin/sh` on Linux and
                    /// `cmd.exe` on Windows.
                    Shell,
                    /// Indicates that the script runs with PowerShell.
                    Powershell,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Interpreter::value] or
                    /// [Interpreter::name].
                    UnknownValue(interpreter::UnknownValue),
                }

                #[doc(hidden)]
                pub mod interpreter {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Interpreter {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::None => std::option::Option::Some(1),
                            Self::Shell => std::option::Option::Some(2),
                            Self::Powershell => std::option::Option::Some(3),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("INTERPRETER_UNSPECIFIED")
                            }
                            Self::None => std::option::Option::Some("NONE"),
                            Self::Shell => std::option::Option::Some("SHELL"),
                            Self::Powershell => std::option::Option::Some("POWERSHELL"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Interpreter {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Interpreter {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Interpreter {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::None,
                            2 => Self::Shell,
                            3 => Self::Powershell,
                            _ => Self::UnknownValue(interpreter::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Interpreter {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "INTERPRETER_UNSPECIFIED" => Self::Unspecified,
                            "NONE" => Self::None,
                            "SHELL" => Self::Shell,
                            "POWERSHELL" => Self::Powershell,
                            _ => Self::UnknownValue(interpreter::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Interpreter {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::None => serializer.serialize_i32(1),
                            Self::Shell => serializer.serialize_i32(2),
                            Self::Powershell => serializer.serialize_i32(3),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Interpreter {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Interpreter>::new(
                            ".google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.Interpreter"))
                    }
                }

                /// What to execute.
                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Source {
                    /// A remote or local file.
                    File(std::boxed::Box<crate::model::os_policy::resource::File>),
                    /// An inline script.
                    /// The size of the script is limited to 1024 characters.
                    Script(std::string::String),
                }
            }
        }

        /// A resource that manages the state of a file.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FileResource {
            /// Required. The absolute path of the file within the VM.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub path: std::string::String,

            /// Required. Desired state of the file.
            pub state: crate::model::os_policy::resource::file_resource::DesiredState,

            /// Consists of three octal digits which represent, in
            /// order, the permissions of the owner, group, and other users for the
            /// file (similarly to the numeric mode used in the linux chmod
            /// utility). Each digit represents a three bit number with the 4 bit
            /// corresponding to the read permissions, the 2 bit corresponds to the
            /// write bit, and the one bit corresponds to the execute permission.
            /// Default behavior is 755.
            ///
            /// Below are some examples of permissions and their associated values:
            /// read, write, and execute: 7
            /// read and execute: 5
            /// read and write: 6
            /// read only: 4
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub permissions: std::string::String,

            /// The source for the contents of the file.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub source:
                std::option::Option<crate::model::os_policy::resource::file_resource::Source>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FileResource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [path][crate::model::os_policy::resource::FileResource::path].
            pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.path = v.into();
                self
            }

            /// Sets the value of [state][crate::model::os_policy::resource::FileResource::state].
            pub fn set_state<
                T: std::convert::Into<crate::model::os_policy::resource::file_resource::DesiredState>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.state = v.into();
                self
            }

            /// Sets the value of [permissions][crate::model::os_policy::resource::FileResource::permissions].
            pub fn set_permissions<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.permissions = v.into();
                self
            }

            /// Sets the value of [source][crate::model::os_policy::resource::FileResource::source].
            ///
            /// Note that all the setters affecting `source` are mutually
            /// exclusive.
            pub fn set_source<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::os_policy::resource::file_resource::Source,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.source = v.into();
                self
            }

            /// The value of [source][crate::model::os_policy::resource::FileResource::source]
            /// if it holds a `File`, `None` if the field is not set or
            /// holds a different branch.
            pub fn file(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::os_policy::resource::File>>
            {
                #[allow(unreachable_patterns)]
                self.source.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file_resource::Source::File(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [source][crate::model::os_policy::resource::FileResource::source]
            /// to hold a `File`.
            ///
            /// Note that all the setters affecting `source` are
            /// mutually exclusive.
            pub fn set_file<
                T: std::convert::Into<std::boxed::Box<crate::model::os_policy::resource::File>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.source = std::option::Option::Some(
                    crate::model::os_policy::resource::file_resource::Source::File(v.into()),
                );
                self
            }

            /// The value of [source][crate::model::os_policy::resource::FileResource::source]
            /// if it holds a `Content`, `None` if the field is not set or
            /// holds a different branch.
            pub fn content(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.source.as_ref().and_then(|v| match v {
                    crate::model::os_policy::resource::file_resource::Source::Content(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [source][crate::model::os_policy::resource::FileResource::source]
            /// to hold a `Content`.
            ///
            /// Note that all the setters affecting `source` are
            /// mutually exclusive.
            pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.source = std::option::Option::Some(
                    crate::model::os_policy::resource::file_resource::Source::Content(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for FileResource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.Resource.FileResource"
            }
        }

        /// Defines additional types related to [FileResource].
        pub mod file_resource {
            #[allow(unused_imports)]
            use super::*;

            /// Desired state of the file.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum DesiredState {
                /// Unspecified is invalid.
                Unspecified,
                /// Ensure file at path is present.
                Present,
                /// Ensure file at path is absent.
                Absent,
                /// Ensure the contents of the file at path matches. If the file does
                /// not exist it will be created.
                ContentsMatch,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [DesiredState::value] or
                /// [DesiredState::name].
                UnknownValue(desired_state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod desired_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl DesiredState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Present => std::option::Option::Some(1),
                        Self::Absent => std::option::Option::Some(2),
                        Self::ContentsMatch => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("DESIRED_STATE_UNSPECIFIED"),
                        Self::Present => std::option::Option::Some("PRESENT"),
                        Self::Absent => std::option::Option::Some("ABSENT"),
                        Self::ContentsMatch => std::option::Option::Some("CONTENTS_MATCH"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for DesiredState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for DesiredState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for DesiredState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Present,
                        2 => Self::Absent,
                        3 => Self::ContentsMatch,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for DesiredState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "DESIRED_STATE_UNSPECIFIED" => Self::Unspecified,
                        "PRESENT" => Self::Present,
                        "ABSENT" => Self::Absent,
                        "CONTENTS_MATCH" => Self::ContentsMatch,
                        _ => Self::UnknownValue(desired_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for DesiredState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Present => serializer.serialize_i32(1),
                        Self::Absent => serializer.serialize_i32(2),
                        Self::ContentsMatch => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for DesiredState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<DesiredState>::new(
                        ".google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.DesiredState",
                    ))
                }
            }

            /// The source for the contents of the file.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Source {
                /// A remote or local source.
                File(std::boxed::Box<crate::model::os_policy::resource::File>),
                /// A a file with this content.
                /// The size of the content is limited to 1024 characters.
                Content(std::string::String),
            }
        }

        /// Resource type.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ResourceType {
            /// Package resource
            Pkg(std::boxed::Box<crate::model::os_policy::resource::PackageResource>),
            /// Package repository resource
            Repository(std::boxed::Box<crate::model::os_policy::resource::RepositoryResource>),
            /// Exec resource
            Exec(std::boxed::Box<crate::model::os_policy::resource::ExecResource>),
            /// File resource
            File(std::boxed::Box<crate::model::os_policy::resource::FileResource>),
        }
    }

    /// Resource groups provide a mechanism to group OS policy resources.
    ///
    /// Resource groups enable OS policy authors to create a single OS policy
    /// to be applied to VMs running different operating Systems.
    ///
    /// When the OS policy is applied to a target VM, the appropriate resource
    /// group within the OS policy is selected based on the `OSFilter` specified
    /// within the resource group.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceGroup {
        /// List of inventory filters for the resource group.
        ///
        /// The resources in this resource group are applied to the target VM if it
        /// satisfies at least one of the following inventory filters.
        ///
        /// For example, to apply this resource group to VMs running either `RHEL` or
        /// `CentOS` operating systems, specify 2 items for the list with following
        /// values:
        /// inventory_filters[0].os_short_name='rhel' and
        /// inventory_filters[1].os_short_name='centos'
        ///
        /// If the list is empty, this resource group will be applied to the target
        /// VM unconditionally.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub inventory_filters: std::vec::Vec<crate::model::os_policy::InventoryFilter>,

        /// Required. List of resources configured for this resource group.
        /// The resources are executed in the exact order specified here.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub resources: std::vec::Vec<crate::model::os_policy::Resource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceGroup {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [inventory_filters][crate::model::os_policy::ResourceGroup::inventory_filters].
        pub fn set_inventory_filters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy::InventoryFilter>,
        {
            use std::iter::Iterator;
            self.inventory_filters = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [resources][crate::model::os_policy::ResourceGroup::resources].
        pub fn set_resources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy::Resource>,
        {
            use std::iter::Iterator;
            self.resources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ResourceGroup {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicy.ResourceGroup"
        }
    }

    /// Policy mode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Invalid mode
        Unspecified,
        /// This mode checks if the configuration resources in the policy are in
        /// their desired state. No actions are performed if they are not in the
        /// desired state. This mode is used for reporting purposes.
        Validation,
        /// This mode checks if the configuration resources in the policy are in
        /// their desired state, and if not, enforces the desired state.
        Enforcement,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Validation => std::option::Option::Some(1),
                Self::Enforcement => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Validation => std::option::Option::Some("VALIDATION"),
                Self::Enforcement => std::option::Option::Some("ENFORCEMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Validation,
                2 => Self::Enforcement,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "VALIDATION" => Self::Validation,
                "ENFORCEMENT" => Self::Enforcement,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Validation => serializer.serialize_i32(1),
                Self::Enforcement => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.osconfig.v1.OSPolicy.Mode",
            ))
        }
    }
}

/// Get a report of the OS policy assignment for a VM instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOSPolicyAssignmentReportRequest {
    /// Required. API resource name for OS policy assignment report.
    ///
    /// Format:
    /// `/projects/{project}/locations/{location}/instances/{instance}/osPolicyAssignments/{assignment}/report`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance_id}`, either Compute Engine `instance-id` or `instance-name`
    /// can be provided.
    /// For `{assignment_id}`, the OSPolicyAssignment id must be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOSPolicyAssignmentReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOSPolicyAssignmentReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOSPolicyAssignmentReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetOSPolicyAssignmentReportRequest"
    }
}

/// List the OS policy assignment reports for VM instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentReportsRequest {
    /// Required. The parent resource name.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}/osPolicyAssignments/{assignment}/reports`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance}`, either `instance-name`, `instance-id`, or `-` can be
    /// provided. If '-' is provided, the response will include
    /// OSPolicyAssignmentReports for all instances in the project/location.
    /// For `{assignment}`, either `assignment-id` or `-` can be provided. If '-'
    /// is provided, the response will include OSPolicyAssignmentReports for all
    /// OSPolicyAssignments in the project/location.
    /// Either {instance} or {assignment} must be `-`.
    ///
    /// For example:
    /// `projects/{project}/locations/{location}/instances/{instance}/osPolicyAssignments/-/reports`
    /// returns all reports for the instance
    /// `projects/{project}/locations/{location}/instances/-/osPolicyAssignments/{assignment-id}/reports`
    /// returns all the reports for the given assignment across all instances.
    /// `projects/{project}/locations/{location}/instances/-/osPolicyAssignments/-/reports`
    /// returns all the reports for all assignments across all instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// If provided, this field specifies the criteria that must be met by the
    /// `OSPolicyAssignmentReport` API resource that is included in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A pagination token returned from a previous call to the
    /// `ListOSPolicyAssignmentReports` method that indicates where this listing
    /// should continue from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSPolicyAssignmentReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSPolicyAssignmentReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOSPolicyAssignmentReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSPolicyAssignmentReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentReportsRequest"
    }
}

/// A response message for listing OS Policy assignment reports including the
/// page of results and page token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentReportsResponse {
    /// List of OS policy assignment reports.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub os_policy_assignment_reports: std::vec::Vec<crate::model::OSPolicyAssignmentReport>,

    /// The pagination token to retrieve the next page of OS policy assignment
    /// report objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignment_reports][crate::model::ListOSPolicyAssignmentReportsResponse::os_policy_assignment_reports].
    pub fn set_os_policy_assignment_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicyAssignmentReport>,
    {
        use std::iter::Iterator;
        self.os_policy_assignment_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSPolicyAssignmentReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSPolicyAssignmentReportsResponse {
    type PageItem = crate::model::OSPolicyAssignmentReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_policy_assignment_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A report of the OS policy assignment status for a given instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OSPolicyAssignmentReport {
    /// The `OSPolicyAssignmentReport` API resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/instances/{instance_id}/osPolicyAssignments/{os_policy_assignment_id}/report`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The Compute Engine VM instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Reference to the `OSPolicyAssignment` API resource that the `OSPolicy`
    /// belongs to.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_policy_assignment: std::string::String,

    /// Compliance data for each `OSPolicy` that is applied to the VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub os_policy_compliances:
        std::vec::Vec<crate::model::os_policy_assignment_report::OSPolicyCompliance>,

    /// Timestamp for when the report was last generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Unique identifier of the last attempted run to apply the OS policies
    /// associated with this assignment on the VM.
    ///
    /// This ID is logged by the OS Config agent while applying the OS
    /// policies associated with this assignment on the VM.
    /// NOTE: If the service is unable to successfully connect to the agent for
    /// this run, then this id will not be available in the agent logs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub last_run_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicyAssignmentReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSPolicyAssignmentReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::OSPolicyAssignmentReport::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [os_policy_assignment][crate::model::OSPolicyAssignmentReport::os_policy_assignment].
    pub fn set_os_policy_assignment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment = v.into();
        self
    }

    /// Sets the value of [os_policy_compliances][crate::model::OSPolicyAssignmentReport::os_policy_compliances].
    pub fn set_os_policy_compliances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::os_policy_assignment_report::OSPolicyCompliance>,
    {
        use std::iter::Iterator;
        self.os_policy_compliances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::OSPolicyAssignmentReport::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_run_id][crate::model::OSPolicyAssignmentReport::last_run_id].
    pub fn set_last_run_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_run_id = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicyAssignmentReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport"
    }
}

/// Defines additional types related to [OSPolicyAssignmentReport].
pub mod os_policy_assignment_report {
    #[allow(unused_imports)]
    use super::*;

    /// Compliance data for an OS policy
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OSPolicyCompliance {

        /// The OS policy id
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub os_policy_id: std::string::String,

        /// The compliance state of the OS policy.
        pub compliance_state: crate::model::os_policy_assignment_report::os_policy_compliance::ComplianceState,

        /// The reason for the OS policy to be in an unknown compliance state.
        /// This field is always populated when `compliance_state` is `UNKNOWN`.
        ///
        /// If populated, the field can contain one of the following values:
        ///
        /// * `vm-not-running`: The VM was not running.
        /// * `os-policies-not-supported-by-agent`: The version of the OS Config
        ///   agent running on the VM does not support running OS policies.
        /// * `no-agent-detected`: The OS Config agent is not detected for the VM.
        /// * `resource-execution-errors`: The OS Config agent encountered errors
        ///   while executing one or more resources in the policy. See
        ///   `os_policy_resource_compliances` for details.
        /// * `task-timeout`: The task sent to the agent to apply the policy timed
        ///   out.
        /// * `unexpected-agent-state`: The OS Config agent did not report the final
        ///   status of the task that attempted to apply the policy. Instead, the agent
        ///   unexpectedly started working on a different task. This mostly happens
        ///   when the agent or VM unexpectedly restarts while applying OS policies.
        /// * `internal-service-errors`: Internal service errors were encountered
        ///   while attempting to apply the policy.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub compliance_state_reason: std::string::String,

        /// Compliance data for each resource within the policy that is applied to
        /// the VM.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub os_policy_resource_compliances: std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OSPolicyCompliance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [os_policy_id][crate::model::os_policy_assignment_report::OSPolicyCompliance::os_policy_id].
        pub fn set_os_policy_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.os_policy_id = v.into();
            self
        }

        /// Sets the value of [compliance_state][crate::model::os_policy_assignment_report::OSPolicyCompliance::compliance_state].
        pub fn set_compliance_state<T: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::ComplianceState>>(mut self, v: T) -> Self{
            self.compliance_state = v.into();
            self
        }

        /// Sets the value of [compliance_state_reason][crate::model::os_policy_assignment_report::OSPolicyCompliance::compliance_state_reason].
        pub fn set_compliance_state_reason<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.compliance_state_reason = v.into();
            self
        }

        /// Sets the value of [os_policy_resource_compliances][crate::model::os_policy_assignment_report::OSPolicyCompliance::os_policy_resource_compliances].
        pub fn set_os_policy_resource_compliances<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance>
        {
            use std::iter::Iterator;
            self.os_policy_resource_compliances = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for OSPolicyCompliance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance"
        }
    }

    /// Defines additional types related to [OSPolicyCompliance].
    pub mod os_policy_compliance {
        #[allow(unused_imports)]
        use super::*;

        /// Compliance data for an OS policy resource.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OSPolicyResourceCompliance {

            /// The ID of the OS policy resource.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub os_policy_resource_id: std::string::String,

            /// Ordered list of configuration completed by the agent for the OS policy
            /// resource.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub config_steps: std::vec::Vec<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep>,

            /// The compliance state of the resource.
            pub compliance_state: crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ComplianceState,

            /// A reason for the resource to be in the given compliance state.
            /// This field is always populated when `compliance_state` is `UNKNOWN`.
            ///
            /// The following values are supported when `compliance_state == UNKNOWN`
            ///
            /// * `execution-errors`: Errors were encountered by the agent while
            ///   executing the resource and the compliance state couldn't be
            ///   determined.
            /// * `execution-skipped-by-agent`: Resource execution was skipped by the
            ///   agent because errors were encountered while executing prior resources
            ///   in the OS policy.
            /// * `os-policy-execution-attempt-failed`: The execution of the OS policy
            ///   containing this resource failed and the compliance state couldn't be
            ///   determined.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub compliance_state_reason: std::string::String,

            /// Resource specific output.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub output: std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OSPolicyResourceCompliance {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [os_policy_resource_id][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::os_policy_resource_id].
            pub fn set_os_policy_resource_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.os_policy_resource_id = v.into();
                self
            }

            /// Sets the value of [config_steps][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::config_steps].
            pub fn set_config_steps<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep>
            {
                use std::iter::Iterator;
                self.config_steps = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [compliance_state][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::compliance_state].
            pub fn set_compliance_state<T: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ComplianceState>>(mut self, v: T) -> Self{
                self.compliance_state = v.into();
                self
            }

            /// Sets the value of [compliance_state_reason][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::compliance_state_reason].
            pub fn set_compliance_state_reason<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.compliance_state_reason = v.into();
                self
            }

            /// Sets the value of [output][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::output].
            ///
            /// Note that all the setters affecting `output` are mutually
            /// exclusive.
            pub fn set_output<T: std::convert::Into<std::option::Option<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output>>>(mut self, v: T) -> Self
            {
                self.output = v.into();
                self
            }

            /// The value of [output][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::output]
            /// if it holds a `ExecResourceOutput`, `None` if the field is not set or
            /// holds a different branch.
            pub fn exec_resource_output(&self) -> std::option::Option<&std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>>{
                #[allow(unreachable_patterns)]
                self.output.as_ref().and_then(|v| match v {
                    crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output::ExecResourceOutput(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [output][crate::model::os_policy_assignment_report::os_policy_compliance::OSPolicyResourceCompliance::output]
            /// to hold a `ExecResourceOutput`.
            ///
            /// Note that all the setters affecting `output` are
            /// mutually exclusive.
            pub fn set_exec_resource_output<T: std::convert::Into<std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>>>(mut self, v: T) -> Self{
                self.output = std::option::Option::Some(
                    crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::Output::ExecResourceOutput(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for OSPolicyResourceCompliance {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance"
            }
        }

        /// Defines additional types related to [OSPolicyResourceCompliance].
        pub mod os_policy_resource_compliance {
            #[allow(unused_imports)]
            use super::*;

            /// Step performed by the OS Config agent for configuring an
            /// `OSPolicy` resource to its desired state.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct OSPolicyResourceConfigStep {

                /// Configuration step type.
                #[serde(rename = "type")]
                pub r#type: crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::os_policy_resource_config_step::Type,

                /// An error message recorded during the execution of this step.
                /// Only populated if errors were encountered during this step execution.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub error_message: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OSPolicyResourceConfigStep {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [r#type][crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep::type].
                pub fn set_type<T: std::convert::Into<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::os_policy_resource_config_step::Type>>(mut self, v: T) -> Self{
                    self.r#type = v.into();
                    self
                }

                /// Sets the value of [error_message][crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::OSPolicyResourceConfigStep::error_message].
                pub fn set_error_message<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.error_message = v.into();
                    self
                }
            }

            impl wkt::message::Message for OSPolicyResourceConfigStep {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep"
                }
            }

            /// Defines additional types related to [OSPolicyResourceConfigStep].
            pub mod os_policy_resource_config_step {
                #[allow(unused_imports)]
                use super::*;

                /// Supported configuration step types
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Type {
                    /// Default value. This value is unused.
                    Unspecified,
                    /// Checks for resource conflicts such as schema errors.
                    Validation,
                    /// Checks the current status of the desired state for a resource.
                    DesiredStateCheck,
                    /// Enforces the desired state for a resource that is not in desired
                    /// state.
                    DesiredStateEnforcement,
                    /// Re-checks the status of the desired state. This check is done
                    /// for a resource after the enforcement of all OS policies.
                    ///
                    /// This step is used to determine the final desired state status for
                    /// the resource. It accounts for any resources that might have drifted
                    /// from their desired state due to side effects from executing other
                    /// resources.
                    DesiredStateCheckPostEnforcement,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Type::value] or
                    /// [Type::name].
                    UnknownValue(r#type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod r#type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Type {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Validation => std::option::Option::Some(1),
                            Self::DesiredStateCheck => std::option::Option::Some(2),
                            Self::DesiredStateEnforcement => std::option::Option::Some(3),
                            Self::DesiredStateCheckPostEnforcement => std::option::Option::Some(4),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                            Self::Validation => std::option::Option::Some("VALIDATION"),
                            Self::DesiredStateCheck => {
                                std::option::Option::Some("DESIRED_STATE_CHECK")
                            }
                            Self::DesiredStateEnforcement => {
                                std::option::Option::Some("DESIRED_STATE_ENFORCEMENT")
                            }
                            Self::DesiredStateCheckPostEnforcement => {
                                std::option::Option::Some("DESIRED_STATE_CHECK_POST_ENFORCEMENT")
                            }
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Type {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Type {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Type {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Validation,
                            2 => Self::DesiredStateCheck,
                            3 => Self::DesiredStateEnforcement,
                            4 => Self::DesiredStateCheckPostEnforcement,
                            _ => Self::UnknownValue(r#type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Type {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "TYPE_UNSPECIFIED" => Self::Unspecified,
                            "VALIDATION" => Self::Validation,
                            "DESIRED_STATE_CHECK" => Self::DesiredStateCheck,
                            "DESIRED_STATE_ENFORCEMENT" => Self::DesiredStateEnforcement,
                            "DESIRED_STATE_CHECK_POST_ENFORCEMENT" => {
                                Self::DesiredStateCheckPostEnforcement
                            }
                            _ => Self::UnknownValue(r#type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Type {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Validation => serializer.serialize_i32(1),
                            Self::DesiredStateCheck => serializer.serialize_i32(2),
                            Self::DesiredStateEnforcement => serializer.serialize_i32(3),
                            Self::DesiredStateCheckPostEnforcement => serializer.serialize_i32(4),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Type {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                            ".google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep.Type"))
                    }
                }
            }

            /// ExecResource specific output.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ExecResourceOutput {
                /// Output from enforcement phase output file (if run).
                /// Output size is limited to 100K bytes.
                #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
                #[serde_as(as = "serde_with::base64::Base64")]
                pub enforcement_output: ::bytes::Bytes,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ExecResourceOutput {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [enforcement_output][crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput::enforcement_output].
                pub fn set_enforcement_output<T: std::convert::Into<::bytes::Bytes>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.enforcement_output = v.into();
                    self
                }
            }

            impl wkt::message::Message for ExecResourceOutput {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ExecResourceOutput"
                }
            }

            /// Possible compliance states for a resource.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ComplianceState {
                /// The resource is in an unknown compliance state.
                ///
                /// To get more details about why the policy is in this state, review
                /// the output of the `compliance_state_reason` field.
                Unknown,
                /// Resource is compliant.
                Compliant,
                /// Resource is non-compliant.
                NonCompliant,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ComplianceState::value] or
                /// [ComplianceState::name].
                UnknownValue(compliance_state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod compliance_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl ComplianceState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unknown => std::option::Option::Some(0),
                        Self::Compliant => std::option::Option::Some(1),
                        Self::NonCompliant => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unknown => std::option::Option::Some("UNKNOWN"),
                        Self::Compliant => std::option::Option::Some("COMPLIANT"),
                        Self::NonCompliant => std::option::Option::Some("NON_COMPLIANT"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for ComplianceState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for ComplianceState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for ComplianceState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unknown,
                        1 => Self::Compliant,
                        2 => Self::NonCompliant,
                        _ => Self::UnknownValue(compliance_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for ComplianceState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "UNKNOWN" => Self::Unknown,
                        "COMPLIANT" => Self::Compliant,
                        "NON_COMPLIANT" => Self::NonCompliant,
                        _ => Self::UnknownValue(compliance_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for ComplianceState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unknown => serializer.serialize_i32(0),
                        Self::Compliant => serializer.serialize_i32(1),
                        Self::NonCompliant => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for ComplianceState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComplianceState>::new(
                        ".google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ComplianceState"))
                }
            }

            /// Resource specific output.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Output {
                /// ExecResource specific output.
                ExecResourceOutput(std::boxed::Box<crate::model::os_policy_assignment_report::os_policy_compliance::os_policy_resource_compliance::ExecResourceOutput>),
            }
        }

        /// Possible compliance states for an os policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ComplianceState {
            /// The policy is in an unknown compliance state.
            ///
            /// Refer to the field `compliance_state_reason` to learn the exact reason
            /// for the policy to be in this compliance state.
            Unknown,
            /// Policy is compliant.
            ///
            /// The policy is compliant if all the underlying resources are also
            /// compliant.
            Compliant,
            /// Policy is non-compliant.
            ///
            /// The policy is non-compliant if one or more underlying resources are
            /// non-compliant.
            NonCompliant,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ComplianceState::value] or
            /// [ComplianceState::name].
            UnknownValue(compliance_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod compliance_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ComplianceState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unknown => std::option::Option::Some(0),
                    Self::Compliant => std::option::Option::Some(1),
                    Self::NonCompliant => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::Compliant => std::option::Option::Some("COMPLIANT"),
                    Self::NonCompliant => std::option::Option::Some("NON_COMPLIANT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ComplianceState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ComplianceState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ComplianceState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unknown,
                    1 => Self::Compliant,
                    2 => Self::NonCompliant,
                    _ => Self::UnknownValue(compliance_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ComplianceState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN" => Self::Unknown,
                    "COMPLIANT" => Self::Compliant,
                    "NON_COMPLIANT" => Self::NonCompliant,
                    _ => Self::UnknownValue(compliance_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ComplianceState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unknown => serializer.serialize_i32(0),
                    Self::Compliant => serializer.serialize_i32(1),
                    Self::NonCompliant => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ComplianceState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComplianceState>::new(
                    ".google.cloud.osconfig.v1.OSPolicyAssignmentReport.OSPolicyCompliance.ComplianceState"))
            }
        }
    }
}

/// OS policy assignment is an API resource that is used to
/// apply a set of OS policies to a dynamically targeted group of Compute Engine
/// VM instances.
///
/// An OS policy is used to define the desired state configuration for a
/// Compute Engine VM instance through a set of configuration resources that
/// provide capabilities such as installing or removing software packages, or
/// executing a script.
///
/// For more information, see [OS policy and OS policy
/// assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OSPolicyAssignment {
    /// Resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id}`
    ///
    /// This field is ignored when you create an OS policy assignment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// OS policy assignment description.
    /// Length of the description is limited to 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. List of OS policies to be applied to the VMs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub os_policies: std::vec::Vec<crate::model::OSPolicy>,

    /// Required. Filter to select VMs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_filter: std::option::Option<crate::model::os_policy_assignment::InstanceFilter>,

    /// Required. Rollout to deploy the OS policy assignment.
    /// A rollout is triggered in the following situations:
    ///
    /// ) OSPolicyAssignment is created.
    /// ) OSPolicyAssignment is updated and the update contains changes to one of
    ///   the following fields:
    ///   - instance_filter
    ///   - os_policies
    /// ) OSPolicyAssignment is deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::os_policy_assignment::Rollout>,

    /// Output only. The assignment revision ID
    /// A new revision is committed whenever a rollout is triggered for a OS policy
    /// assignment
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The etag for this OS policy assignment.
    /// If this is provided on update, it must match the server's etag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. OS policy assignment rollout state
    pub rollout_state: crate::model::os_policy_assignment::RolloutState,

    /// Output only. Indicates that this revision has been successfully rolled out
    /// in this zone and new VMs will be assigned OS policies from this revision.
    ///
    /// For a given OS policy assignment, there is only one revision with a value
    /// of `true` for this field.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub baseline: bool,

    /// Output only. Indicates that this revision deletes the OS policy assignment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub deleted: bool,

    /// Output only. Indicates that reconciliation is in progress for the revision.
    /// This value is `true` when the `rollout_state` is one of:
    ///
    /// * IN_PROGRESS
    /// * CANCELLING
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Output only. Server generated unique id for the OS policy assignment
    /// resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicyAssignment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OSPolicyAssignment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::OSPolicyAssignment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [os_policies][crate::model::OSPolicyAssignment::os_policies].
    pub fn set_os_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicy>,
    {
        use std::iter::Iterator;
        self.os_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_filter][crate::model::OSPolicyAssignment::instance_filter].
    pub fn set_instance_filter<
        T: std::convert::Into<std::option::Option<crate::model::os_policy_assignment::InstanceFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_filter = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::OSPolicyAssignment::rollout].
    pub fn set_rollout<
        T: std::convert::Into<std::option::Option<crate::model::os_policy_assignment::Rollout>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::OSPolicyAssignment::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::OSPolicyAssignment::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::OSPolicyAssignment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [rollout_state][crate::model::OSPolicyAssignment::rollout_state].
    pub fn set_rollout_state<
        T: std::convert::Into<crate::model::os_policy_assignment::RolloutState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_state = v.into();
        self
    }

    /// Sets the value of [baseline][crate::model::OSPolicyAssignment::baseline].
    pub fn set_baseline<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.baseline = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::OSPolicyAssignment::deleted].
    pub fn set_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deleted = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::OSPolicyAssignment::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::OSPolicyAssignment::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicyAssignment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment"
    }
}

/// Defines additional types related to [OSPolicyAssignment].
pub mod os_policy_assignment {
    #[allow(unused_imports)]
    use super::*;

    /// Message representing label set.
    ///
    /// * A label is a key value pair set for a VM.
    /// * A LabelSet is a set of labels.
    /// * Labels within a LabelSet are ANDed. In other words, a LabelSet is
    ///   applicable for a VM only if it matches all the labels in the
    ///   LabelSet.
    /// * Example: A LabelSet with 2 labels: `env=prod` and `type=webserver` will
    ///   only be applicable for those VMs with both labels
    ///   present.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LabelSet {
        /// Labels are identified by key/value pairs in this map.
        /// A VM should contain all the key/value pairs specified in this
        /// map to be selected.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LabelSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::os_policy_assignment::LabelSet::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for LabelSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.LabelSet"
        }
    }

    /// Filters to select target VMs for an assignment.
    ///
    /// If more than one filter criteria is specified below, a VM will be selected
    /// if and only if it satisfies all of them.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceFilter {
        /// Target all VMs in the project. If true, no other criteria is
        /// permitted.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub all: bool,

        /// List of label sets used for VM inclusion.
        ///
        /// If the list has more than one `LabelSet`, the VM is included if any
        /// of the label sets are applicable for the VM.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub inclusion_labels: std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,

        /// List of label sets used for VM exclusion.
        ///
        /// If the list has more than one label set, the VM is excluded if any
        /// of the label sets are applicable for the VM.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub exclusion_labels: std::vec::Vec<crate::model::os_policy_assignment::LabelSet>,

        /// List of inventories to select VMs.
        ///
        /// A VM is selected if its inventory data matches at least one of the
        /// following inventories.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub inventories:
            std::vec::Vec<crate::model::os_policy_assignment::instance_filter::Inventory>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [all][crate::model::os_policy_assignment::InstanceFilter::all].
        pub fn set_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.all = v.into();
            self
        }

        /// Sets the value of [inclusion_labels][crate::model::os_policy_assignment::InstanceFilter::inclusion_labels].
        pub fn set_inclusion_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment::LabelSet>,
        {
            use std::iter::Iterator;
            self.inclusion_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclusion_labels][crate::model::os_policy_assignment::InstanceFilter::exclusion_labels].
        pub fn set_exclusion_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment::LabelSet>,
        {
            use std::iter::Iterator;
            self.exclusion_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [inventories][crate::model::os_policy_assignment::InstanceFilter::inventories].
        pub fn set_inventories<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::os_policy_assignment::instance_filter::Inventory>,
        {
            use std::iter::Iterator;
            self.inventories = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InstanceFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.InstanceFilter"
        }
    }

    /// Defines additional types related to [InstanceFilter].
    pub mod instance_filter {
        #[allow(unused_imports)]
        use super::*;

        /// VM inventory details.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Inventory {
            /// Required. The OS short name
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub os_short_name: std::string::String,

            /// The OS version
            ///
            /// Prefix matches are supported if asterisk(*) is provided as the
            /// last character. For example, to match all versions with a major
            /// version of `7`, specify the following value for this field `7.*`
            ///
            /// An empty string matches all OS versions.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub os_version: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Inventory {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [os_short_name][crate::model::os_policy_assignment::instance_filter::Inventory::os_short_name].
            pub fn set_os_short_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.os_short_name = v.into();
                self
            }

            /// Sets the value of [os_version][crate::model::os_policy_assignment::instance_filter::Inventory::os_version].
            pub fn set_os_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.os_version = v.into();
                self
            }
        }

        impl wkt::message::Message for Inventory {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.InstanceFilter.Inventory"
            }
        }
    }

    /// Message to configure the rollout at the zonal level for the OS policy
    /// assignment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Rollout {
        /// Required. The maximum number (or percentage) of VMs per zone to disrupt
        /// at any given moment.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub disruption_budget: std::option::Option<crate::model::FixedOrPercent>,

        /// Required. This determines the minimum duration of time to wait after the
        /// configuration changes are applied through the current rollout. A
        /// VM continues to count towards the `disruption_budget` at least
        /// until this duration of time has passed after configuration changes are
        /// applied.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub min_wait_duration: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Rollout {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disruption_budget][crate::model::os_policy_assignment::Rollout::disruption_budget].
        pub fn set_disruption_budget<
            T: std::convert::Into<std::option::Option<crate::model::FixedOrPercent>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.disruption_budget = v.into();
            self
        }

        /// Sets the value of [min_wait_duration][crate::model::os_policy_assignment::Rollout::min_wait_duration].
        pub fn set_min_wait_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_wait_duration = v.into();
            self
        }
    }

    impl wkt::message::Message for Rollout {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignment.Rollout"
        }
    }

    /// OS policy assignment rollout state
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutState {
        /// Invalid value
        Unspecified,
        /// The rollout is in progress.
        InProgress,
        /// The rollout is being cancelled.
        Cancelling,
        /// The rollout is cancelled.
        Cancelled,
        /// The rollout has completed successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutState::value] or
        /// [RolloutState::name].
        UnknownValue(rollout_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Cancelling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutState>::new(
                ".google.cloud.osconfig.v1.OSPolicyAssignment.RolloutState",
            ))
        }
    }
}

/// OS policy assignment operation metadata provided by OS policy assignment API
/// methods that return long running operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OSPolicyAssignmentOperationMetadata {
    /// Reference to the `OSPolicyAssignment` API resource.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_policy_assignment: std::string::String,

    /// The OS policy assignment API method.
    pub api_method: crate::model::os_policy_assignment_operation_metadata::APIMethod,

    /// State of the rollout
    pub rollout_state: crate::model::os_policy_assignment_operation_metadata::RolloutState,

    /// Rollout start time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout_start_time: std::option::Option<wkt::Timestamp>,

    /// Rollout update time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout_update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OSPolicyAssignmentOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignment][crate::model::OSPolicyAssignmentOperationMetadata::os_policy_assignment].
    pub fn set_os_policy_assignment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment = v.into();
        self
    }

    /// Sets the value of [api_method][crate::model::OSPolicyAssignmentOperationMetadata::api_method].
    pub fn set_api_method<
        T: std::convert::Into<crate::model::os_policy_assignment_operation_metadata::APIMethod>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.api_method = v.into();
        self
    }

    /// Sets the value of [rollout_state][crate::model::OSPolicyAssignmentOperationMetadata::rollout_state].
    pub fn set_rollout_state<
        T: std::convert::Into<crate::model::os_policy_assignment_operation_metadata::RolloutState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_state = v.into();
        self
    }

    /// Sets the value of [rollout_start_time][crate::model::OSPolicyAssignmentOperationMetadata::rollout_start_time].
    pub fn set_rollout_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_start_time = v.into();
        self
    }

    /// Sets the value of [rollout_update_time][crate::model::OSPolicyAssignmentOperationMetadata::rollout_update_time].
    pub fn set_rollout_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_update_time = v.into();
        self
    }
}

impl wkt::message::Message for OSPolicyAssignmentOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OSPolicyAssignmentOperationMetadata"
    }
}

/// Defines additional types related to [OSPolicyAssignmentOperationMetadata].
pub mod os_policy_assignment_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The OS policy assignment API method.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum APIMethod {
        /// Invalid value
        Unspecified,
        /// Create OS policy assignment API method
        Create,
        /// Update OS policy assignment API method
        Update,
        /// Delete OS policy assignment API method
        Delete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [APIMethod::value] or
        /// [APIMethod::name].
        UnknownValue(api_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod api_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl APIMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("API_METHOD_UNSPECIFIED"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for APIMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for APIMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for APIMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                _ => Self::UnknownValue(api_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for APIMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "API_METHOD_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                _ => Self::UnknownValue(api_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for APIMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for APIMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<APIMethod>::new(
                ".google.cloud.osconfig.v1.OSPolicyAssignmentOperationMetadata.APIMethod",
            ))
        }
    }

    /// State of the rollout
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutState {
        /// Invalid value
        Unspecified,
        /// The rollout is in progress.
        InProgress,
        /// The rollout is being cancelled.
        Cancelling,
        /// The rollout is cancelled.
        Cancelled,
        /// The rollout has completed successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutState::value] or
        /// [RolloutState::name].
        UnknownValue(rollout_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Cancelling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(rollout_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutState>::new(
                ".google.cloud.osconfig.v1.OSPolicyAssignmentOperationMetadata.RolloutState",
            ))
        }
    }
}

/// A request message to create an OS policy assignment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateOSPolicyAssignmentRequest {
    /// Required. The parent resource name in the form:
    /// projects/{project}/locations/{location}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The OS policy assignment to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub os_policy_assignment: std::option::Option<crate::model::OSPolicyAssignment>,

    /// Required. The logical name of the OS policy assignment in the project
    /// with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_policy_assignment_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateOSPolicyAssignmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [os_policy_assignment][crate::model::CreateOSPolicyAssignmentRequest::os_policy_assignment].
    pub fn set_os_policy_assignment<
        T: std::convert::Into<std::option::Option<crate::model::OSPolicyAssignment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment = v.into();
        self
    }

    /// Sets the value of [os_policy_assignment_id][crate::model::CreateOSPolicyAssignmentRequest::os_policy_assignment_id].
    pub fn set_os_policy_assignment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CreateOSPolicyAssignmentRequest"
    }
}

/// A request message to update an OS policy assignment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateOSPolicyAssignmentRequest {
    /// Required. The updated OS policy assignment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub os_policy_assignment: std::option::Option<crate::model::OSPolicyAssignment>,

    /// Optional. Field mask that controls which fields of the assignment should be
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignment][crate::model::UpdateOSPolicyAssignmentRequest::os_policy_assignment].
    pub fn set_os_policy_assignment<
        T: std::convert::Into<std::option::Option<crate::model::OSPolicyAssignment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_policy_assignment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateOSPolicyAssignmentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.UpdateOSPolicyAssignmentRequest"
    }
}

/// A request message to get an OS policy assignment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOSPolicyAssignmentRequest {
    /// Required. The resource name of OS policy assignment.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/osPolicyAssignments/{os_policy_assignment}@{revisionId}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOSPolicyAssignmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetOSPolicyAssignmentRequest"
    }
}

/// A request message to list OS policy assignments for a parent resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentsRequest {
    /// Required. The parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of assignments to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListOSPolicyAssignments` that indicates where this listing should continue
    /// from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOSPolicyAssignmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSPolicyAssignmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSPolicyAssignmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentsRequest"
    }
}

/// A response message for listing all assignments under given parent.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentsResponse {
    /// The list of assignments
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub os_policy_assignments: std::vec::Vec<crate::model::OSPolicyAssignment>,

    /// The pagination token to retrieve the next page of OS policy assignments.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignments][crate::model::ListOSPolicyAssignmentsResponse::os_policy_assignments].
    pub fn set_os_policy_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        use std::iter::Iterator;
        self.os_policy_assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSPolicyAssignmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSPolicyAssignmentsResponse {
    type PageItem = crate::model::OSPolicyAssignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_policy_assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request message to list revisions for a OS policy assignment
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentRevisionsRequest {
    /// Required. The name of the OS policy assignment to list revisions for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The maximum number of revisions to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListOSPolicyAssignmentRevisions` that indicates where this listing should
    /// continue from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListOSPolicyAssignmentRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOSPolicyAssignmentRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOSPolicyAssignmentRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentRevisionsRequest"
    }
}

/// A response message for listing all revisions for a OS policy assignment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOSPolicyAssignmentRevisionsResponse {
    /// The OS policy assignment revisions
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub os_policy_assignments: std::vec::Vec<crate::model::OSPolicyAssignment>,

    /// The pagination token to retrieve the next page of OS policy assignment
    /// revisions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOSPolicyAssignmentRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_policy_assignments][crate::model::ListOSPolicyAssignmentRevisionsResponse::os_policy_assignments].
    pub fn set_os_policy_assignments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OSPolicyAssignment>,
    {
        use std::iter::Iterator;
        self.os_policy_assignments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOSPolicyAssignmentRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOSPolicyAssignmentRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListOSPolicyAssignmentRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOSPolicyAssignmentRevisionsResponse {
    type PageItem = crate::model::OSPolicyAssignment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.os_policy_assignments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request message for deleting a OS policy assignment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteOSPolicyAssignmentRequest {
    /// Required. The name of the OS policy assignment to be deleted
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteOSPolicyAssignmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteOSPolicyAssignmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteOSPolicyAssignmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.DeleteOSPolicyAssignmentRequest"
    }
}

/// Message encapsulating a value that can be either absolute ("fixed") or
/// relative ("percent") to a value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FixedOrPercent {
    /// Type of the value.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::fixed_or_percent::Mode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FixedOrPercent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::FixedOrPercent::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::fixed_or_percent::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::FixedOrPercent::mode]
    /// if it holds a `Fixed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::fixed_or_percent::Mode::Fixed(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::FixedOrPercent::mode]
    /// to hold a `Fixed`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_fixed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::fixed_or_percent::Mode::Fixed(v.into()));
        self
    }

    /// The value of [mode][crate::model::FixedOrPercent::mode]
    /// if it holds a `Percent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn percent(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::fixed_or_percent::Mode::Percent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::FixedOrPercent::mode]
    /// to hold a `Percent`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::fixed_or_percent::Mode::Percent(v.into()));
        self
    }
}

impl wkt::message::Message for FixedOrPercent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.FixedOrPercent"
    }
}

/// Defines additional types related to [FixedOrPercent].
pub mod fixed_or_percent {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the value.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Specifies a fixed value.
        Fixed(i32),
        /// Specifies the relative value defined as a percentage, which will be
        /// multiplied by a reference value.
        Percent(i32),
    }
}

/// Patch deployments are configurations that individual patch jobs use to
/// complete a patch. These configurations include instance filter, package
/// repository settings, and a schedule. For more information about creating and
/// managing patch deployments, see [Scheduling patch
/// jobs](https://cloud.google.com/compute/docs/os-patch-management/schedule-patch-jobs).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchDeployment {
    /// Unique name for the patch deployment resource in a project. The patch
    /// deployment name is in the form:
    /// `projects/{project_id}/patchDeployments/{patch_deployment_id}`.
    /// This field is ignored when you create a new patch deployment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description of the patch deployment. Length of the description is
    /// limited to 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. VM instances to patch.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_filter: std::option::Option<crate::model::PatchInstanceFilter>,

    /// Optional. Patch configuration that is applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub patch_config: std::option::Option<crate::model::PatchConfig>,

    /// Optional. Duration of the patch. After the duration ends, the patch times
    /// out.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. Time the patch deployment was created. Timestamp is in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time the patch deployment was last updated. Timestamp is in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time a patch job was started by this deployment.
    /// Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text
    /// format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_execute_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Rollout strategy of the patch job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::PatchRollout>,

    /// Output only. Current state of the patch deployment.
    pub state: crate::model::patch_deployment::State,

    /// Schedule for the patch.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::patch_deployment::Schedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PatchDeployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PatchDeployment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [instance_filter][crate::model::PatchDeployment::instance_filter].
    pub fn set_instance_filter<
        T: std::convert::Into<std::option::Option<crate::model::PatchInstanceFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_filter = v.into();
        self
    }

    /// Sets the value of [patch_config][crate::model::PatchDeployment::patch_config].
    pub fn set_patch_config<
        T: std::convert::Into<std::option::Option<crate::model::PatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patch_config = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::PatchDeployment::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PatchDeployment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PatchDeployment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [last_execute_time][crate::model::PatchDeployment::last_execute_time].
    pub fn set_last_execute_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_execute_time = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::PatchDeployment::rollout].
    pub fn set_rollout<T: std::convert::Into<std::option::Option<crate::model::PatchRollout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PatchDeployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::patch_deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::PatchDeployment::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::patch_deployment::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::PatchDeployment::schedule]
    /// if it holds a `OneTimeSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn one_time_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OneTimeSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::patch_deployment::Schedule::OneTimeSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::PatchDeployment::schedule]
    /// to hold a `OneTimeSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_one_time_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::OneTimeSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::patch_deployment::Schedule::OneTimeSchedule(v.into()),
        );
        self
    }

    /// The value of [schedule][crate::model::PatchDeployment::schedule]
    /// if it holds a `RecurringSchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recurring_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecurringSchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::patch_deployment::Schedule::RecurringSchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::PatchDeployment::schedule]
    /// to hold a `RecurringSchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_recurring_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::RecurringSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::patch_deployment::Schedule::RecurringSchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PatchDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchDeployment"
    }
}

/// Defines additional types related to [PatchDeployment].
pub mod patch_deployment {
    #[allow(unused_imports)]
    use super::*;

    /// Represents state of patch peployment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Active value means that patch deployment generates Patch Jobs.
        Active,
        /// Paused value means that patch deployment does not generate
        /// Patch jobs. Requires user action to move in and out from this state.
        Paused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Paused,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PAUSED" => Self::Paused,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.osconfig.v1.PatchDeployment.State",
            ))
        }
    }

    /// Schedule for the patch.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Schedule {
        /// Required. Schedule a one-time execution.
        OneTimeSchedule(std::boxed::Box<crate::model::OneTimeSchedule>),
        /// Required. Schedule recurring executions.
        RecurringSchedule(std::boxed::Box<crate::model::RecurringSchedule>),
    }
}

/// Sets the time for a one time patch deployment. Timestamp is in
/// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OneTimeSchedule {
    /// Required. The desired patch job execution time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execute_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OneTimeSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execute_time][crate::model::OneTimeSchedule::execute_time].
    pub fn set_execute_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execute_time = v.into();
        self
    }
}

impl wkt::message::Message for OneTimeSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.OneTimeSchedule"
    }
}

/// Sets the time for recurring patch deployments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecurringSchedule {
    /// Required. Defines the time zone that `time_of_day` is relative to.
    /// The rules for daylight saving time are determined by the chosen time zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_zone: std::option::Option<gtype::model::TimeZone>,

    /// Optional. The time that the recurring schedule becomes effective.
    /// Defaults to `create_time` of the patch deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The end time at which a recurring patch deployment schedule is no
    /// longer active.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Required. Time of the day to run a recurring deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_of_day: std::option::Option<gtype::model::TimeOfDay>,

    /// Required. The frequency unit of this recurring schedule.
    pub frequency: crate::model::recurring_schedule::Frequency,

    /// Output only. The time the last patch job ran successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_execute_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the next patch job is scheduled to run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_execute_time: std::option::Option<wkt::Timestamp>,

    /// Configurations for this recurring schedule.
    /// Configurations must match frequency.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_config: std::option::Option<crate::model::recurring_schedule::ScheduleConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecurringSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_zone][crate::model::RecurringSchedule::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::option::Option<gtype::model::TimeZone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::RecurringSchedule::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::RecurringSchedule::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [time_of_day][crate::model::RecurringSchedule::time_of_day].
    pub fn set_time_of_day<T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_of_day = v.into();
        self
    }

    /// Sets the value of [frequency][crate::model::RecurringSchedule::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::recurring_schedule::Frequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// Sets the value of [last_execute_time][crate::model::RecurringSchedule::last_execute_time].
    pub fn set_last_execute_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_execute_time = v.into();
        self
    }

    /// Sets the value of [next_execute_time][crate::model::RecurringSchedule::next_execute_time].
    pub fn set_next_execute_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_execute_time = v.into();
        self
    }

    /// Sets the value of [schedule_config][crate::model::RecurringSchedule::schedule_config].
    ///
    /// Note that all the setters affecting `schedule_config` are mutually
    /// exclusive.
    pub fn set_schedule_config<
        T: std::convert::Into<std::option::Option<crate::model::recurring_schedule::ScheduleConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_config = v.into();
        self
    }

    /// The value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// if it holds a `Weekly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn weekly(&self) -> std::option::Option<&std::boxed::Box<crate::model::WeeklySchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule_config.as_ref().and_then(|v| match v {
            crate::model::recurring_schedule::ScheduleConfig::Weekly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// to hold a `Weekly`.
    ///
    /// Note that all the setters affecting `schedule_config` are
    /// mutually exclusive.
    pub fn set_weekly<T: std::convert::Into<std::boxed::Box<crate::model::WeeklySchedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_config = std::option::Option::Some(
            crate::model::recurring_schedule::ScheduleConfig::Weekly(v.into()),
        );
        self
    }

    /// The value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// if it holds a `Monthly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn monthly(&self) -> std::option::Option<&std::boxed::Box<crate::model::MonthlySchedule>> {
        #[allow(unreachable_patterns)]
        self.schedule_config.as_ref().and_then(|v| match v {
            crate::model::recurring_schedule::ScheduleConfig::Monthly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule_config][crate::model::RecurringSchedule::schedule_config]
    /// to hold a `Monthly`.
    ///
    /// Note that all the setters affecting `schedule_config` are
    /// mutually exclusive.
    pub fn set_monthly<T: std::convert::Into<std::boxed::Box<crate::model::MonthlySchedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_config = std::option::Option::Some(
            crate::model::recurring_schedule::ScheduleConfig::Monthly(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RecurringSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.RecurringSchedule"
    }
}

/// Defines additional types related to [RecurringSchedule].
pub mod recurring_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the frequency of the recurring patch deployments.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Frequency {
        /// Invalid. A frequency must be specified.
        Unspecified,
        /// Indicates that the frequency of recurrence should be expressed in terms
        /// of weeks.
        Weekly,
        /// Indicates that the frequency of recurrence should be expressed in terms
        /// of months.
        Monthly,
        /// Indicates that the frequency of recurrence should be expressed in terms
        /// of days.
        Daily,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Frequency::value] or
        /// [Frequency::name].
        UnknownValue(frequency::UnknownValue),
    }

    #[doc(hidden)]
    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Frequency {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Weekly => std::option::Option::Some(1),
                Self::Monthly => std::option::Option::Some(2),
                Self::Daily => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FREQUENCY_UNSPECIFIED"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Frequency {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Frequency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Frequency {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Weekly,
                2 => Self::Monthly,
                3 => Self::Daily,
                _ => Self::UnknownValue(frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Frequency {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FREQUENCY_UNSPECIFIED" => Self::Unspecified,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "DAILY" => Self::Daily,
                _ => Self::UnknownValue(frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Frequency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Weekly => serializer.serialize_i32(1),
                Self::Monthly => serializer.serialize_i32(2),
                Self::Daily => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Frequency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Frequency>::new(
                ".google.cloud.osconfig.v1.RecurringSchedule.Frequency",
            ))
        }
    }

    /// Configurations for this recurring schedule.
    /// Configurations must match frequency.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ScheduleConfig {
        /// Required. Schedule with weekly executions.
        Weekly(std::boxed::Box<crate::model::WeeklySchedule>),
        /// Required. Schedule with monthly executions.
        Monthly(std::boxed::Box<crate::model::MonthlySchedule>),
    }
}

/// Represents a weekly schedule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeeklySchedule {
    /// Required. Day of the week.
    pub day_of_week: gtype::model::DayOfWeek,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_week][crate::model::WeeklySchedule::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }
}

impl wkt::message::Message for WeeklySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.WeeklySchedule"
    }
}

/// Represents a monthly schedule. An example of a valid monthly schedule is
/// "on the third Tuesday of the month" or "on the 15th of the month".
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MonthlySchedule {
    /// One day in a month.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub day_of_month: std::option::Option<crate::model::monthly_schedule::DayOfMonth>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonthlySchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day_of_month][crate::model::MonthlySchedule::day_of_month].
    ///
    /// Note that all the setters affecting `day_of_month` are mutually
    /// exclusive.
    pub fn set_day_of_month<
        T: std::convert::Into<std::option::Option<crate::model::monthly_schedule::DayOfMonth>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.day_of_month = v.into();
        self
    }

    /// The value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// if it holds a `WeekDayOfMonth`, `None` if the field is not set or
    /// holds a different branch.
    pub fn week_day_of_month(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WeekDayOfMonth>> {
        #[allow(unreachable_patterns)]
        self.day_of_month.as_ref().and_then(|v| match v {
            crate::model::monthly_schedule::DayOfMonth::WeekDayOfMonth(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// to hold a `WeekDayOfMonth`.
    ///
    /// Note that all the setters affecting `day_of_month` are
    /// mutually exclusive.
    pub fn set_week_day_of_month<
        T: std::convert::Into<std::boxed::Box<crate::model::WeekDayOfMonth>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.day_of_month = std::option::Option::Some(
            crate::model::monthly_schedule::DayOfMonth::WeekDayOfMonth(v.into()),
        );
        self
    }

    /// The value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// if it holds a `MonthDay`, `None` if the field is not set or
    /// holds a different branch.
    pub fn month_day(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.day_of_month.as_ref().and_then(|v| match v {
            crate::model::monthly_schedule::DayOfMonth::MonthDay(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [day_of_month][crate::model::MonthlySchedule::day_of_month]
    /// to hold a `MonthDay`.
    ///
    /// Note that all the setters affecting `day_of_month` are
    /// mutually exclusive.
    pub fn set_month_day<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.day_of_month = std::option::Option::Some(
            crate::model::monthly_schedule::DayOfMonth::MonthDay(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MonthlySchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.MonthlySchedule"
    }
}

/// Defines additional types related to [MonthlySchedule].
pub mod monthly_schedule {
    #[allow(unused_imports)]
    use super::*;

    /// One day in a month.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DayOfMonth {
        /// Required. Week day in a month.
        WeekDayOfMonth(std::boxed::Box<crate::model::WeekDayOfMonth>),
        /// Required. One day of the month. 1-31 indicates the 1st to the 31st day.
        /// -1 indicates the last day of the month. Months without the target day
        /// will be skipped. For example, a schedule to run "every month on the 31st"
        /// will not run in February, April, June, etc.
        MonthDay(i32),
    }
}

/// Represents one week day in a month. An example is "the 4th Sunday".
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeekDayOfMonth {
    /// Required. Week number in a month. 1-4 indicates the 1st to 4th week of the
    /// month. -1 indicates the last week of the month.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub week_ordinal: i32,

    /// Required. A day of the week.
    pub day_of_week: gtype::model::DayOfWeek,

    /// Optional. Represents the number of days before or after the given week day
    /// of month that the patch deployment is scheduled for. For example if
    /// `week_ordinal` and `day_of_week` values point to the second day of the
    /// month and this `day_offset` value is set to `3`, the patch deployment takes
    /// place three days after the second Tuesday of the month. If this value is
    /// negative, for example -5, the patches are deployed five days before before
    /// the second Tuesday of the month. Allowed values are in range [-30, 30].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub day_offset: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeekDayOfMonth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [week_ordinal][crate::model::WeekDayOfMonth::week_ordinal].
    pub fn set_week_ordinal<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.week_ordinal = v.into();
        self
    }

    /// Sets the value of [day_of_week][crate::model::WeekDayOfMonth::day_of_week].
    pub fn set_day_of_week<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day_of_week = v.into();
        self
    }

    /// Sets the value of [day_offset][crate::model::WeekDayOfMonth::day_offset].
    pub fn set_day_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.day_offset = v.into();
        self
    }
}

impl wkt::message::Message for WeekDayOfMonth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.WeekDayOfMonth"
    }
}

/// A request message for creating a patch deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePatchDeploymentRequest {
    /// Required. The project to apply this patch deployment to in the form
    /// `projects/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A name for the patch deployment in the project. When creating a
    /// name the following rules apply:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub patch_deployment_id: std::string::String,

    /// Required. The patch deployment to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub patch_deployment: std::option::Option<crate::model::PatchDeployment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePatchDeploymentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [patch_deployment_id][crate::model::CreatePatchDeploymentRequest::patch_deployment_id].
    pub fn set_patch_deployment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.patch_deployment_id = v.into();
        self
    }

    /// Sets the value of [patch_deployment][crate::model::CreatePatchDeploymentRequest::patch_deployment].
    pub fn set_patch_deployment<
        T: std::convert::Into<std::option::Option<crate::model::PatchDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patch_deployment = v.into();
        self
    }
}

impl wkt::message::Message for CreatePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CreatePatchDeploymentRequest"
    }
}

/// A request message for retrieving a patch deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetPatchDeploymentRequest"
    }
}

/// A request message for listing patch deployments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPatchDeploymentsRequest {
    /// Required. The resource name of the parent in the form `projects/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of patch deployments to return. Default is
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A pagination token returned from a previous call to
    /// ListPatchDeployments that indicates where this listing should continue
    /// from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPatchDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPatchDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPatchDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchDeploymentsRequest"
    }
}

/// A response message for listing patch deployments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPatchDeploymentsResponse {
    /// The list of patch deployments.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patch_deployments: std::vec::Vec<crate::model::PatchDeployment>,

    /// A pagination token that can be used to get the next page of patch
    /// deployments.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_deployments][crate::model::ListPatchDeploymentsResponse::patch_deployments].
    pub fn set_patch_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PatchDeployment>,
    {
        use std::iter::Iterator;
        self.patch_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPatchDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPatchDeploymentsResponse {
    type PageItem = crate::model::PatchDeployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.patch_deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request message for deleting a patch deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.DeletePatchDeploymentRequest"
    }
}

/// A request message for updating a patch deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePatchDeploymentRequest {
    /// Required. The patch deployment to Update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub patch_deployment: std::option::Option<crate::model::PatchDeployment>,

    /// Optional. Field mask that controls which fields of the patch deployment
    /// should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_deployment][crate::model::UpdatePatchDeploymentRequest::patch_deployment].
    pub fn set_patch_deployment<
        T: std::convert::Into<std::option::Option<crate::model::PatchDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patch_deployment = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePatchDeploymentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.UpdatePatchDeploymentRequest"
    }
}

/// A request message for pausing a patch deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PausePatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PausePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PausePatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PausePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PausePatchDeploymentRequest"
    }
}

/// A request message for resuming a patch deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumePatchDeploymentRequest {
    /// Required. The resource name of the patch deployment in the form
    /// `projects/*/patchDeployments/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumePatchDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumePatchDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumePatchDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ResumePatchDeploymentRequest"
    }
}

/// A request message to initiate patching across Compute Engine
/// instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutePatchJobRequest {
    /// Required. The project in which to run this patch in the form `projects/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Description of the patch job. Length of the description is limited
    /// to 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. Instances to patch, either explicitly or filtered by some
    /// criteria such as zone or labels.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_filter: std::option::Option<crate::model::PatchInstanceFilter>,

    /// Patch configuration being applied. If omitted, instances are
    /// patched using the default configurations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub patch_config: std::option::Option<crate::model::PatchConfig>,

    /// Duration of the patch job. After the duration ends, the patch job
    /// times out.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// If this patch is a dry-run only, instances are contacted but
    /// will do nothing.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub dry_run: bool,

    /// Display name for this patch job. This does not have to be unique.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Rollout strategy of the patch job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::PatchRollout>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutePatchJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExecutePatchJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ExecutePatchJobRequest::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [instance_filter][crate::model::ExecutePatchJobRequest::instance_filter].
    pub fn set_instance_filter<
        T: std::convert::Into<std::option::Option<crate::model::PatchInstanceFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_filter = v.into();
        self
    }

    /// Sets the value of [patch_config][crate::model::ExecutePatchJobRequest::patch_config].
    pub fn set_patch_config<
        T: std::convert::Into<std::option::Option<crate::model::PatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patch_config = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::ExecutePatchJobRequest::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::ExecutePatchJobRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ExecutePatchJobRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::ExecutePatchJobRequest::rollout].
    pub fn set_rollout<T: std::convert::Into<std::option::Option<crate::model::PatchRollout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout = v.into();
        self
    }
}

impl wkt::message::Message for ExecutePatchJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ExecutePatchJobRequest"
    }
}

/// Request to get an active or completed patch job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPatchJobRequest {
    /// Required. Name of the patch in the form `projects/*/patchJobs/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPatchJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPatchJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPatchJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetPatchJobRequest"
    }
}

/// Request to list details for all instances that are part of a patch job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPatchJobInstanceDetailsRequest {
    /// Required. The parent for the instances are in the form of
    /// `projects/*/patchJobs/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of instance details records to return.  Default is 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A pagination token returned from a previous call
    /// that indicates where this listing should continue from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters results listed in the response. This
    /// field supports filtering results by instance zone, name, state, or
    /// `failure_reason`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobInstanceDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPatchJobInstanceDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPatchJobInstanceDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPatchJobInstanceDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPatchJobInstanceDetailsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobInstanceDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobInstanceDetailsRequest"
    }
}

/// A response message for listing the instances details for a patch job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPatchJobInstanceDetailsResponse {
    /// A list of instance status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patch_job_instance_details: std::vec::Vec<crate::model::PatchJobInstanceDetails>,

    /// A pagination token that can be used to get the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobInstanceDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_job_instance_details][crate::model::ListPatchJobInstanceDetailsResponse::patch_job_instance_details].
    pub fn set_patch_job_instance_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PatchJobInstanceDetails>,
    {
        use std::iter::Iterator;
        self.patch_job_instance_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPatchJobInstanceDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobInstanceDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobInstanceDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPatchJobInstanceDetailsResponse {
    type PageItem = crate::model::PatchJobInstanceDetails;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.patch_job_instance_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Patch details for a VM instance. For more information about reviewing VM
/// instance details, see
/// [Listing all VM instance details for a specific patch
/// job](https://cloud.google.com/compute/docs/os-patch-management/manage-patch-jobs#list-instance-details).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchJobInstanceDetails {
    /// The instance name in the form `projects/*/zones/*/instances/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The unique identifier for the instance. This identifier is
    /// defined by the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_system_id: std::string::String,

    /// Current state of instance patch.
    pub state: crate::model::instance::PatchState,

    /// If the patch fails, this field provides the reason.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub failure_reason: std::string::String,

    /// The number of times the agent that the agent attempts to apply the patch.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub attempt_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchJobInstanceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PatchJobInstanceDetails::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance_system_id][crate::model::PatchJobInstanceDetails::instance_system_id].
    pub fn set_instance_system_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_system_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PatchJobInstanceDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::PatchState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [failure_reason][crate::model::PatchJobInstanceDetails::failure_reason].
    pub fn set_failure_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_reason = v.into();
        self
    }

    /// Sets the value of [attempt_count][crate::model::PatchJobInstanceDetails::attempt_count].
    pub fn set_attempt_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.attempt_count = v.into();
        self
    }
}

impl wkt::message::Message for PatchJobInstanceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchJobInstanceDetails"
    }
}

/// A request message for listing patch jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPatchJobsRequest {
    /// Required. In the form of `projects/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of instance status to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A pagination token returned from a previous call
    /// that indicates where this listing should continue from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If provided, this field specifies the criteria that must be met by patch
    /// jobs to be included in the response.
    /// Currently, filtering is only available on the patch_deployment field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPatchJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPatchJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPatchJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPatchJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobsRequest"
    }
}

/// A response message for listing patch jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPatchJobsResponse {
    /// The list of patch jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patch_jobs: std::vec::Vec<crate::model::PatchJob>,

    /// A pagination token that can be used to get the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPatchJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_jobs][crate::model::ListPatchJobsResponse::patch_jobs].
    pub fn set_patch_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PatchJob>,
    {
        use std::iter::Iterator;
        self.patch_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPatchJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPatchJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListPatchJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPatchJobsResponse {
    type PageItem = crate::model::PatchJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.patch_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A high level representation of a patch job that is either in progress
/// or has completed.
///
/// Instance details are not included in the job. To paginate through instance
/// details, use ListPatchJobInstanceDetails.
///
/// For more information about patch jobs, see
/// [Creating patch
/// jobs](https://cloud.google.com/compute/docs/os-patch-management/create-patch-job).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchJob {
    /// Unique identifier for this patch job in the form
    /// `projects/*/patchJobs/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Display name for this patch job. This is not a unique identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Description of the patch job. Length of the description is limited
    /// to 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Time this patch job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Last time this patch job was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The current state of the PatchJob.
    pub state: crate::model::patch_job::State,

    /// Instances to patch.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_filter: std::option::Option<crate::model::PatchInstanceFilter>,

    /// Patch configuration being applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub patch_config: std::option::Option<crate::model::PatchConfig>,

    /// Duration of the patch job. After the duration ends, the
    /// patch job times out.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Summary of instance details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_details_summary:
        std::option::Option<crate::model::patch_job::InstanceDetailsSummary>,

    /// If this patch job is a dry run, the agent reports that it has
    /// finished without running any updates on the VM instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub dry_run: bool,

    /// If this patch job failed, this message provides information about the
    /// failure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    /// Reflects the overall progress of the patch job in the range of
    /// 0.0 being no progress to 100.0 being complete.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub percent_complete: f64,

    /// Output only. Name of the patch deployment that created this patch job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub patch_deployment: std::string::String,

    /// Rollout strategy being applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::PatchRollout>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PatchJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PatchJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::PatchJob::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PatchJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PatchJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PatchJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::patch_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [instance_filter][crate::model::PatchJob::instance_filter].
    pub fn set_instance_filter<
        T: std::convert::Into<std::option::Option<crate::model::PatchInstanceFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_filter = v.into();
        self
    }

    /// Sets the value of [patch_config][crate::model::PatchJob::patch_config].
    pub fn set_patch_config<
        T: std::convert::Into<std::option::Option<crate::model::PatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patch_config = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::PatchJob::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [instance_details_summary][crate::model::PatchJob::instance_details_summary].
    pub fn set_instance_details_summary<
        T: std::convert::Into<std::option::Option<crate::model::patch_job::InstanceDetailsSummary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_details_summary = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::PatchJob::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::PatchJob::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [percent_complete][crate::model::PatchJob::percent_complete].
    pub fn set_percent_complete<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.percent_complete = v.into();
        self
    }

    /// Sets the value of [patch_deployment][crate::model::PatchJob::patch_deployment].
    pub fn set_patch_deployment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.patch_deployment = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::PatchJob::rollout].
    pub fn set_rollout<T: std::convert::Into<std::option::Option<crate::model::PatchRollout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout = v.into();
        self
    }
}

impl wkt::message::Message for PatchJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchJob"
    }
}

/// Defines additional types related to [PatchJob].
pub mod patch_job {
    #[allow(unused_imports)]
    use super::*;

    /// A summary of the current patch state across all instances that this patch
    /// job affects. Contains counts of instances in different states. These states
    /// map to `InstancePatchState`. List patch job instance details to see the
    /// specific states of each instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceDetailsSummary {
        /// Number of instances pending patch job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub pending_instance_count: i64,

        /// Number of instances that are inactive.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub inactive_instance_count: i64,

        /// Number of instances notified about patch job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub notified_instance_count: i64,

        /// Number of instances that have started.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub started_instance_count: i64,

        /// Number of instances that are downloading patches.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub downloading_patches_instance_count: i64,

        /// Number of instances that are applying patches.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub applying_patches_instance_count: i64,

        /// Number of instances rebooting.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub rebooting_instance_count: i64,

        /// Number of instances that have completed successfully.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub succeeded_instance_count: i64,

        /// Number of instances that require reboot.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub succeeded_reboot_required_instance_count: i64,

        /// Number of instances that failed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub failed_instance_count: i64,

        /// Number of instances that have acked and will start shortly.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub acked_instance_count: i64,

        /// Number of instances that exceeded the time out while applying the patch.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub timed_out_instance_count: i64,

        /// Number of instances that are running the pre-patch step.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub pre_patch_step_instance_count: i64,

        /// Number of instances that are running the post-patch step.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub post_patch_step_instance_count: i64,

        /// Number of instances that do not appear to be running the agent. Check to
        /// ensure that the agent is installed, running, and able to communicate with
        /// the service.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub no_agent_detected_instance_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceDetailsSummary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pending_instance_count][crate::model::patch_job::InstanceDetailsSummary::pending_instance_count].
        pub fn set_pending_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.pending_instance_count = v.into();
            self
        }

        /// Sets the value of [inactive_instance_count][crate::model::patch_job::InstanceDetailsSummary::inactive_instance_count].
        pub fn set_inactive_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.inactive_instance_count = v.into();
            self
        }

        /// Sets the value of [notified_instance_count][crate::model::patch_job::InstanceDetailsSummary::notified_instance_count].
        pub fn set_notified_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.notified_instance_count = v.into();
            self
        }

        /// Sets the value of [started_instance_count][crate::model::patch_job::InstanceDetailsSummary::started_instance_count].
        pub fn set_started_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.started_instance_count = v.into();
            self
        }

        /// Sets the value of [downloading_patches_instance_count][crate::model::patch_job::InstanceDetailsSummary::downloading_patches_instance_count].
        pub fn set_downloading_patches_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.downloading_patches_instance_count = v.into();
            self
        }

        /// Sets the value of [applying_patches_instance_count][crate::model::patch_job::InstanceDetailsSummary::applying_patches_instance_count].
        pub fn set_applying_patches_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.applying_patches_instance_count = v.into();
            self
        }

        /// Sets the value of [rebooting_instance_count][crate::model::patch_job::InstanceDetailsSummary::rebooting_instance_count].
        pub fn set_rebooting_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.rebooting_instance_count = v.into();
            self
        }

        /// Sets the value of [succeeded_instance_count][crate::model::patch_job::InstanceDetailsSummary::succeeded_instance_count].
        pub fn set_succeeded_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.succeeded_instance_count = v.into();
            self
        }

        /// Sets the value of [succeeded_reboot_required_instance_count][crate::model::patch_job::InstanceDetailsSummary::succeeded_reboot_required_instance_count].
        pub fn set_succeeded_reboot_required_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.succeeded_reboot_required_instance_count = v.into();
            self
        }

        /// Sets the value of [failed_instance_count][crate::model::patch_job::InstanceDetailsSummary::failed_instance_count].
        pub fn set_failed_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.failed_instance_count = v.into();
            self
        }

        /// Sets the value of [acked_instance_count][crate::model::patch_job::InstanceDetailsSummary::acked_instance_count].
        pub fn set_acked_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.acked_instance_count = v.into();
            self
        }

        /// Sets the value of [timed_out_instance_count][crate::model::patch_job::InstanceDetailsSummary::timed_out_instance_count].
        pub fn set_timed_out_instance_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.timed_out_instance_count = v.into();
            self
        }

        /// Sets the value of [pre_patch_step_instance_count][crate::model::patch_job::InstanceDetailsSummary::pre_patch_step_instance_count].
        pub fn set_pre_patch_step_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.pre_patch_step_instance_count = v.into();
            self
        }

        /// Sets the value of [post_patch_step_instance_count][crate::model::patch_job::InstanceDetailsSummary::post_patch_step_instance_count].
        pub fn set_post_patch_step_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.post_patch_step_instance_count = v.into();
            self
        }

        /// Sets the value of [no_agent_detected_instance_count][crate::model::patch_job::InstanceDetailsSummary::no_agent_detected_instance_count].
        pub fn set_no_agent_detected_instance_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.no_agent_detected_instance_count = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceDetailsSummary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.PatchJob.InstanceDetailsSummary"
        }
    }

    /// Enumeration of the various states a patch job passes through as it
    /// executes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State must be specified.
        Unspecified,
        /// The patch job was successfully initiated.
        Started,
        /// The patch job is looking up instances to run the patch on.
        InstanceLookup,
        /// Instances are being patched.
        Patching,
        /// Patch job completed successfully.
        Succeeded,
        /// Patch job completed but there were errors.
        CompletedWithErrors,
        /// The patch job was canceled.
        Canceled,
        /// The patch job timed out.
        TimedOut,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(1),
                Self::InstanceLookup => std::option::Option::Some(2),
                Self::Patching => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::CompletedWithErrors => std::option::Option::Some(5),
                Self::Canceled => std::option::Option::Some(6),
                Self::TimedOut => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::InstanceLookup => std::option::Option::Some("INSTANCE_LOOKUP"),
                Self::Patching => std::option::Option::Some("PATCHING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::CompletedWithErrors => std::option::Option::Some("COMPLETED_WITH_ERRORS"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::TimedOut => std::option::Option::Some("TIMED_OUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Started,
                2 => Self::InstanceLookup,
                3 => Self::Patching,
                4 => Self::Succeeded,
                5 => Self::CompletedWithErrors,
                6 => Self::Canceled,
                7 => Self::TimedOut,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "INSTANCE_LOOKUP" => Self::InstanceLookup,
                "PATCHING" => Self::Patching,
                "SUCCEEDED" => Self::Succeeded,
                "COMPLETED_WITH_ERRORS" => Self::CompletedWithErrors,
                "CANCELED" => Self::Canceled,
                "TIMED_OUT" => Self::TimedOut,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(1),
                Self::InstanceLookup => serializer.serialize_i32(2),
                Self::Patching => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::CompletedWithErrors => serializer.serialize_i32(5),
                Self::Canceled => serializer.serialize_i32(6),
                Self::TimedOut => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.osconfig.v1.PatchJob.State",
            ))
        }
    }
}

/// Patch configuration specifications. Contains details on how to apply the
/// patch(es) to a VM instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchConfig {
    /// Post-patch reboot settings.
    pub reboot_config: crate::model::patch_config::RebootConfig,

    /// Apt update settings. Use this setting to override the default `apt` patch
    /// rules.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub apt: std::option::Option<crate::model::AptSettings>,

    /// Yum update settings. Use this setting to override the default `yum` patch
    /// rules.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub yum: std::option::Option<crate::model::YumSettings>,

    /// Goo update settings. Use this setting to override the default `goo` patch
    /// rules.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub goo: std::option::Option<crate::model::GooSettings>,

    /// Zypper update settings. Use this setting to override the default `zypper`
    /// patch rules.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zypper: std::option::Option<crate::model::ZypperSettings>,

    /// Windows update settings. Use this override the default windows patch rules.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub windows_update: std::option::Option<crate::model::WindowsUpdateSettings>,

    /// The `ExecStep` to run before the patch update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pre_step: std::option::Option<crate::model::ExecStep>,

    /// The `ExecStep` to run after the patch update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_step: std::option::Option<crate::model::ExecStep>,

    /// Allows the patch job to run on Managed instance groups (MIGs).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub mig_instances_allowed: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reboot_config][crate::model::PatchConfig::reboot_config].
    pub fn set_reboot_config<T: std::convert::Into<crate::model::patch_config::RebootConfig>>(
        mut self,
        v: T,
    ) -> Self {
        self.reboot_config = v.into();
        self
    }

    /// Sets the value of [apt][crate::model::PatchConfig::apt].
    pub fn set_apt<T: std::convert::Into<std::option::Option<crate::model::AptSettings>>>(
        mut self,
        v: T,
    ) -> Self {
        self.apt = v.into();
        self
    }

    /// Sets the value of [yum][crate::model::PatchConfig::yum].
    pub fn set_yum<T: std::convert::Into<std::option::Option<crate::model::YumSettings>>>(
        mut self,
        v: T,
    ) -> Self {
        self.yum = v.into();
        self
    }

    /// Sets the value of [goo][crate::model::PatchConfig::goo].
    pub fn set_goo<T: std::convert::Into<std::option::Option<crate::model::GooSettings>>>(
        mut self,
        v: T,
    ) -> Self {
        self.goo = v.into();
        self
    }

    /// Sets the value of [zypper][crate::model::PatchConfig::zypper].
    pub fn set_zypper<T: std::convert::Into<std::option::Option<crate::model::ZypperSettings>>>(
        mut self,
        v: T,
    ) -> Self {
        self.zypper = v.into();
        self
    }

    /// Sets the value of [windows_update][crate::model::PatchConfig::windows_update].
    pub fn set_windows_update<
        T: std::convert::Into<std::option::Option<crate::model::WindowsUpdateSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.windows_update = v.into();
        self
    }

    /// Sets the value of [pre_step][crate::model::PatchConfig::pre_step].
    pub fn set_pre_step<T: std::convert::Into<std::option::Option<crate::model::ExecStep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.pre_step = v.into();
        self
    }

    /// Sets the value of [post_step][crate::model::PatchConfig::post_step].
    pub fn set_post_step<T: std::convert::Into<std::option::Option<crate::model::ExecStep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.post_step = v.into();
        self
    }

    /// Sets the value of [mig_instances_allowed][crate::model::PatchConfig::mig_instances_allowed].
    pub fn set_mig_instances_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.mig_instances_allowed = v.into();
        self
    }
}

impl wkt::message::Message for PatchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchConfig"
    }
}

/// Defines additional types related to [PatchConfig].
pub mod patch_config {
    #[allow(unused_imports)]
    use super::*;

    /// Post-patch reboot settings.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RebootConfig {
        /// The default behavior is DEFAULT.
        Unspecified,
        /// The agent decides if a reboot is necessary by checking signals such as
        /// registry keys on Windows or `/var/run/reboot-required` on APT based
        /// systems. On RPM based systems, a set of core system package install times
        /// are compared with system boot time.
        Default,
        /// Always reboot the machine after the update completes.
        Always,
        /// Never reboot the machine after the update completes.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RebootConfig::value] or
        /// [RebootConfig::name].
        UnknownValue(reboot_config::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reboot_config {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RebootConfig {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::Always => std::option::Option::Some(2),
                Self::Never => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REBOOT_CONFIG_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RebootConfig {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RebootConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RebootConfig {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::Always,
                3 => Self::Never,
                _ => Self::UnknownValue(reboot_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RebootConfig {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REBOOT_CONFIG_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                _ => Self::UnknownValue(reboot_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RebootConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::Always => serializer.serialize_i32(2),
                Self::Never => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RebootConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RebootConfig>::new(
                ".google.cloud.osconfig.v1.PatchConfig.RebootConfig",
            ))
        }
    }
}

/// Namespace for instance state enums.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Patch state of an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PatchState {
        /// Unspecified.
        Unspecified,
        /// The instance is not yet notified.
        Pending,
        /// Instance is inactive and cannot be patched.
        Inactive,
        /// The instance is notified that it should be patched.
        Notified,
        /// The instance has started the patching process.
        Started,
        /// The instance is downloading patches.
        DownloadingPatches,
        /// The instance is applying patches.
        ApplyingPatches,
        /// The instance is rebooting.
        Rebooting,
        /// The instance has completed applying patches.
        Succeeded,
        /// The instance has completed applying patches but a reboot is required.
        SucceededRebootRequired,
        /// The instance has failed to apply the patch.
        Failed,
        /// The instance acked the notification and will start shortly.
        Acked,
        /// The instance exceeded the time out while applying the patch.
        TimedOut,
        /// The instance is running the pre-patch step.
        RunningPrePatchStep,
        /// The instance is running the post-patch step.
        RunningPostPatchStep,
        /// The service could not detect the presence of the agent. Check to ensure
        /// that the agent is installed, running, and able to communicate with the
        /// service.
        NoAgentDetected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PatchState::value] or
        /// [PatchState::name].
        UnknownValue(patch_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod patch_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PatchState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::Notified => std::option::Option::Some(3),
                Self::Started => std::option::Option::Some(4),
                Self::DownloadingPatches => std::option::Option::Some(5),
                Self::ApplyingPatches => std::option::Option::Some(6),
                Self::Rebooting => std::option::Option::Some(7),
                Self::Succeeded => std::option::Option::Some(8),
                Self::SucceededRebootRequired => std::option::Option::Some(9),
                Self::Failed => std::option::Option::Some(10),
                Self::Acked => std::option::Option::Some(11),
                Self::TimedOut => std::option::Option::Some(12),
                Self::RunningPrePatchStep => std::option::Option::Some(13),
                Self::RunningPostPatchStep => std::option::Option::Some(14),
                Self::NoAgentDetected => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PATCH_STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Notified => std::option::Option::Some("NOTIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::DownloadingPatches => std::option::Option::Some("DOWNLOADING_PATCHES"),
                Self::ApplyingPatches => std::option::Option::Some("APPLYING_PATCHES"),
                Self::Rebooting => std::option::Option::Some("REBOOTING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::SucceededRebootRequired => {
                    std::option::Option::Some("SUCCEEDED_REBOOT_REQUIRED")
                }
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Acked => std::option::Option::Some("ACKED"),
                Self::TimedOut => std::option::Option::Some("TIMED_OUT"),
                Self::RunningPrePatchStep => std::option::Option::Some("RUNNING_PRE_PATCH_STEP"),
                Self::RunningPostPatchStep => std::option::Option::Some("RUNNING_POST_PATCH_STEP"),
                Self::NoAgentDetected => std::option::Option::Some("NO_AGENT_DETECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PatchState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PatchState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PatchState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Inactive,
                3 => Self::Notified,
                4 => Self::Started,
                5 => Self::DownloadingPatches,
                6 => Self::ApplyingPatches,
                7 => Self::Rebooting,
                8 => Self::Succeeded,
                9 => Self::SucceededRebootRequired,
                10 => Self::Failed,
                11 => Self::Acked,
                12 => Self::TimedOut,
                13 => Self::RunningPrePatchStep,
                14 => Self::RunningPostPatchStep,
                15 => Self::NoAgentDetected,
                _ => Self::UnknownValue(patch_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PatchState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PATCH_STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "INACTIVE" => Self::Inactive,
                "NOTIFIED" => Self::Notified,
                "STARTED" => Self::Started,
                "DOWNLOADING_PATCHES" => Self::DownloadingPatches,
                "APPLYING_PATCHES" => Self::ApplyingPatches,
                "REBOOTING" => Self::Rebooting,
                "SUCCEEDED" => Self::Succeeded,
                "SUCCEEDED_REBOOT_REQUIRED" => Self::SucceededRebootRequired,
                "FAILED" => Self::Failed,
                "ACKED" => Self::Acked,
                "TIMED_OUT" => Self::TimedOut,
                "RUNNING_PRE_PATCH_STEP" => Self::RunningPrePatchStep,
                "RUNNING_POST_PATCH_STEP" => Self::RunningPostPatchStep,
                "NO_AGENT_DETECTED" => Self::NoAgentDetected,
                _ => Self::UnknownValue(patch_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PatchState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::Notified => serializer.serialize_i32(3),
                Self::Started => serializer.serialize_i32(4),
                Self::DownloadingPatches => serializer.serialize_i32(5),
                Self::ApplyingPatches => serializer.serialize_i32(6),
                Self::Rebooting => serializer.serialize_i32(7),
                Self::Succeeded => serializer.serialize_i32(8),
                Self::SucceededRebootRequired => serializer.serialize_i32(9),
                Self::Failed => serializer.serialize_i32(10),
                Self::Acked => serializer.serialize_i32(11),
                Self::TimedOut => serializer.serialize_i32(12),
                Self::RunningPrePatchStep => serializer.serialize_i32(13),
                Self::RunningPostPatchStep => serializer.serialize_i32(14),
                Self::NoAgentDetected => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PatchState>::new(
                ".google.cloud.osconfig.v1.Instance.PatchState",
            ))
        }
    }
}

/// Message for canceling a patch job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelPatchJobRequest {
    /// Required. Name of the patch in the form `projects/*/patchJobs/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelPatchJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelPatchJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelPatchJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CancelPatchJobRequest"
    }
}

/// Apt patching is completed by executing `apt-get update && apt-get
/// upgrade`. Additional options can be set to control how this is executed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AptSettings {
    /// By changing the type to DIST, the patching is performed
    /// using `apt-get dist-upgrade` instead.
    #[serde(rename = "type")]
    pub r#type: crate::model::apt_settings::Type,

    /// List of packages to exclude from update. These packages will be excluded
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of packages to be updated. These are the only packages
    /// that will be updated. If these packages are not installed, they will be
    /// ignored. This field cannot be specified with any other patch configuration
    /// fields.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclusive_packages: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AptSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AptSettings::type].
    pub fn set_type<T: std::convert::Into<crate::model::apt_settings::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [excludes][crate::model::AptSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_packages][crate::model::AptSettings::exclusive_packages].
    pub fn set_exclusive_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AptSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.AptSettings"
    }
}

/// Defines additional types related to [AptSettings].
pub mod apt_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Apt patch type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// By default, upgrade will be performed.
        Unspecified,
        /// Runs `apt-get dist-upgrade`.
        Dist,
        /// Runs `apt-get upgrade`.
        Upgrade,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dist => std::option::Option::Some(1),
                Self::Upgrade => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Dist => std::option::Option::Some("DIST"),
                Self::Upgrade => std::option::Option::Some("UPGRADE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dist,
                2 => Self::Upgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "DIST" => Self::Dist,
                "UPGRADE" => Self::Upgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dist => serializer.serialize_i32(1),
                Self::Upgrade => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.osconfig.v1.AptSettings.Type",
            ))
        }
    }
}

/// Yum patching is performed by executing `yum update`. Additional options
/// can be set to control how this is executed.
///
/// Note that not all settings are supported on all platforms.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct YumSettings {
    /// Adds the `--security` flag to `yum update`. Not supported on
    /// all platforms.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub security: bool,

    /// Will cause patch to run `yum update-minimal` instead.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub minimal: bool,

    /// List of packages to exclude from update. These packages are excluded by
    /// using the yum `--exclude` flag.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of packages to be updated. These are the only packages
    /// that will be updated. If these packages are not installed, they will be
    /// ignored. This field must not be specified with any other patch
    /// configuration fields.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclusive_packages: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl YumSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [security][crate::model::YumSettings::security].
    pub fn set_security<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.security = v.into();
        self
    }

    /// Sets the value of [minimal][crate::model::YumSettings::minimal].
    pub fn set_minimal<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.minimal = v.into();
        self
    }

    /// Sets the value of [excludes][crate::model::YumSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_packages][crate::model::YumSettings::exclusive_packages].
    pub fn set_exclusive_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for YumSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.YumSettings"
    }
}

/// Googet patching is performed by running `googet update`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GooSettings {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GooSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for GooSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GooSettings"
    }
}

/// Zypper patching is performed by running `zypper patch`.
/// See also <https://en.opensuse.org/SDB:Zypper_manual>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZypperSettings {
    /// Adds the `--with-optional` flag to `zypper patch`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub with_optional: bool,

    /// Adds the `--with-update` flag, to `zypper patch`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub with_update: bool,

    /// Install only patches with these categories.
    /// Common categories include security, recommended, and feature.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub categories: std::vec::Vec<std::string::String>,

    /// Install only patches with these severities.
    /// Common severities include critical, important, moderate, and low.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub severities: std::vec::Vec<std::string::String>,

    /// List of patches to exclude from update.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of patches to be updated. These are the only patches
    /// that will be installed using 'zypper patch patch:<patch_name>' command.
    /// This field must not be used with any other patch configuration fields.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclusive_patches: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZypperSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [with_optional][crate::model::ZypperSettings::with_optional].
    pub fn set_with_optional<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.with_optional = v.into();
        self
    }

    /// Sets the value of [with_update][crate::model::ZypperSettings::with_update].
    pub fn set_with_update<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.with_update = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::ZypperSettings::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [severities][crate::model::ZypperSettings::severities].
    pub fn set_severities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.severities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [excludes][crate::model::ZypperSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_patches][crate::model::ZypperSettings::exclusive_patches].
    pub fn set_exclusive_patches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_patches = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ZypperSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ZypperSettings"
    }
}

/// Windows patching is performed using the Windows Update Agent.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WindowsUpdateSettings {
    /// Only apply updates of these windows update classifications. If empty, all
    /// updates are applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub classifications: std::vec::Vec<crate::model::windows_update_settings::Classification>,

    /// List of KBs to exclude from update.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub excludes: std::vec::Vec<std::string::String>,

    /// An exclusive list of kbs to be updated. These are the only patches
    /// that will be updated. This field must not be used with other
    /// patch configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclusive_patches: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsUpdateSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [classifications][crate::model::WindowsUpdateSettings::classifications].
    pub fn set_classifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::windows_update_settings::Classification>,
    {
        use std::iter::Iterator;
        self.classifications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [excludes][crate::model::WindowsUpdateSettings::excludes].
    pub fn set_excludes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excludes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclusive_patches][crate::model::WindowsUpdateSettings::exclusive_patches].
    pub fn set_exclusive_patches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclusive_patches = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WindowsUpdateSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.WindowsUpdateSettings"
    }
}

/// Defines additional types related to [WindowsUpdateSettings].
pub mod windows_update_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Microsoft Windows update classifications as defined in
    /// [1]
    /// <https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro>
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Classification {
        /// Invalid. If classifications are included, they must be specified.
        Unspecified,
        /// "A widely released fix for a specific problem that addresses a critical,
        /// non-security-related bug." [1]
        Critical,
        /// "A widely released fix for a product-specific, security-related
        /// vulnerability. Security vulnerabilities are rated by their severity. The
        /// severity rating is indicated in the Microsoft security bulletin as
        /// critical, important, moderate, or low." [1]
        Security,
        /// "A widely released and frequent software update that contains additions
        /// to a product's definition database. Definition databases are often used
        /// to detect objects that have specific attributes, such as malicious code,
        /// phishing websites, or junk mail." [1]
        Definition,
        /// "Software that controls the input and output of a device." [1]
        Driver,
        /// "New product functionality that is first distributed outside the context
        /// of a product release and that is typically included in the next full
        /// product release." [1]
        FeaturePack,
        /// "A tested, cumulative set of all hotfixes, security updates, critical
        /// updates, and updates. Additionally, service packs may contain additional
        /// fixes for problems that are found internally since the release of the
        /// product. Service packs my also contain a limited number of
        /// customer-requested design changes or features." [1]
        ServicePack,
        /// "A utility or feature that helps complete a task or set of tasks." [1]
        Tool,
        /// "A tested, cumulative set of hotfixes, security updates, critical
        /// updates, and updates that are packaged together for easy deployment. A
        /// rollup generally targets a specific area, such as security, or a
        /// component of a product, such as Internet Information Services (IIS)." [1]
        UpdateRollup,
        /// "A widely released fix for a specific problem. An update addresses a
        /// noncritical, non-security-related bug." [1]
        Update,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Classification::value] or
        /// [Classification::name].
        UnknownValue(classification::UnknownValue),
    }

    #[doc(hidden)]
    pub mod classification {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Classification {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Critical => std::option::Option::Some(1),
                Self::Security => std::option::Option::Some(2),
                Self::Definition => std::option::Option::Some(3),
                Self::Driver => std::option::Option::Some(4),
                Self::FeaturePack => std::option::Option::Some(5),
                Self::ServicePack => std::option::Option::Some(6),
                Self::Tool => std::option::Option::Some(7),
                Self::UpdateRollup => std::option::Option::Some(8),
                Self::Update => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLASSIFICATION_UNSPECIFIED"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::Definition => std::option::Option::Some("DEFINITION"),
                Self::Driver => std::option::Option::Some("DRIVER"),
                Self::FeaturePack => std::option::Option::Some("FEATURE_PACK"),
                Self::ServicePack => std::option::Option::Some("SERVICE_PACK"),
                Self::Tool => std::option::Option::Some("TOOL"),
                Self::UpdateRollup => std::option::Option::Some("UPDATE_ROLLUP"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Classification {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Classification {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Classification {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Critical,
                2 => Self::Security,
                3 => Self::Definition,
                4 => Self::Driver,
                5 => Self::FeaturePack,
                6 => Self::ServicePack,
                7 => Self::Tool,
                8 => Self::UpdateRollup,
                9 => Self::Update,
                _ => Self::UnknownValue(classification::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Classification {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLASSIFICATION_UNSPECIFIED" => Self::Unspecified,
                "CRITICAL" => Self::Critical,
                "SECURITY" => Self::Security,
                "DEFINITION" => Self::Definition,
                "DRIVER" => Self::Driver,
                "FEATURE_PACK" => Self::FeaturePack,
                "SERVICE_PACK" => Self::ServicePack,
                "TOOL" => Self::Tool,
                "UPDATE_ROLLUP" => Self::UpdateRollup,
                "UPDATE" => Self::Update,
                _ => Self::UnknownValue(classification::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Classification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Critical => serializer.serialize_i32(1),
                Self::Security => serializer.serialize_i32(2),
                Self::Definition => serializer.serialize_i32(3),
                Self::Driver => serializer.serialize_i32(4),
                Self::FeaturePack => serializer.serialize_i32(5),
                Self::ServicePack => serializer.serialize_i32(6),
                Self::Tool => serializer.serialize_i32(7),
                Self::UpdateRollup => serializer.serialize_i32(8),
                Self::Update => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Classification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Classification>::new(
                ".google.cloud.osconfig.v1.WindowsUpdateSettings.Classification",
            ))
        }
    }
}

/// A step that runs an executable for a PatchJob.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecStep {
    /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub linux_exec_step_config: std::option::Option<crate::model::ExecStepConfig>,

    /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub windows_exec_step_config: std::option::Option<crate::model::ExecStepConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [linux_exec_step_config][crate::model::ExecStep::linux_exec_step_config].
    pub fn set_linux_exec_step_config<
        T: std::convert::Into<std::option::Option<crate::model::ExecStepConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.linux_exec_step_config = v.into();
        self
    }

    /// Sets the value of [windows_exec_step_config][crate::model::ExecStep::windows_exec_step_config].
    pub fn set_windows_exec_step_config<
        T: std::convert::Into<std::option::Option<crate::model::ExecStepConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.windows_exec_step_config = v.into();
        self
    }
}

impl wkt::message::Message for ExecStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ExecStep"
    }
}

/// Common configurations for an ExecStep.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecStepConfig {
    /// Defaults to [0]. A list of possible return values that the
    /// execution can return to indicate a success.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_success_codes: std::vec::Vec<i32>,

    /// The script interpreter to use to run the script. If no interpreter is
    /// specified the script will be executed directly, which will likely
    /// only succeed for scripts with [shebang lines]
    /// (<https://en.wikipedia.org/wiki/Shebang_>\(Unix\)).
    pub interpreter: crate::model::exec_step_config::Interpreter,

    /// Location of the executable.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub executable: std::option::Option<crate::model::exec_step_config::Executable>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecStepConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_success_codes][crate::model::ExecStepConfig::allowed_success_codes].
    pub fn set_allowed_success_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.allowed_success_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [interpreter][crate::model::ExecStepConfig::interpreter].
    pub fn set_interpreter<T: std::convert::Into<crate::model::exec_step_config::Interpreter>>(
        mut self,
        v: T,
    ) -> Self {
        self.interpreter = v.into();
        self
    }

    /// Sets the value of [executable][crate::model::ExecStepConfig::executable].
    ///
    /// Note that all the setters affecting `executable` are mutually
    /// exclusive.
    pub fn set_executable<
        T: std::convert::Into<std::option::Option<crate::model::exec_step_config::Executable>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.executable = v.into();
        self
    }

    /// The value of [executable][crate::model::ExecStepConfig::executable]
    /// if it holds a `LocalPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn local_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.executable.as_ref().and_then(|v| match v {
            crate::model::exec_step_config::Executable::LocalPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [executable][crate::model::ExecStepConfig::executable]
    /// to hold a `LocalPath`.
    ///
    /// Note that all the setters affecting `executable` are
    /// mutually exclusive.
    pub fn set_local_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.executable = std::option::Option::Some(
            crate::model::exec_step_config::Executable::LocalPath(v.into()),
        );
        self
    }

    /// The value of [executable][crate::model::ExecStepConfig::executable]
    /// if it holds a `GcsObject`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_object(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsObject>> {
        #[allow(unreachable_patterns)]
        self.executable.as_ref().and_then(|v| match v {
            crate::model::exec_step_config::Executable::GcsObject(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [executable][crate::model::ExecStepConfig::executable]
    /// to hold a `GcsObject`.
    ///
    /// Note that all the setters affecting `executable` are
    /// mutually exclusive.
    pub fn set_gcs_object<T: std::convert::Into<std::boxed::Box<crate::model::GcsObject>>>(
        mut self,
        v: T,
    ) -> Self {
        self.executable = std::option::Option::Some(
            crate::model::exec_step_config::Executable::GcsObject(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecStepConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ExecStepConfig"
    }
}

/// Defines additional types related to [ExecStepConfig].
pub mod exec_step_config {
    #[allow(unused_imports)]
    use super::*;

    /// The interpreter used to execute the a file.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Interpreter {
        /// Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
        /// interpreter will be parsed from the shebang line of the script if
        /// unspecified.
        Unspecified,
        /// Indicates that the script is run with `/bin/sh` on Linux and `cmd`
        /// on Windows.
        Shell,
        /// Indicates that the file is run with PowerShell flags
        /// `-NonInteractive`, `-NoProfile`, and `-ExecutionPolicy Bypass`.
        Powershell,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Interpreter::value] or
        /// [Interpreter::name].
        UnknownValue(interpreter::UnknownValue),
    }

    #[doc(hidden)]
    pub mod interpreter {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Interpreter {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Shell => std::option::Option::Some(1),
                Self::Powershell => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INTERPRETER_UNSPECIFIED"),
                Self::Shell => std::option::Option::Some("SHELL"),
                Self::Powershell => std::option::Option::Some("POWERSHELL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Interpreter {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Interpreter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Interpreter {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Shell,
                2 => Self::Powershell,
                _ => Self::UnknownValue(interpreter::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Interpreter {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERPRETER_UNSPECIFIED" => Self::Unspecified,
                "SHELL" => Self::Shell,
                "POWERSHELL" => Self::Powershell,
                _ => Self::UnknownValue(interpreter::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Interpreter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Shell => serializer.serialize_i32(1),
                Self::Powershell => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Interpreter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Interpreter>::new(
                ".google.cloud.osconfig.v1.ExecStepConfig.Interpreter",
            ))
        }
    }

    /// Location of the executable.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Executable {
        /// An absolute path to the executable on the VM.
        LocalPath(std::string::String),
        /// A Cloud Storage object containing the executable.
        GcsObject(std::boxed::Box<crate::model::GcsObject>),
    }
}

/// Cloud Storage object representation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsObject {
    /// Required. Bucket of the Cloud Storage object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. Name of the Cloud Storage object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Required. Generation number of the Cloud Storage object. This is used to
    /// ensure that the ExecStep specified by this PatchJob does not change.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation_number: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsObject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GcsObject::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::GcsObject::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation_number][crate::model::GcsObject::generation_number].
    pub fn set_generation_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation_number = v.into();
        self
    }
}

impl wkt::message::Message for GcsObject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GcsObject"
    }
}

/// A filter to target VM instances for patching. The targeted
/// VMs must meet all criteria specified. So if both labels and zones are
/// specified, the patch job targets only VMs with those labels and in those
/// zones.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchInstanceFilter {
    /// Target all VM instances in the project. If true, no other criteria is
    /// permitted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub all: bool,

    /// Targets VM instances matching ANY of these GroupLabels. This allows
    /// targeting of disparate groups of VM instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group_labels: std::vec::Vec<crate::model::patch_instance_filter::GroupLabel>,

    /// Targets VM instances in ANY of these zones. Leave empty to target VM
    /// instances in any zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub zones: std::vec::Vec<std::string::String>,

    /// Targets any of the VM instances specified. Instances are specified by their
    /// URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`,
    /// `projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`, or
    /// `<https://www.googleapis.com/compute/v1/projects/>[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<std::string::String>,

    /// Targets VMs whose name starts with one of these prefixes. Similar to
    /// labels, this is another way to group VMs when targeting configs, for
    /// example prefix="prod-".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_name_prefixes: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchInstanceFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all][crate::model::PatchInstanceFilter::all].
    pub fn set_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all = v.into();
        self
    }

    /// Sets the value of [group_labels][crate::model::PatchInstanceFilter::group_labels].
    pub fn set_group_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::patch_instance_filter::GroupLabel>,
    {
        use std::iter::Iterator;
        self.group_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [zones][crate::model::PatchInstanceFilter::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instances][crate::model::PatchInstanceFilter::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_name_prefixes][crate::model::PatchInstanceFilter::instance_name_prefixes].
    pub fn set_instance_name_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_name_prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PatchInstanceFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchInstanceFilter"
    }
}

/// Defines additional types related to [PatchInstanceFilter].
pub mod patch_instance_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Targets a group of VM instances by using their [assigned
    /// labels](https://cloud.google.com/compute/docs/labeling-resources). Labels
    /// are key-value pairs. A `GroupLabel` is a combination of labels
    /// that is used to target VMs for a patch job.
    ///
    /// For example, a patch job can target VMs that have the following
    /// `GroupLabel`: `{"env":"test", "app":"web"}`. This means that the patch job
    /// is applied to VMs that have both the labels `env=test` and `app=web`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroupLabel {
        /// Compute Engine instance labels that must be present for a VM
        /// instance to be targeted by this filter.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupLabel {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::patch_instance_filter::GroupLabel::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for GroupLabel {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.PatchInstanceFilter.GroupLabel"
        }
    }
}

/// Patch rollout configuration specifications. Contains details on the
/// concurrency control when applying patch(es) to all targeted VMs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PatchRollout {
    /// Mode of the patch rollout.
    pub mode: crate::model::patch_rollout::Mode,

    /// The maximum number (or percentage) of VMs per zone to disrupt at any given
    /// moment. The number of VMs calculated from multiplying the percentage by the
    /// total number of VMs in a zone is rounded up.
    ///
    /// During patching, a VM is considered disrupted from the time the agent is
    /// notified to begin until patching has completed. This disruption time
    /// includes the time to complete reboot and any post-patch steps.
    ///
    /// A VM contributes to the disruption budget if its patching operation fails
    /// either when applying the patches, running pre or post patch steps, or if it
    /// fails to respond with a success notification before timing out. VMs that
    /// are not running or do not have an active agent do not count toward this
    /// disruption budget.
    ///
    /// For zone-by-zone rollouts, if the disruption budget in a zone is exceeded,
    /// the patch job stops, because continuing to the next zone requires
    /// completion of the patch process in the previous zone.
    ///
    /// For example, if the disruption budget has a fixed value of `10`, and 8 VMs
    /// fail to patch in the current zone, the patch job continues to patch 2 VMs
    /// at a time until the zone is completed. When that zone is completed
    /// successfully, patching begins with 10 VMs at a time in the next zone. If 10
    /// VMs in the next zone fail to patch, the patch job stops.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disruption_budget: std::option::Option<crate::model::FixedOrPercent>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchRollout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::PatchRollout::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::patch_rollout::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [disruption_budget][crate::model::PatchRollout::disruption_budget].
    pub fn set_disruption_budget<
        T: std::convert::Into<std::option::Option<crate::model::FixedOrPercent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.disruption_budget = v.into();
        self
    }
}

impl wkt::message::Message for PatchRollout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.PatchRollout"
    }
}

/// Defines additional types related to [PatchRollout].
pub mod patch_rollout {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the rollout.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode must be specified.
        Unspecified,
        /// Patches are applied one zone at a time. The patch job begins in the
        /// region with the lowest number of targeted VMs. Within the region,
        /// patching begins in the zone with the lowest number of targeted VMs. If
        /// multiple regions (or zones within a region) have the same number of
        /// targeted VMs, a tie-breaker is achieved by sorting the regions or zones
        /// in alphabetical order.
        ZoneByZone,
        /// Patches are applied to VMs in all zones at the same time.
        ConcurrentZones,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ZoneByZone => std::option::Option::Some(1),
                Self::ConcurrentZones => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::ZoneByZone => std::option::Option::Some("ZONE_BY_ZONE"),
                Self::ConcurrentZones => std::option::Option::Some("CONCURRENT_ZONES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ZoneByZone,
                2 => Self::ConcurrentZones,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "ZONE_BY_ZONE" => Self::ZoneByZone,
                "CONCURRENT_ZONES" => Self::ConcurrentZones,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ZoneByZone => serializer.serialize_i32(1),
                Self::ConcurrentZones => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.osconfig.v1.PatchRollout.Mode",
            ))
        }
    }
}

/// This API resource represents the vulnerability report for a specified
/// Compute Engine virtual machine (VM) instance at a given point in time.
///
/// For more information, see [Vulnerability
/// reports](https://cloud.google.com/compute/docs/instances/os-inventory-management#vulnerability-reports).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VulnerabilityReport {
    /// Output only. The `vulnerabilityReport` API resource name.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location}/instances/{instance_id}/vulnerabilityReport`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. List of vulnerabilities affecting the VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vulnerabilities: std::vec::Vec<crate::model::vulnerability_report::Vulnerability>,

    /// Output only. The timestamp for when the last vulnerability report was generated for the
    /// VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VulnerabilityReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VulnerabilityReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [vulnerabilities][crate::model::VulnerabilityReport::vulnerabilities].
    pub fn set_vulnerabilities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vulnerability_report::Vulnerability>,
    {
        use std::iter::Iterator;
        self.vulnerabilities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::VulnerabilityReport::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for VulnerabilityReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport"
    }
}

/// Defines additional types related to [VulnerabilityReport].
pub mod vulnerability_report {
    #[allow(unused_imports)]
    use super::*;

    /// A vulnerability affecting the VM instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Vulnerability {
        /// Contains metadata as per the upstream feed of the operating system and
        /// NVD.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub details:
            std::option::Option<crate::model::vulnerability_report::vulnerability::Details>,

        /// Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
        /// This field displays the inventory items affected by this vulnerability.
        /// If the vulnerability report was not updated after the VM inventory
        /// update, these values might not display in VM inventory. For some distros,
        /// this field may be empty.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[deprecated]
        pub installed_inventory_item_ids: std::vec::Vec<std::string::String>,

        /// Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
        /// If the vulnerability report was not updated after the VM inventory
        /// update, these values might not display in VM inventory. If there is no
        /// available fix, the field is empty. The `inventory_item` value specifies
        /// the latest `SoftwarePackage` available to the VM that fixes the
        /// vulnerability.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[deprecated]
        pub available_inventory_item_ids: std::vec::Vec<std::string::String>,

        /// The timestamp for when the vulnerability was first detected.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// The timestamp for when the vulnerability was last modified.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// List of items affected by the vulnerability.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub items: std::vec::Vec<crate::model::vulnerability_report::vulnerability::Item>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Vulnerability {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [details][crate::model::vulnerability_report::Vulnerability::details].
        pub fn set_details<
            T: std::convert::Into<
                    std::option::Option<crate::model::vulnerability_report::vulnerability::Details>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.details = v.into();
            self
        }

        /// Sets the value of [installed_inventory_item_ids][crate::model::vulnerability_report::Vulnerability::installed_inventory_item_ids].
        #[deprecated]
        pub fn set_installed_inventory_item_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.installed_inventory_item_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [available_inventory_item_ids][crate::model::vulnerability_report::Vulnerability::available_inventory_item_ids].
        #[deprecated]
        pub fn set_available_inventory_item_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.available_inventory_item_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [create_time][crate::model::vulnerability_report::Vulnerability::create_time].
        pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.create_time = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::vulnerability_report::Vulnerability::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [items][crate::model::vulnerability_report::Vulnerability::items].
        pub fn set_items<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vulnerability_report::vulnerability::Item>,
        {
            use std::iter::Iterator;
            self.items = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Vulnerability {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability"
        }
    }

    /// Defines additional types related to [Vulnerability].
    pub mod vulnerability {
        #[allow(unused_imports)]
        use super::*;

        /// Contains metadata information for the vulnerability. This information is
        /// collected from the upstream feed of the operating system.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Details {
            /// The CVE of the vulnerability. CVE cannot be
            /// empty and the combination of <cve, classification> should be unique
            /// across vulnerabilities for a VM.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub cve: std::string::String,

            /// The CVSS V2 score of this vulnerability. CVSS V2 score is on a scale of
            /// 0 - 10 where 0 indicates low severity and 10 indicates high severity.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F32")]
            pub cvss_v2_score: f32,

            /// The full description of the CVSSv3 for this vulnerability from NVD.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub cvss_v3: std::option::Option<crate::model::CVSSv3>,

            /// Assigned severity/impact ranking from the distro.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub severity: std::string::String,

            /// The note or description describing the vulnerability from the distro.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub description: std::string::String,

            /// Corresponds to the references attached to the `VulnerabilityDetails`.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub references: std::vec::Vec<
                crate::model::vulnerability_report::vulnerability::details::Reference,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Details {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cve][crate::model::vulnerability_report::vulnerability::Details::cve].
            pub fn set_cve<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.cve = v.into();
                self
            }

            /// Sets the value of [cvss_v2_score][crate::model::vulnerability_report::vulnerability::Details::cvss_v2_score].
            pub fn set_cvss_v2_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.cvss_v2_score = v.into();
                self
            }

            /// Sets the value of [cvss_v3][crate::model::vulnerability_report::vulnerability::Details::cvss_v3].
            pub fn set_cvss_v3<T: std::convert::Into<std::option::Option<crate::model::CVSSv3>>>(
                mut self,
                v: T,
            ) -> Self {
                self.cvss_v3 = v.into();
                self
            }

            /// Sets the value of [severity][crate::model::vulnerability_report::vulnerability::Details::severity].
            pub fn set_severity<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.severity = v.into();
                self
            }

            /// Sets the value of [description][crate::model::vulnerability_report::vulnerability::Details::description].
            pub fn set_description<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.description = v.into();
                self
            }

            /// Sets the value of [references][crate::model::vulnerability_report::vulnerability::Details::references].
            pub fn set_references<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::vulnerability_report::vulnerability::details::Reference,
                    >,
            {
                use std::iter::Iterator;
                self.references = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Details {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability.Details"
            }
        }

        /// Defines additional types related to [Details].
        pub mod details {
            #[allow(unused_imports)]
            use super::*;

            /// A reference for this vulnerability.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Reference {
                /// The url of the reference.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub url: std::string::String,

                /// The source of the reference e.g. NVD.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub source: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Reference {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [url][crate::model::vulnerability_report::vulnerability::details::Reference::url].
                pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.url = v.into();
                    self
                }

                /// Sets the value of [source][crate::model::vulnerability_report::vulnerability::details::Reference::source].
                pub fn set_source<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.source = v.into();
                    self
                }
            }

            impl wkt::message::Message for Reference {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability.Details.Reference"
                }
            }
        }

        /// OS inventory item that is affected by a vulnerability or fixed as a
        /// result of a vulnerability.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Item {
            /// Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
            /// This field displays the inventory items affected by this vulnerability.
            /// If the vulnerability report was not updated after the VM inventory
            /// update, these values might not display in VM inventory. For some
            /// operating systems, this field might be empty.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub installed_inventory_item_id: std::string::String,

            /// Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
            /// If the vulnerability report was not updated after the VM inventory
            /// update, these values might not display in VM inventory. If there is no
            /// available fix, the field is empty. The `inventory_item` value specifies
            /// the latest `SoftwarePackage` available to the VM that fixes the
            /// vulnerability.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub available_inventory_item_id: std::string::String,

            /// The recommended [CPE URI](https://cpe.mitre.org/specification/) update
            /// that contains a fix for this vulnerability.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub fixed_cpe_uri: std::string::String,

            /// The upstream OS patch, packages or KB that fixes the vulnerability.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub upstream_fix: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Item {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [installed_inventory_item_id][crate::model::vulnerability_report::vulnerability::Item::installed_inventory_item_id].
            pub fn set_installed_inventory_item_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.installed_inventory_item_id = v.into();
                self
            }

            /// Sets the value of [available_inventory_item_id][crate::model::vulnerability_report::vulnerability::Item::available_inventory_item_id].
            pub fn set_available_inventory_item_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.available_inventory_item_id = v.into();
                self
            }

            /// Sets the value of [fixed_cpe_uri][crate::model::vulnerability_report::vulnerability::Item::fixed_cpe_uri].
            pub fn set_fixed_cpe_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.fixed_cpe_uri = v.into();
                self
            }

            /// Sets the value of [upstream_fix][crate::model::vulnerability_report::vulnerability::Item::upstream_fix].
            pub fn set_upstream_fix<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.upstream_fix = v.into();
                self
            }
        }

        impl wkt::message::Message for Item {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.osconfig.v1.VulnerabilityReport.Vulnerability.Item"
            }
        }
    }
}

/// A request message for getting the vulnerability report for the specified VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVulnerabilityReportRequest {
    /// Required. API resource name for vulnerability resource.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/instances/{instance}/vulnerabilityReport`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    /// For `{instance}`, either Compute Engine `instance-id` or `instance-name`
    /// can be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVulnerabilityReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVulnerabilityReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVulnerabilityReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.GetVulnerabilityReportRequest"
    }
}

/// A request message for listing vulnerability reports for all VM instances in
/// the specified location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVulnerabilityReportsRequest {
    /// Required. The parent resource name.
    ///
    /// Format: `projects/{project}/locations/{location}/instances/-`
    ///
    /// For `{project}`, either `project-number` or `project-id` can be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A pagination token returned from a previous call to
    /// `ListVulnerabilityReports` that indicates where this listing
    /// should continue from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If provided, this field specifies the criteria that must be met by a
    /// `vulnerabilityReport` API resource to be included in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVulnerabilityReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVulnerabilityReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVulnerabilityReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVulnerabilityReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVulnerabilityReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListVulnerabilityReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListVulnerabilityReportsRequest"
    }
}

/// A response message for listing vulnerability reports for all VM instances in
/// the specified location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVulnerabilityReportsResponse {
    /// List of vulnerabilityReport objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vulnerability_reports: std::vec::Vec<crate::model::VulnerabilityReport>,

    /// The pagination token to retrieve the next page of vulnerabilityReports
    /// object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVulnerabilityReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vulnerability_reports][crate::model::ListVulnerabilityReportsResponse::vulnerability_reports].
    pub fn set_vulnerability_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VulnerabilityReport>,
    {
        use std::iter::Iterator;
        self.vulnerability_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVulnerabilityReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVulnerabilityReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.ListVulnerabilityReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVulnerabilityReportsResponse {
    type PageItem = crate::model::VulnerabilityReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vulnerability_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Common Vulnerability Scoring System version 3.
/// For details, see <https://www.first.org/cvss/specification-document>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CVSSv3 {
    /// The base score is a function of the base metric scores.
    /// <https://www.first.org/cvss/specification-document#Base-Metrics>
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub base_score: f32,

    /// The Exploitability sub-score equation is derived from the Base
    /// Exploitability metrics.
    /// <https://www.first.org/cvss/specification-document#2-1-Exploitability-Metrics>
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub exploitability_score: f32,

    /// The Impact sub-score equation is derived from the Base Impact metrics.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub impact_score: f32,

    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    pub attack_vector: crate::model::cvs_sv_3::AttackVector,

    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    pub attack_complexity: crate::model::cvs_sv_3::AttackComplexity,

    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    pub privileges_required: crate::model::cvs_sv_3::PrivilegesRequired,

    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    pub user_interaction: crate::model::cvs_sv_3::UserInteraction,

    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    pub scope: crate::model::cvs_sv_3::Scope,

    /// This metric measures the impact to the confidentiality of the information
    /// resources managed by a software component due to a successfully exploited
    /// vulnerability.
    pub confidentiality_impact: crate::model::cvs_sv_3::Impact,

    /// This metric measures the impact to integrity of a successfully exploited
    /// vulnerability.
    pub integrity_impact: crate::model::cvs_sv_3::Impact,

    /// This metric measures the impact to the availability of the impacted
    /// component resulting from a successfully exploited vulnerability.
    pub availability_impact: crate::model::cvs_sv_3::Impact,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CVSSv3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::CVSSv3::base_score].
    pub fn set_base_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [exploitability_score][crate::model::CVSSv3::exploitability_score].
    pub fn set_exploitability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.exploitability_score = v.into();
        self
    }

    /// Sets the value of [impact_score][crate::model::CVSSv3::impact_score].
    pub fn set_impact_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.impact_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::CVSSv3::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvs_sv_3::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::CVSSv3::attack_complexity].
    pub fn set_attack_complexity<
        T: std::convert::Into<crate::model::cvs_sv_3::AttackComplexity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::CVSSv3::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvs_sv_3::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::CVSSv3::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvs_sv_3::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::CVSSv3::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvs_sv_3::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::CVSSv3::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::CVSSv3::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::CVSSv3::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvs_sv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for CVSSv3 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.osconfig.v1.CVSSv3"
    }
}

/// Defines additional types related to [CVSSv3].
pub mod cvs_sv_3 {
    #[allow(unused_imports)]
    use super::*;

    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        /// Invalid value.
        Unspecified,
        /// The vulnerable component is bound to the network stack and the set of
        /// possible attackers extends beyond the other options listed below, up to
        /// and including the entire Internet.
        Network,
        /// The vulnerable component is bound to the network stack, but the attack is
        /// limited at the protocol level to a logically adjacent topology.
        Adjacent,
        /// The vulnerable component is not bound to the network stack and the
        /// attacker's path is via read/write/execute capabilities.
        Local,
        /// The attack requires the attacker to physically touch or manipulate the
        /// vulnerable component.
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".google.cloud.osconfig.v1.CVSSv3.AttackVector",
            ))
        }
    }

    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        /// Invalid value.
        Unspecified,
        /// Specialized access conditions or extenuating circumstances do not exist.
        /// An attacker can expect repeatable success when attacking the vulnerable
        /// component.
        Low,
        /// A successful attack depends on conditions beyond the attacker's control.
        /// That is, a successful attack cannot be accomplished at will, but requires
        /// the attacker to invest in some measurable amount of effort in preparation
        /// or execution against the vulnerable component before a successful attack
        /// can be expected.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".google.cloud.osconfig.v1.CVSSv3.AttackComplexity",
            ))
        }
    }

    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        /// Invalid value.
        Unspecified,
        /// The attacker is unauthorized prior to attack, and therefore does not
        /// require any access to settings or files of the vulnerable system to
        /// carry out an attack.
        None,
        /// The attacker requires privileges that provide basic user capabilities
        /// that could normally affect only settings and files owned by a user.
        /// Alternatively, an attacker with Low privileges has the ability to access
        /// only non-sensitive resources.
        Low,
        /// The attacker requires privileges that provide significant (e.g.,
        /// administrative) control over the vulnerable component allowing access to
        /// component-wide settings and files.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".google.cloud.osconfig.v1.CVSSv3.PrivilegesRequired",
            ))
        }
    }

    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        /// Invalid value.
        Unspecified,
        /// The vulnerable system can be exploited without interaction from any user.
        None,
        /// Successful exploitation of this vulnerability requires a user to take
        /// some action before the vulnerability can be exploited.
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".google.cloud.osconfig.v1.CVSSv3.UserInteraction",
            ))
        }
    }

    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Invalid value.
        Unspecified,
        /// An exploited vulnerability can only affect resources managed by the same
        /// security authority.
        Unchanged,
        /// An exploited vulnerability can affect resources beyond the security scope
        /// managed by the security authority of the vulnerable component.
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.osconfig.v1.CVSSv3.Scope",
            ))
        }
    }

    /// The Impact metrics capture the effects of a successfully exploited
    /// vulnerability on the component that suffers the worst outcome that is most
    /// directly and predictably associated with the attack.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        /// Invalid value.
        Unspecified,
        /// High impact.
        High,
        /// Low impact.
        Low,
        /// No impact.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".google.cloud.osconfig.v1.CVSSv3.Impact",
            ))
        }
    }
}

/// The view for inventory objects.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InventoryView {
    /// The default value.
    /// The API defaults to the BASIC view.
    Unspecified,
    /// Returns the basic inventory information that includes `os_info`.
    Basic,
    /// Returns all fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InventoryView::value] or
    /// [InventoryView::name].
    UnknownValue(inventory_view::UnknownValue),
}

#[doc(hidden)]
pub mod inventory_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InventoryView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INVENTORY_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InventoryView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InventoryView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InventoryView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(inventory_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InventoryView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INVENTORY_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(inventory_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InventoryView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InventoryView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InventoryView>::new(
            ".google.cloud.osconfig.v1.InventoryView",
        ))
    }
}
