// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [OsConfigService](crate::stubs::OsConfigService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct OsConfigService<T>
where
    T: crate::stubs::OsConfigService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> OsConfigService<T>
where
    T: crate::stubs::OsConfigService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::OsConfigService for OsConfigService<T>
where
    T: crate::stubs::OsConfigService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn execute_patch_job(
        &self,
        req: crate::model::ExecutePatchJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchJob> {
        self.inner.execute_patch_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_patch_job(
        &self,
        req: crate::model::GetPatchJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchJob> {
        self.inner.get_patch_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_patch_job(
        &self,
        req: crate::model::CancelPatchJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchJob> {
        self.inner.cancel_patch_job(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_patch_jobs(
        &self,
        req: crate::model::ListPatchJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListPatchJobsResponse> {
        self.inner.list_patch_jobs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_patch_job_instance_details(
        &self,
        req: crate::model::ListPatchJobInstanceDetailsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListPatchJobInstanceDetailsResponse> {
        self.inner
            .list_patch_job_instance_details(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn create_patch_deployment(
        &self,
        req: crate::model::CreatePatchDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchDeployment> {
        self.inner.create_patch_deployment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_patch_deployment(
        &self,
        req: crate::model::GetPatchDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchDeployment> {
        self.inner.get_patch_deployment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_patch_deployments(
        &self,
        req: crate::model::ListPatchDeploymentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListPatchDeploymentsResponse> {
        self.inner.list_patch_deployments(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_patch_deployment(
        &self,
        req: crate::model::DeletePatchDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_patch_deployment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_patch_deployment(
        &self,
        req: crate::model::UpdatePatchDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchDeployment> {
        self.inner.update_patch_deployment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn pause_patch_deployment(
        &self,
        req: crate::model::PausePatchDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchDeployment> {
        self.inner.pause_patch_deployment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume_patch_deployment(
        &self,
        req: crate::model::ResumePatchDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::PatchDeployment> {
        self.inner.resume_patch_deployment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [OsConfigZonalService](crate::stubs::OsConfigZonalService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct OsConfigZonalService<T>
where
    T: crate::stubs::OsConfigZonalService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> OsConfigZonalService<T>
where
    T: crate::stubs::OsConfigZonalService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::OsConfigZonalService for OsConfigZonalService<T>
where
    T: crate::stubs::OsConfigZonalService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_os_policy_assignment(
        &self,
        req: crate::model::CreateOSPolicyAssignmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_os_policy_assignment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_os_policy_assignment(
        &self,
        req: crate::model::UpdateOSPolicyAssignmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.update_os_policy_assignment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_os_policy_assignment(
        &self,
        req: crate::model::GetOSPolicyAssignmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::OSPolicyAssignment> {
        self.inner.get_os_policy_assignment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_os_policy_assignments(
        &self,
        req: crate::model::ListOSPolicyAssignmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListOSPolicyAssignmentsResponse> {
        self.inner.list_os_policy_assignments(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_os_policy_assignment_revisions(
        &self,
        req: crate::model::ListOSPolicyAssignmentRevisionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListOSPolicyAssignmentRevisionsResponse> {
        self.inner
            .list_os_policy_assignment_revisions(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn delete_os_policy_assignment(
        &self,
        req: crate::model::DeleteOSPolicyAssignmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_os_policy_assignment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_os_policy_assignment_report(
        &self,
        req: crate::model::GetOSPolicyAssignmentReportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::OSPolicyAssignmentReport> {
        self.inner
            .get_os_policy_assignment_report(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_os_policy_assignment_reports(
        &self,
        req: crate::model::ListOSPolicyAssignmentReportsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListOSPolicyAssignmentReportsResponse> {
        self.inner
            .list_os_policy_assignment_reports(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_inventory(
        &self,
        req: crate::model::GetInventoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Inventory> {
        self.inner.get_inventory(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_inventories(
        &self,
        req: crate::model::ListInventoriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListInventoriesResponse> {
        self.inner.list_inventories(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_vulnerability_report(
        &self,
        req: crate::model::GetVulnerabilityReportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::VulnerabilityReport> {
        self.inner.get_vulnerability_report(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_vulnerability_reports(
        &self,
        req: crate::model::ListVulnerabilityReportsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListVulnerabilityReportsResponse> {
        self.inner.list_vulnerability_reports(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
