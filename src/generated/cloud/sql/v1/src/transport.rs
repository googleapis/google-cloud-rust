// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [SqlBackupRunsService](super::stub::SqlBackupRunsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlBackupRunsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlBackupRunsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlBackupRunsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlBackupRunsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlBackupRunsService for SqlBackupRunsService {
    async fn delete(
        &self,
        req: crate::model::SqlBackupRunsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/backupRuns/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.id), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.id),
                    &[Segment::SingleWildcard],
                    "id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get(
        &self,
        req: crate::model::SqlBackupRunsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRun>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/backupRuns/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.id), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.id),
                    &[Segment::SingleWildcard],
                    "id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert(
        &self,
        req: crate::model::SqlBackupRunsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/backupRuns",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list(
        &self,
        req: crate::model::SqlBackupRunsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRunsListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/backupRuns",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("maxResults", &req.max_results)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlConnectService](super::stub::SqlConnectService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlConnectService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlConnectService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlConnectService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlConnectService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlConnectService for SqlConnectService {
    async fn get_connect_settings(
        &self,
        req: crate::model::GetConnectSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConnectSettings>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/connectSettings",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = (|| {
                let builder = req.read_time.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "readTime") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn generate_ephemeral_cert(
        &self,
        req: crate::model::GenerateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateEphemeralCertResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}:generateEphemeralCert",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlDatabasesService](super::stub::SqlDatabasesService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlDatabasesService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlDatabasesService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlDatabasesService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlDatabasesService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlDatabasesService for SqlDatabasesService {
    async fn delete(
        &self,
        req: crate::model::SqlDatabasesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/databases/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.database).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.database).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "database",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get(
        &self,
        req: crate::model::SqlDatabasesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Database>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/databases/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.database).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.database).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "database",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert(
        &self,
        req: crate::model::SqlDatabasesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/databases",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list(
        &self,
        req: crate::model::SqlDatabasesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabasesListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/databases",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn patch(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/databases/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.database).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.database).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "database",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/databases/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.database).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.database).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "database",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlFlagsService](super::stub::SqlFlagsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlFlagsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlFlagsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlFlagsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlFlagsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlFlagsService for SqlFlagsService {
    async fn list(
        &self,
        req: crate::model::SqlFlagsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlagsListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
        .or_else(|| {
            let path = "/v1/flags".to_string();

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("databaseVersion", &req.database_version)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlInstancesService](super::stub::SqlInstancesService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlInstancesService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlInstancesService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlInstancesService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlInstancesService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlInstancesService for SqlInstancesService {
    async fn add_server_ca(
        &self,
        req: crate::model::SqlInstancesAddServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/addServerCa",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn clone(
        &self,
        req: crate::model::SqlInstancesCloneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/clone",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn delete(
        &self,
        req: crate::model::SqlInstancesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn demote_master(
        &self,
        req: crate::model::SqlInstancesDemoteMasterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/demoteMaster",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn demote(
        &self,
        req: crate::model::SqlInstancesDemoteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/demote",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn export(
        &self,
        req: crate::model::SqlInstancesExportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/export",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn failover(
        &self,
        req: crate::model::SqlInstancesFailoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/failover",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn reencrypt(
        &self,
        req: crate::model::SqlInstancesReencryptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/reencrypt",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get(
        &self,
        req: crate::model::SqlInstancesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabaseInstance>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn import(
        &self,
        req: crate::model::SqlInstancesImportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/import",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert(
        &self,
        req: crate::model::SqlInstancesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list(
        &self,
        req: crate::model::SqlInstancesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("filter", &req.filter)]);
            let builder = builder.query(&[("maxResults", &req.max_results)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list_server_cas(
        &self,
        req: crate::model::SqlInstancesListServerCasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListServerCasResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/listServerCas",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn patch(
        &self,
        req: crate::model::SqlInstancesPatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn promote_replica(
        &self,
        req: crate::model::SqlInstancesPromoteReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/promoteReplica",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = builder.query(&[("failover", &req.failover)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn switchover(
        &self,
        req: crate::model::SqlInstancesSwitchoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/switchover",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = (|| {
                let builder = req.db_timeout.as_ref().map(|p| serde_json::to_value(p).map_err(Error::ser) ).transpose()?.into_iter().fold(builder, |builder, v| { use gaxi::query_parameter::QueryParameter; v.add(builder, "dbTimeout") });
                Ok(builder)
            })();
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn reset_ssl_config(
        &self,
        req: crate::model::SqlInstancesResetSslConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/resetSslConfig",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn restart(
        &self,
        req: crate::model::SqlInstancesRestartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/restart",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn restore_backup(
        &self,
        req: crate::model::SqlInstancesRestoreBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/restoreBackup",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn rotate_server_ca(
        &self,
        req: crate::model::SqlInstancesRotateServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/rotateServerCa",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn start_replica(
        &self,
        req: crate::model::SqlInstancesStartReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/startReplica",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn stop_replica(
        &self,
        req: crate::model::SqlInstancesStopReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/stopReplica",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn truncate_log(
        &self,
        req: crate::model::SqlInstancesTruncateLogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/truncateLog",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update(
        &self,
        req: crate::model::SqlInstancesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn create_ephemeral(
        &self,
        req: crate::model::SqlInstancesCreateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/createEphemeral",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn reschedule_maintenance(
        &self,
        req: crate::model::SqlInstancesRescheduleMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/rescheduleMaintenance",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn verify_external_sync_settings(
        &self,
        req: crate::model::SqlInstancesVerifyExternalSyncSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesVerifyExternalSyncSettingsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/verifyExternalSyncSettings",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn start_external_sync(
        &self,
        req: crate::model::SqlInstancesStartExternalSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/startExternalSync",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn perform_disk_shrink(
        &self,
        req: crate::model::SqlInstancesPerformDiskShrinkRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/performDiskShrink",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_disk_shrink_config(
        &self,
        req: crate::model::SqlInstancesGetDiskShrinkConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetDiskShrinkConfigResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/getDiskShrinkConfig",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn reset_replica_size(
        &self,
        req: crate::model::SqlInstancesResetReplicaSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/resetReplicaSize",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get_latest_recovery_time(
        &self,
        req: crate::model::SqlInstancesGetLatestRecoveryTimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetLatestRecoveryTimeResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/getLatestRecoveryTime",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn acquire_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesAcquireSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesAcquireSsrsLeaseResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/acquireSsrsLease",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn release_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesReleaseSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesReleaseSsrsLeaseResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/releaseSsrsLease",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlOperationsService](super::stub::SqlOperationsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlOperationsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlOperationsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlOperationsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlOperationsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlOperationsService for SqlOperationsService {
    async fn get(
        &self,
        req: crate::model::SqlOperationsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/operations/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.operation).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "operation",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list(
        &self,
        req: crate::model::SqlOperationsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationsListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/operations",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("instance", &req.instance)]);
            let builder = builder.query(&[("maxResults", &req.max_results)]);
            let builder = builder.query(&[("pageToken", &req.page_token)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn cancel(
        &self,
        req: crate::model::SqlOperationsCancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/operations/{}/cancel",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.operation).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "operation",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
        .map(|r: gax::response::Response<wkt::Empty>| {
            let (parts, _) = r.into_parts();
            gax::response::Response::from_parts(parts, ())
        })
    }

}

/// Implements [SqlSslCertsService](super::stub::SqlSslCertsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlSslCertsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlSslCertsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlSslCertsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlSslCertsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlSslCertsService for SqlSslCertsService {
    async fn delete(
        &self,
        req: crate::model::SqlSslCertsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/sslCerts/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.sha1_fingerprint).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.sha1_fingerprint).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "sha1_fingerprint",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get(
        &self,
        req: crate::model::SqlSslCertsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/sslCerts/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.sha1_fingerprint).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.sha1_fingerprint).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "sha1_fingerprint",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert(
        &self,
        req: crate::model::SqlSslCertsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsInsertResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/sslCerts",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list(
        &self,
        req: crate::model::SqlSslCertsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/sslCerts",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlTiersService](super::stub::SqlTiersService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlTiersService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlTiersService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlTiersService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlTiersService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlTiersService for SqlTiersService {
    async fn list(
        &self,
        req: crate::model::SqlTiersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TiersListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/tiers",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

/// Implements [SqlUsersService](super::stub::SqlUsersService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlUsersService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlUsersService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlUsersService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlUsersService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlUsersService for SqlUsersService {
    async fn delete(
        &self,
        req: crate::model::SqlUsersDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/users",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("host", &req.host)]);
            let builder = builder.query(&[("name", &req.name)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn get(
        &self,
        req: crate::model::SqlUsersGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/users/{}",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("host", &req.host)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "name",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn insert(
        &self,
        req: crate::model::SqlUsersInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/users",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn list(
        &self,
        req: crate::model::SqlUsersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UsersListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/users",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

    async fn update(
        &self,
        req: crate::model::SqlUsersUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/instances/{}/users",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = builder.query(&[("host", &req.host)]);
            let builder = builder.query(&[("name", &req.name)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder
                .query(&[("$alt", "json;enum-encoding=int")])
                .header("x-goog-api-client", reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER));
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(
            builder,
            body,
            options,
        ).await
    }

}

