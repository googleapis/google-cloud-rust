// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [SqlBackupRunsService](super::stub::SqlBackupRunsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlBackupRunsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlBackupRunsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlBackupRunsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlBackupRunsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlBackupRunsService for SqlBackupRunsService {
    async fn delete(
        &self,
        req: crate::model::SqlBackupRunsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/backupRuns/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            { &req.id },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get(
        &self,
        req: crate::model::SqlBackupRunsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRun>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/backupRuns/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            { &req.id },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn insert(
        &self,
        req: crate::model::SqlBackupRunsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/backupRuns",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn list(
        &self,
        req: crate::model::SqlBackupRunsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRunsListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/backupRuns",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("maxResults", &req.max_results)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [SqlConnectService](super::stub::SqlConnectService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlConnectService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlConnectService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlConnectService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlConnectService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlConnectService for SqlConnectService {
    async fn get_connect_settings(
        &self,
        req: crate::model::GetConnectSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConnectSettings>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/connectSettings",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .read_time
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "readTime")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn generate_ephemeral_cert(
        &self,
        req: crate::model::GenerateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateEphemeralCertResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}:generateEphemeralCert",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }
}

/// Implements [SqlDatabasesService](super::stub::SqlDatabasesService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlDatabasesService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlDatabasesService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlDatabasesService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlDatabasesService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlDatabasesService for SqlDatabasesService {
    async fn delete(
        &self,
        req: crate::model::SqlDatabasesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/databases/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.database;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("database"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get(
        &self,
        req: crate::model::SqlDatabasesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Database>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/databases/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.database;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("database"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn insert(
        &self,
        req: crate::model::SqlDatabasesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/databases",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn list(
        &self,
        req: crate::model::SqlDatabasesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabasesListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/databases",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn patch(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/databases/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.database;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("database"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn update(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/databases/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.database;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("database"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }
}

/// Implements [SqlFlagsService](super::stub::SqlFlagsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlFlagsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlFlagsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlFlagsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlFlagsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlFlagsService for SqlFlagsService {
    async fn list(
        &self,
        req: crate::model::SqlFlagsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlagsListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = "/v1/flags".to_string();
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("databaseVersion", &req.database_version)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [SqlInstancesService](super::stub::SqlInstancesService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlInstancesService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlInstancesService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlInstancesService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlInstancesService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlInstancesService for SqlInstancesService {
    async fn add_server_ca(
        &self,
        req: crate::model::SqlInstancesAddServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/addServerCa",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn clone(
        &self,
        req: crate::model::SqlInstancesCloneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/clone",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn delete(
        &self,
        req: crate::model::SqlInstancesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn demote_master(
        &self,
        req: crate::model::SqlInstancesDemoteMasterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/demoteMaster",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn demote(
        &self,
        req: crate::model::SqlInstancesDemoteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/demote",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn export(
        &self,
        req: crate::model::SqlInstancesExportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/export",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn failover(
        &self,
        req: crate::model::SqlInstancesFailoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/failover",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn reencrypt(
        &self,
        req: crate::model::SqlInstancesReencryptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/reencrypt",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn get(
        &self,
        req: crate::model::SqlInstancesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabaseInstance>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn import(
        &self,
        req: crate::model::SqlInstancesImportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/import",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn insert(
        &self,
        req: crate::model::SqlInstancesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v1/projects/{}/instances", {
            let arg = &req.project;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("project"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn list(
        &self,
        req: crate::model::SqlInstancesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v1/projects/{}/instances", {
            let arg = &req.project;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("project"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("maxResults", &req.max_results)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_server_cas(
        &self,
        req: crate::model::SqlInstancesListServerCasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListServerCasResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/listServerCas",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn patch(
        &self,
        req: crate::model::SqlInstancesPatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn promote_replica(
        &self,
        req: crate::model::SqlInstancesPromoteReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/promoteReplica",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("failover", &req.failover)]);
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn switchover(
        &self,
        req: crate::model::SqlInstancesSwitchoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/switchover",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .db_timeout
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "dbTimeout")
            });
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn reset_ssl_config(
        &self,
        req: crate::model::SqlInstancesResetSslConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/resetSslConfig",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn restart(
        &self,
        req: crate::model::SqlInstancesRestartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/restart",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn restore_backup(
        &self,
        req: crate::model::SqlInstancesRestoreBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/restoreBackup",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn rotate_server_ca(
        &self,
        req: crate::model::SqlInstancesRotateServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/rotateServerCa",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn start_replica(
        &self,
        req: crate::model::SqlInstancesStartReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/startReplica",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn stop_replica(
        &self,
        req: crate::model::SqlInstancesStopReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/stopReplica",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn truncate_log(
        &self,
        req: crate::model::SqlInstancesTruncateLogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/truncateLog",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn update(
        &self,
        req: crate::model::SqlInstancesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn create_ephemeral(
        &self,
        req: crate::model::SqlInstancesCreateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/createEphemeral",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn reschedule_maintenance(
        &self,
        req: crate::model::SqlInstancesRescheduleMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/rescheduleMaintenance",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn verify_external_sync_settings(
        &self,
        req: crate::model::SqlInstancesVerifyExternalSyncSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesVerifyExternalSyncSettingsResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/verifyExternalSyncSettings",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn start_external_sync(
        &self,
        req: crate::model::SqlInstancesStartExternalSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/startExternalSync",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn perform_disk_shrink(
        &self,
        req: crate::model::SqlInstancesPerformDiskShrinkRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/performDiskShrink",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn get_disk_shrink_config(
        &self,
        req: crate::model::SqlInstancesGetDiskShrinkConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetDiskShrinkConfigResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/getDiskShrinkConfig",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn reset_replica_size(
        &self,
        req: crate::model::SqlInstancesResetReplicaSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/resetReplicaSize",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_latest_recovery_time(
        &self,
        req: crate::model::SqlInstancesGetLatestRecoveryTimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetLatestRecoveryTimeResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/getLatestRecoveryTime",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn acquire_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesAcquireSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesAcquireSsrsLeaseResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/acquireSsrsLease",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn release_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesReleaseSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesReleaseSsrsLeaseResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/releaseSsrsLease",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }
}

/// Implements [SqlOperationsService](super::stub::SqlOperationsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlOperationsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlOperationsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlOperationsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlOperationsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlOperationsService for SqlOperationsService {
    async fn get(
        &self,
        req: crate::model::SqlOperationsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/operations/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.operation;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("operation"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list(
        &self,
        req: crate::model::SqlOperationsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationsListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v1/projects/{}/operations", {
            let arg = &req.project;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("project"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("instance", &req.instance)]);
        let builder = builder.query(&[("maxResults", &req.max_results)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel(
        &self,
        req: crate::model::SqlOperationsCancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/operations/{}/cancel",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.operation;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("operation"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [SqlSslCertsService](super::stub::SqlSslCertsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlSslCertsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlSslCertsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlSslCertsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlSslCertsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlSslCertsService for SqlSslCertsService {
    async fn delete(
        &self,
        req: crate::model::SqlSslCertsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/sslCerts/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.sha1_fingerprint;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("sha1_fingerprint"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get(
        &self,
        req: crate::model::SqlSslCertsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/sslCerts/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.sha1_fingerprint;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("sha1_fingerprint"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn insert(
        &self,
        req: crate::model::SqlSslCertsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsInsertResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/sslCerts",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn list(
        &self,
        req: crate::model::SqlSslCertsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/sslCerts",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [SqlTiersService](super::stub::SqlTiersService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlTiersService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlTiersService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlTiersService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlTiersService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlTiersService for SqlTiersService {
    async fn list(
        &self,
        req: crate::model::SqlTiersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TiersListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v1/projects/{}/tiers", {
            let arg = &req.project;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("project"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [SqlUsersService](super::stub::SqlUsersService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SqlUsersService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SqlUsersService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SqlUsersService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SqlUsersService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SqlUsersService for SqlUsersService {
    async fn delete(
        &self,
        req: crate::model::SqlUsersDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/users",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("host", &req.host)]);
        let builder = builder.query(&[("name", &req.name)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get(
        &self,
        req: crate::model::SqlUsersGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/users/{}",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
            {
                let arg = &req.name;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("name"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("host", &req.host)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn insert(
        &self,
        req: crate::model::SqlUsersInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!(
            "/v1/projects/{}/instances/{}/users",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req.body), options).await
    }

    async fn list(
        &self,
        req: crate::model::SqlUsersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UsersListResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/users",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update(
        &self,
        req: crate::model::SqlUsersUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!(
            "/v1/projects/{}/instances/{}/users",
            {
                let arg = &req.project;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("project"));
                }
                arg
            },
            {
                let arg = &req.instance;
                if arg.is_empty() {
                    return Err(gaxi::path_parameter::missing("instance"));
                }
                arg
            },
        );
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("host", &req.host)]);
        let builder = builder.query(&[("name", &req.name)]);
        self.inner.execute(builder, Some(req.body), options).await
    }
}
